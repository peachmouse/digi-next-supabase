/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@baselime+node-opentelemetry@0.5.8_@trpc+server@10.45.2";
exports.ids = ["vendor-chunks/@baselime+node-opentelemetry@0.5.8_@trpc+server@10.45.2"];
exports.modules = {

/***/ "(instrument)/../../node_modules/.pnpm/@baselime+node-opentelemetry@0.5.8_@trpc+server@10.45.2/node_modules/@baselime/node-opentelemetry/dist/index.cjs":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@baselime+node-opentelemetry@0.5.8_@trpc+server@10.45.2/node_modules/@baselime/node-opentelemetry/dist/index.cjs ***!
  \*************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js\nvar _globalThis;\nvar init_globalThis = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js\"() {\n    _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/platform/node/index.js\nvar init_node = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/platform/node/index.js\"() {\n    init_globalThis();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/platform/index.js\nvar init_platform = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/platform/index.js\"() {\n    init_node();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/version.js\nvar VERSION;\nvar init_version = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/version.js\"() {\n    VERSION = \"1.8.0\";\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/internal/semver.js\nfunction _makeCompatibilityCheck(ownVersion) {\n  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);\n  var rejectedVersions = /* @__PURE__ */ new Set();\n  var myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    return function() {\n      return false;\n    };\n  }\n  var ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4]\n  };\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion) {\n      return globalVersion === ownVersion;\n    };\n  }\n  function _reject(v) {\n    rejectedVersions.add(v);\n    return false;\n  }\n  function _accept(v) {\n    acceptedVersions.add(v);\n    return true;\n  }\n  return function isCompatible2(globalVersion) {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n    var globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      return _reject(globalVersion);\n    }\n    var globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4]\n    };\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.major === 0) {\n      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {\n        return _accept(globalVersion);\n      }\n      return _reject(globalVersion);\n    }\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n    return _reject(globalVersion);\n  };\n}\nvar re, isCompatible;\nvar init_semver = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/internal/semver.js\"() {\n    init_version();\n    re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n    isCompatible = _makeCompatibilityCheck(VERSION);\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js\nfunction registerGlobal(type, instance, diag3, allowOverride) {\n  var _a2;\n  if (allowOverride === void 0) {\n    allowOverride = false;\n  }\n  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a2 !== void 0 ? _a2 : {\n    version: VERSION\n  };\n  if (!allowOverride && api[type]) {\n    var err = new Error(\"@opentelemetry/api: Attempted duplicate registration of API: \" + type);\n    diag3.error(err.stack || err.message);\n    return false;\n  }\n  if (api.version !== VERSION) {\n    var err = new Error(\"@opentelemetry/api: Registration of version v\" + api.version + \" for \" + type + \" does not match previously registered API v\" + VERSION);\n    diag3.error(err.stack || err.message);\n    return false;\n  }\n  api[type] = instance;\n  diag3.debug(\"@opentelemetry/api: Registered a global for \" + type + \" v\" + VERSION + \".\");\n  return true;\n}\nfunction getGlobal(type) {\n  var _a2, _b;\n  var globalVersion = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a2 === void 0 ? void 0 : _a2.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];\n}\nfunction unregisterGlobal(type, diag3) {\n  diag3.debug(\"@opentelemetry/api: Unregistering a global for \" + type + \" v\" + VERSION + \".\");\n  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n  if (api) {\n    delete api[type];\n  }\n}\nvar major, GLOBAL_OPENTELEMETRY_API_KEY, _global;\nvar init_global_utils = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/internal/global-utils.js\"() {\n    init_platform();\n    init_version();\n    init_semver();\n    major = VERSION.split(\".\")[0];\n    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\"opentelemetry.js.api.\" + major);\n    _global = _globalThis;\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js\nfunction logProxy(funcName, namespace, args) {\n  var logger = getGlobal(\"diag\");\n  if (!logger) {\n    return;\n  }\n  args.unshift(namespace);\n  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));\n}\nvar __read, __spreadArray, DiagComponentLogger;\nvar init_ComponentLogger = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js\"() {\n    init_global_utils();\n    __read = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __spreadArray = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n          if (ar || !(i in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    DiagComponentLogger = /** @class */\n    function() {\n      function DiagComponentLogger2(props) {\n        this._namespace = props.namespace || \"DiagComponentLogger\";\n      }\n      DiagComponentLogger2.prototype.debug = function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return logProxy(\"debug\", this._namespace, args);\n      };\n      DiagComponentLogger2.prototype.error = function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return logProxy(\"error\", this._namespace, args);\n      };\n      DiagComponentLogger2.prototype.info = function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return logProxy(\"info\", this._namespace, args);\n      };\n      DiagComponentLogger2.prototype.warn = function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return logProxy(\"warn\", this._namespace, args);\n      };\n      DiagComponentLogger2.prototype.verbose = function() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        return logProxy(\"verbose\", this._namespace, args);\n      };\n      return DiagComponentLogger2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/diag/types.js\nvar DiagLogLevel;\nvar init_types = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/diag/types.js\"() {\n    (function(DiagLogLevel2) {\n      DiagLogLevel2[DiagLogLevel2[\"NONE\"] = 0] = \"NONE\";\n      DiagLogLevel2[DiagLogLevel2[\"ERROR\"] = 30] = \"ERROR\";\n      DiagLogLevel2[DiagLogLevel2[\"WARN\"] = 50] = \"WARN\";\n      DiagLogLevel2[DiagLogLevel2[\"INFO\"] = 60] = \"INFO\";\n      DiagLogLevel2[DiagLogLevel2[\"DEBUG\"] = 70] = \"DEBUG\";\n      DiagLogLevel2[DiagLogLevel2[\"VERBOSE\"] = 80] = \"VERBOSE\";\n      DiagLogLevel2[DiagLogLevel2[\"ALL\"] = 9999] = \"ALL\";\n    })(DiagLogLevel || (DiagLogLevel = {}));\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js\nfunction createLogLevelDiagLogger(maxLevel, logger) {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n  logger = logger || {};\n  function _filterFunc(funcName, theLevel) {\n    var theFunc = logger[funcName];\n    if (typeof theFunc === \"function\" && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function() {\n    };\n  }\n  return {\n    error: _filterFunc(\"error\", DiagLogLevel.ERROR),\n    warn: _filterFunc(\"warn\", DiagLogLevel.WARN),\n    info: _filterFunc(\"info\", DiagLogLevel.INFO),\n    debug: _filterFunc(\"debug\", DiagLogLevel.DEBUG),\n    verbose: _filterFunc(\"verbose\", DiagLogLevel.VERBOSE)\n  };\n}\nvar init_logLevelLogger = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js\"() {\n    init_types();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/api/diag.js\nvar __read2, __spreadArray2, API_NAME, DiagAPI;\nvar init_diag = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/api/diag.js\"() {\n    init_ComponentLogger();\n    init_logLevelLogger();\n    init_types();\n    init_global_utils();\n    __read2 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __spreadArray2 = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n          if (ar || !(i in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    API_NAME = \"diag\";\n    DiagAPI = /** @class */\n    function() {\n      function DiagAPI2() {\n        function _logProxy(funcName) {\n          return function() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n            var logger = getGlobal(\"diag\");\n            if (!logger)\n              return;\n            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));\n          };\n        }\n        var self2 = this;\n        var setLogger = function(logger, optionsOrLogLevel) {\n          var _a2, _b, _c;\n          if (optionsOrLogLevel === void 0) {\n            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };\n          }\n          if (logger === self2) {\n            var err = new Error(\"Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation\");\n            self2.error((_a2 = err.stack) !== null && _a2 !== void 0 ? _a2 : err.message);\n            return false;\n          }\n          if (typeof optionsOrLogLevel === \"number\") {\n            optionsOrLogLevel = {\n              logLevel: optionsOrLogLevel\n            };\n          }\n          var oldLogger = getGlobal(\"diag\");\n          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);\n          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : \"<failed to generate stacktrace>\";\n            oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n            newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n          }\n          return registerGlobal(\"diag\", newLogger, self2, true);\n        };\n        self2.setLogger = setLogger;\n        self2.disable = function() {\n          unregisterGlobal(API_NAME, self2);\n        };\n        self2.createComponentLogger = function(options) {\n          return new DiagComponentLogger(options);\n        };\n        self2.verbose = _logProxy(\"verbose\");\n        self2.debug = _logProxy(\"debug\");\n        self2.info = _logProxy(\"info\");\n        self2.warn = _logProxy(\"warn\");\n        self2.error = _logProxy(\"error\");\n      }\n      DiagAPI2.instance = function() {\n        if (!this._instance) {\n          this._instance = new DiagAPI2();\n        }\n        return this._instance;\n      };\n      return DiagAPI2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js\nvar __read3, __values, BaggageImpl;\nvar init_baggage_impl = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js\"() {\n    __read3 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __values = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n    BaggageImpl = /** @class */\n    function() {\n      function BaggageImpl2(entries) {\n        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();\n      }\n      BaggageImpl2.prototype.getEntry = function(key) {\n        var entry = this._entries.get(key);\n        if (!entry) {\n          return void 0;\n        }\n        return Object.assign({}, entry);\n      };\n      BaggageImpl2.prototype.getAllEntries = function() {\n        return Array.from(this._entries.entries()).map(function(_a2) {\n          var _b = __read3(_a2, 2), k = _b[0], v = _b[1];\n          return [k, v];\n        });\n      };\n      BaggageImpl2.prototype.setEntry = function(key, entry) {\n        var newBaggage = new BaggageImpl2(this._entries);\n        newBaggage._entries.set(key, entry);\n        return newBaggage;\n      };\n      BaggageImpl2.prototype.removeEntry = function(key) {\n        var newBaggage = new BaggageImpl2(this._entries);\n        newBaggage._entries.delete(key);\n        return newBaggage;\n      };\n      BaggageImpl2.prototype.removeEntries = function() {\n        var e_1, _a2;\n        var keys = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          keys[_i] = arguments[_i];\n        }\n        var newBaggage = new BaggageImpl2(this._entries);\n        try {\n          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n            var key = keys_1_1.value;\n            newBaggage._entries.delete(key);\n          }\n        } catch (e_1_1) {\n          e_1 = { error: e_1_1 };\n        } finally {\n          try {\n            if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return))\n              _a2.call(keys_1);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n        return newBaggage;\n      };\n      BaggageImpl2.prototype.clear = function() {\n        return new BaggageImpl2();\n      };\n      return BaggageImpl2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js\nvar baggageEntryMetadataSymbol;\nvar init_symbol = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js\"() {\n    baggageEntryMetadataSymbol = Symbol(\"BaggageEntryMetadata\");\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/baggage/utils.js\nfunction createBaggage(entries) {\n  if (entries === void 0) {\n    entries = {};\n  }\n  return new BaggageImpl(new Map(Object.entries(entries)));\n}\nfunction baggageEntryMetadataFromString(str) {\n  if (typeof str !== \"string\") {\n    diag.error(\"Cannot create baggage metadata from unknown type: \" + typeof str);\n    str = \"\";\n  }\n  return {\n    __TYPE__: baggageEntryMetadataSymbol,\n    toString: function() {\n      return str;\n    }\n  };\n}\nvar diag;\nvar init_utils = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/baggage/utils.js\"() {\n    init_diag();\n    init_baggage_impl();\n    init_symbol();\n    diag = DiagAPI.instance();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/context/context.js\nfunction createContextKey(description) {\n  return Symbol.for(description);\n}\nvar BaseContext, ROOT_CONTEXT;\nvar init_context = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/context/context.js\"() {\n    BaseContext = /** @class */\n    function() {\n      function BaseContext2(parentContext) {\n        var self2 = this;\n        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();\n        self2.getValue = function(key) {\n          return self2._currentContext.get(key);\n        };\n        self2.setValue = function(key, value) {\n          var context2 = new BaseContext2(self2._currentContext);\n          context2._currentContext.set(key, value);\n          return context2;\n        };\n        self2.deleteValue = function(key) {\n          var context2 = new BaseContext2(self2._currentContext);\n          context2._currentContext.delete(key);\n          return context2;\n        };\n      }\n      return BaseContext2;\n    }();\n    ROOT_CONTEXT = new BaseContext();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js\nvar consoleMap, DiagConsoleLogger;\nvar init_consoleLogger = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js\"() {\n    consoleMap = [\n      { n: \"error\", c: \"error\" },\n      { n: \"warn\", c: \"warn\" },\n      { n: \"info\", c: \"info\" },\n      { n: \"debug\", c: \"debug\" },\n      { n: \"verbose\", c: \"trace\" }\n    ];\n    DiagConsoleLogger = /** @class */\n    function() {\n      function DiagConsoleLogger2() {\n        function _consoleFunc(funcName) {\n          return function() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n            if (console) {\n              var theFunc = console[funcName];\n              if (typeof theFunc !== \"function\") {\n                theFunc = console.log;\n              }\n              if (typeof theFunc === \"function\") {\n                return theFunc.apply(console, args);\n              }\n            }\n          };\n        }\n        for (var i = 0; i < consoleMap.length; i++) {\n          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);\n        }\n      }\n      return DiagConsoleLogger2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js\nfunction createNoopMeter() {\n  return NOOP_METER;\n}\nvar __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;\nvar init_NoopMeter = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js\"() {\n    __extends = function() {\n      var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n          d2.__proto__ = b2;\n        } || function(d2, b2) {\n          for (var p in b2)\n            if (Object.prototype.hasOwnProperty.call(b2, p))\n              d2[p] = b2[p];\n        };\n        return extendStatics(d, b);\n      };\n      return function(d, b) {\n        if (typeof b !== \"function\" && b !== null)\n          throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n    NoopMeter = /** @class */\n    function() {\n      function NoopMeter2() {\n      }\n      NoopMeter2.prototype.createHistogram = function(_name, _options) {\n        return NOOP_HISTOGRAM_METRIC;\n      };\n      NoopMeter2.prototype.createCounter = function(_name, _options) {\n        return NOOP_COUNTER_METRIC;\n      };\n      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {\n        return NOOP_UP_DOWN_COUNTER_METRIC;\n      };\n      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {\n        return NOOP_OBSERVABLE_GAUGE_METRIC;\n      };\n      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {\n        return NOOP_OBSERVABLE_COUNTER_METRIC;\n      };\n      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {\n        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;\n      };\n      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {\n      };\n      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {\n      };\n      return NoopMeter2;\n    }();\n    NoopMetric = /** @class */\n    function() {\n      function NoopMetric2() {\n      }\n      return NoopMetric2;\n    }();\n    NoopCounterMetric = /** @class */\n    function(_super) {\n      __extends(NoopCounterMetric2, _super);\n      function NoopCounterMetric2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      NoopCounterMetric2.prototype.add = function(_value, _attributes) {\n      };\n      return NoopCounterMetric2;\n    }(NoopMetric);\n    NoopUpDownCounterMetric = /** @class */\n    function(_super) {\n      __extends(NoopUpDownCounterMetric2, _super);\n      function NoopUpDownCounterMetric2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {\n      };\n      return NoopUpDownCounterMetric2;\n    }(NoopMetric);\n    NoopHistogramMetric = /** @class */\n    function(_super) {\n      __extends(NoopHistogramMetric2, _super);\n      function NoopHistogramMetric2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {\n      };\n      return NoopHistogramMetric2;\n    }(NoopMetric);\n    NoopObservableMetric = /** @class */\n    function() {\n      function NoopObservableMetric2() {\n      }\n      NoopObservableMetric2.prototype.addCallback = function(_callback) {\n      };\n      NoopObservableMetric2.prototype.removeCallback = function(_callback) {\n      };\n      return NoopObservableMetric2;\n    }();\n    NoopObservableCounterMetric = /** @class */\n    function(_super) {\n      __extends(NoopObservableCounterMetric2, _super);\n      function NoopObservableCounterMetric2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      return NoopObservableCounterMetric2;\n    }(NoopObservableMetric);\n    NoopObservableGaugeMetric = /** @class */\n    function(_super) {\n      __extends(NoopObservableGaugeMetric2, _super);\n      function NoopObservableGaugeMetric2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      return NoopObservableGaugeMetric2;\n    }(NoopObservableMetric);\n    NoopObservableUpDownCounterMetric = /** @class */\n    function(_super) {\n      __extends(NoopObservableUpDownCounterMetric2, _super);\n      function NoopObservableUpDownCounterMetric2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      return NoopObservableUpDownCounterMetric2;\n    }(NoopObservableMetric);\n    NOOP_METER = new NoopMeter();\n    NOOP_COUNTER_METRIC = new NoopCounterMetric();\n    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();\n    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();\n    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();\n    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();\n    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js\nvar ValueType;\nvar init_Metric = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/metrics/Metric.js\"() {\n    (function(ValueType2) {\n      ValueType2[ValueType2[\"INT\"] = 0] = \"INT\";\n      ValueType2[ValueType2[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    })(ValueType || (ValueType = {}));\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js\nvar defaultTextMapGetter, defaultTextMapSetter;\nvar init_TextMapPropagator = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js\"() {\n    defaultTextMapGetter = {\n      get: function(carrier, key) {\n        if (carrier == null) {\n          return void 0;\n        }\n        return carrier[key];\n      },\n      keys: function(carrier) {\n        if (carrier == null) {\n          return [];\n        }\n        return Object.keys(carrier);\n      }\n    };\n    defaultTextMapSetter = {\n      set: function(carrier, key, value) {\n        if (carrier == null) {\n          return;\n        }\n        carrier[key] = value;\n      }\n    };\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js\nvar __read4, __spreadArray3, NoopContextManager;\nvar init_NoopContextManager = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js\"() {\n    init_context();\n    __read4 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __spreadArray3 = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n          if (ar || !(i in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    NoopContextManager = /** @class */\n    function() {\n      function NoopContextManager2() {\n      }\n      NoopContextManager2.prototype.active = function() {\n        return ROOT_CONTEXT;\n      };\n      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {\n        var args = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n          args[_i - 3] = arguments[_i];\n        }\n        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));\n      };\n      NoopContextManager2.prototype.bind = function(_context, target) {\n        return target;\n      };\n      NoopContextManager2.prototype.enable = function() {\n        return this;\n      };\n      NoopContextManager2.prototype.disable = function() {\n        return this;\n      };\n      return NoopContextManager2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/api/context.js\nvar __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;\nvar init_context2 = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/api/context.js\"() {\n    init_NoopContextManager();\n    init_global_utils();\n    init_diag();\n    __read5 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __spreadArray4 = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n          if (ar || !(i in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    API_NAME2 = \"context\";\n    NOOP_CONTEXT_MANAGER = new NoopContextManager();\n    ContextAPI = /** @class */\n    function() {\n      function ContextAPI2() {\n      }\n      ContextAPI2.getInstance = function() {\n        if (!this._instance) {\n          this._instance = new ContextAPI2();\n        }\n        return this._instance;\n      };\n      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {\n        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());\n      };\n      ContextAPI2.prototype.active = function() {\n        return this._getContextManager().active();\n      };\n      ContextAPI2.prototype.with = function(context2, fn, thisArg) {\n        var _a2;\n        var args = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n          args[_i - 3] = arguments[_i];\n        }\n        return (_a2 = this._getContextManager()).with.apply(_a2, __spreadArray4([context2, fn, thisArg], __read5(args), false));\n      };\n      ContextAPI2.prototype.bind = function(context2, target) {\n        return this._getContextManager().bind(context2, target);\n      };\n      ContextAPI2.prototype._getContextManager = function() {\n        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;\n      };\n      ContextAPI2.prototype.disable = function() {\n        this._getContextManager().disable();\n        unregisterGlobal(API_NAME2, DiagAPI.instance());\n      };\n      return ContextAPI2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js\nvar TraceFlags;\nvar init_trace_flags = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js\"() {\n    (function(TraceFlags2) {\n      TraceFlags2[TraceFlags2[\"NONE\"] = 0] = \"NONE\";\n      TraceFlags2[TraceFlags2[\"SAMPLED\"] = 1] = \"SAMPLED\";\n    })(TraceFlags || (TraceFlags = {}));\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js\nvar INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;\nvar init_invalid_span_constants = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js\"() {\n    init_trace_flags();\n    INVALID_SPANID = \"0000000000000000\";\n    INVALID_TRACEID = \"00000000000000000000000000000000\";\n    INVALID_SPAN_CONTEXT = {\n      traceId: INVALID_TRACEID,\n      spanId: INVALID_SPANID,\n      traceFlags: TraceFlags.NONE\n    };\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js\nvar NonRecordingSpan;\nvar init_NonRecordingSpan = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js\"() {\n    init_invalid_span_constants();\n    NonRecordingSpan = /** @class */\n    function() {\n      function NonRecordingSpan2(_spanContext) {\n        if (_spanContext === void 0) {\n          _spanContext = INVALID_SPAN_CONTEXT;\n        }\n        this._spanContext = _spanContext;\n      }\n      NonRecordingSpan2.prototype.spanContext = function() {\n        return this._spanContext;\n      };\n      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {\n        return this;\n      };\n      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {\n        return this;\n      };\n      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {\n        return this;\n      };\n      NonRecordingSpan2.prototype.setStatus = function(_status) {\n        return this;\n      };\n      NonRecordingSpan2.prototype.updateName = function(_name) {\n        return this;\n      };\n      NonRecordingSpan2.prototype.end = function(_endTime) {\n      };\n      NonRecordingSpan2.prototype.isRecording = function() {\n        return false;\n      };\n      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {\n      };\n      return NonRecordingSpan2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js\nfunction getSpan(context2) {\n  return context2.getValue(SPAN_KEY) || void 0;\n}\nfunction getActiveSpan() {\n  return getSpan(ContextAPI.getInstance().active());\n}\nfunction setSpan(context2, span) {\n  return context2.setValue(SPAN_KEY, span);\n}\nfunction deleteSpan(context2) {\n  return context2.deleteValue(SPAN_KEY);\n}\nfunction setSpanContext(context2, spanContext) {\n  return setSpan(context2, new NonRecordingSpan(spanContext));\n}\nfunction getSpanContext(context2) {\n  var _a2;\n  return (_a2 = getSpan(context2)) === null || _a2 === void 0 ? void 0 : _a2.spanContext();\n}\nvar SPAN_KEY;\nvar init_context_utils = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/context-utils.js\"() {\n    init_context();\n    init_NonRecordingSpan();\n    init_context2();\n    SPAN_KEY = createContextKey(\"OpenTelemetry Context Key SPAN\");\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js\nfunction isValidTraceId(traceId) {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\nfunction isValidSpanId(spanId) {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\nfunction isSpanContextValid(spanContext) {\n  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);\n}\nfunction wrapSpanContext(spanContext) {\n  return new NonRecordingSpan(spanContext);\n}\nvar VALID_TRACEID_REGEX, VALID_SPANID_REGEX;\nvar init_spancontext_utils = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js\"() {\n    init_invalid_span_constants();\n    init_NonRecordingSpan();\n    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\n    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js\nfunction isSpanContext(spanContext) {\n  return typeof spanContext === \"object\" && typeof spanContext[\"spanId\"] === \"string\" && typeof spanContext[\"traceId\"] === \"string\" && typeof spanContext[\"traceFlags\"] === \"number\";\n}\nvar contextApi, NoopTracer;\nvar init_NoopTracer = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js\"() {\n    init_context2();\n    init_context_utils();\n    init_NonRecordingSpan();\n    init_spancontext_utils();\n    contextApi = ContextAPI.getInstance();\n    NoopTracer = /** @class */\n    function() {\n      function NoopTracer2() {\n      }\n      NoopTracer2.prototype.startSpan = function(name, options, context2) {\n        if (context2 === void 0) {\n          context2 = contextApi.active();\n        }\n        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);\n        if (root) {\n          return new NonRecordingSpan();\n        }\n        var parentFromContext = context2 && getSpanContext(context2);\n        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {\n          return new NonRecordingSpan(parentFromContext);\n        } else {\n          return new NonRecordingSpan();\n        }\n      };\n      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {\n        var opts;\n        var ctx;\n        var fn;\n        if (arguments.length < 2) {\n          return;\n        } else if (arguments.length === 2) {\n          fn = arg2;\n        } else if (arguments.length === 3) {\n          opts = arg2;\n          fn = arg3;\n        } else {\n          opts = arg2;\n          ctx = arg3;\n          fn = arg4;\n        }\n        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();\n        var span = this.startSpan(name, opts, parentContext);\n        var contextWithSpanSet = setSpan(parentContext, span);\n        return contextApi.with(contextWithSpanSet, fn, void 0, span);\n      };\n      return NoopTracer2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js\nvar NOOP_TRACER, ProxyTracer;\nvar init_ProxyTracer = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js\"() {\n    init_NoopTracer();\n    NOOP_TRACER = new NoopTracer();\n    ProxyTracer = /** @class */\n    function() {\n      function ProxyTracer2(_provider, name, version, options) {\n        this._provider = _provider;\n        this.name = name;\n        this.version = version;\n        this.options = options;\n      }\n      ProxyTracer2.prototype.startSpan = function(name, options, context2) {\n        return this._getTracer().startSpan(name, options, context2);\n      };\n      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {\n        var tracer = this._getTracer();\n        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n      };\n      ProxyTracer2.prototype._getTracer = function() {\n        if (this._delegate) {\n          return this._delegate;\n        }\n        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);\n        if (!tracer) {\n          return NOOP_TRACER;\n        }\n        this._delegate = tracer;\n        return this._delegate;\n      };\n      return ProxyTracer2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js\nvar NoopTracerProvider;\nvar init_NoopTracerProvider = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js\"() {\n    init_NoopTracer();\n    NoopTracerProvider = /** @class */\n    function() {\n      function NoopTracerProvider2() {\n      }\n      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {\n        return new NoopTracer();\n      };\n      return NoopTracerProvider2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js\nvar NOOP_TRACER_PROVIDER, ProxyTracerProvider;\nvar init_ProxyTracerProvider = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js\"() {\n    init_ProxyTracer();\n    init_NoopTracerProvider();\n    NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n    ProxyTracerProvider = /** @class */\n    function() {\n      function ProxyTracerProvider2() {\n      }\n      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {\n        var _a2;\n        return (_a2 = this.getDelegateTracer(name, version, options)) !== null && _a2 !== void 0 ? _a2 : new ProxyTracer(this, name, version, options);\n      };\n      ProxyTracerProvider2.prototype.getDelegate = function() {\n        var _a2;\n        return (_a2 = this._delegate) !== null && _a2 !== void 0 ? _a2 : NOOP_TRACER_PROVIDER;\n      };\n      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {\n        this._delegate = delegate;\n      };\n      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {\n        var _a2;\n        return (_a2 = this._delegate) === null || _a2 === void 0 ? void 0 : _a2.getTracer(name, version, options);\n      };\n      return ProxyTracerProvider2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js\nvar SamplingDecision;\nvar init_SamplingResult = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js\"() {\n    (function(SamplingDecision3) {\n      SamplingDecision3[SamplingDecision3[\"NOT_RECORD\"] = 0] = \"NOT_RECORD\";\n      SamplingDecision3[SamplingDecision3[\"RECORD\"] = 1] = \"RECORD\";\n      SamplingDecision3[SamplingDecision3[\"RECORD_AND_SAMPLED\"] = 2] = \"RECORD_AND_SAMPLED\";\n    })(SamplingDecision || (SamplingDecision = {}));\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js\nvar SpanKind;\nvar init_span_kind = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/span_kind.js\"() {\n    (function(SpanKind2) {\n      SpanKind2[SpanKind2[\"INTERNAL\"] = 0] = \"INTERNAL\";\n      SpanKind2[SpanKind2[\"SERVER\"] = 1] = \"SERVER\";\n      SpanKind2[SpanKind2[\"CLIENT\"] = 2] = \"CLIENT\";\n      SpanKind2[SpanKind2[\"PRODUCER\"] = 3] = \"PRODUCER\";\n      SpanKind2[SpanKind2[\"CONSUMER\"] = 4] = \"CONSUMER\";\n    })(SpanKind || (SpanKind = {}));\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/status.js\nvar SpanStatusCode;\nvar init_status = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/status.js\"() {\n    (function(SpanStatusCode2) {\n      SpanStatusCode2[SpanStatusCode2[\"UNSET\"] = 0] = \"UNSET\";\n      SpanStatusCode2[SpanStatusCode2[\"OK\"] = 1] = \"OK\";\n      SpanStatusCode2[SpanStatusCode2[\"ERROR\"] = 2] = \"ERROR\";\n    })(SpanStatusCode || (SpanStatusCode = {}));\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js\nfunction validateKey(key) {\n  return VALID_KEY_REGEX.test(key);\n}\nfunction validateValue(value) {\n  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);\n}\nvar VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;\nvar init_tracestate_validators = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js\"() {\n    VALID_KEY_CHAR_RANGE = \"[_0-9a-z-*/]\";\n    VALID_KEY = \"[a-z]\" + VALID_KEY_CHAR_RANGE + \"{0,255}\";\n    VALID_VENDOR_KEY = \"[a-z0-9]\" + VALID_KEY_CHAR_RANGE + \"{0,240}@[a-z]\" + VALID_KEY_CHAR_RANGE + \"{0,13}\";\n    VALID_KEY_REGEX = new RegExp(\"^(?:\" + VALID_KEY + \"|\" + VALID_VENDOR_KEY + \")$\");\n    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\n    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js\nvar MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;\nvar init_tracestate_impl = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js\"() {\n    init_tracestate_validators();\n    MAX_TRACE_STATE_ITEMS = 32;\n    MAX_TRACE_STATE_LEN = 512;\n    LIST_MEMBERS_SEPARATOR = \",\";\n    LIST_MEMBER_KEY_VALUE_SPLITTER = \"=\";\n    TraceStateImpl = /** @class */\n    function() {\n      function TraceStateImpl2(rawTraceState) {\n        this._internalState = /* @__PURE__ */ new Map();\n        if (rawTraceState)\n          this._parse(rawTraceState);\n      }\n      TraceStateImpl2.prototype.set = function(key, value) {\n        var traceState = this._clone();\n        if (traceState._internalState.has(key)) {\n          traceState._internalState.delete(key);\n        }\n        traceState._internalState.set(key, value);\n        return traceState;\n      };\n      TraceStateImpl2.prototype.unset = function(key) {\n        var traceState = this._clone();\n        traceState._internalState.delete(key);\n        return traceState;\n      };\n      TraceStateImpl2.prototype.get = function(key) {\n        return this._internalState.get(key);\n      };\n      TraceStateImpl2.prototype.serialize = function() {\n        var _this = this;\n        return this._keys().reduce(function(agg, key) {\n          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));\n          return agg;\n        }, []).join(LIST_MEMBERS_SEPARATOR);\n      };\n      TraceStateImpl2.prototype._parse = function(rawTraceState) {\n        if (rawTraceState.length > MAX_TRACE_STATE_LEN)\n          return;\n        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {\n          var listMember = part.trim();\n          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n          if (i !== -1) {\n            var key = listMember.slice(0, i);\n            var value = listMember.slice(i + 1, part.length);\n            if (validateKey(key) && validateValue(value)) {\n              agg.set(key, value);\n            } else {\n            }\n          }\n          return agg;\n        }, /* @__PURE__ */ new Map());\n        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));\n        }\n      };\n      TraceStateImpl2.prototype._keys = function() {\n        return Array.from(this._internalState.keys()).reverse();\n      };\n      TraceStateImpl2.prototype._clone = function() {\n        var traceState = new TraceStateImpl2();\n        traceState._internalState = new Map(this._internalState);\n        return traceState;\n      };\n      return TraceStateImpl2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js\nfunction createTraceState(rawTraceState) {\n  return new TraceStateImpl(rawTraceState);\n}\nvar init_utils2 = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js\"() {\n    init_tracestate_impl();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/context-api.js\nvar context;\nvar init_context_api = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/context-api.js\"() {\n    init_context2();\n    context = ContextAPI.getInstance();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/diag-api.js\nvar diag2;\nvar init_diag_api = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/diag-api.js\"() {\n    init_diag();\n    diag2 = DiagAPI.instance();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js\nvar NoopMeterProvider, NOOP_METER_PROVIDER;\nvar init_NoopMeterProvider = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js\"() {\n    init_NoopMeter();\n    NoopMeterProvider = /** @class */\n    function() {\n      function NoopMeterProvider2() {\n      }\n      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {\n        return NOOP_METER;\n      };\n      return NoopMeterProvider2;\n    }();\n    NOOP_METER_PROVIDER = new NoopMeterProvider();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/api/metrics.js\nvar API_NAME3, MetricsAPI;\nvar init_metrics = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/api/metrics.js\"() {\n    init_NoopMeterProvider();\n    init_global_utils();\n    init_diag();\n    API_NAME3 = \"metrics\";\n    MetricsAPI = /** @class */\n    function() {\n      function MetricsAPI2() {\n      }\n      MetricsAPI2.getInstance = function() {\n        if (!this._instance) {\n          this._instance = new MetricsAPI2();\n        }\n        return this._instance;\n      };\n      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {\n        return registerGlobal(API_NAME3, provider, DiagAPI.instance());\n      };\n      MetricsAPI2.prototype.getMeterProvider = function() {\n        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;\n      };\n      MetricsAPI2.prototype.getMeter = function(name, version, options) {\n        return this.getMeterProvider().getMeter(name, version, options);\n      };\n      MetricsAPI2.prototype.disable = function() {\n        unregisterGlobal(API_NAME3, DiagAPI.instance());\n      };\n      return MetricsAPI2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/metrics-api.js\nvar metrics;\nvar init_metrics_api = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/metrics-api.js\"() {\n    init_metrics();\n    metrics = MetricsAPI.getInstance();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js\nvar NoopTextMapPropagator;\nvar init_NoopTextMapPropagator = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js\"() {\n    NoopTextMapPropagator = /** @class */\n    function() {\n      function NoopTextMapPropagator2() {\n      }\n      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {\n      };\n      NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {\n        return context2;\n      };\n      NoopTextMapPropagator2.prototype.fields = function() {\n        return [];\n      };\n      return NoopTextMapPropagator2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js\nfunction getBaggage(context2) {\n  return context2.getValue(BAGGAGE_KEY) || void 0;\n}\nfunction getActiveBaggage() {\n  return getBaggage(ContextAPI.getInstance().active());\n}\nfunction setBaggage(context2, baggage) {\n  return context2.setValue(BAGGAGE_KEY, baggage);\n}\nfunction deleteBaggage(context2) {\n  return context2.deleteValue(BAGGAGE_KEY);\n}\nvar BAGGAGE_KEY;\nvar init_context_helpers = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js\"() {\n    init_context2();\n    init_context();\n    BAGGAGE_KEY = createContextKey(\"OpenTelemetry Baggage Key\");\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/api/propagation.js\nvar API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;\nvar init_propagation = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/api/propagation.js\"() {\n    init_global_utils();\n    init_NoopTextMapPropagator();\n    init_TextMapPropagator();\n    init_context_helpers();\n    init_utils();\n    init_diag();\n    API_NAME4 = \"propagation\";\n    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\n    PropagationAPI = /** @class */\n    function() {\n      function PropagationAPI2() {\n        this.createBaggage = createBaggage;\n        this.getBaggage = getBaggage;\n        this.getActiveBaggage = getActiveBaggage;\n        this.setBaggage = setBaggage;\n        this.deleteBaggage = deleteBaggage;\n      }\n      PropagationAPI2.getInstance = function() {\n        if (!this._instance) {\n          this._instance = new PropagationAPI2();\n        }\n        return this._instance;\n      };\n      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {\n        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());\n      };\n      PropagationAPI2.prototype.inject = function(context2, carrier, setter) {\n        if (setter === void 0) {\n          setter = defaultTextMapSetter;\n        }\n        return this._getGlobalPropagator().inject(context2, carrier, setter);\n      };\n      PropagationAPI2.prototype.extract = function(context2, carrier, getter) {\n        if (getter === void 0) {\n          getter = defaultTextMapGetter;\n        }\n        return this._getGlobalPropagator().extract(context2, carrier, getter);\n      };\n      PropagationAPI2.prototype.fields = function() {\n        return this._getGlobalPropagator().fields();\n      };\n      PropagationAPI2.prototype.disable = function() {\n        unregisterGlobal(API_NAME4, DiagAPI.instance());\n      };\n      PropagationAPI2.prototype._getGlobalPropagator = function() {\n        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;\n      };\n      return PropagationAPI2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/propagation-api.js\nvar propagation;\nvar init_propagation_api = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/propagation-api.js\"() {\n    init_propagation();\n    propagation = PropagationAPI.getInstance();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/api/trace.js\nvar API_NAME5, TraceAPI;\nvar init_trace = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/api/trace.js\"() {\n    init_global_utils();\n    init_ProxyTracerProvider();\n    init_spancontext_utils();\n    init_context_utils();\n    init_diag();\n    API_NAME5 = \"trace\";\n    TraceAPI = /** @class */\n    function() {\n      function TraceAPI2() {\n        this._proxyTracerProvider = new ProxyTracerProvider();\n        this.wrapSpanContext = wrapSpanContext;\n        this.isSpanContextValid = isSpanContextValid;\n        this.deleteSpan = deleteSpan;\n        this.getSpan = getSpan;\n        this.getActiveSpan = getActiveSpan;\n        this.getSpanContext = getSpanContext;\n        this.setSpan = setSpan;\n        this.setSpanContext = setSpanContext;\n      }\n      TraceAPI2.getInstance = function() {\n        if (!this._instance) {\n          this._instance = new TraceAPI2();\n        }\n        return this._instance;\n      };\n      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {\n        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());\n        if (success) {\n          this._proxyTracerProvider.setDelegate(provider);\n        }\n        return success;\n      };\n      TraceAPI2.prototype.getTracerProvider = function() {\n        return getGlobal(API_NAME5) || this._proxyTracerProvider;\n      };\n      TraceAPI2.prototype.getTracer = function(name, version) {\n        return this.getTracerProvider().getTracer(name, version);\n      };\n      TraceAPI2.prototype.disable = function() {\n        unregisterGlobal(API_NAME5, DiagAPI.instance());\n        this._proxyTracerProvider = new ProxyTracerProvider();\n      };\n      return TraceAPI2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/trace-api.js\nvar trace;\nvar init_trace_api = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/trace-api.js\"() {\n    init_trace();\n    trace = TraceAPI.getInstance();\n  }\n});\n\n// node_modules/@opentelemetry/api/build/esm/index.js\nvar esm_exports = {};\n__export(esm_exports, {\n  DiagConsoleLogger: () => DiagConsoleLogger,\n  DiagLogLevel: () => DiagLogLevel,\n  INVALID_SPANID: () => INVALID_SPANID,\n  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,\n  INVALID_TRACEID: () => INVALID_TRACEID,\n  ProxyTracer: () => ProxyTracer,\n  ProxyTracerProvider: () => ProxyTracerProvider,\n  ROOT_CONTEXT: () => ROOT_CONTEXT,\n  SamplingDecision: () => SamplingDecision,\n  SpanKind: () => SpanKind,\n  SpanStatusCode: () => SpanStatusCode,\n  TraceFlags: () => TraceFlags,\n  ValueType: () => ValueType,\n  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,\n  context: () => context,\n  createContextKey: () => createContextKey,\n  createNoopMeter: () => createNoopMeter,\n  createTraceState: () => createTraceState,\n  default: () => esm_default,\n  defaultTextMapGetter: () => defaultTextMapGetter,\n  defaultTextMapSetter: () => defaultTextMapSetter,\n  diag: () => diag2,\n  isSpanContextValid: () => isSpanContextValid,\n  isValidSpanId: () => isValidSpanId,\n  isValidTraceId: () => isValidTraceId,\n  metrics: () => metrics,\n  propagation: () => propagation,\n  trace: () => trace\n});\nvar esm_default;\nvar init_esm = __esm({\n  \"node_modules/@opentelemetry/api/build/esm/index.js\"() {\n    init_utils();\n    init_context();\n    init_consoleLogger();\n    init_types();\n    init_NoopMeter();\n    init_Metric();\n    init_TextMapPropagator();\n    init_ProxyTracer();\n    init_ProxyTracerProvider();\n    init_SamplingResult();\n    init_span_kind();\n    init_status();\n    init_trace_flags();\n    init_utils2();\n    init_spancontext_utils();\n    init_invalid_span_constants();\n    init_context_api();\n    init_diag_api();\n    init_metrics_api();\n    init_propagation_api();\n    init_trace_api();\n    esm_default = {\n      context,\n      diag: diag2,\n      metrics,\n      propagation,\n      trace\n    };\n  }\n});\n\n// node_modules/@opentelemetry/context-async-hooks/build/src/AbstractAsyncHooksContextManager.js\nvar require_AbstractAsyncHooksContextManager = __commonJS({\n  \"node_modules/@opentelemetry/context-async-hooks/build/src/AbstractAsyncHooksContextManager.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.AbstractAsyncHooksContextManager = void 0;\n    var events_1 = __webpack_require__(/*! events */ \"events\");\n    var ADD_LISTENER_METHODS = [\n      \"addListener\",\n      \"on\",\n      \"once\",\n      \"prependListener\",\n      \"prependOnceListener\"\n    ];\n    var AbstractAsyncHooksContextManager = class {\n      constructor() {\n        this._kOtListeners = Symbol(\"OtListeners\");\n        this._wrapped = false;\n      }\n      /**\n       * Binds a the certain context or the active one to the target function and then returns the target\n       * @param context A context (span) to be bind to target\n       * @param target a function or event emitter. When target or one of its callbacks is called,\n       *  the provided context will be used as the active context for the duration of the call.\n       */\n      bind(context2, target) {\n        if (target instanceof events_1.EventEmitter) {\n          return this._bindEventEmitter(context2, target);\n        }\n        if (typeof target === \"function\") {\n          return this._bindFunction(context2, target);\n        }\n        return target;\n      }\n      _bindFunction(context2, target) {\n        const manager = this;\n        const contextWrapper = function(...args) {\n          return manager.with(context2, () => target.apply(this, args));\n        };\n        Object.defineProperty(contextWrapper, \"length\", {\n          enumerable: false,\n          configurable: true,\n          writable: false,\n          value: target.length\n        });\n        return contextWrapper;\n      }\n      /**\n       * By default, EventEmitter call their callback with their context, which we do\n       * not want, instead we will bind a specific context to all callbacks that\n       * go through it.\n       * @param context the context we want to bind\n       * @param ee EventEmitter an instance of EventEmitter to patch\n       */\n      _bindEventEmitter(context2, ee) {\n        const map = this._getPatchMap(ee);\n        if (map !== void 0)\n          return ee;\n        this._createPatchMap(ee);\n        ADD_LISTENER_METHODS.forEach((methodName) => {\n          if (ee[methodName] === void 0)\n            return;\n          ee[methodName] = this._patchAddListener(ee, ee[methodName], context2);\n        });\n        if (typeof ee.removeListener === \"function\") {\n          ee.removeListener = this._patchRemoveListener(ee, ee.removeListener);\n        }\n        if (typeof ee.off === \"function\") {\n          ee.off = this._patchRemoveListener(ee, ee.off);\n        }\n        if (typeof ee.removeAllListeners === \"function\") {\n          ee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners);\n        }\n        return ee;\n      }\n      /**\n       * Patch methods that remove a given listener so that we match the \"patched\"\n       * version of that listener (the one that propagate context).\n       * @param ee EventEmitter instance\n       * @param original reference to the patched method\n       */\n      _patchRemoveListener(ee, original) {\n        const contextManager = this;\n        return function(event, listener) {\n          var _a2;\n          const events = (_a2 = contextManager._getPatchMap(ee)) === null || _a2 === void 0 ? void 0 : _a2[event];\n          if (events === void 0) {\n            return original.call(this, event, listener);\n          }\n          const patchedListener = events.get(listener);\n          return original.call(this, event, patchedListener || listener);\n        };\n      }\n      /**\n       * Patch methods that remove all listeners so we remove our\n       * internal references for a given event.\n       * @param ee EventEmitter instance\n       * @param original reference to the patched method\n       */\n      _patchRemoveAllListeners(ee, original) {\n        const contextManager = this;\n        return function(event) {\n          const map = contextManager._getPatchMap(ee);\n          if (map !== void 0) {\n            if (arguments.length === 0) {\n              contextManager._createPatchMap(ee);\n            } else if (map[event] !== void 0) {\n              delete map[event];\n            }\n          }\n          return original.apply(this, arguments);\n        };\n      }\n      /**\n       * Patch methods on an event emitter instance that can add listeners so we\n       * can force them to propagate a given context.\n       * @param ee EventEmitter instance\n       * @param original reference to the patched method\n       * @param [context] context to propagate when calling listeners\n       */\n      _patchAddListener(ee, original, context2) {\n        const contextManager = this;\n        return function(event, listener) {\n          if (contextManager._wrapped) {\n            return original.call(this, event, listener);\n          }\n          let map = contextManager._getPatchMap(ee);\n          if (map === void 0) {\n            map = contextManager._createPatchMap(ee);\n          }\n          let listeners = map[event];\n          if (listeners === void 0) {\n            listeners = /* @__PURE__ */ new WeakMap();\n            map[event] = listeners;\n          }\n          const patchedListener = contextManager.bind(context2, listener);\n          listeners.set(listener, patchedListener);\n          contextManager._wrapped = true;\n          try {\n            return original.call(this, event, patchedListener);\n          } finally {\n            contextManager._wrapped = false;\n          }\n        };\n      }\n      _createPatchMap(ee) {\n        const map = /* @__PURE__ */ Object.create(null);\n        ee[this._kOtListeners] = map;\n        return map;\n      }\n      _getPatchMap(ee) {\n        return ee[this._kOtListeners];\n      }\n    };\n    exports.AbstractAsyncHooksContextManager = AbstractAsyncHooksContextManager;\n  }\n});\n\n// node_modules/@opentelemetry/context-async-hooks/build/src/AsyncHooksContextManager.js\nvar require_AsyncHooksContextManager = __commonJS({\n  \"node_modules/@opentelemetry/context-async-hooks/build/src/AsyncHooksContextManager.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.AsyncHooksContextManager = void 0;\n    var api_1 = (init_esm(), __toCommonJS(esm_exports));\n    var asyncHooks = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();\n    var AsyncHooksContextManager = class extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {\n      constructor() {\n        super();\n        this._contexts = /* @__PURE__ */ new Map();\n        this._stack = [];\n        this._asyncHook = asyncHooks.createHook({\n          init: this._init.bind(this),\n          before: this._before.bind(this),\n          after: this._after.bind(this),\n          destroy: this._destroy.bind(this),\n          promiseResolve: this._destroy.bind(this)\n        });\n      }\n      active() {\n        var _a2;\n        return (_a2 = this._stack[this._stack.length - 1]) !== null && _a2 !== void 0 ? _a2 : api_1.ROOT_CONTEXT;\n      }\n      with(context2, fn, thisArg, ...args) {\n        this._enterContext(context2);\n        try {\n          return fn.call(thisArg, ...args);\n        } finally {\n          this._exitContext();\n        }\n      }\n      enable() {\n        this._asyncHook.enable();\n        return this;\n      }\n      disable() {\n        this._asyncHook.disable();\n        this._contexts.clear();\n        this._stack = [];\n        return this;\n      }\n      /**\n       * Init hook will be called when userland create a async context, setting the\n       * context as the current one if it exist.\n       * @param uid id of the async context\n       * @param type the resource type\n       */\n      _init(uid, type) {\n        if (type === \"TIMERWRAP\")\n          return;\n        const context2 = this._stack[this._stack.length - 1];\n        if (context2 !== void 0) {\n          this._contexts.set(uid, context2);\n        }\n      }\n      /**\n       * Destroy hook will be called when a given context is no longer used so we can\n       * remove its attached context.\n       * @param uid uid of the async context\n       */\n      _destroy(uid) {\n        this._contexts.delete(uid);\n      }\n      /**\n       * Before hook is called just before executing a async context.\n       * @param uid uid of the async context\n       */\n      _before(uid) {\n        const context2 = this._contexts.get(uid);\n        if (context2 !== void 0) {\n          this._enterContext(context2);\n        }\n      }\n      /**\n       * After hook is called just after completing the execution of a async context.\n       */\n      _after() {\n        this._exitContext();\n      }\n      /**\n       * Set the given context as active\n       */\n      _enterContext(context2) {\n        this._stack.push(context2);\n      }\n      /**\n       * Remove the context at the root of the stack\n       */\n      _exitContext() {\n        this._stack.pop();\n      }\n    };\n    exports.AsyncHooksContextManager = AsyncHooksContextManager;\n  }\n});\n\n// node_modules/@opentelemetry/context-async-hooks/build/src/AsyncLocalStorageContextManager.js\nvar require_AsyncLocalStorageContextManager = __commonJS({\n  \"node_modules/@opentelemetry/context-async-hooks/build/src/AsyncLocalStorageContextManager.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.AsyncLocalStorageContextManager = void 0;\n    var api_1 = (init_esm(), __toCommonJS(esm_exports));\n    var async_hooks_1 = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n    var AbstractAsyncHooksContextManager_1 = require_AbstractAsyncHooksContextManager();\n    var AsyncLocalStorageContextManager = class extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {\n      constructor() {\n        super();\n        this._asyncLocalStorage = new async_hooks_1.AsyncLocalStorage();\n      }\n      active() {\n        var _a2;\n        return (_a2 = this._asyncLocalStorage.getStore()) !== null && _a2 !== void 0 ? _a2 : api_1.ROOT_CONTEXT;\n      }\n      with(context2, fn, thisArg, ...args) {\n        const cb = thisArg == null ? fn : fn.bind(thisArg);\n        return this._asyncLocalStorage.run(context2, cb, ...args);\n      }\n      enable() {\n        return this;\n      }\n      disable() {\n        this._asyncLocalStorage.disable();\n        return this;\n      }\n    };\n    exports.AsyncLocalStorageContextManager = AsyncLocalStorageContextManager;\n  }\n});\n\n// node_modules/@opentelemetry/context-async-hooks/build/src/index.js\nvar require_src = __commonJS({\n  \"node_modules/@opentelemetry/context-async-hooks/build/src/index.js\"(exports) {\n    \"use strict\";\n    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      Object.defineProperty(o, k2, { enumerable: true, get: function() {\n        return m[k];\n      } });\n    } : function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      o[k2] = m[k];\n    });\n    var __exportStar = exports && exports.__exportStar || function(m, exports2) {\n      for (var p in m)\n        if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports2, p))\n          __createBinding(exports2, m, p);\n    };\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    __exportStar(require_AsyncHooksContextManager(), exports);\n    __exportStar(require_AsyncLocalStorageContextManager(), exports);\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js\nfunction suppressTracing(context2) {\n  return context2.setValue(SUPPRESS_TRACING_KEY, true);\n}\nfunction unsuppressTracing(context2) {\n  return context2.deleteValue(SUPPRESS_TRACING_KEY);\n}\nfunction isTracingSuppressed(context2) {\n  return context2.getValue(SUPPRESS_TRACING_KEY) === true;\n}\nvar SUPPRESS_TRACING_KEY;\nvar init_suppress_tracing = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/suppress-tracing.js\"() {\n    init_esm();\n    SUPPRESS_TRACING_KEY = createContextKey(\"OpenTelemetry SDK Context Key SUPPRESS_TRACING\");\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/baggage/constants.js\nvar BAGGAGE_KEY_PAIR_SEPARATOR, BAGGAGE_PROPERTIES_SEPARATOR, BAGGAGE_ITEMS_SEPARATOR, BAGGAGE_HEADER, BAGGAGE_MAX_NAME_VALUE_PAIRS, BAGGAGE_MAX_PER_NAME_VALUE_PAIRS, BAGGAGE_MAX_TOTAL_LENGTH;\nvar init_constants = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/baggage/constants.js\"() {\n    BAGGAGE_KEY_PAIR_SEPARATOR = \"=\";\n    BAGGAGE_PROPERTIES_SEPARATOR = \";\";\n    BAGGAGE_ITEMS_SEPARATOR = \",\";\n    BAGGAGE_HEADER = \"baggage\";\n    BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;\n    BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;\n    BAGGAGE_MAX_TOTAL_LENGTH = 8192;\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/baggage/utils.js\nvar utils_exports = {};\n__export(utils_exports, {\n  getKeyPairs: () => getKeyPairs,\n  parseKeyPairsIntoRecord: () => parseKeyPairsIntoRecord,\n  parsePairKeyValue: () => parsePairKeyValue,\n  serializeKeyPairs: () => serializeKeyPairs\n});\nfunction serializeKeyPairs(keyPairs) {\n  return keyPairs.reduce(function(hValue, current) {\n    var value = \"\" + hValue + (hValue !== \"\" ? BAGGAGE_ITEMS_SEPARATOR : \"\") + current;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, \"\");\n}\nfunction getKeyPairs(baggage) {\n  return baggage.getAllEntries().map(function(_a2) {\n    var _b = __read6(_a2, 2), key = _b[0], value = _b[1];\n    var entry = encodeURIComponent(key) + \"=\" + encodeURIComponent(value.value);\n    if (value.metadata !== void 0) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n    return entry;\n  });\n}\nfunction parsePairKeyValue(entry) {\n  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0)\n    return;\n  var keyPairPart = valueProps.shift();\n  if (!keyPairPart)\n    return;\n  var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (separatorIndex <= 0)\n    return;\n  var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());\n  var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());\n  var metadata;\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));\n  }\n  return { key, value, metadata };\n}\nfunction parseKeyPairsIntoRecord(value) {\n  if (typeof value !== \"string\" || value.length === 0)\n    return {};\n  return value.split(BAGGAGE_ITEMS_SEPARATOR).map(function(entry) {\n    return parsePairKeyValue(entry);\n  }).filter(function(keyPair) {\n    return keyPair !== void 0 && keyPair.value.length > 0;\n  }).reduce(function(headers, keyPair) {\n    headers[keyPair.key] = keyPair.value;\n    return headers;\n  }, {});\n}\nvar __read6;\nvar init_utils3 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/baggage/utils.js\"() {\n    init_esm();\n    init_constants();\n    __read6 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js\nvar W3CBaggagePropagator;\nvar init_W3CBaggagePropagator = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/baggage/propagation/W3CBaggagePropagator.js\"() {\n    init_esm();\n    init_suppress_tracing();\n    init_constants();\n    init_utils3();\n    W3CBaggagePropagator = /** @class */\n    function() {\n      function W3CBaggagePropagator2() {\n      }\n      W3CBaggagePropagator2.prototype.inject = function(context2, carrier, setter) {\n        var baggage = propagation.getBaggage(context2);\n        if (!baggage || isTracingSuppressed(context2))\n          return;\n        var keyPairs = getKeyPairs(baggage).filter(function(pair) {\n          return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;\n        }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);\n        var headerValue = serializeKeyPairs(keyPairs);\n        if (headerValue.length > 0) {\n          setter.set(carrier, BAGGAGE_HEADER, headerValue);\n        }\n      };\n      W3CBaggagePropagator2.prototype.extract = function(context2, carrier, getter) {\n        var headerValue = getter.get(carrier, BAGGAGE_HEADER);\n        var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;\n        if (!baggageString)\n          return context2;\n        var baggage = {};\n        if (baggageString.length === 0) {\n          return context2;\n        }\n        var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);\n        pairs.forEach(function(entry) {\n          var keyPair = parsePairKeyValue(entry);\n          if (keyPair) {\n            var baggageEntry = { value: keyPair.value };\n            if (keyPair.metadata) {\n              baggageEntry.metadata = keyPair.metadata;\n            }\n            baggage[keyPair.key] = baggageEntry;\n          }\n        });\n        if (Object.entries(baggage).length === 0) {\n          return context2;\n        }\n        return propagation.setBaggage(context2, propagation.createBaggage(baggage));\n      };\n      W3CBaggagePropagator2.prototype.fields = function() {\n        return [BAGGAGE_HEADER];\n      };\n      return W3CBaggagePropagator2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/common/anchored-clock.js\nvar AnchoredClock;\nvar init_anchored_clock = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/common/anchored-clock.js\"() {\n    AnchoredClock = /** @class */\n    function() {\n      function AnchoredClock2(systemClock, monotonicClock) {\n        this._monotonicClock = monotonicClock;\n        this._epochMillis = systemClock.now();\n        this._performanceMillis = monotonicClock.now();\n      }\n      AnchoredClock2.prototype.now = function() {\n        var delta = this._monotonicClock.now() - this._performanceMillis;\n        return this._epochMillis + delta;\n      };\n      return AnchoredClock2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/common/attributes.js\nfunction sanitizeAttributes(attributes) {\n  var e_1, _a2;\n  var out = {};\n  if (typeof attributes !== \"object\" || attributes == null) {\n    return out;\n  }\n  try {\n    for (var _b = __values2(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var _d = __read7(_c.value, 2), key = _d[0], val = _d[1];\n      if (!isAttributeKey(key)) {\n        diag2.warn(\"Invalid attribute key: \" + key);\n        continue;\n      }\n      if (!isAttributeValue(val)) {\n        diag2.warn(\"Invalid attribute value set for key: \" + key);\n        continue;\n      }\n      if (Array.isArray(val)) {\n        out[key] = val.slice();\n      } else {\n        out[key] = val;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = { error: e_1_1 };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a2 = _b.return))\n        _a2.call(_b);\n    } finally {\n      if (e_1)\n        throw e_1.error;\n    }\n  }\n  return out;\n}\nfunction isAttributeKey(key) {\n  return typeof key === \"string\" && key.length > 0;\n}\nfunction isAttributeValue(val) {\n  if (val == null) {\n    return true;\n  }\n  if (Array.isArray(val)) {\n    return isHomogeneousAttributeValueArray(val);\n  }\n  return isValidPrimitiveAttributeValue(val);\n}\nfunction isHomogeneousAttributeValueArray(arr) {\n  var e_2, _a2;\n  var type;\n  try {\n    for (var arr_1 = __values2(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n      var element = arr_1_1.value;\n      if (element == null)\n        continue;\n      if (!type) {\n        if (isValidPrimitiveAttributeValue(element)) {\n          type = typeof element;\n          continue;\n        }\n        return false;\n      }\n      if (typeof element === type) {\n        continue;\n      }\n      return false;\n    }\n  } catch (e_2_1) {\n    e_2 = { error: e_2_1 };\n  } finally {\n    try {\n      if (arr_1_1 && !arr_1_1.done && (_a2 = arr_1.return))\n        _a2.call(arr_1);\n    } finally {\n      if (e_2)\n        throw e_2.error;\n    }\n  }\n  return true;\n}\nfunction isValidPrimitiveAttributeValue(val) {\n  switch (typeof val) {\n    case \"number\":\n    case \"boolean\":\n    case \"string\":\n      return true;\n  }\n  return false;\n}\nvar __values2, __read7;\nvar init_attributes = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/common/attributes.js\"() {\n    init_esm();\n    __values2 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n    __read7 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js\nfunction loggingErrorHandler() {\n  return function(ex) {\n    diag2.error(stringifyException(ex));\n  };\n}\nfunction stringifyException(ex) {\n  if (typeof ex === \"string\") {\n    return ex;\n  } else {\n    return JSON.stringify(flattenException(ex));\n  }\n}\nfunction flattenException(ex) {\n  var result = {};\n  var current = ex;\n  while (current !== null) {\n    Object.getOwnPropertyNames(current).forEach(function(propertyName) {\n      if (result[propertyName])\n        return;\n      var value = current[propertyName];\n      if (value) {\n        result[propertyName] = String(value);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  }\n  return result;\n}\nvar init_logging_error_handler = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/common/logging-error-handler.js\"() {\n    init_esm();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js\nfunction setGlobalErrorHandler(handler) {\n  delegateHandler = handler;\n}\nfunction globalErrorHandler(ex) {\n  try {\n    delegateHandler(ex);\n  } catch (_a2) {\n  }\n}\nvar delegateHandler;\nvar init_global_error_handler = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/common/global-error-handler.js\"() {\n    init_logging_error_handler();\n    delegateHandler = loggingErrorHandler();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/sampling.js\nvar TracesSamplerValues;\nvar init_sampling = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/sampling.js\"() {\n    (function(TracesSamplerValues2) {\n      TracesSamplerValues2[\"AlwaysOff\"] = \"always_off\";\n      TracesSamplerValues2[\"AlwaysOn\"] = \"always_on\";\n      TracesSamplerValues2[\"ParentBasedAlwaysOff\"] = \"parentbased_always_off\";\n      TracesSamplerValues2[\"ParentBasedAlwaysOn\"] = \"parentbased_always_on\";\n      TracesSamplerValues2[\"ParentBasedTraceIdRatio\"] = \"parentbased_traceidratio\";\n      TracesSamplerValues2[\"TraceIdRatio\"] = \"traceidratio\";\n    })(TracesSamplerValues || (TracesSamplerValues = {}));\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js\nvar _globalThis2;\nvar init_globalThis2 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/browser/globalThis.js\"() {\n    _globalThis2 = typeof globalThis === \"object\" ? globalThis : typeof self === \"object\" ? self : typeof window === \"object\" ? window : typeof global === \"object\" ? global : {};\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/environment.js\nfunction isEnvVarABoolean(key) {\n  return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;\n}\nfunction isEnvVarANumber(key) {\n  return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;\n}\nfunction isEnvVarAList(key) {\n  return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;\n}\nfunction parseBoolean(key, environment, values) {\n  if (typeof values[key] === \"undefined\") {\n    return;\n  }\n  var value = String(values[key]);\n  environment[key] = value.toLowerCase() === \"true\";\n}\nfunction parseNumber(name, environment, values, min, max) {\n  if (min === void 0) {\n    min = -Infinity;\n  }\n  if (max === void 0) {\n    max = Infinity;\n  }\n  if (typeof values[name] !== \"undefined\") {\n    var value = Number(values[name]);\n    if (!isNaN(value)) {\n      if (value < min) {\n        environment[name] = min;\n      } else if (value > max) {\n        environment[name] = max;\n      } else {\n        environment[name] = value;\n      }\n    }\n  }\n}\nfunction parseStringList(name, output, input, separator) {\n  if (separator === void 0) {\n    separator = DEFAULT_LIST_SEPARATOR;\n  }\n  var givenValue = input[name];\n  if (typeof givenValue === \"string\") {\n    output[name] = givenValue.split(separator).map(function(v) {\n      return v.trim();\n    });\n  }\n}\nfunction setLogLevelFromEnv(key, environment, values) {\n  var value = values[key];\n  if (typeof value === \"string\") {\n    var theLevel = logLevelMap[value.toUpperCase()];\n    if (theLevel != null) {\n      environment[key] = theLevel;\n    }\n  }\n}\nfunction parseEnvironment(values) {\n  var environment = {};\n  for (var env3 in DEFAULT_ENVIRONMENT) {\n    var key = env3;\n    switch (key) {\n      case \"OTEL_LOG_LEVEL\":\n        setLogLevelFromEnv(key, environment, values);\n        break;\n      default:\n        if (isEnvVarABoolean(key)) {\n          parseBoolean(key, environment, values);\n        } else if (isEnvVarANumber(key)) {\n          parseNumber(key, environment, values);\n        } else if (isEnvVarAList(key)) {\n          parseStringList(key, environment, values);\n        } else {\n          var value = values[key];\n          if (typeof value !== \"undefined\" && value !== null) {\n            environment[key] = String(value);\n          }\n        }\n    }\n  }\n  return environment;\n}\nfunction getEnvWithoutDefaults() {\n  return typeof process !== \"undefined\" && process && process.env ? parseEnvironment(process.env) : parseEnvironment(_globalThis2);\n}\nvar DEFAULT_LIST_SEPARATOR, ENVIRONMENT_BOOLEAN_KEYS, ENVIRONMENT_NUMBERS_KEYS, ENVIRONMENT_LISTS_KEYS, DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT, DEFAULT_ATTRIBUTE_COUNT_LIMIT, DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT, DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT, DEFAULT_ENVIRONMENT, logLevelMap;\nvar init_environment = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/environment.js\"() {\n    init_esm();\n    init_sampling();\n    init_globalThis2();\n    DEFAULT_LIST_SEPARATOR = \",\";\n    ENVIRONMENT_BOOLEAN_KEYS = [\"OTEL_SDK_DISABLED\"];\n    ENVIRONMENT_NUMBERS_KEYS = [\n      \"OTEL_BSP_EXPORT_TIMEOUT\",\n      \"OTEL_BSP_MAX_EXPORT_BATCH_SIZE\",\n      \"OTEL_BSP_MAX_QUEUE_SIZE\",\n      \"OTEL_BSP_SCHEDULE_DELAY\",\n      \"OTEL_BLRP_EXPORT_TIMEOUT\",\n      \"OTEL_BLRP_MAX_EXPORT_BATCH_SIZE\",\n      \"OTEL_BLRP_MAX_QUEUE_SIZE\",\n      \"OTEL_BLRP_SCHEDULE_DELAY\",\n      \"OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT\",\n      \"OTEL_ATTRIBUTE_COUNT_LIMIT\",\n      \"OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT\",\n      \"OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT\",\n      \"OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT\",\n      \"OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT\",\n      \"OTEL_SPAN_EVENT_COUNT_LIMIT\",\n      \"OTEL_SPAN_LINK_COUNT_LIMIT\",\n      \"OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT\",\n      \"OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT\",\n      \"OTEL_EXPORTER_OTLP_TIMEOUT\",\n      \"OTEL_EXPORTER_OTLP_TRACES_TIMEOUT\",\n      \"OTEL_EXPORTER_OTLP_METRICS_TIMEOUT\",\n      \"OTEL_EXPORTER_OTLP_LOGS_TIMEOUT\",\n      \"OTEL_EXPORTER_JAEGER_AGENT_PORT\"\n    ];\n    ENVIRONMENT_LISTS_KEYS = [\n      \"OTEL_NO_PATCH_MODULES\",\n      \"OTEL_PROPAGATORS\"\n    ];\n    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;\n    DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;\n    DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;\n    DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;\n    DEFAULT_ENVIRONMENT = {\n      OTEL_SDK_DISABLED: false,\n      CONTAINER_NAME: \"\",\n      ECS_CONTAINER_METADATA_URI_V4: \"\",\n      ECS_CONTAINER_METADATA_URI: \"\",\n      HOSTNAME: \"\",\n      KUBERNETES_SERVICE_HOST: \"\",\n      NAMESPACE: \"\",\n      OTEL_BSP_EXPORT_TIMEOUT: 3e4,\n      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,\n      OTEL_BSP_MAX_QUEUE_SIZE: 2048,\n      OTEL_BSP_SCHEDULE_DELAY: 5e3,\n      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,\n      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,\n      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,\n      OTEL_BLRP_SCHEDULE_DELAY: 5e3,\n      OTEL_EXPORTER_JAEGER_AGENT_HOST: \"\",\n      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,\n      OTEL_EXPORTER_JAEGER_ENDPOINT: \"\",\n      OTEL_EXPORTER_JAEGER_PASSWORD: \"\",\n      OTEL_EXPORTER_JAEGER_USER: \"\",\n      OTEL_EXPORTER_OTLP_ENDPOINT: \"\",\n      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: \"\",\n      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: \"\",\n      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: \"\",\n      OTEL_EXPORTER_OTLP_HEADERS: \"\",\n      OTEL_EXPORTER_OTLP_TRACES_HEADERS: \"\",\n      OTEL_EXPORTER_OTLP_METRICS_HEADERS: \"\",\n      OTEL_EXPORTER_OTLP_LOGS_HEADERS: \"\",\n      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,\n      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,\n      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,\n      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,\n      OTEL_EXPORTER_ZIPKIN_ENDPOINT: \"http://localhost:9411/api/v2/spans\",\n      OTEL_LOG_LEVEL: DiagLogLevel.INFO,\n      OTEL_NO_PATCH_MODULES: [],\n      OTEL_PROPAGATORS: [\"tracecontext\", \"baggage\"],\n      OTEL_RESOURCE_ATTRIBUTES: \"\",\n      OTEL_SERVICE_NAME: \"\",\n      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,\n      OTEL_SPAN_LINK_COUNT_LIMIT: 128,\n      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,\n      OTEL_TRACES_EXPORTER: \"\",\n      OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,\n      OTEL_TRACES_SAMPLER_ARG: \"\",\n      OTEL_LOGS_EXPORTER: \"\",\n      OTEL_EXPORTER_OTLP_INSECURE: \"\",\n      OTEL_EXPORTER_OTLP_TRACES_INSECURE: \"\",\n      OTEL_EXPORTER_OTLP_METRICS_INSECURE: \"\",\n      OTEL_EXPORTER_OTLP_LOGS_INSECURE: \"\",\n      OTEL_EXPORTER_OTLP_CERTIFICATE: \"\",\n      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: \"\",\n      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: \"\",\n      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: \"\",\n      OTEL_EXPORTER_OTLP_COMPRESSION: \"\",\n      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: \"\",\n      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: \"\",\n      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: \"\",\n      OTEL_EXPORTER_OTLP_CLIENT_KEY: \"\",\n      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: \"\",\n      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: \"\",\n      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: \"\",\n      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: \"\",\n      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: \"\",\n      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: \"\",\n      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: \"\",\n      OTEL_EXPORTER_OTLP_PROTOCOL: \"http/protobuf\",\n      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: \"http/protobuf\",\n      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: \"http/protobuf\",\n      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: \"http/protobuf\",\n      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: \"cumulative\"\n    };\n    logLevelMap = {\n      ALL: DiagLogLevel.ALL,\n      VERBOSE: DiagLogLevel.VERBOSE,\n      DEBUG: DiagLogLevel.DEBUG,\n      INFO: DiagLogLevel.INFO,\n      WARN: DiagLogLevel.WARN,\n      ERROR: DiagLogLevel.ERROR,\n      NONE: DiagLogLevel.NONE\n    };\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/node/environment.js\nfunction getEnv() {\n  var processEnv = parseEnvironment(process.env);\n  return Object.assign({}, DEFAULT_ENVIRONMENT, processEnv);\n}\nvar init_environment2 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/node/environment.js\"() {\n    init_environment();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/node/globalThis.js\nvar _globalThis3;\nvar init_globalThis3 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/node/globalThis.js\"() {\n    _globalThis3 = typeof globalThis === \"object\" ? globalThis : global;\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/common/hex-to-binary.js\nfunction intValue(charCode) {\n  if (charCode >= 48 && charCode <= 57) {\n    return charCode - 48;\n  }\n  if (charCode >= 97 && charCode <= 102) {\n    return charCode - 87;\n  }\n  return charCode - 55;\n}\nfunction hexToBinary(hexStr) {\n  var buf = new Uint8Array(hexStr.length / 2);\n  var offset = 0;\n  for (var i = 0; i < hexStr.length; i += 2) {\n    var hi = intValue(hexStr.charCodeAt(i));\n    var lo = intValue(hexStr.charCodeAt(i + 1));\n    buf[offset++] = hi << 4 | lo;\n  }\n  return buf;\n}\nvar init_hex_to_binary = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/common/hex-to-binary.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/node/hex-to-base64.js\nfunction hexToBase64(hexStr) {\n  return Buffer.from(hexToBinary(hexStr)).toString(\"base64\");\n}\nvar init_hex_to_base64 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/node/hex-to-base64.js\"() {\n    init_hex_to_binary();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/node/RandomIdGenerator.js\nfunction getIdGenerator(bytes) {\n  return function generateId() {\n    for (var i = 0; i < bytes / 4; i++) {\n      SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);\n    }\n    for (var i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER[bytes - 1] = 1;\n      }\n    }\n    return SHARED_BUFFER.toString(\"hex\", 0, bytes);\n  };\n}\nvar SPAN_ID_BYTES, TRACE_ID_BYTES, RandomIdGenerator, SHARED_BUFFER;\nvar init_RandomIdGenerator = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/node/RandomIdGenerator.js\"() {\n    SPAN_ID_BYTES = 8;\n    TRACE_ID_BYTES = 16;\n    RandomIdGenerator = /** @class */\n    function() {\n      function RandomIdGenerator3() {\n        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n      }\n      return RandomIdGenerator3;\n    }();\n    SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/node/performance.js\nvar import_perf_hooks, otperformance;\nvar init_performance = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/node/performance.js\"() {\n    import_perf_hooks = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n    otperformance = import_perf_hooks.performance;\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/version.js\nvar VERSION2;\nvar init_version2 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/version.js\"() {\n    VERSION2 = \"1.23.0\";\n  }\n});\n\n// node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js\n// @__NO_SIDE_EFFECTS__\nfunction createConstMap(values) {\n  var res = {};\n  var len = values.length;\n  for (var lp = 0; lp < len; lp++) {\n    var val = values[lp];\n    if (val) {\n      res[String(val).toUpperCase().replace(/[-.]/g, \"_\")] = val;\n    }\n  }\n  return res;\n}\nvar init_utils4 = __esm({\n  \"node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js\nvar TMP_AWS_LAMBDA_INVOKED_ARN, TMP_DB_SYSTEM, TMP_DB_CONNECTION_STRING, TMP_DB_USER, TMP_DB_JDBC_DRIVER_CLASSNAME, TMP_DB_NAME, TMP_DB_STATEMENT, TMP_DB_OPERATION, TMP_DB_MSSQL_INSTANCE_NAME, TMP_DB_CASSANDRA_KEYSPACE, TMP_DB_CASSANDRA_PAGE_SIZE, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL, TMP_DB_CASSANDRA_TABLE, TMP_DB_CASSANDRA_IDEMPOTENCE, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, TMP_DB_CASSANDRA_COORDINATOR_ID, TMP_DB_CASSANDRA_COORDINATOR_DC, TMP_DB_HBASE_NAMESPACE, TMP_DB_REDIS_DATABASE_INDEX, TMP_DB_MONGODB_COLLECTION, TMP_DB_SQL_TABLE, TMP_EXCEPTION_TYPE, TMP_EXCEPTION_MESSAGE, TMP_EXCEPTION_STACKTRACE, TMP_EXCEPTION_ESCAPED, TMP_FAAS_TRIGGER, TMP_FAAS_EXECUTION, TMP_FAAS_DOCUMENT_COLLECTION, TMP_FAAS_DOCUMENT_OPERATION, TMP_FAAS_DOCUMENT_TIME, TMP_FAAS_DOCUMENT_NAME, TMP_FAAS_TIME, TMP_FAAS_CRON, TMP_FAAS_COLDSTART, TMP_FAAS_INVOKED_NAME, TMP_FAAS_INVOKED_PROVIDER, TMP_FAAS_INVOKED_REGION, TMP_NET_TRANSPORT, TMP_NET_PEER_IP, TMP_NET_PEER_PORT, TMP_NET_PEER_NAME, TMP_NET_HOST_IP, TMP_NET_HOST_PORT, TMP_NET_HOST_NAME, TMP_NET_HOST_CONNECTION_TYPE, TMP_NET_HOST_CONNECTION_SUBTYPE, TMP_NET_HOST_CARRIER_NAME, TMP_NET_HOST_CARRIER_MCC, TMP_NET_HOST_CARRIER_MNC, TMP_NET_HOST_CARRIER_ICC, TMP_PEER_SERVICE, TMP_ENDUSER_ID, TMP_ENDUSER_ROLE, TMP_ENDUSER_SCOPE, TMP_THREAD_ID, TMP_THREAD_NAME, TMP_CODE_FUNCTION, TMP_CODE_NAMESPACE, TMP_CODE_FILEPATH, TMP_CODE_LINENO, TMP_HTTP_METHOD, TMP_HTTP_URL, TMP_HTTP_TARGET, TMP_HTTP_HOST, TMP_HTTP_SCHEME, TMP_HTTP_STATUS_CODE, TMP_HTTP_FLAVOR, TMP_HTTP_USER_AGENT, TMP_HTTP_REQUEST_CONTENT_LENGTH, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_RESPONSE_CONTENT_LENGTH, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_SERVER_NAME, TMP_HTTP_ROUTE, TMP_HTTP_CLIENT_IP, TMP_AWS_DYNAMODB_TABLE_NAMES, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, TMP_AWS_DYNAMODB_CONSISTENT_READ, TMP_AWS_DYNAMODB_PROJECTION, TMP_AWS_DYNAMODB_LIMIT, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET, TMP_AWS_DYNAMODB_INDEX_NAME, TMP_AWS_DYNAMODB_SELECT, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, TMP_AWS_DYNAMODB_TABLE_COUNT, TMP_AWS_DYNAMODB_SCAN_FORWARD, TMP_AWS_DYNAMODB_SEGMENT, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS, TMP_AWS_DYNAMODB_COUNT, TMP_AWS_DYNAMODB_SCANNED_COUNT, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, TMP_MESSAGING_SYSTEM, TMP_MESSAGING_DESTINATION, TMP_MESSAGING_DESTINATION_KIND, TMP_MESSAGING_TEMP_DESTINATION, TMP_MESSAGING_PROTOCOL, TMP_MESSAGING_PROTOCOL_VERSION, TMP_MESSAGING_URL, TMP_MESSAGING_MESSAGE_ID, TMP_MESSAGING_CONVERSATION_ID, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, TMP_MESSAGING_OPERATION, TMP_MESSAGING_CONSUMER_ID, TMP_MESSAGING_RABBITMQ_ROUTING_KEY, TMP_MESSAGING_KAFKA_MESSAGE_KEY, TMP_MESSAGING_KAFKA_CONSUMER_GROUP, TMP_MESSAGING_KAFKA_CLIENT_ID, TMP_MESSAGING_KAFKA_PARTITION, TMP_MESSAGING_KAFKA_TOMBSTONE, TMP_RPC_SYSTEM, TMP_RPC_SERVICE, TMP_RPC_METHOD, TMP_RPC_GRPC_STATUS_CODE, TMP_RPC_JSONRPC_VERSION, TMP_RPC_JSONRPC_REQUEST_ID, TMP_RPC_JSONRPC_ERROR_CODE, TMP_RPC_JSONRPC_ERROR_MESSAGE, TMP_MESSAGE_TYPE, TMP_MESSAGE_ID, TMP_MESSAGE_COMPRESSED_SIZE, TMP_MESSAGE_UNCOMPRESSED_SIZE, SEMATTRS_AWS_LAMBDA_INVOKED_ARN, SEMATTRS_DB_SYSTEM, SEMATTRS_DB_CONNECTION_STRING, SEMATTRS_DB_USER, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME, SEMATTRS_DB_NAME, SEMATTRS_DB_STATEMENT, SEMATTRS_DB_OPERATION, SEMATTRS_DB_MSSQL_INSTANCE_NAME, SEMATTRS_DB_CASSANDRA_KEYSPACE, SEMATTRS_DB_CASSANDRA_PAGE_SIZE, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL, SEMATTRS_DB_CASSANDRA_TABLE, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC, SEMATTRS_DB_HBASE_NAMESPACE, SEMATTRS_DB_REDIS_DATABASE_INDEX, SEMATTRS_DB_MONGODB_COLLECTION, SEMATTRS_DB_SQL_TABLE, SEMATTRS_EXCEPTION_TYPE, SEMATTRS_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_ESCAPED, SEMATTRS_FAAS_TRIGGER, SEMATTRS_FAAS_EXECUTION, SEMATTRS_FAAS_DOCUMENT_COLLECTION, SEMATTRS_FAAS_DOCUMENT_OPERATION, SEMATTRS_FAAS_DOCUMENT_TIME, SEMATTRS_FAAS_DOCUMENT_NAME, SEMATTRS_FAAS_TIME, SEMATTRS_FAAS_CRON, SEMATTRS_FAAS_COLDSTART, SEMATTRS_FAAS_INVOKED_NAME, SEMATTRS_FAAS_INVOKED_PROVIDER, SEMATTRS_FAAS_INVOKED_REGION, SEMATTRS_NET_TRANSPORT, SEMATTRS_NET_PEER_IP, SEMATTRS_NET_PEER_PORT, SEMATTRS_NET_PEER_NAME, SEMATTRS_NET_HOST_IP, SEMATTRS_NET_HOST_PORT, SEMATTRS_NET_HOST_NAME, SEMATTRS_NET_HOST_CONNECTION_TYPE, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE, SEMATTRS_NET_HOST_CARRIER_NAME, SEMATTRS_NET_HOST_CARRIER_MCC, SEMATTRS_NET_HOST_CARRIER_MNC, SEMATTRS_NET_HOST_CARRIER_ICC, SEMATTRS_PEER_SERVICE, SEMATTRS_ENDUSER_ID, SEMATTRS_ENDUSER_ROLE, SEMATTRS_ENDUSER_SCOPE, SEMATTRS_THREAD_ID, SEMATTRS_THREAD_NAME, SEMATTRS_CODE_FUNCTION, SEMATTRS_CODE_NAMESPACE, SEMATTRS_CODE_FILEPATH, SEMATTRS_CODE_LINENO, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_URL, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_FLAVOR, SEMATTRS_HTTP_USER_AGENT, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_SERVER_NAME, SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_CLIENT_IP, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ, SEMATTRS_AWS_DYNAMODB_PROJECTION, SEMATTRS_AWS_DYNAMODB_LIMIT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET, SEMATTRS_AWS_DYNAMODB_INDEX_NAME, SEMATTRS_AWS_DYNAMODB_SELECT, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD, SEMATTRS_AWS_DYNAMODB_SEGMENT, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS, SEMATTRS_AWS_DYNAMODB_COUNT, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, SEMATTRS_MESSAGING_SYSTEM, SEMATTRS_MESSAGING_DESTINATION, SEMATTRS_MESSAGING_DESTINATION_KIND, SEMATTRS_MESSAGING_TEMP_DESTINATION, SEMATTRS_MESSAGING_PROTOCOL, SEMATTRS_MESSAGING_PROTOCOL_VERSION, SEMATTRS_MESSAGING_URL, SEMATTRS_MESSAGING_MESSAGE_ID, SEMATTRS_MESSAGING_CONVERSATION_ID, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, SEMATTRS_MESSAGING_OPERATION, SEMATTRS_MESSAGING_CONSUMER_ID, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID, SEMATTRS_MESSAGING_KAFKA_PARTITION, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE, SEMATTRS_RPC_SYSTEM, SEMATTRS_RPC_SERVICE, SEMATTRS_RPC_METHOD, SEMATTRS_RPC_GRPC_STATUS_CODE, SEMATTRS_RPC_JSONRPC_VERSION, SEMATTRS_RPC_JSONRPC_REQUEST_ID, SEMATTRS_RPC_JSONRPC_ERROR_CODE, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE, SEMATTRS_MESSAGE_TYPE, SEMATTRS_MESSAGE_ID, SEMATTRS_MESSAGE_COMPRESSED_SIZE, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE, SemanticAttributes, TMP_DBSYSTEMVALUES_OTHER_SQL, TMP_DBSYSTEMVALUES_MSSQL, TMP_DBSYSTEMVALUES_MYSQL, TMP_DBSYSTEMVALUES_ORACLE, TMP_DBSYSTEMVALUES_DB2, TMP_DBSYSTEMVALUES_POSTGRESQL, TMP_DBSYSTEMVALUES_REDSHIFT, TMP_DBSYSTEMVALUES_HIVE, TMP_DBSYSTEMVALUES_CLOUDSCAPE, TMP_DBSYSTEMVALUES_HSQLDB, TMP_DBSYSTEMVALUES_PROGRESS, TMP_DBSYSTEMVALUES_MAXDB, TMP_DBSYSTEMVALUES_HANADB, TMP_DBSYSTEMVALUES_INGRES, TMP_DBSYSTEMVALUES_FIRSTSQL, TMP_DBSYSTEMVALUES_EDB, TMP_DBSYSTEMVALUES_CACHE, TMP_DBSYSTEMVALUES_ADABAS, TMP_DBSYSTEMVALUES_FIREBIRD, TMP_DBSYSTEMVALUES_DERBY, TMP_DBSYSTEMVALUES_FILEMAKER, TMP_DBSYSTEMVALUES_INFORMIX, TMP_DBSYSTEMVALUES_INSTANTDB, TMP_DBSYSTEMVALUES_INTERBASE, TMP_DBSYSTEMVALUES_MARIADB, TMP_DBSYSTEMVALUES_NETEZZA, TMP_DBSYSTEMVALUES_PERVASIVE, TMP_DBSYSTEMVALUES_POINTBASE, TMP_DBSYSTEMVALUES_SQLITE, TMP_DBSYSTEMVALUES_SYBASE, TMP_DBSYSTEMVALUES_TERADATA, TMP_DBSYSTEMVALUES_VERTICA, TMP_DBSYSTEMVALUES_H2, TMP_DBSYSTEMVALUES_COLDFUSION, TMP_DBSYSTEMVALUES_CASSANDRA, TMP_DBSYSTEMVALUES_HBASE, TMP_DBSYSTEMVALUES_MONGODB, TMP_DBSYSTEMVALUES_REDIS, TMP_DBSYSTEMVALUES_COUCHBASE, TMP_DBSYSTEMVALUES_COUCHDB, TMP_DBSYSTEMVALUES_COSMOSDB, TMP_DBSYSTEMVALUES_DYNAMODB, TMP_DBSYSTEMVALUES_NEO4J, TMP_DBSYSTEMVALUES_GEODE, TMP_DBSYSTEMVALUES_ELASTICSEARCH, TMP_DBSYSTEMVALUES_MEMCACHED, TMP_DBSYSTEMVALUES_COCKROACHDB, DBSYSTEMVALUES_OTHER_SQL, DBSYSTEMVALUES_MSSQL, DBSYSTEMVALUES_MYSQL, DBSYSTEMVALUES_ORACLE, DBSYSTEMVALUES_DB2, DBSYSTEMVALUES_POSTGRESQL, DBSYSTEMVALUES_REDSHIFT, DBSYSTEMVALUES_HIVE, DBSYSTEMVALUES_CLOUDSCAPE, DBSYSTEMVALUES_HSQLDB, DBSYSTEMVALUES_PROGRESS, DBSYSTEMVALUES_MAXDB, DBSYSTEMVALUES_HANADB, DBSYSTEMVALUES_INGRES, DBSYSTEMVALUES_FIRSTSQL, DBSYSTEMVALUES_EDB, DBSYSTEMVALUES_CACHE, DBSYSTEMVALUES_ADABAS, DBSYSTEMVALUES_FIREBIRD, DBSYSTEMVALUES_DERBY, DBSYSTEMVALUES_FILEMAKER, DBSYSTEMVALUES_INFORMIX, DBSYSTEMVALUES_INSTANTDB, DBSYSTEMVALUES_INTERBASE, DBSYSTEMVALUES_MARIADB, DBSYSTEMVALUES_NETEZZA, DBSYSTEMVALUES_PERVASIVE, DBSYSTEMVALUES_POINTBASE, DBSYSTEMVALUES_SQLITE, DBSYSTEMVALUES_SYBASE, DBSYSTEMVALUES_TERADATA, DBSYSTEMVALUES_VERTICA, DBSYSTEMVALUES_H2, DBSYSTEMVALUES_COLDFUSION, DBSYSTEMVALUES_CASSANDRA, DBSYSTEMVALUES_HBASE, DBSYSTEMVALUES_MONGODB, DBSYSTEMVALUES_REDIS, DBSYSTEMVALUES_COUCHBASE, DBSYSTEMVALUES_COUCHDB, DBSYSTEMVALUES_COSMOSDB, DBSYSTEMVALUES_DYNAMODB, DBSYSTEMVALUES_NEO4J, DBSYSTEMVALUES_GEODE, DBSYSTEMVALUES_ELASTICSEARCH, DBSYSTEMVALUES_MEMCACHED, DBSYSTEMVALUES_COCKROACHDB, DbSystemValues, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_ALL, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_TWO, DBCASSANDRACONSISTENCYLEVELVALUES_THREE, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_ANY, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DbCassandraConsistencyLevelValues, TMP_FAASTRIGGERVALUES_DATASOURCE, TMP_FAASTRIGGERVALUES_HTTP, TMP_FAASTRIGGERVALUES_PUBSUB, TMP_FAASTRIGGERVALUES_TIMER, TMP_FAASTRIGGERVALUES_OTHER, FAASTRIGGERVALUES_DATASOURCE, FAASTRIGGERVALUES_HTTP, FAASTRIGGERVALUES_PUBSUB, FAASTRIGGERVALUES_TIMER, FAASTRIGGERVALUES_OTHER, FaasTriggerValues, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE, FAASDOCUMENTOPERATIONVALUES_INSERT, FAASDOCUMENTOPERATIONVALUES_EDIT, FAASDOCUMENTOPERATIONVALUES_DELETE, FaasDocumentOperationValues, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, TMP_FAASINVOKEDPROVIDERVALUES_AWS, TMP_FAASINVOKEDPROVIDERVALUES_AZURE, TMP_FAASINVOKEDPROVIDERVALUES_GCP, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, FAASINVOKEDPROVIDERVALUES_AWS, FAASINVOKEDPROVIDERVALUES_AZURE, FAASINVOKEDPROVIDERVALUES_GCP, FaasInvokedProviderValues, TMP_NETTRANSPORTVALUES_IP_TCP, TMP_NETTRANSPORTVALUES_IP_UDP, TMP_NETTRANSPORTVALUES_IP, TMP_NETTRANSPORTVALUES_UNIX, TMP_NETTRANSPORTVALUES_PIPE, TMP_NETTRANSPORTVALUES_INPROC, TMP_NETTRANSPORTVALUES_OTHER, NETTRANSPORTVALUES_IP_TCP, NETTRANSPORTVALUES_IP_UDP, NETTRANSPORTVALUES_IP, NETTRANSPORTVALUES_UNIX, NETTRANSPORTVALUES_PIPE, NETTRANSPORTVALUES_INPROC, NETTRANSPORTVALUES_OTHER, NetTransportValues, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NETHOSTCONNECTIONTYPEVALUES_WIFI, NETHOSTCONNECTIONTYPEVALUES_WIRED, NETHOSTCONNECTIONTYPEVALUES_CELL, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NetHostConnectionTypeValues, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, NETHOSTCONNECTIONSUBTYPEVALUES_LTE, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, NETHOSTCONNECTIONSUBTYPEVALUES_GSM, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, NETHOSTCONNECTIONSUBTYPEVALUES_NR, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NetHostConnectionSubtypeValues, TMP_HTTPFLAVORVALUES_HTTP_1_0, TMP_HTTPFLAVORVALUES_HTTP_1_1, TMP_HTTPFLAVORVALUES_HTTP_2_0, TMP_HTTPFLAVORVALUES_SPDY, TMP_HTTPFLAVORVALUES_QUIC, HTTPFLAVORVALUES_HTTP_1_0, HTTPFLAVORVALUES_HTTP_1_1, HTTPFLAVORVALUES_HTTP_2_0, HTTPFLAVORVALUES_SPDY, HTTPFLAVORVALUES_QUIC, HttpFlavorValues, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC, MESSAGINGDESTINATIONKINDVALUES_QUEUE, MESSAGINGDESTINATIONKINDVALUES_TOPIC, MessagingDestinationKindValues, TMP_MESSAGINGOPERATIONVALUES_RECEIVE, TMP_MESSAGINGOPERATIONVALUES_PROCESS, MESSAGINGOPERATIONVALUES_RECEIVE, MESSAGINGOPERATIONVALUES_PROCESS, MessagingOperationValues, TMP_RPCGRPCSTATUSCODEVALUES_OK, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RPCGRPCSTATUSCODEVALUES_OK, RPCGRPCSTATUSCODEVALUES_CANCELLED, RPCGRPCSTATUSCODEVALUES_UNKNOWN, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, RPCGRPCSTATUSCODEVALUES_NOT_FOUND, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, RPCGRPCSTATUSCODEVALUES_ABORTED, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, RPCGRPCSTATUSCODEVALUES_INTERNAL, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, RPCGRPCSTATUSCODEVALUES_DATA_LOSS, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RpcGrpcStatusCodeValues, TMP_MESSAGETYPEVALUES_SENT, TMP_MESSAGETYPEVALUES_RECEIVED, MESSAGETYPEVALUES_SENT, MESSAGETYPEVALUES_RECEIVED, MessageTypeValues;\nvar init_SemanticAttributes = __esm({\n  \"node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js\"() {\n    init_utils4();\n    TMP_AWS_LAMBDA_INVOKED_ARN = \"aws.lambda.invoked_arn\";\n    TMP_DB_SYSTEM = \"db.system\";\n    TMP_DB_CONNECTION_STRING = \"db.connection_string\";\n    TMP_DB_USER = \"db.user\";\n    TMP_DB_JDBC_DRIVER_CLASSNAME = \"db.jdbc.driver_classname\";\n    TMP_DB_NAME = \"db.name\";\n    TMP_DB_STATEMENT = \"db.statement\";\n    TMP_DB_OPERATION = \"db.operation\";\n    TMP_DB_MSSQL_INSTANCE_NAME = \"db.mssql.instance_name\";\n    TMP_DB_CASSANDRA_KEYSPACE = \"db.cassandra.keyspace\";\n    TMP_DB_CASSANDRA_PAGE_SIZE = \"db.cassandra.page_size\";\n    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = \"db.cassandra.consistency_level\";\n    TMP_DB_CASSANDRA_TABLE = \"db.cassandra.table\";\n    TMP_DB_CASSANDRA_IDEMPOTENCE = \"db.cassandra.idempotence\";\n    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = \"db.cassandra.speculative_execution_count\";\n    TMP_DB_CASSANDRA_COORDINATOR_ID = \"db.cassandra.coordinator.id\";\n    TMP_DB_CASSANDRA_COORDINATOR_DC = \"db.cassandra.coordinator.dc\";\n    TMP_DB_HBASE_NAMESPACE = \"db.hbase.namespace\";\n    TMP_DB_REDIS_DATABASE_INDEX = \"db.redis.database_index\";\n    TMP_DB_MONGODB_COLLECTION = \"db.mongodb.collection\";\n    TMP_DB_SQL_TABLE = \"db.sql.table\";\n    TMP_EXCEPTION_TYPE = \"exception.type\";\n    TMP_EXCEPTION_MESSAGE = \"exception.message\";\n    TMP_EXCEPTION_STACKTRACE = \"exception.stacktrace\";\n    TMP_EXCEPTION_ESCAPED = \"exception.escaped\";\n    TMP_FAAS_TRIGGER = \"faas.trigger\";\n    TMP_FAAS_EXECUTION = \"faas.execution\";\n    TMP_FAAS_DOCUMENT_COLLECTION = \"faas.document.collection\";\n    TMP_FAAS_DOCUMENT_OPERATION = \"faas.document.operation\";\n    TMP_FAAS_DOCUMENT_TIME = \"faas.document.time\";\n    TMP_FAAS_DOCUMENT_NAME = \"faas.document.name\";\n    TMP_FAAS_TIME = \"faas.time\";\n    TMP_FAAS_CRON = \"faas.cron\";\n    TMP_FAAS_COLDSTART = \"faas.coldstart\";\n    TMP_FAAS_INVOKED_NAME = \"faas.invoked_name\";\n    TMP_FAAS_INVOKED_PROVIDER = \"faas.invoked_provider\";\n    TMP_FAAS_INVOKED_REGION = \"faas.invoked_region\";\n    TMP_NET_TRANSPORT = \"net.transport\";\n    TMP_NET_PEER_IP = \"net.peer.ip\";\n    TMP_NET_PEER_PORT = \"net.peer.port\";\n    TMP_NET_PEER_NAME = \"net.peer.name\";\n    TMP_NET_HOST_IP = \"net.host.ip\";\n    TMP_NET_HOST_PORT = \"net.host.port\";\n    TMP_NET_HOST_NAME = \"net.host.name\";\n    TMP_NET_HOST_CONNECTION_TYPE = \"net.host.connection.type\";\n    TMP_NET_HOST_CONNECTION_SUBTYPE = \"net.host.connection.subtype\";\n    TMP_NET_HOST_CARRIER_NAME = \"net.host.carrier.name\";\n    TMP_NET_HOST_CARRIER_MCC = \"net.host.carrier.mcc\";\n    TMP_NET_HOST_CARRIER_MNC = \"net.host.carrier.mnc\";\n    TMP_NET_HOST_CARRIER_ICC = \"net.host.carrier.icc\";\n    TMP_PEER_SERVICE = \"peer.service\";\n    TMP_ENDUSER_ID = \"enduser.id\";\n    TMP_ENDUSER_ROLE = \"enduser.role\";\n    TMP_ENDUSER_SCOPE = \"enduser.scope\";\n    TMP_THREAD_ID = \"thread.id\";\n    TMP_THREAD_NAME = \"thread.name\";\n    TMP_CODE_FUNCTION = \"code.function\";\n    TMP_CODE_NAMESPACE = \"code.namespace\";\n    TMP_CODE_FILEPATH = \"code.filepath\";\n    TMP_CODE_LINENO = \"code.lineno\";\n    TMP_HTTP_METHOD = \"http.method\";\n    TMP_HTTP_URL = \"http.url\";\n    TMP_HTTP_TARGET = \"http.target\";\n    TMP_HTTP_HOST = \"http.host\";\n    TMP_HTTP_SCHEME = \"http.scheme\";\n    TMP_HTTP_STATUS_CODE = \"http.status_code\";\n    TMP_HTTP_FLAVOR = \"http.flavor\";\n    TMP_HTTP_USER_AGENT = \"http.user_agent\";\n    TMP_HTTP_REQUEST_CONTENT_LENGTH = \"http.request_content_length\";\n    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = \"http.request_content_length_uncompressed\";\n    TMP_HTTP_RESPONSE_CONTENT_LENGTH = \"http.response_content_length\";\n    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = \"http.response_content_length_uncompressed\";\n    TMP_HTTP_SERVER_NAME = \"http.server_name\";\n    TMP_HTTP_ROUTE = \"http.route\";\n    TMP_HTTP_CLIENT_IP = \"http.client_ip\";\n    TMP_AWS_DYNAMODB_TABLE_NAMES = \"aws.dynamodb.table_names\";\n    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = \"aws.dynamodb.consumed_capacity\";\n    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = \"aws.dynamodb.item_collection_metrics\";\n    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = \"aws.dynamodb.provisioned_read_capacity\";\n    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = \"aws.dynamodb.provisioned_write_capacity\";\n    TMP_AWS_DYNAMODB_CONSISTENT_READ = \"aws.dynamodb.consistent_read\";\n    TMP_AWS_DYNAMODB_PROJECTION = \"aws.dynamodb.projection\";\n    TMP_AWS_DYNAMODB_LIMIT = \"aws.dynamodb.limit\";\n    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = \"aws.dynamodb.attributes_to_get\";\n    TMP_AWS_DYNAMODB_INDEX_NAME = \"aws.dynamodb.index_name\";\n    TMP_AWS_DYNAMODB_SELECT = \"aws.dynamodb.select\";\n    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = \"aws.dynamodb.global_secondary_indexes\";\n    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = \"aws.dynamodb.local_secondary_indexes\";\n    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = \"aws.dynamodb.exclusive_start_table\";\n    TMP_AWS_DYNAMODB_TABLE_COUNT = \"aws.dynamodb.table_count\";\n    TMP_AWS_DYNAMODB_SCAN_FORWARD = \"aws.dynamodb.scan_forward\";\n    TMP_AWS_DYNAMODB_SEGMENT = \"aws.dynamodb.segment\";\n    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = \"aws.dynamodb.total_segments\";\n    TMP_AWS_DYNAMODB_COUNT = \"aws.dynamodb.count\";\n    TMP_AWS_DYNAMODB_SCANNED_COUNT = \"aws.dynamodb.scanned_count\";\n    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = \"aws.dynamodb.attribute_definitions\";\n    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = \"aws.dynamodb.global_secondary_index_updates\";\n    TMP_MESSAGING_SYSTEM = \"messaging.system\";\n    TMP_MESSAGING_DESTINATION = \"messaging.destination\";\n    TMP_MESSAGING_DESTINATION_KIND = \"messaging.destination_kind\";\n    TMP_MESSAGING_TEMP_DESTINATION = \"messaging.temp_destination\";\n    TMP_MESSAGING_PROTOCOL = \"messaging.protocol\";\n    TMP_MESSAGING_PROTOCOL_VERSION = \"messaging.protocol_version\";\n    TMP_MESSAGING_URL = \"messaging.url\";\n    TMP_MESSAGING_MESSAGE_ID = \"messaging.message_id\";\n    TMP_MESSAGING_CONVERSATION_ID = \"messaging.conversation_id\";\n    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = \"messaging.message_payload_size_bytes\";\n    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = \"messaging.message_payload_compressed_size_bytes\";\n    TMP_MESSAGING_OPERATION = \"messaging.operation\";\n    TMP_MESSAGING_CONSUMER_ID = \"messaging.consumer_id\";\n    TMP_MESSAGING_RABBITMQ_ROUTING_KEY = \"messaging.rabbitmq.routing_key\";\n    TMP_MESSAGING_KAFKA_MESSAGE_KEY = \"messaging.kafka.message_key\";\n    TMP_MESSAGING_KAFKA_CONSUMER_GROUP = \"messaging.kafka.consumer_group\";\n    TMP_MESSAGING_KAFKA_CLIENT_ID = \"messaging.kafka.client_id\";\n    TMP_MESSAGING_KAFKA_PARTITION = \"messaging.kafka.partition\";\n    TMP_MESSAGING_KAFKA_TOMBSTONE = \"messaging.kafka.tombstone\";\n    TMP_RPC_SYSTEM = \"rpc.system\";\n    TMP_RPC_SERVICE = \"rpc.service\";\n    TMP_RPC_METHOD = \"rpc.method\";\n    TMP_RPC_GRPC_STATUS_CODE = \"rpc.grpc.status_code\";\n    TMP_RPC_JSONRPC_VERSION = \"rpc.jsonrpc.version\";\n    TMP_RPC_JSONRPC_REQUEST_ID = \"rpc.jsonrpc.request_id\";\n    TMP_RPC_JSONRPC_ERROR_CODE = \"rpc.jsonrpc.error_code\";\n    TMP_RPC_JSONRPC_ERROR_MESSAGE = \"rpc.jsonrpc.error_message\";\n    TMP_MESSAGE_TYPE = \"message.type\";\n    TMP_MESSAGE_ID = \"message.id\";\n    TMP_MESSAGE_COMPRESSED_SIZE = \"message.compressed_size\";\n    TMP_MESSAGE_UNCOMPRESSED_SIZE = \"message.uncompressed_size\";\n    SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;\n    SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;\n    SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;\n    SEMATTRS_DB_USER = TMP_DB_USER;\n    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;\n    SEMATTRS_DB_NAME = TMP_DB_NAME;\n    SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;\n    SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;\n    SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;\n    SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;\n    SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;\n    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;\n    SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;\n    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;\n    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;\n    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;\n    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;\n    SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;\n    SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;\n    SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;\n    SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;\n    SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;\n    SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;\n    SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;\n    SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;\n    SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;\n    SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;\n    SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;\n    SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;\n    SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;\n    SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;\n    SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;\n    SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;\n    SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;\n    SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;\n    SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;\n    SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;\n    SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;\n    SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;\n    SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;\n    SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;\n    SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;\n    SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;\n    SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;\n    SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;\n    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;\n    SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;\n    SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;\n    SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;\n    SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;\n    SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;\n    SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;\n    SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;\n    SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;\n    SEMATTRS_THREAD_ID = TMP_THREAD_ID;\n    SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;\n    SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;\n    SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;\n    SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;\n    SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;\n    SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;\n    SEMATTRS_HTTP_URL = TMP_HTTP_URL;\n    SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;\n    SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;\n    SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;\n    SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;\n    SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;\n    SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;\n    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;\n    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;\n    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;\n    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;\n    SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;\n    SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;\n    SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;\n    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;\n    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;\n    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;\n    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;\n    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;\n    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;\n    SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;\n    SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;\n    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;\n    SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;\n    SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;\n    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;\n    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;\n    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;\n    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;\n    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;\n    SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;\n    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;\n    SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;\n    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;\n    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;\n    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;\n    SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;\n    SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;\n    SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;\n    SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;\n    SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;\n    SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;\n    SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;\n    SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;\n    SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;\n    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;\n    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;\n    SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;\n    SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;\n    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;\n    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;\n    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;\n    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;\n    SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;\n    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;\n    SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;\n    SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;\n    SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;\n    SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;\n    SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;\n    SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;\n    SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;\n    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;\n    SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;\n    SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;\n    SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;\n    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;\n    SemanticAttributes = /* @__PURE__ */ createConstMap([\n      TMP_AWS_LAMBDA_INVOKED_ARN,\n      TMP_DB_SYSTEM,\n      TMP_DB_CONNECTION_STRING,\n      TMP_DB_USER,\n      TMP_DB_JDBC_DRIVER_CLASSNAME,\n      TMP_DB_NAME,\n      TMP_DB_STATEMENT,\n      TMP_DB_OPERATION,\n      TMP_DB_MSSQL_INSTANCE_NAME,\n      TMP_DB_CASSANDRA_KEYSPACE,\n      TMP_DB_CASSANDRA_PAGE_SIZE,\n      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,\n      TMP_DB_CASSANDRA_TABLE,\n      TMP_DB_CASSANDRA_IDEMPOTENCE,\n      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,\n      TMP_DB_CASSANDRA_COORDINATOR_ID,\n      TMP_DB_CASSANDRA_COORDINATOR_DC,\n      TMP_DB_HBASE_NAMESPACE,\n      TMP_DB_REDIS_DATABASE_INDEX,\n      TMP_DB_MONGODB_COLLECTION,\n      TMP_DB_SQL_TABLE,\n      TMP_EXCEPTION_TYPE,\n      TMP_EXCEPTION_MESSAGE,\n      TMP_EXCEPTION_STACKTRACE,\n      TMP_EXCEPTION_ESCAPED,\n      TMP_FAAS_TRIGGER,\n      TMP_FAAS_EXECUTION,\n      TMP_FAAS_DOCUMENT_COLLECTION,\n      TMP_FAAS_DOCUMENT_OPERATION,\n      TMP_FAAS_DOCUMENT_TIME,\n      TMP_FAAS_DOCUMENT_NAME,\n      TMP_FAAS_TIME,\n      TMP_FAAS_CRON,\n      TMP_FAAS_COLDSTART,\n      TMP_FAAS_INVOKED_NAME,\n      TMP_FAAS_INVOKED_PROVIDER,\n      TMP_FAAS_INVOKED_REGION,\n      TMP_NET_TRANSPORT,\n      TMP_NET_PEER_IP,\n      TMP_NET_PEER_PORT,\n      TMP_NET_PEER_NAME,\n      TMP_NET_HOST_IP,\n      TMP_NET_HOST_PORT,\n      TMP_NET_HOST_NAME,\n      TMP_NET_HOST_CONNECTION_TYPE,\n      TMP_NET_HOST_CONNECTION_SUBTYPE,\n      TMP_NET_HOST_CARRIER_NAME,\n      TMP_NET_HOST_CARRIER_MCC,\n      TMP_NET_HOST_CARRIER_MNC,\n      TMP_NET_HOST_CARRIER_ICC,\n      TMP_PEER_SERVICE,\n      TMP_ENDUSER_ID,\n      TMP_ENDUSER_ROLE,\n      TMP_ENDUSER_SCOPE,\n      TMP_THREAD_ID,\n      TMP_THREAD_NAME,\n      TMP_CODE_FUNCTION,\n      TMP_CODE_NAMESPACE,\n      TMP_CODE_FILEPATH,\n      TMP_CODE_LINENO,\n      TMP_HTTP_METHOD,\n      TMP_HTTP_URL,\n      TMP_HTTP_TARGET,\n      TMP_HTTP_HOST,\n      TMP_HTTP_SCHEME,\n      TMP_HTTP_STATUS_CODE,\n      TMP_HTTP_FLAVOR,\n      TMP_HTTP_USER_AGENT,\n      TMP_HTTP_REQUEST_CONTENT_LENGTH,\n      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n      TMP_HTTP_RESPONSE_CONTENT_LENGTH,\n      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,\n      TMP_HTTP_SERVER_NAME,\n      TMP_HTTP_ROUTE,\n      TMP_HTTP_CLIENT_IP,\n      TMP_AWS_DYNAMODB_TABLE_NAMES,\n      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,\n      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,\n      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,\n      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,\n      TMP_AWS_DYNAMODB_CONSISTENT_READ,\n      TMP_AWS_DYNAMODB_PROJECTION,\n      TMP_AWS_DYNAMODB_LIMIT,\n      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,\n      TMP_AWS_DYNAMODB_INDEX_NAME,\n      TMP_AWS_DYNAMODB_SELECT,\n      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,\n      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,\n      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,\n      TMP_AWS_DYNAMODB_TABLE_COUNT,\n      TMP_AWS_DYNAMODB_SCAN_FORWARD,\n      TMP_AWS_DYNAMODB_SEGMENT,\n      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,\n      TMP_AWS_DYNAMODB_COUNT,\n      TMP_AWS_DYNAMODB_SCANNED_COUNT,\n      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,\n      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,\n      TMP_MESSAGING_SYSTEM,\n      TMP_MESSAGING_DESTINATION,\n      TMP_MESSAGING_DESTINATION_KIND,\n      TMP_MESSAGING_TEMP_DESTINATION,\n      TMP_MESSAGING_PROTOCOL,\n      TMP_MESSAGING_PROTOCOL_VERSION,\n      TMP_MESSAGING_URL,\n      TMP_MESSAGING_MESSAGE_ID,\n      TMP_MESSAGING_CONVERSATION_ID,\n      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,\n      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,\n      TMP_MESSAGING_OPERATION,\n      TMP_MESSAGING_CONSUMER_ID,\n      TMP_MESSAGING_RABBITMQ_ROUTING_KEY,\n      TMP_MESSAGING_KAFKA_MESSAGE_KEY,\n      TMP_MESSAGING_KAFKA_CONSUMER_GROUP,\n      TMP_MESSAGING_KAFKA_CLIENT_ID,\n      TMP_MESSAGING_KAFKA_PARTITION,\n      TMP_MESSAGING_KAFKA_TOMBSTONE,\n      TMP_RPC_SYSTEM,\n      TMP_RPC_SERVICE,\n      TMP_RPC_METHOD,\n      TMP_RPC_GRPC_STATUS_CODE,\n      TMP_RPC_JSONRPC_VERSION,\n      TMP_RPC_JSONRPC_REQUEST_ID,\n      TMP_RPC_JSONRPC_ERROR_CODE,\n      TMP_RPC_JSONRPC_ERROR_MESSAGE,\n      TMP_MESSAGE_TYPE,\n      TMP_MESSAGE_ID,\n      TMP_MESSAGE_COMPRESSED_SIZE,\n      TMP_MESSAGE_UNCOMPRESSED_SIZE\n    ]);\n    TMP_DBSYSTEMVALUES_OTHER_SQL = \"other_sql\";\n    TMP_DBSYSTEMVALUES_MSSQL = \"mssql\";\n    TMP_DBSYSTEMVALUES_MYSQL = \"mysql\";\n    TMP_DBSYSTEMVALUES_ORACLE = \"oracle\";\n    TMP_DBSYSTEMVALUES_DB2 = \"db2\";\n    TMP_DBSYSTEMVALUES_POSTGRESQL = \"postgresql\";\n    TMP_DBSYSTEMVALUES_REDSHIFT = \"redshift\";\n    TMP_DBSYSTEMVALUES_HIVE = \"hive\";\n    TMP_DBSYSTEMVALUES_CLOUDSCAPE = \"cloudscape\";\n    TMP_DBSYSTEMVALUES_HSQLDB = \"hsqldb\";\n    TMP_DBSYSTEMVALUES_PROGRESS = \"progress\";\n    TMP_DBSYSTEMVALUES_MAXDB = \"maxdb\";\n    TMP_DBSYSTEMVALUES_HANADB = \"hanadb\";\n    TMP_DBSYSTEMVALUES_INGRES = \"ingres\";\n    TMP_DBSYSTEMVALUES_FIRSTSQL = \"firstsql\";\n    TMP_DBSYSTEMVALUES_EDB = \"edb\";\n    TMP_DBSYSTEMVALUES_CACHE = \"cache\";\n    TMP_DBSYSTEMVALUES_ADABAS = \"adabas\";\n    TMP_DBSYSTEMVALUES_FIREBIRD = \"firebird\";\n    TMP_DBSYSTEMVALUES_DERBY = \"derby\";\n    TMP_DBSYSTEMVALUES_FILEMAKER = \"filemaker\";\n    TMP_DBSYSTEMVALUES_INFORMIX = \"informix\";\n    TMP_DBSYSTEMVALUES_INSTANTDB = \"instantdb\";\n    TMP_DBSYSTEMVALUES_INTERBASE = \"interbase\";\n    TMP_DBSYSTEMVALUES_MARIADB = \"mariadb\";\n    TMP_DBSYSTEMVALUES_NETEZZA = \"netezza\";\n    TMP_DBSYSTEMVALUES_PERVASIVE = \"pervasive\";\n    TMP_DBSYSTEMVALUES_POINTBASE = \"pointbase\";\n    TMP_DBSYSTEMVALUES_SQLITE = \"sqlite\";\n    TMP_DBSYSTEMVALUES_SYBASE = \"sybase\";\n    TMP_DBSYSTEMVALUES_TERADATA = \"teradata\";\n    TMP_DBSYSTEMVALUES_VERTICA = \"vertica\";\n    TMP_DBSYSTEMVALUES_H2 = \"h2\";\n    TMP_DBSYSTEMVALUES_COLDFUSION = \"coldfusion\";\n    TMP_DBSYSTEMVALUES_CASSANDRA = \"cassandra\";\n    TMP_DBSYSTEMVALUES_HBASE = \"hbase\";\n    TMP_DBSYSTEMVALUES_MONGODB = \"mongodb\";\n    TMP_DBSYSTEMVALUES_REDIS = \"redis\";\n    TMP_DBSYSTEMVALUES_COUCHBASE = \"couchbase\";\n    TMP_DBSYSTEMVALUES_COUCHDB = \"couchdb\";\n    TMP_DBSYSTEMVALUES_COSMOSDB = \"cosmosdb\";\n    TMP_DBSYSTEMVALUES_DYNAMODB = \"dynamodb\";\n    TMP_DBSYSTEMVALUES_NEO4J = \"neo4j\";\n    TMP_DBSYSTEMVALUES_GEODE = \"geode\";\n    TMP_DBSYSTEMVALUES_ELASTICSEARCH = \"elasticsearch\";\n    TMP_DBSYSTEMVALUES_MEMCACHED = \"memcached\";\n    TMP_DBSYSTEMVALUES_COCKROACHDB = \"cockroachdb\";\n    DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;\n    DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;\n    DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;\n    DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;\n    DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;\n    DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;\n    DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;\n    DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;\n    DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;\n    DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;\n    DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;\n    DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;\n    DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;\n    DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;\n    DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;\n    DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;\n    DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;\n    DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;\n    DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;\n    DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;\n    DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;\n    DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;\n    DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;\n    DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;\n    DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;\n    DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;\n    DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;\n    DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;\n    DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;\n    DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;\n    DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;\n    DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;\n    DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;\n    DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;\n    DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;\n    DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;\n    DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;\n    DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;\n    DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;\n    DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;\n    DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;\n    DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;\n    DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;\n    DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;\n    DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;\n    DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;\n    DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;\n    DbSystemValues = /* @__PURE__ */ createConstMap([\n      TMP_DBSYSTEMVALUES_OTHER_SQL,\n      TMP_DBSYSTEMVALUES_MSSQL,\n      TMP_DBSYSTEMVALUES_MYSQL,\n      TMP_DBSYSTEMVALUES_ORACLE,\n      TMP_DBSYSTEMVALUES_DB2,\n      TMP_DBSYSTEMVALUES_POSTGRESQL,\n      TMP_DBSYSTEMVALUES_REDSHIFT,\n      TMP_DBSYSTEMVALUES_HIVE,\n      TMP_DBSYSTEMVALUES_CLOUDSCAPE,\n      TMP_DBSYSTEMVALUES_HSQLDB,\n      TMP_DBSYSTEMVALUES_PROGRESS,\n      TMP_DBSYSTEMVALUES_MAXDB,\n      TMP_DBSYSTEMVALUES_HANADB,\n      TMP_DBSYSTEMVALUES_INGRES,\n      TMP_DBSYSTEMVALUES_FIRSTSQL,\n      TMP_DBSYSTEMVALUES_EDB,\n      TMP_DBSYSTEMVALUES_CACHE,\n      TMP_DBSYSTEMVALUES_ADABAS,\n      TMP_DBSYSTEMVALUES_FIREBIRD,\n      TMP_DBSYSTEMVALUES_DERBY,\n      TMP_DBSYSTEMVALUES_FILEMAKER,\n      TMP_DBSYSTEMVALUES_INFORMIX,\n      TMP_DBSYSTEMVALUES_INSTANTDB,\n      TMP_DBSYSTEMVALUES_INTERBASE,\n      TMP_DBSYSTEMVALUES_MARIADB,\n      TMP_DBSYSTEMVALUES_NETEZZA,\n      TMP_DBSYSTEMVALUES_PERVASIVE,\n      TMP_DBSYSTEMVALUES_POINTBASE,\n      TMP_DBSYSTEMVALUES_SQLITE,\n      TMP_DBSYSTEMVALUES_SYBASE,\n      TMP_DBSYSTEMVALUES_TERADATA,\n      TMP_DBSYSTEMVALUES_VERTICA,\n      TMP_DBSYSTEMVALUES_H2,\n      TMP_DBSYSTEMVALUES_COLDFUSION,\n      TMP_DBSYSTEMVALUES_CASSANDRA,\n      TMP_DBSYSTEMVALUES_HBASE,\n      TMP_DBSYSTEMVALUES_MONGODB,\n      TMP_DBSYSTEMVALUES_REDIS,\n      TMP_DBSYSTEMVALUES_COUCHBASE,\n      TMP_DBSYSTEMVALUES_COUCHDB,\n      TMP_DBSYSTEMVALUES_COSMOSDB,\n      TMP_DBSYSTEMVALUES_DYNAMODB,\n      TMP_DBSYSTEMVALUES_NEO4J,\n      TMP_DBSYSTEMVALUES_GEODE,\n      TMP_DBSYSTEMVALUES_ELASTICSEARCH,\n      TMP_DBSYSTEMVALUES_MEMCACHED,\n      TMP_DBSYSTEMVALUES_COCKROACHDB\n    ]);\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = \"all\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = \"each_quorum\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = \"quorum\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = \"local_quorum\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = \"one\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = \"two\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = \"three\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = \"local_one\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = \"any\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = \"serial\";\n    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = \"local_serial\";\n    DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;\n    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;\n    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;\n    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;\n    DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;\n    DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;\n    DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;\n    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;\n    DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;\n    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;\n    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;\n    DbCassandraConsistencyLevelValues = /* @__PURE__ */ createConstMap([\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,\n      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL\n    ]);\n    TMP_FAASTRIGGERVALUES_DATASOURCE = \"datasource\";\n    TMP_FAASTRIGGERVALUES_HTTP = \"http\";\n    TMP_FAASTRIGGERVALUES_PUBSUB = \"pubsub\";\n    TMP_FAASTRIGGERVALUES_TIMER = \"timer\";\n    TMP_FAASTRIGGERVALUES_OTHER = \"other\";\n    FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;\n    FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;\n    FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;\n    FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;\n    FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;\n    FaasTriggerValues = /* @__PURE__ */ createConstMap([\n      TMP_FAASTRIGGERVALUES_DATASOURCE,\n      TMP_FAASTRIGGERVALUES_HTTP,\n      TMP_FAASTRIGGERVALUES_PUBSUB,\n      TMP_FAASTRIGGERVALUES_TIMER,\n      TMP_FAASTRIGGERVALUES_OTHER\n    ]);\n    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = \"insert\";\n    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = \"edit\";\n    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = \"delete\";\n    FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;\n    FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;\n    FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;\n    FaasDocumentOperationValues = /* @__PURE__ */ createConstMap([\n      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,\n      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,\n      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE\n    ]);\n    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = \"alibaba_cloud\";\n    TMP_FAASINVOKEDPROVIDERVALUES_AWS = \"aws\";\n    TMP_FAASINVOKEDPROVIDERVALUES_AZURE = \"azure\";\n    TMP_FAASINVOKEDPROVIDERVALUES_GCP = \"gcp\";\n    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;\n    FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;\n    FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;\n    FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;\n    FaasInvokedProviderValues = /* @__PURE__ */ createConstMap([\n      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,\n      TMP_FAASINVOKEDPROVIDERVALUES_AWS,\n      TMP_FAASINVOKEDPROVIDERVALUES_AZURE,\n      TMP_FAASINVOKEDPROVIDERVALUES_GCP\n    ]);\n    TMP_NETTRANSPORTVALUES_IP_TCP = \"ip_tcp\";\n    TMP_NETTRANSPORTVALUES_IP_UDP = \"ip_udp\";\n    TMP_NETTRANSPORTVALUES_IP = \"ip\";\n    TMP_NETTRANSPORTVALUES_UNIX = \"unix\";\n    TMP_NETTRANSPORTVALUES_PIPE = \"pipe\";\n    TMP_NETTRANSPORTVALUES_INPROC = \"inproc\";\n    TMP_NETTRANSPORTVALUES_OTHER = \"other\";\n    NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;\n    NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;\n    NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;\n    NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;\n    NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;\n    NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;\n    NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;\n    NetTransportValues = /* @__PURE__ */ createConstMap([\n      TMP_NETTRANSPORTVALUES_IP_TCP,\n      TMP_NETTRANSPORTVALUES_IP_UDP,\n      TMP_NETTRANSPORTVALUES_IP,\n      TMP_NETTRANSPORTVALUES_UNIX,\n      TMP_NETTRANSPORTVALUES_PIPE,\n      TMP_NETTRANSPORTVALUES_INPROC,\n      TMP_NETTRANSPORTVALUES_OTHER\n    ]);\n    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = \"wifi\";\n    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = \"wired\";\n    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = \"cell\";\n    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = \"unavailable\";\n    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = \"unknown\";\n    NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;\n    NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;\n    NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;\n    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;\n    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;\n    NetHostConnectionTypeValues = /* @__PURE__ */ createConstMap([\n      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,\n      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,\n      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,\n      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,\n      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN\n    ]);\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = \"gprs\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = \"edge\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = \"umts\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = \"cdma\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = \"evdo_0\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = \"evdo_a\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = \"cdma2000_1xrtt\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = \"hsdpa\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = \"hsupa\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = \"hspa\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = \"iden\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = \"evdo_b\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = \"lte\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = \"ehrpd\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = \"hspap\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = \"gsm\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = \"td_scdma\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = \"iwlan\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = \"nr\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = \"nrnsa\";\n    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = \"lte_ca\";\n    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;\n    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;\n    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;\n    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;\n    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;\n    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;\n    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;\n    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;\n    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;\n    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;\n    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;\n    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;\n    NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;\n    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;\n    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;\n    NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;\n    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;\n    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;\n    NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;\n    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;\n    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;\n    NetHostConnectionSubtypeValues = /* @__PURE__ */ createConstMap([\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,\n      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA\n    ]);\n    TMP_HTTPFLAVORVALUES_HTTP_1_0 = \"1.0\";\n    TMP_HTTPFLAVORVALUES_HTTP_1_1 = \"1.1\";\n    TMP_HTTPFLAVORVALUES_HTTP_2_0 = \"2.0\";\n    TMP_HTTPFLAVORVALUES_SPDY = \"SPDY\";\n    TMP_HTTPFLAVORVALUES_QUIC = \"QUIC\";\n    HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;\n    HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;\n    HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;\n    HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;\n    HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;\n    HttpFlavorValues = {\n      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,\n      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,\n      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,\n      SPDY: TMP_HTTPFLAVORVALUES_SPDY,\n      QUIC: TMP_HTTPFLAVORVALUES_QUIC\n    };\n    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = \"queue\";\n    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = \"topic\";\n    MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;\n    MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;\n    MessagingDestinationKindValues = /* @__PURE__ */ createConstMap([\n      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,\n      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC\n    ]);\n    TMP_MESSAGINGOPERATIONVALUES_RECEIVE = \"receive\";\n    TMP_MESSAGINGOPERATIONVALUES_PROCESS = \"process\";\n    MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;\n    MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;\n    MessagingOperationValues = /* @__PURE__ */ createConstMap([\n      TMP_MESSAGINGOPERATIONVALUES_RECEIVE,\n      TMP_MESSAGINGOPERATIONVALUES_PROCESS\n    ]);\n    TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;\n    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;\n    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;\n    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;\n    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;\n    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;\n    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;\n    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;\n    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;\n    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;\n    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;\n    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;\n    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;\n    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;\n    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;\n    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;\n    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;\n    RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;\n    RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;\n    RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;\n    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;\n    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;\n    RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;\n    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;\n    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;\n    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;\n    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;\n    RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;\n    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;\n    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;\n    RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;\n    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;\n    RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;\n    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;\n    RpcGrpcStatusCodeValues = {\n      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,\n      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,\n      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,\n      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,\n      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,\n      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,\n      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,\n      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,\n      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,\n      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,\n      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,\n      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,\n      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,\n      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,\n      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,\n      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,\n      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED\n    };\n    TMP_MESSAGETYPEVALUES_SENT = \"SENT\";\n    TMP_MESSAGETYPEVALUES_RECEIVED = \"RECEIVED\";\n    MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;\n    MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;\n    MessageTypeValues = /* @__PURE__ */ createConstMap([\n      TMP_MESSAGETYPEVALUES_SENT,\n      TMP_MESSAGETYPEVALUES_RECEIVED\n    ]);\n  }\n});\n\n// node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js\nvar init_trace2 = __esm({\n  \"node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js\"() {\n    init_SemanticAttributes();\n  }\n});\n\n// node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js\nvar TMP_CLOUD_PROVIDER, TMP_CLOUD_ACCOUNT_ID, TMP_CLOUD_REGION, TMP_CLOUD_AVAILABILITY_ZONE, TMP_CLOUD_PLATFORM, TMP_AWS_ECS_CONTAINER_ARN, TMP_AWS_ECS_CLUSTER_ARN, TMP_AWS_ECS_LAUNCHTYPE, TMP_AWS_ECS_TASK_ARN, TMP_AWS_ECS_TASK_FAMILY, TMP_AWS_ECS_TASK_REVISION, TMP_AWS_EKS_CLUSTER_ARN, TMP_AWS_LOG_GROUP_NAMES, TMP_AWS_LOG_GROUP_ARNS, TMP_AWS_LOG_STREAM_NAMES, TMP_AWS_LOG_STREAM_ARNS, TMP_CONTAINER_NAME, TMP_CONTAINER_ID, TMP_CONTAINER_RUNTIME, TMP_CONTAINER_IMAGE_NAME, TMP_CONTAINER_IMAGE_TAG, TMP_DEPLOYMENT_ENVIRONMENT, TMP_DEVICE_ID, TMP_DEVICE_MODEL_IDENTIFIER, TMP_DEVICE_MODEL_NAME, TMP_FAAS_NAME, TMP_FAAS_ID, TMP_FAAS_VERSION, TMP_FAAS_INSTANCE, TMP_FAAS_MAX_MEMORY, TMP_HOST_ID, TMP_HOST_NAME, TMP_HOST_TYPE, TMP_HOST_ARCH, TMP_HOST_IMAGE_NAME, TMP_HOST_IMAGE_ID, TMP_HOST_IMAGE_VERSION, TMP_K8S_CLUSTER_NAME, TMP_K8S_NODE_NAME, TMP_K8S_NODE_UID, TMP_K8S_NAMESPACE_NAME, TMP_K8S_POD_UID, TMP_K8S_POD_NAME, TMP_K8S_CONTAINER_NAME, TMP_K8S_REPLICASET_UID, TMP_K8S_REPLICASET_NAME, TMP_K8S_DEPLOYMENT_UID, TMP_K8S_DEPLOYMENT_NAME, TMP_K8S_STATEFULSET_UID, TMP_K8S_STATEFULSET_NAME, TMP_K8S_DAEMONSET_UID, TMP_K8S_DAEMONSET_NAME, TMP_K8S_JOB_UID, TMP_K8S_JOB_NAME, TMP_K8S_CRONJOB_UID, TMP_K8S_CRONJOB_NAME, TMP_OS_TYPE, TMP_OS_DESCRIPTION, TMP_OS_NAME, TMP_OS_VERSION, TMP_PROCESS_PID, TMP_PROCESS_EXECUTABLE_NAME, TMP_PROCESS_EXECUTABLE_PATH, TMP_PROCESS_COMMAND, TMP_PROCESS_COMMAND_LINE, TMP_PROCESS_COMMAND_ARGS, TMP_PROCESS_OWNER, TMP_PROCESS_RUNTIME_NAME, TMP_PROCESS_RUNTIME_VERSION, TMP_PROCESS_RUNTIME_DESCRIPTION, TMP_SERVICE_NAME, TMP_SERVICE_NAMESPACE, TMP_SERVICE_INSTANCE_ID, TMP_SERVICE_VERSION, TMP_TELEMETRY_SDK_NAME, TMP_TELEMETRY_SDK_LANGUAGE, TMP_TELEMETRY_SDK_VERSION, TMP_TELEMETRY_AUTO_VERSION, TMP_WEBENGINE_NAME, TMP_WEBENGINE_VERSION, TMP_WEBENGINE_DESCRIPTION, SEMRESATTRS_CLOUD_PROVIDER, SEMRESATTRS_CLOUD_ACCOUNT_ID, SEMRESATTRS_CLOUD_REGION, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE, SEMRESATTRS_CLOUD_PLATFORM, SEMRESATTRS_AWS_ECS_CONTAINER_ARN, SEMRESATTRS_AWS_ECS_CLUSTER_ARN, SEMRESATTRS_AWS_ECS_LAUNCHTYPE, SEMRESATTRS_AWS_ECS_TASK_ARN, SEMRESATTRS_AWS_ECS_TASK_FAMILY, SEMRESATTRS_AWS_ECS_TASK_REVISION, SEMRESATTRS_AWS_EKS_CLUSTER_ARN, SEMRESATTRS_AWS_LOG_GROUP_NAMES, SEMRESATTRS_AWS_LOG_GROUP_ARNS, SEMRESATTRS_AWS_LOG_STREAM_NAMES, SEMRESATTRS_AWS_LOG_STREAM_ARNS, SEMRESATTRS_CONTAINER_NAME, SEMRESATTRS_CONTAINER_ID, SEMRESATTRS_CONTAINER_RUNTIME, SEMRESATTRS_CONTAINER_IMAGE_NAME, SEMRESATTRS_CONTAINER_IMAGE_TAG, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT, SEMRESATTRS_DEVICE_ID, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER, SEMRESATTRS_DEVICE_MODEL_NAME, SEMRESATTRS_FAAS_NAME, SEMRESATTRS_FAAS_ID, SEMRESATTRS_FAAS_VERSION, SEMRESATTRS_FAAS_INSTANCE, SEMRESATTRS_FAAS_MAX_MEMORY, SEMRESATTRS_HOST_ID, SEMRESATTRS_HOST_NAME, SEMRESATTRS_HOST_TYPE, SEMRESATTRS_HOST_ARCH, SEMRESATTRS_HOST_IMAGE_NAME, SEMRESATTRS_HOST_IMAGE_ID, SEMRESATTRS_HOST_IMAGE_VERSION, SEMRESATTRS_K8S_CLUSTER_NAME, SEMRESATTRS_K8S_NODE_NAME, SEMRESATTRS_K8S_NODE_UID, SEMRESATTRS_K8S_NAMESPACE_NAME, SEMRESATTRS_K8S_POD_UID, SEMRESATTRS_K8S_POD_NAME, SEMRESATTRS_K8S_CONTAINER_NAME, SEMRESATTRS_K8S_REPLICASET_UID, SEMRESATTRS_K8S_REPLICASET_NAME, SEMRESATTRS_K8S_DEPLOYMENT_UID, SEMRESATTRS_K8S_DEPLOYMENT_NAME, SEMRESATTRS_K8S_STATEFULSET_UID, SEMRESATTRS_K8S_STATEFULSET_NAME, SEMRESATTRS_K8S_DAEMONSET_UID, SEMRESATTRS_K8S_DAEMONSET_NAME, SEMRESATTRS_K8S_JOB_UID, SEMRESATTRS_K8S_JOB_NAME, SEMRESATTRS_K8S_CRONJOB_UID, SEMRESATTRS_K8S_CRONJOB_NAME, SEMRESATTRS_OS_TYPE, SEMRESATTRS_OS_DESCRIPTION, SEMRESATTRS_OS_NAME, SEMRESATTRS_OS_VERSION, SEMRESATTRS_PROCESS_PID, SEMRESATTRS_PROCESS_EXECUTABLE_NAME, SEMRESATTRS_PROCESS_EXECUTABLE_PATH, SEMRESATTRS_PROCESS_COMMAND, SEMRESATTRS_PROCESS_COMMAND_LINE, SEMRESATTRS_PROCESS_COMMAND_ARGS, SEMRESATTRS_PROCESS_OWNER, SEMRESATTRS_PROCESS_RUNTIME_NAME, SEMRESATTRS_PROCESS_RUNTIME_VERSION, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION, SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_NAMESPACE, SEMRESATTRS_SERVICE_INSTANCE_ID, SEMRESATTRS_SERVICE_VERSION, SEMRESATTRS_TELEMETRY_SDK_NAME, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE, SEMRESATTRS_TELEMETRY_SDK_VERSION, SEMRESATTRS_TELEMETRY_AUTO_VERSION, SEMRESATTRS_WEBENGINE_NAME, SEMRESATTRS_WEBENGINE_VERSION, SEMRESATTRS_WEBENGINE_DESCRIPTION, SemanticResourceAttributes, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD, TMP_CLOUDPROVIDERVALUES_AWS, TMP_CLOUDPROVIDERVALUES_AZURE, TMP_CLOUDPROVIDERVALUES_GCP, CLOUDPROVIDERVALUES_ALIBABA_CLOUD, CLOUDPROVIDERVALUES_AWS, CLOUDPROVIDERVALUES_AZURE, CLOUDPROVIDERVALUES_GCP, CloudProviderValues, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, TMP_CLOUDPLATFORMVALUES_AWS_EC2, TMP_CLOUDPLATFORMVALUES_AWS_ECS, TMP_CLOUDPLATFORMVALUES_AWS_EKS, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, TMP_CLOUDPLATFORMVALUES_AZURE_VM, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, TMP_CLOUDPLATFORMVALUES_AZURE_AKS, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, CLOUDPLATFORMVALUES_AWS_EC2, CLOUDPLATFORMVALUES_AWS_ECS, CLOUDPLATFORMVALUES_AWS_EKS, CLOUDPLATFORMVALUES_AWS_LAMBDA, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, CLOUDPLATFORMVALUES_AZURE_VM, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, CLOUDPLATFORMVALUES_AZURE_AKS, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CloudPlatformValues, TMP_AWSECSLAUNCHTYPEVALUES_EC2, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE, AWSECSLAUNCHTYPEVALUES_EC2, AWSECSLAUNCHTYPEVALUES_FARGATE, AwsEcsLaunchtypeValues, TMP_HOSTARCHVALUES_AMD64, TMP_HOSTARCHVALUES_ARM32, TMP_HOSTARCHVALUES_ARM64, TMP_HOSTARCHVALUES_IA64, TMP_HOSTARCHVALUES_PPC32, TMP_HOSTARCHVALUES_PPC64, TMP_HOSTARCHVALUES_X86, HOSTARCHVALUES_AMD64, HOSTARCHVALUES_ARM32, HOSTARCHVALUES_ARM64, HOSTARCHVALUES_IA64, HOSTARCHVALUES_PPC32, HOSTARCHVALUES_PPC64, HOSTARCHVALUES_X86, HostArchValues, TMP_OSTYPEVALUES_WINDOWS, TMP_OSTYPEVALUES_LINUX, TMP_OSTYPEVALUES_DARWIN, TMP_OSTYPEVALUES_FREEBSD, TMP_OSTYPEVALUES_NETBSD, TMP_OSTYPEVALUES_OPENBSD, TMP_OSTYPEVALUES_DRAGONFLYBSD, TMP_OSTYPEVALUES_HPUX, TMP_OSTYPEVALUES_AIX, TMP_OSTYPEVALUES_SOLARIS, TMP_OSTYPEVALUES_Z_OS, OSTYPEVALUES_WINDOWS, OSTYPEVALUES_LINUX, OSTYPEVALUES_DARWIN, OSTYPEVALUES_FREEBSD, OSTYPEVALUES_NETBSD, OSTYPEVALUES_OPENBSD, OSTYPEVALUES_DRAGONFLYBSD, OSTYPEVALUES_HPUX, OSTYPEVALUES_AIX, OSTYPEVALUES_SOLARIS, OSTYPEVALUES_Z_OS, OsTypeValues, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG, TMP_TELEMETRYSDKLANGUAGEVALUES_GO, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS, TELEMETRYSDKLANGUAGEVALUES_CPP, TELEMETRYSDKLANGUAGEVALUES_DOTNET, TELEMETRYSDKLANGUAGEVALUES_ERLANG, TELEMETRYSDKLANGUAGEVALUES_GO, TELEMETRYSDKLANGUAGEVALUES_JAVA, TELEMETRYSDKLANGUAGEVALUES_NODEJS, TELEMETRYSDKLANGUAGEVALUES_PHP, TELEMETRYSDKLANGUAGEVALUES_PYTHON, TELEMETRYSDKLANGUAGEVALUES_RUBY, TELEMETRYSDKLANGUAGEVALUES_WEBJS, TelemetrySdkLanguageValues;\nvar init_SemanticResourceAttributes = __esm({\n  \"node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js\"() {\n    init_utils4();\n    TMP_CLOUD_PROVIDER = \"cloud.provider\";\n    TMP_CLOUD_ACCOUNT_ID = \"cloud.account.id\";\n    TMP_CLOUD_REGION = \"cloud.region\";\n    TMP_CLOUD_AVAILABILITY_ZONE = \"cloud.availability_zone\";\n    TMP_CLOUD_PLATFORM = \"cloud.platform\";\n    TMP_AWS_ECS_CONTAINER_ARN = \"aws.ecs.container.arn\";\n    TMP_AWS_ECS_CLUSTER_ARN = \"aws.ecs.cluster.arn\";\n    TMP_AWS_ECS_LAUNCHTYPE = \"aws.ecs.launchtype\";\n    TMP_AWS_ECS_TASK_ARN = \"aws.ecs.task.arn\";\n    TMP_AWS_ECS_TASK_FAMILY = \"aws.ecs.task.family\";\n    TMP_AWS_ECS_TASK_REVISION = \"aws.ecs.task.revision\";\n    TMP_AWS_EKS_CLUSTER_ARN = \"aws.eks.cluster.arn\";\n    TMP_AWS_LOG_GROUP_NAMES = \"aws.log.group.names\";\n    TMP_AWS_LOG_GROUP_ARNS = \"aws.log.group.arns\";\n    TMP_AWS_LOG_STREAM_NAMES = \"aws.log.stream.names\";\n    TMP_AWS_LOG_STREAM_ARNS = \"aws.log.stream.arns\";\n    TMP_CONTAINER_NAME = \"container.name\";\n    TMP_CONTAINER_ID = \"container.id\";\n    TMP_CONTAINER_RUNTIME = \"container.runtime\";\n    TMP_CONTAINER_IMAGE_NAME = \"container.image.name\";\n    TMP_CONTAINER_IMAGE_TAG = \"container.image.tag\";\n    TMP_DEPLOYMENT_ENVIRONMENT = \"deployment.environment\";\n    TMP_DEVICE_ID = \"device.id\";\n    TMP_DEVICE_MODEL_IDENTIFIER = \"device.model.identifier\";\n    TMP_DEVICE_MODEL_NAME = \"device.model.name\";\n    TMP_FAAS_NAME = \"faas.name\";\n    TMP_FAAS_ID = \"faas.id\";\n    TMP_FAAS_VERSION = \"faas.version\";\n    TMP_FAAS_INSTANCE = \"faas.instance\";\n    TMP_FAAS_MAX_MEMORY = \"faas.max_memory\";\n    TMP_HOST_ID = \"host.id\";\n    TMP_HOST_NAME = \"host.name\";\n    TMP_HOST_TYPE = \"host.type\";\n    TMP_HOST_ARCH = \"host.arch\";\n    TMP_HOST_IMAGE_NAME = \"host.image.name\";\n    TMP_HOST_IMAGE_ID = \"host.image.id\";\n    TMP_HOST_IMAGE_VERSION = \"host.image.version\";\n    TMP_K8S_CLUSTER_NAME = \"k8s.cluster.name\";\n    TMP_K8S_NODE_NAME = \"k8s.node.name\";\n    TMP_K8S_NODE_UID = \"k8s.node.uid\";\n    TMP_K8S_NAMESPACE_NAME = \"k8s.namespace.name\";\n    TMP_K8S_POD_UID = \"k8s.pod.uid\";\n    TMP_K8S_POD_NAME = \"k8s.pod.name\";\n    TMP_K8S_CONTAINER_NAME = \"k8s.container.name\";\n    TMP_K8S_REPLICASET_UID = \"k8s.replicaset.uid\";\n    TMP_K8S_REPLICASET_NAME = \"k8s.replicaset.name\";\n    TMP_K8S_DEPLOYMENT_UID = \"k8s.deployment.uid\";\n    TMP_K8S_DEPLOYMENT_NAME = \"k8s.deployment.name\";\n    TMP_K8S_STATEFULSET_UID = \"k8s.statefulset.uid\";\n    TMP_K8S_STATEFULSET_NAME = \"k8s.statefulset.name\";\n    TMP_K8S_DAEMONSET_UID = \"k8s.daemonset.uid\";\n    TMP_K8S_DAEMONSET_NAME = \"k8s.daemonset.name\";\n    TMP_K8S_JOB_UID = \"k8s.job.uid\";\n    TMP_K8S_JOB_NAME = \"k8s.job.name\";\n    TMP_K8S_CRONJOB_UID = \"k8s.cronjob.uid\";\n    TMP_K8S_CRONJOB_NAME = \"k8s.cronjob.name\";\n    TMP_OS_TYPE = \"os.type\";\n    TMP_OS_DESCRIPTION = \"os.description\";\n    TMP_OS_NAME = \"os.name\";\n    TMP_OS_VERSION = \"os.version\";\n    TMP_PROCESS_PID = \"process.pid\";\n    TMP_PROCESS_EXECUTABLE_NAME = \"process.executable.name\";\n    TMP_PROCESS_EXECUTABLE_PATH = \"process.executable.path\";\n    TMP_PROCESS_COMMAND = \"process.command\";\n    TMP_PROCESS_COMMAND_LINE = \"process.command_line\";\n    TMP_PROCESS_COMMAND_ARGS = \"process.command_args\";\n    TMP_PROCESS_OWNER = \"process.owner\";\n    TMP_PROCESS_RUNTIME_NAME = \"process.runtime.name\";\n    TMP_PROCESS_RUNTIME_VERSION = \"process.runtime.version\";\n    TMP_PROCESS_RUNTIME_DESCRIPTION = \"process.runtime.description\";\n    TMP_SERVICE_NAME = \"service.name\";\n    TMP_SERVICE_NAMESPACE = \"service.namespace\";\n    TMP_SERVICE_INSTANCE_ID = \"service.instance.id\";\n    TMP_SERVICE_VERSION = \"service.version\";\n    TMP_TELEMETRY_SDK_NAME = \"telemetry.sdk.name\";\n    TMP_TELEMETRY_SDK_LANGUAGE = \"telemetry.sdk.language\";\n    TMP_TELEMETRY_SDK_VERSION = \"telemetry.sdk.version\";\n    TMP_TELEMETRY_AUTO_VERSION = \"telemetry.auto.version\";\n    TMP_WEBENGINE_NAME = \"webengine.name\";\n    TMP_WEBENGINE_VERSION = \"webengine.version\";\n    TMP_WEBENGINE_DESCRIPTION = \"webengine.description\";\n    SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;\n    SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;\n    SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;\n    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;\n    SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;\n    SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;\n    SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;\n    SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;\n    SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;\n    SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;\n    SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;\n    SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;\n    SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;\n    SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;\n    SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;\n    SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;\n    SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;\n    SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;\n    SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;\n    SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;\n    SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;\n    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;\n    SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;\n    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;\n    SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;\n    SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;\n    SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;\n    SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;\n    SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;\n    SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;\n    SEMRESATTRS_HOST_ID = TMP_HOST_ID;\n    SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;\n    SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;\n    SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;\n    SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;\n    SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;\n    SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;\n    SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;\n    SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;\n    SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;\n    SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;\n    SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;\n    SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;\n    SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;\n    SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;\n    SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;\n    SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;\n    SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;\n    SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;\n    SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;\n    SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;\n    SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;\n    SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;\n    SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;\n    SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;\n    SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;\n    SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;\n    SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;\n    SEMRESATTRS_OS_NAME = TMP_OS_NAME;\n    SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;\n    SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;\n    SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;\n    SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;\n    SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;\n    SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;\n    SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;\n    SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;\n    SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;\n    SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;\n    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;\n    SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;\n    SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;\n    SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;\n    SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;\n    SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;\n    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;\n    SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;\n    SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;\n    SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;\n    SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;\n    SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;\n    SemanticResourceAttributes = /* @__PURE__ */ createConstMap([\n      TMP_CLOUD_PROVIDER,\n      TMP_CLOUD_ACCOUNT_ID,\n      TMP_CLOUD_REGION,\n      TMP_CLOUD_AVAILABILITY_ZONE,\n      TMP_CLOUD_PLATFORM,\n      TMP_AWS_ECS_CONTAINER_ARN,\n      TMP_AWS_ECS_CLUSTER_ARN,\n      TMP_AWS_ECS_LAUNCHTYPE,\n      TMP_AWS_ECS_TASK_ARN,\n      TMP_AWS_ECS_TASK_FAMILY,\n      TMP_AWS_ECS_TASK_REVISION,\n      TMP_AWS_EKS_CLUSTER_ARN,\n      TMP_AWS_LOG_GROUP_NAMES,\n      TMP_AWS_LOG_GROUP_ARNS,\n      TMP_AWS_LOG_STREAM_NAMES,\n      TMP_AWS_LOG_STREAM_ARNS,\n      TMP_CONTAINER_NAME,\n      TMP_CONTAINER_ID,\n      TMP_CONTAINER_RUNTIME,\n      TMP_CONTAINER_IMAGE_NAME,\n      TMP_CONTAINER_IMAGE_TAG,\n      TMP_DEPLOYMENT_ENVIRONMENT,\n      TMP_DEVICE_ID,\n      TMP_DEVICE_MODEL_IDENTIFIER,\n      TMP_DEVICE_MODEL_NAME,\n      TMP_FAAS_NAME,\n      TMP_FAAS_ID,\n      TMP_FAAS_VERSION,\n      TMP_FAAS_INSTANCE,\n      TMP_FAAS_MAX_MEMORY,\n      TMP_HOST_ID,\n      TMP_HOST_NAME,\n      TMP_HOST_TYPE,\n      TMP_HOST_ARCH,\n      TMP_HOST_IMAGE_NAME,\n      TMP_HOST_IMAGE_ID,\n      TMP_HOST_IMAGE_VERSION,\n      TMP_K8S_CLUSTER_NAME,\n      TMP_K8S_NODE_NAME,\n      TMP_K8S_NODE_UID,\n      TMP_K8S_NAMESPACE_NAME,\n      TMP_K8S_POD_UID,\n      TMP_K8S_POD_NAME,\n      TMP_K8S_CONTAINER_NAME,\n      TMP_K8S_REPLICASET_UID,\n      TMP_K8S_REPLICASET_NAME,\n      TMP_K8S_DEPLOYMENT_UID,\n      TMP_K8S_DEPLOYMENT_NAME,\n      TMP_K8S_STATEFULSET_UID,\n      TMP_K8S_STATEFULSET_NAME,\n      TMP_K8S_DAEMONSET_UID,\n      TMP_K8S_DAEMONSET_NAME,\n      TMP_K8S_JOB_UID,\n      TMP_K8S_JOB_NAME,\n      TMP_K8S_CRONJOB_UID,\n      TMP_K8S_CRONJOB_NAME,\n      TMP_OS_TYPE,\n      TMP_OS_DESCRIPTION,\n      TMP_OS_NAME,\n      TMP_OS_VERSION,\n      TMP_PROCESS_PID,\n      TMP_PROCESS_EXECUTABLE_NAME,\n      TMP_PROCESS_EXECUTABLE_PATH,\n      TMP_PROCESS_COMMAND,\n      TMP_PROCESS_COMMAND_LINE,\n      TMP_PROCESS_COMMAND_ARGS,\n      TMP_PROCESS_OWNER,\n      TMP_PROCESS_RUNTIME_NAME,\n      TMP_PROCESS_RUNTIME_VERSION,\n      TMP_PROCESS_RUNTIME_DESCRIPTION,\n      TMP_SERVICE_NAME,\n      TMP_SERVICE_NAMESPACE,\n      TMP_SERVICE_INSTANCE_ID,\n      TMP_SERVICE_VERSION,\n      TMP_TELEMETRY_SDK_NAME,\n      TMP_TELEMETRY_SDK_LANGUAGE,\n      TMP_TELEMETRY_SDK_VERSION,\n      TMP_TELEMETRY_AUTO_VERSION,\n      TMP_WEBENGINE_NAME,\n      TMP_WEBENGINE_VERSION,\n      TMP_WEBENGINE_DESCRIPTION\n    ]);\n    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = \"alibaba_cloud\";\n    TMP_CLOUDPROVIDERVALUES_AWS = \"aws\";\n    TMP_CLOUDPROVIDERVALUES_AZURE = \"azure\";\n    TMP_CLOUDPROVIDERVALUES_GCP = \"gcp\";\n    CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;\n    CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;\n    CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;\n    CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;\n    CloudProviderValues = /* @__PURE__ */ createConstMap([\n      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,\n      TMP_CLOUDPROVIDERVALUES_AWS,\n      TMP_CLOUDPROVIDERVALUES_AZURE,\n      TMP_CLOUDPROVIDERVALUES_GCP\n    ]);\n    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = \"alibaba_cloud_ecs\";\n    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = \"alibaba_cloud_fc\";\n    TMP_CLOUDPLATFORMVALUES_AWS_EC2 = \"aws_ec2\";\n    TMP_CLOUDPLATFORMVALUES_AWS_ECS = \"aws_ecs\";\n    TMP_CLOUDPLATFORMVALUES_AWS_EKS = \"aws_eks\";\n    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = \"aws_lambda\";\n    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = \"aws_elastic_beanstalk\";\n    TMP_CLOUDPLATFORMVALUES_AZURE_VM = \"azure_vm\";\n    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = \"azure_container_instances\";\n    TMP_CLOUDPLATFORMVALUES_AZURE_AKS = \"azure_aks\";\n    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = \"azure_functions\";\n    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = \"azure_app_service\";\n    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = \"gcp_compute_engine\";\n    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = \"gcp_cloud_run\";\n    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = \"gcp_kubernetes_engine\";\n    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = \"gcp_cloud_functions\";\n    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = \"gcp_app_engine\";\n    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;\n    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;\n    CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;\n    CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;\n    CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;\n    CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;\n    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;\n    CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;\n    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;\n    CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;\n    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;\n    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;\n    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;\n    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;\n    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;\n    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;\n    CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;\n    CloudPlatformValues = /* @__PURE__ */ createConstMap([\n      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,\n      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,\n      TMP_CLOUDPLATFORMVALUES_AWS_EC2,\n      TMP_CLOUDPLATFORMVALUES_AWS_ECS,\n      TMP_CLOUDPLATFORMVALUES_AWS_EKS,\n      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,\n      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,\n      TMP_CLOUDPLATFORMVALUES_AZURE_VM,\n      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,\n      TMP_CLOUDPLATFORMVALUES_AZURE_AKS,\n      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,\n      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,\n      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,\n      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,\n      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,\n      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,\n      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE\n    ]);\n    TMP_AWSECSLAUNCHTYPEVALUES_EC2 = \"ec2\";\n    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = \"fargate\";\n    AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;\n    AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;\n    AwsEcsLaunchtypeValues = /* @__PURE__ */ createConstMap([\n      TMP_AWSECSLAUNCHTYPEVALUES_EC2,\n      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE\n    ]);\n    TMP_HOSTARCHVALUES_AMD64 = \"amd64\";\n    TMP_HOSTARCHVALUES_ARM32 = \"arm32\";\n    TMP_HOSTARCHVALUES_ARM64 = \"arm64\";\n    TMP_HOSTARCHVALUES_IA64 = \"ia64\";\n    TMP_HOSTARCHVALUES_PPC32 = \"ppc32\";\n    TMP_HOSTARCHVALUES_PPC64 = \"ppc64\";\n    TMP_HOSTARCHVALUES_X86 = \"x86\";\n    HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;\n    HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;\n    HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;\n    HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;\n    HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;\n    HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;\n    HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;\n    HostArchValues = /* @__PURE__ */ createConstMap([\n      TMP_HOSTARCHVALUES_AMD64,\n      TMP_HOSTARCHVALUES_ARM32,\n      TMP_HOSTARCHVALUES_ARM64,\n      TMP_HOSTARCHVALUES_IA64,\n      TMP_HOSTARCHVALUES_PPC32,\n      TMP_HOSTARCHVALUES_PPC64,\n      TMP_HOSTARCHVALUES_X86\n    ]);\n    TMP_OSTYPEVALUES_WINDOWS = \"windows\";\n    TMP_OSTYPEVALUES_LINUX = \"linux\";\n    TMP_OSTYPEVALUES_DARWIN = \"darwin\";\n    TMP_OSTYPEVALUES_FREEBSD = \"freebsd\";\n    TMP_OSTYPEVALUES_NETBSD = \"netbsd\";\n    TMP_OSTYPEVALUES_OPENBSD = \"openbsd\";\n    TMP_OSTYPEVALUES_DRAGONFLYBSD = \"dragonflybsd\";\n    TMP_OSTYPEVALUES_HPUX = \"hpux\";\n    TMP_OSTYPEVALUES_AIX = \"aix\";\n    TMP_OSTYPEVALUES_SOLARIS = \"solaris\";\n    TMP_OSTYPEVALUES_Z_OS = \"z_os\";\n    OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;\n    OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;\n    OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;\n    OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;\n    OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;\n    OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;\n    OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;\n    OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;\n    OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;\n    OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;\n    OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;\n    OsTypeValues = /* @__PURE__ */ createConstMap([\n      TMP_OSTYPEVALUES_WINDOWS,\n      TMP_OSTYPEVALUES_LINUX,\n      TMP_OSTYPEVALUES_DARWIN,\n      TMP_OSTYPEVALUES_FREEBSD,\n      TMP_OSTYPEVALUES_NETBSD,\n      TMP_OSTYPEVALUES_OPENBSD,\n      TMP_OSTYPEVALUES_DRAGONFLYBSD,\n      TMP_OSTYPEVALUES_HPUX,\n      TMP_OSTYPEVALUES_AIX,\n      TMP_OSTYPEVALUES_SOLARIS,\n      TMP_OSTYPEVALUES_Z_OS\n    ]);\n    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = \"cpp\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = \"dotnet\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = \"erlang\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_GO = \"go\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = \"java\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = \"nodejs\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = \"php\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = \"python\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = \"ruby\";\n    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = \"webjs\";\n    TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;\n    TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;\n    TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;\n    TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;\n    TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;\n    TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;\n    TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;\n    TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;\n    TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;\n    TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;\n    TelemetrySdkLanguageValues = /* @__PURE__ */ createConstMap([\n      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_GO,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,\n      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS\n    ]);\n  }\n});\n\n// node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js\nvar init_resource = __esm({\n  \"node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js\"() {\n    init_SemanticResourceAttributes();\n  }\n});\n\n// node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\nvar esm_exports2 = {};\n__export(esm_exports2, {\n  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC2,\n  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE,\n  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues,\n  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,\n  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,\n  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC2,\n  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS,\n  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS,\n  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,\n  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA,\n  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS,\n  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,\n  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,\n  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,\n  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM,\n  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE,\n  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,\n  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,\n  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,\n  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,\n  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD,\n  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS,\n  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE,\n  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP,\n  CloudPlatformValues: () => CloudPlatformValues,\n  CloudProviderValues: () => CloudProviderValues,\n  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL,\n  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY,\n  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,\n  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,\n  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,\n  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL,\n  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE,\n  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,\n  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,\n  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE,\n  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO,\n  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS,\n  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE,\n  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA,\n  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE,\n  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB,\n  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION,\n  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB,\n  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE,\n  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB,\n  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB2,\n  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY,\n  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB,\n  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB,\n  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH,\n  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER,\n  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD,\n  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL,\n  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE,\n  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H2,\n  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB,\n  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE,\n  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE,\n  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB,\n  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX,\n  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES,\n  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB,\n  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE,\n  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB,\n  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB,\n  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED,\n  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB,\n  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL,\n  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL,\n  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J,\n  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA,\n  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE,\n  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL,\n  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE,\n  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE,\n  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL,\n  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS,\n  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS,\n  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT,\n  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE,\n  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE,\n  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA,\n  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA,\n  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues,\n  DbSystemValues: () => DbSystemValues,\n  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE,\n  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT,\n  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT,\n  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,\n  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS,\n  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE,\n  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP,\n  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE,\n  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP,\n  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER,\n  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB,\n  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER,\n  FaasDocumentOperationValues: () => FaasDocumentOperationValues,\n  FaasInvokedProviderValues: () => FaasInvokedProviderValues,\n  FaasTriggerValues: () => FaasTriggerValues,\n  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD64,\n  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM32,\n  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM64,\n  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA64,\n  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC32,\n  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC64,\n  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X86,\n  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_0,\n  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_1,\n  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_0,\n  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC,\n  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY,\n  HostArchValues: () => HostArchValues,\n  HttpFlavorValues: () => HttpFlavorValues,\n  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED,\n  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT,\n  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE,\n  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC,\n  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS,\n  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE,\n  MessageTypeValues: () => MessageTypeValues,\n  MessagingDestinationKindValues: () => MessagingDestinationKindValues,\n  MessagingOperationValues: () => MessagingOperationValues,\n  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,\n  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,\n  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,\n  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,\n  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,\n  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,\n  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,\n  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,\n  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM,\n  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,\n  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,\n  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,\n  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,\n  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,\n  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,\n  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE,\n  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA,\n  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR,\n  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,\n  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,\n  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,\n  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL,\n  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,\n  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN,\n  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI,\n  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED,\n  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC,\n  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP,\n  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP,\n  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP,\n  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER,\n  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE,\n  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX,\n  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues,\n  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues,\n  NetTransportValues: () => NetTransportValues,\n  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX,\n  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN,\n  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD,\n  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD,\n  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX,\n  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX,\n  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD,\n  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD,\n  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS,\n  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS,\n  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS,\n  OsTypeValues: () => OsTypeValues,\n  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED,\n  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,\n  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED,\n  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS,\n  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,\n  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,\n  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL,\n  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,\n  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND,\n  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK,\n  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,\n  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,\n  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,\n  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED,\n  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,\n  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,\n  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN,\n  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues,\n  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET,\n  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,\n  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ,\n  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY,\n  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT,\n  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,\n  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,\n  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,\n  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME,\n  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,\n  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT,\n  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,\n  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION,\n  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,\n  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,\n  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT,\n  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD,\n  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT,\n  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT,\n  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT,\n  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES,\n  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS,\n  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN,\n  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH,\n  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION,\n  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO,\n  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE,\n  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL,\n  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC,\n  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID,\n  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE,\n  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE,\n  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE,\n  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,\n  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE,\n  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING,\n  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE,\n  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME,\n  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION,\n  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME,\n  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME,\n  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION,\n  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX,\n  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE,\n  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT,\n  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM,\n  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER,\n  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID,\n  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE,\n  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE,\n  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED,\n  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE,\n  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE,\n  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE,\n  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART,\n  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON,\n  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION,\n  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME,\n  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION,\n  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME,\n  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION,\n  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME,\n  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER,\n  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION,\n  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME,\n  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER,\n  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP,\n  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR,\n  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST,\n  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH,\n  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH,\n  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,\n  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE,\n  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME,\n  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME,\n  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE,\n  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET,\n  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL,\n  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT,\n  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE,\n  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID,\n  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE,\n  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE,\n  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID,\n  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID,\n  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION,\n  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND,\n  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID,\n  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP,\n  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY,\n  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION,\n  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE,\n  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID,\n  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,\n  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,\n  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION,\n  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL,\n  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION,\n  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY,\n  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM,\n  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION,\n  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL,\n  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC,\n  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC,\n  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC,\n  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME,\n  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE,\n  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE,\n  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP,\n  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME,\n  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT,\n  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP,\n  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME,\n  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT,\n  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT,\n  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE,\n  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE,\n  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE,\n  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE,\n  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID,\n  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION,\n  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD,\n  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE,\n  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM,\n  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID,\n  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME,\n  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN,\n  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN,\n  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE,\n  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN,\n  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY,\n  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION,\n  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN,\n  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS,\n  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES,\n  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS,\n  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES,\n  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID,\n  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,\n  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM,\n  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER,\n  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION,\n  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID,\n  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME,\n  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG,\n  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME,\n  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME,\n  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT,\n  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID,\n  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER,\n  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME,\n  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID,\n  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE,\n  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY,\n  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME,\n  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION,\n  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH,\n  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID,\n  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID,\n  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME,\n  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION,\n  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME,\n  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE,\n  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME,\n  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME,\n  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME,\n  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID,\n  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME,\n  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID,\n  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME,\n  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID,\n  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME,\n  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID,\n  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME,\n  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME,\n  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID,\n  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME,\n  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID,\n  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME,\n  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID,\n  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME,\n  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID,\n  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION,\n  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME,\n  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE,\n  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION,\n  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND,\n  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS,\n  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE,\n  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME,\n  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH,\n  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER,\n  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID,\n  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION,\n  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME,\n  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION,\n  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID,\n  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME,\n  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE,\n  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION,\n  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION,\n  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE,\n  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME,\n  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION,\n  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION,\n  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME,\n  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION,\n  SemanticAttributes: () => SemanticAttributes,\n  SemanticResourceAttributes: () => SemanticResourceAttributes,\n  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP,\n  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET,\n  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG,\n  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO,\n  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA,\n  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS,\n  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP,\n  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON,\n  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY,\n  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS,\n  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues\n});\nvar init_esm2 = __esm({\n  \"node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\"() {\n    init_trace2();\n    init_resource();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js\nvar _a, SDK_INFO;\nvar init_sdk_info = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js\"() {\n    init_version2();\n    init_esm2();\n    SDK_INFO = (_a = {}, _a[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = \"opentelemetry\", _a[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"node\", _a[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = TelemetrySdkLanguageValues.NODEJS, _a[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = VERSION2, _a);\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/node/timer-util.js\nfunction unrefTimer(timer) {\n  timer.unref();\n}\nvar init_timer_util = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/node/timer-util.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/node/index.js\nvar init_node2 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/node/index.js\"() {\n    init_environment2();\n    init_globalThis3();\n    init_hex_to_base64();\n    init_RandomIdGenerator();\n    init_performance();\n    init_sdk_info();\n    init_timer_util();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/platform/index.js\nvar init_platform2 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/platform/index.js\"() {\n    init_node2();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/common/time.js\nfunction millisToHrTime(epochMillis) {\n  var epochSeconds = epochMillis / 1e3;\n  var seconds = Math.trunc(epochSeconds);\n  var nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);\n  return [seconds, nanos];\n}\nfunction getTimeOrigin() {\n  var timeOrigin = otperformance.timeOrigin;\n  if (typeof timeOrigin !== \"number\") {\n    var perf = otperformance;\n    timeOrigin = perf.timing && perf.timing.fetchStart;\n  }\n  return timeOrigin;\n}\nfunction hrTime(performanceNow) {\n  var timeOrigin = millisToHrTime(getTimeOrigin());\n  var now = millisToHrTime(typeof performanceNow === \"number\" ? performanceNow : otperformance.now());\n  return addHrTimes(timeOrigin, now);\n}\nfunction timeInputToHrTime(time) {\n  if (isTimeInputHrTime(time)) {\n    return time;\n  } else if (typeof time === \"number\") {\n    if (time < getTimeOrigin()) {\n      return hrTime(time);\n    } else {\n      return millisToHrTime(time);\n    }\n  } else if (time instanceof Date) {\n    return millisToHrTime(time.getTime());\n  } else {\n    throw TypeError(\"Invalid input type\");\n  }\n}\nfunction hrTimeDuration(startTime, endTime) {\n  var seconds = endTime[0] - startTime[0];\n  var nanos = endTime[1] - startTime[1];\n  if (nanos < 0) {\n    seconds -= 1;\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n  return [seconds, nanos];\n}\nfunction hrTimeToTimeStamp(time) {\n  var precision = NANOSECOND_DIGITS;\n  var tmp = \"\" + \"0\".repeat(precision) + time[1] + \"Z\";\n  var nanoString = tmp.substr(tmp.length - precision - 1);\n  var date = new Date(time[0] * 1e3).toISOString();\n  return date.replace(\"000Z\", nanoString);\n}\nfunction hrTimeToNanoseconds(time) {\n  return time[0] * SECOND_TO_NANOSECONDS + time[1];\n}\nfunction hrTimeToMilliseconds(time) {\n  return time[0] * 1e3 + time[1] / 1e6;\n}\nfunction hrTimeToMicroseconds(time) {\n  return time[0] * 1e6 + time[1] / 1e3;\n}\nfunction isTimeInputHrTime(value) {\n  return Array.isArray(value) && value.length === 2 && typeof value[0] === \"number\" && typeof value[1] === \"number\";\n}\nfunction isTimeInput(value) {\n  return isTimeInputHrTime(value) || typeof value === \"number\" || value instanceof Date;\n}\nfunction addHrTimes(time1, time2) {\n  var out = [time1[0] + time2[0], time1[1] + time2[1]];\n  if (out[1] >= SECOND_TO_NANOSECONDS) {\n    out[1] -= SECOND_TO_NANOSECONDS;\n    out[0] += 1;\n  }\n  return out;\n}\nvar NANOSECOND_DIGITS, NANOSECOND_DIGITS_IN_MILLIS, MILLISECONDS_TO_NANOSECONDS, SECOND_TO_NANOSECONDS;\nvar init_time = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/common/time.js\"() {\n    init_platform2();\n    NANOSECOND_DIGITS = 9;\n    NANOSECOND_DIGITS_IN_MILLIS = 6;\n    MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);\n    SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/common/types.js\nvar init_types2 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/common/types.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/ExportResult.js\nvar ExportResultCode;\nvar init_ExportResult = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/ExportResult.js\"() {\n    (function(ExportResultCode2) {\n      ExportResultCode2[ExportResultCode2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n      ExportResultCode2[ExportResultCode2[\"FAILED\"] = 1] = \"FAILED\";\n    })(ExportResultCode || (ExportResultCode = {}));\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/propagation/composite.js\nvar __values3, CompositePropagator;\nvar init_composite = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/propagation/composite.js\"() {\n    init_esm();\n    __values3 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n    CompositePropagator = /** @class */\n    function() {\n      function CompositePropagator2(config) {\n        if (config === void 0) {\n          config = {};\n        }\n        var _a2;\n        this._propagators = (_a2 = config.propagators) !== null && _a2 !== void 0 ? _a2 : [];\n        this._fields = Array.from(new Set(this._propagators.map(function(p) {\n          return typeof p.fields === \"function\" ? p.fields() : [];\n        }).reduce(function(x, y) {\n          return x.concat(y);\n        }, [])));\n      }\n      CompositePropagator2.prototype.inject = function(context2, carrier, setter) {\n        var e_1, _a2;\n        try {\n          for (var _b = __values3(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var propagator = _c.value;\n            try {\n              propagator.inject(context2, carrier, setter);\n            } catch (err) {\n              diag2.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = { error: e_1_1 };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a2 = _b.return))\n              _a2.call(_b);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n      };\n      CompositePropagator2.prototype.extract = function(context2, carrier, getter) {\n        return this._propagators.reduce(function(ctx, propagator) {\n          try {\n            return propagator.extract(ctx, carrier, getter);\n          } catch (err) {\n            diag2.warn(\"Failed to inject with \" + propagator.constructor.name + \". Err: \" + err.message);\n          }\n          return ctx;\n        }, context2);\n      };\n      CompositePropagator2.prototype.fields = function() {\n        return this._fields.slice();\n      };\n      return CompositePropagator2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/internal/validators.js\nfunction validateKey2(key) {\n  return VALID_KEY_REGEX2.test(key);\n}\nfunction validateValue2(value) {\n  return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);\n}\nvar VALID_KEY_CHAR_RANGE2, VALID_KEY2, VALID_VENDOR_KEY2, VALID_KEY_REGEX2, VALID_VALUE_BASE_REGEX2, INVALID_VALUE_COMMA_EQUAL_REGEX2;\nvar init_validators = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/internal/validators.js\"() {\n    VALID_KEY_CHAR_RANGE2 = \"[_0-9a-z-*/]\";\n    VALID_KEY2 = \"[a-z]\" + VALID_KEY_CHAR_RANGE2 + \"{0,255}\";\n    VALID_VENDOR_KEY2 = \"[a-z0-9]\" + VALID_KEY_CHAR_RANGE2 + \"{0,240}@[a-z]\" + VALID_KEY_CHAR_RANGE2 + \"{0,13}\";\n    VALID_KEY_REGEX2 = new RegExp(\"^(?:\" + VALID_KEY2 + \"|\" + VALID_VENDOR_KEY2 + \")$\");\n    VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;\n    INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/TraceState.js\nvar MAX_TRACE_STATE_ITEMS2, MAX_TRACE_STATE_LEN2, LIST_MEMBERS_SEPARATOR2, LIST_MEMBER_KEY_VALUE_SPLITTER2, TraceState;\nvar init_TraceState = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/TraceState.js\"() {\n    init_validators();\n    MAX_TRACE_STATE_ITEMS2 = 32;\n    MAX_TRACE_STATE_LEN2 = 512;\n    LIST_MEMBERS_SEPARATOR2 = \",\";\n    LIST_MEMBER_KEY_VALUE_SPLITTER2 = \"=\";\n    TraceState = /** @class */\n    function() {\n      function TraceState2(rawTraceState) {\n        this._internalState = /* @__PURE__ */ new Map();\n        if (rawTraceState)\n          this._parse(rawTraceState);\n      }\n      TraceState2.prototype.set = function(key, value) {\n        var traceState = this._clone();\n        if (traceState._internalState.has(key)) {\n          traceState._internalState.delete(key);\n        }\n        traceState._internalState.set(key, value);\n        return traceState;\n      };\n      TraceState2.prototype.unset = function(key) {\n        var traceState = this._clone();\n        traceState._internalState.delete(key);\n        return traceState;\n      };\n      TraceState2.prototype.get = function(key) {\n        return this._internalState.get(key);\n      };\n      TraceState2.prototype.serialize = function() {\n        var _this = this;\n        return this._keys().reduce(function(agg, key) {\n          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + _this.get(key));\n          return agg;\n        }, []).join(LIST_MEMBERS_SEPARATOR2);\n      };\n      TraceState2.prototype._parse = function(rawTraceState) {\n        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)\n          return;\n        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce(function(agg, part) {\n          var listMember = part.trim();\n          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);\n          if (i !== -1) {\n            var key = listMember.slice(0, i);\n            var value = listMember.slice(i + 1, part.length);\n            if (validateKey2(key) && validateValue2(value)) {\n              agg.set(key, value);\n            } else {\n            }\n          }\n          return agg;\n        }, /* @__PURE__ */ new Map());\n        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {\n          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));\n        }\n      };\n      TraceState2.prototype._keys = function() {\n        return Array.from(this._internalState.keys()).reverse();\n      };\n      TraceState2.prototype._clone = function() {\n        var traceState = new TraceState2();\n        traceState._internalState = new Map(this._internalState);\n        return traceState;\n      };\n      return TraceState2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js\nfunction parseTraceParent(traceParent) {\n  var match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match)\n    return null;\n  if (match[1] === \"00\" && match[5])\n    return null;\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16)\n  };\n}\nvar TRACE_PARENT_HEADER, TRACE_STATE_HEADER, VERSION3, VERSION_PART, TRACE_ID_PART, PARENT_ID_PART, FLAGS_PART, TRACE_PARENT_REGEX, W3CTraceContextPropagator;\nvar init_W3CTraceContextPropagator = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/W3CTraceContextPropagator.js\"() {\n    init_esm();\n    init_suppress_tracing();\n    init_TraceState();\n    TRACE_PARENT_HEADER = \"traceparent\";\n    TRACE_STATE_HEADER = \"tracestate\";\n    VERSION3 = \"00\";\n    VERSION_PART = \"(?!ff)[\\\\da-f]{2}\";\n    TRACE_ID_PART = \"(?![0]{32})[\\\\da-f]{32}\";\n    PARENT_ID_PART = \"(?![0]{16})[\\\\da-f]{16}\";\n    FLAGS_PART = \"[\\\\da-f]{2}\";\n    TRACE_PARENT_REGEX = new RegExp(\"^\\\\s?(\" + VERSION_PART + \")-(\" + TRACE_ID_PART + \")-(\" + PARENT_ID_PART + \")-(\" + FLAGS_PART + \")(-.*)?\\\\s?$\");\n    W3CTraceContextPropagator = /** @class */\n    function() {\n      function W3CTraceContextPropagator2() {\n      }\n      W3CTraceContextPropagator2.prototype.inject = function(context2, carrier, setter) {\n        var spanContext = trace.getSpanContext(context2);\n        if (!spanContext || isTracingSuppressed(context2) || !isSpanContextValid(spanContext))\n          return;\n        var traceParent = VERSION3 + \"-\" + spanContext.traceId + \"-\" + spanContext.spanId + \"-0\" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);\n        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n        if (spanContext.traceState) {\n          setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());\n        }\n      };\n      W3CTraceContextPropagator2.prototype.extract = function(context2, carrier, getter) {\n        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n        if (!traceParentHeader)\n          return context2;\n        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;\n        if (typeof traceParent !== \"string\")\n          return context2;\n        var spanContext = parseTraceParent(traceParent);\n        if (!spanContext)\n          return context2;\n        spanContext.isRemote = true;\n        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n        if (traceStateHeader) {\n          var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(\",\") : traceStateHeader;\n          spanContext.traceState = new TraceState(typeof state === \"string\" ? state : void 0);\n        }\n        return trace.setSpanContext(context2, spanContext);\n      };\n      W3CTraceContextPropagator2.prototype.fields = function() {\n        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n      };\n      return W3CTraceContextPropagator2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/IdGenerator.js\nvar init_IdGenerator = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/IdGenerator.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js\nfunction setRPCMetadata(context2, meta) {\n  return context2.setValue(RPC_METADATA_KEY, meta);\n}\nfunction deleteRPCMetadata(context2) {\n  return context2.deleteValue(RPC_METADATA_KEY);\n}\nfunction getRPCMetadata(context2) {\n  return context2.getValue(RPC_METADATA_KEY);\n}\nvar RPC_METADATA_KEY, RPCType;\nvar init_rpc_metadata = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/rpc-metadata.js\"() {\n    init_esm();\n    RPC_METADATA_KEY = createContextKey(\"OpenTelemetry SDK Context Key RPC_METADATA\");\n    (function(RPCType2) {\n      RPCType2[\"HTTP\"] = \"http\";\n    })(RPCType || (RPCType = {}));\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js\nvar AlwaysOffSampler;\nvar init_AlwaysOffSampler = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOffSampler.js\"() {\n    init_esm();\n    AlwaysOffSampler = /** @class */\n    function() {\n      function AlwaysOffSampler3() {\n      }\n      AlwaysOffSampler3.prototype.shouldSample = function() {\n        return {\n          decision: SamplingDecision.NOT_RECORD\n        };\n      };\n      AlwaysOffSampler3.prototype.toString = function() {\n        return \"AlwaysOffSampler\";\n      };\n      return AlwaysOffSampler3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js\nvar AlwaysOnSampler;\nvar init_AlwaysOnSampler = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/sampler/AlwaysOnSampler.js\"() {\n    init_esm();\n    AlwaysOnSampler = /** @class */\n    function() {\n      function AlwaysOnSampler3() {\n      }\n      AlwaysOnSampler3.prototype.shouldSample = function() {\n        return {\n          decision: SamplingDecision.RECORD_AND_SAMPLED\n        };\n      };\n      AlwaysOnSampler3.prototype.toString = function() {\n        return \"AlwaysOnSampler\";\n      };\n      return AlwaysOnSampler3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js\nvar ParentBasedSampler;\nvar init_ParentBasedSampler = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/sampler/ParentBasedSampler.js\"() {\n    init_esm();\n    init_global_error_handler();\n    init_AlwaysOffSampler();\n    init_AlwaysOnSampler();\n    ParentBasedSampler = /** @class */\n    function() {\n      function ParentBasedSampler3(config) {\n        var _a2, _b, _c, _d;\n        this._root = config.root;\n        if (!this._root) {\n          globalErrorHandler(new Error(\"ParentBasedSampler must have a root sampler configured\"));\n          this._root = new AlwaysOnSampler();\n        }\n        this._remoteParentSampled = (_a2 = config.remoteParentSampled) !== null && _a2 !== void 0 ? _a2 : new AlwaysOnSampler();\n        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler();\n        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();\n        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();\n      }\n      ParentBasedSampler3.prototype.shouldSample = function(context2, traceId, spanName, spanKind, attributes, links) {\n        var parentContext = trace.getSpanContext(context2);\n        if (!parentContext || !isSpanContextValid(parentContext)) {\n          return this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n        }\n        if (parentContext.isRemote) {\n          if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n            return this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n          }\n          return this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n        }\n        if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n          return this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n        }\n        return this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n      };\n      ParentBasedSampler3.prototype.toString = function() {\n        return \"ParentBased{root=\" + this._root.toString() + \", remoteParentSampled=\" + this._remoteParentSampled.toString() + \", remoteParentNotSampled=\" + this._remoteParentNotSampled.toString() + \", localParentSampled=\" + this._localParentSampled.toString() + \", localParentNotSampled=\" + this._localParentNotSampled.toString() + \"}\";\n      };\n      return ParentBasedSampler3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js\nvar TraceIdRatioBasedSampler;\nvar init_TraceIdRatioBasedSampler = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/trace/sampler/TraceIdRatioBasedSampler.js\"() {\n    init_esm();\n    TraceIdRatioBasedSampler = /** @class */\n    function() {\n      function TraceIdRatioBasedSampler3(_ratio) {\n        if (_ratio === void 0) {\n          _ratio = 0;\n        }\n        this._ratio = _ratio;\n        this._ratio = this._normalize(_ratio);\n        this._upperBound = Math.floor(this._ratio * 4294967295);\n      }\n      TraceIdRatioBasedSampler3.prototype.shouldSample = function(context2, traceId) {\n        return {\n          decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD\n        };\n      };\n      TraceIdRatioBasedSampler3.prototype.toString = function() {\n        return \"TraceIdRatioBased{\" + this._ratio + \"}\";\n      };\n      TraceIdRatioBasedSampler3.prototype._normalize = function(ratio) {\n        if (typeof ratio !== \"number\" || isNaN(ratio))\n          return 0;\n        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n      };\n      TraceIdRatioBasedSampler3.prototype._accumulate = function(traceId) {\n        var accumulation = 0;\n        for (var i = 0; i < traceId.length / 8; i++) {\n          var pos = i * 8;\n          var part = parseInt(traceId.slice(pos, pos + 8), 16);\n          accumulation = (accumulation ^ part) >>> 0;\n        }\n        return accumulation;\n      };\n      return TraceIdRatioBasedSampler3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;\n}\nfunction isObjectLike(value) {\n  return value != null && typeof value == \"object\";\n}\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n  var unmasked = false;\n  try {\n    value[symToStringTag] = void 0;\n    unmasked = true;\n  } catch (e) {\n  }\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\nvar objectTag, nullTag, undefinedTag, funcProto, funcToString, objectCtorString, getPrototype, objectProto, hasOwnProperty, symToStringTag, nativeObjectToString;\nvar init_lodash_merge = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/lodash.merge.js\"() {\n    objectTag = \"[object Object]\";\n    nullTag = \"[object Null]\";\n    undefinedTag = \"[object Undefined]\";\n    funcProto = Function.prototype;\n    funcToString = funcProto.toString;\n    objectCtorString = funcToString.call(Object);\n    getPrototype = overArg(Object.getPrototypeOf, Object);\n    objectProto = Object.prototype;\n    hasOwnProperty = objectProto.hasOwnProperty;\n    symToStringTag = Symbol ? Symbol.toStringTag : void 0;\n    nativeObjectToString = objectProto.toString;\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/merge.js\nfunction merge() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var result = args.shift();\n  var objects = /* @__PURE__ */ new WeakMap();\n  while (args.length > 0) {\n    result = mergeTwoObjects(result, args.shift(), 0, objects);\n  }\n  return result;\n}\nfunction takeValue(value) {\n  if (isArray(value)) {\n    return value.slice();\n  }\n  return value;\n}\nfunction mergeTwoObjects(one, two, level, objects) {\n  if (level === void 0) {\n    level = 0;\n  }\n  var result;\n  if (level > MAX_LEVEL) {\n    return void 0;\n  }\n  level++;\n  if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {\n    result = takeValue(two);\n  } else if (isArray(one)) {\n    result = one.slice();\n    if (isArray(two)) {\n      for (var i = 0, j = two.length; i < j; i++) {\n        result.push(takeValue(two[i]));\n      }\n    } else if (isObject(two)) {\n      var keys = Object.keys(two);\n      for (var i = 0, j = keys.length; i < j; i++) {\n        var key = keys[i];\n        result[key] = takeValue(two[key]);\n      }\n    }\n  } else if (isObject(one)) {\n    if (isObject(two)) {\n      if (!shouldMerge(one, two)) {\n        return two;\n      }\n      result = Object.assign({}, one);\n      var keys = Object.keys(two);\n      for (var i = 0, j = keys.length; i < j; i++) {\n        var key = keys[i];\n        var twoValue = two[key];\n        if (isPrimitive(twoValue)) {\n          if (typeof twoValue === \"undefined\") {\n            delete result[key];\n          } else {\n            result[key] = twoValue;\n          }\n        } else {\n          var obj1 = result[key];\n          var obj2 = twoValue;\n          if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {\n            delete result[key];\n          } else {\n            if (isObject(obj1) && isObject(obj2)) {\n              var arr1 = objects.get(obj1) || [];\n              var arr2 = objects.get(obj2) || [];\n              arr1.push({ obj: one, key });\n              arr2.push({ obj: two, key });\n              objects.set(obj1, arr1);\n              objects.set(obj2, arr2);\n            }\n            result[key] = mergeTwoObjects(result[key], twoValue, level, objects);\n          }\n        }\n      }\n    } else {\n      result = two;\n    }\n  }\n  return result;\n}\nfunction wasObjectReferenced(obj, key, objects) {\n  var arr = objects.get(obj[key]) || [];\n  for (var i = 0, j = arr.length; i < j; i++) {\n    var info = arr[i];\n    if (info.key === key && info.obj === obj) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isObject(value) {\n  return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === \"object\";\n}\nfunction isPrimitive(value) {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"undefined\" || value instanceof Date || value instanceof RegExp || value === null;\n}\nfunction shouldMerge(one, two) {\n  if (!isPlainObject(one) || !isPlainObject(two)) {\n    return false;\n  }\n  return true;\n}\nvar MAX_LEVEL;\nvar init_merge = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/merge.js\"() {\n    init_lodash_merge();\n    MAX_LEVEL = 20;\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/timeout.js\nfunction callWithTimeout(promise, timeout) {\n  var timeoutHandle;\n  var timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {\n    timeoutHandle = setTimeout(function timeoutHandler() {\n      reject(new TimeoutError(\"Operation timed out.\"));\n    }, timeout);\n  });\n  return Promise.race([promise, timeoutPromise]).then(function(result) {\n    clearTimeout(timeoutHandle);\n    return result;\n  }, function(reason) {\n    clearTimeout(timeoutHandle);\n    throw reason;\n  });\n}\nvar __extends2, TimeoutError;\nvar init_timeout = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/timeout.js\"() {\n    __extends2 = function() {\n      var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n          d2.__proto__ = b2;\n        } || function(d2, b2) {\n          for (var p in b2)\n            if (Object.prototype.hasOwnProperty.call(b2, p))\n              d2[p] = b2[p];\n        };\n        return extendStatics(d, b);\n      };\n      return function(d, b) {\n        if (typeof b !== \"function\" && b !== null)\n          throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n    TimeoutError = /** @class */\n    function(_super) {\n      __extends2(TimeoutError2, _super);\n      function TimeoutError2(message) {\n        var _this = _super.call(this, message) || this;\n        Object.setPrototypeOf(_this, TimeoutError2.prototype);\n        return _this;\n      }\n      return TimeoutError2;\n    }(Error);\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/url.js\nfunction urlMatches(url4, urlToMatch) {\n  if (typeof urlToMatch === \"string\") {\n    return url4 === urlToMatch;\n  } else {\n    return !!url4.match(urlToMatch);\n  }\n}\nfunction isUrlIgnored(url4, ignoredUrls) {\n  var e_1, _a2;\n  if (!ignoredUrls) {\n    return false;\n  }\n  try {\n    for (var ignoredUrls_1 = __values4(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {\n      var ignoreUrl = ignoredUrls_1_1.value;\n      if (urlMatches(url4, ignoreUrl)) {\n        return true;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = { error: e_1_1 };\n  } finally {\n    try {\n      if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a2 = ignoredUrls_1.return))\n        _a2.call(ignoredUrls_1);\n    } finally {\n      if (e_1)\n        throw e_1.error;\n    }\n  }\n  return false;\n}\nvar __values4;\nvar init_url = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/url.js\"() {\n    __values4 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/wrap.js\nfunction isWrapped(func) {\n  return typeof func === \"function\" && typeof func.__original === \"function\" && typeof func.__unwrap === \"function\" && func.__wrapped === true;\n}\nvar init_wrap = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/wrap.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/promise.js\nvar Deferred;\nvar init_promise = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/promise.js\"() {\n    Deferred = /** @class */\n    function() {\n      function Deferred2() {\n        var _this = this;\n        this._promise = new Promise(function(resolve, reject) {\n          _this._resolve = resolve;\n          _this._reject = reject;\n        });\n      }\n      Object.defineProperty(Deferred2.prototype, \"promise\", {\n        get: function() {\n          return this._promise;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Deferred2.prototype.resolve = function(val) {\n        this._resolve(val);\n      };\n      Deferred2.prototype.reject = function(err) {\n        this._reject(err);\n      };\n      return Deferred2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/utils/callback.js\nvar __read8, __spreadArray5, BindOnceFuture;\nvar init_callback = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/utils/callback.js\"() {\n    init_promise();\n    __read8 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __spreadArray5 = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n          if (ar || !(i in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    BindOnceFuture = /** @class */\n    function() {\n      function BindOnceFuture2(_callback, _that) {\n        this._callback = _callback;\n        this._that = _that;\n        this._isCalled = false;\n        this._deferred = new Deferred();\n      }\n      Object.defineProperty(BindOnceFuture2.prototype, \"isCalled\", {\n        get: function() {\n          return this._isCalled;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(BindOnceFuture2.prototype, \"promise\", {\n        get: function() {\n          return this._deferred.promise;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      BindOnceFuture2.prototype.call = function() {\n        var _a2;\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        if (!this._isCalled) {\n          this._isCalled = true;\n          try {\n            Promise.resolve((_a2 = this._callback).call.apply(_a2, __spreadArray5([this._that], __read8(args), false))).then(function(val) {\n              return _this._deferred.resolve(val);\n            }, function(err) {\n              return _this._deferred.reject(err);\n            });\n          } catch (err) {\n            this._deferred.reject(err);\n          }\n        }\n        return this._deferred.promise;\n      };\n      return BindOnceFuture2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/internal/exporter.js\nfunction _export(exporter, arg) {\n  return new Promise(function(resolve) {\n    context.with(suppressTracing(context.active()), function() {\n      exporter.export(arg, function(result) {\n        resolve(result);\n      });\n    });\n  });\n}\nvar init_exporter = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/internal/exporter.js\"() {\n    init_esm();\n    init_suppress_tracing();\n  }\n});\n\n// node_modules/@opentelemetry/core/build/esm/index.js\nvar esm_exports3 = {};\n__export(esm_exports3, {\n  AlwaysOffSampler: () => AlwaysOffSampler,\n  AlwaysOnSampler: () => AlwaysOnSampler,\n  AnchoredClock: () => AnchoredClock,\n  BindOnceFuture: () => BindOnceFuture,\n  CompositePropagator: () => CompositePropagator,\n  DEFAULT_ATTRIBUTE_COUNT_LIMIT: () => DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n  DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT: () => DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  DEFAULT_ENVIRONMENT: () => DEFAULT_ENVIRONMENT,\n  DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: () => DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n  DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: () => DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,\n  ExportResultCode: () => ExportResultCode,\n  ParentBasedSampler: () => ParentBasedSampler,\n  RPCType: () => RPCType,\n  RandomIdGenerator: () => RandomIdGenerator,\n  SDK_INFO: () => SDK_INFO,\n  TRACE_PARENT_HEADER: () => TRACE_PARENT_HEADER,\n  TRACE_STATE_HEADER: () => TRACE_STATE_HEADER,\n  TimeoutError: () => TimeoutError,\n  TraceIdRatioBasedSampler: () => TraceIdRatioBasedSampler,\n  TraceState: () => TraceState,\n  TracesSamplerValues: () => TracesSamplerValues,\n  VERSION: () => VERSION2,\n  W3CBaggagePropagator: () => W3CBaggagePropagator,\n  W3CTraceContextPropagator: () => W3CTraceContextPropagator,\n  _globalThis: () => _globalThis3,\n  addHrTimes: () => addHrTimes,\n  baggageUtils: () => utils_exports,\n  callWithTimeout: () => callWithTimeout,\n  deleteRPCMetadata: () => deleteRPCMetadata,\n  getEnv: () => getEnv,\n  getEnvWithoutDefaults: () => getEnvWithoutDefaults,\n  getRPCMetadata: () => getRPCMetadata,\n  getTimeOrigin: () => getTimeOrigin,\n  globalErrorHandler: () => globalErrorHandler,\n  hexToBase64: () => hexToBase64,\n  hexToBinary: () => hexToBinary,\n  hrTime: () => hrTime,\n  hrTimeDuration: () => hrTimeDuration,\n  hrTimeToMicroseconds: () => hrTimeToMicroseconds,\n  hrTimeToMilliseconds: () => hrTimeToMilliseconds,\n  hrTimeToNanoseconds: () => hrTimeToNanoseconds,\n  hrTimeToTimeStamp: () => hrTimeToTimeStamp,\n  internal: () => internal,\n  isAttributeKey: () => isAttributeKey,\n  isAttributeValue: () => isAttributeValue,\n  isTimeInput: () => isTimeInput,\n  isTimeInputHrTime: () => isTimeInputHrTime,\n  isTracingSuppressed: () => isTracingSuppressed,\n  isUrlIgnored: () => isUrlIgnored,\n  isWrapped: () => isWrapped,\n  loggingErrorHandler: () => loggingErrorHandler,\n  merge: () => merge,\n  millisToHrTime: () => millisToHrTime,\n  otperformance: () => otperformance,\n  parseEnvironment: () => parseEnvironment,\n  parseTraceParent: () => parseTraceParent,\n  sanitizeAttributes: () => sanitizeAttributes,\n  setGlobalErrorHandler: () => setGlobalErrorHandler,\n  setRPCMetadata: () => setRPCMetadata,\n  suppressTracing: () => suppressTracing,\n  timeInputToHrTime: () => timeInputToHrTime,\n  unrefTimer: () => unrefTimer,\n  unsuppressTracing: () => unsuppressTracing,\n  urlMatches: () => urlMatches\n});\nvar internal;\nvar init_esm3 = __esm({\n  \"node_modules/@opentelemetry/core/build/esm/index.js\"() {\n    init_W3CBaggagePropagator();\n    init_anchored_clock();\n    init_attributes();\n    init_global_error_handler();\n    init_logging_error_handler();\n    init_time();\n    init_types2();\n    init_hex_to_binary();\n    init_ExportResult();\n    init_utils3();\n    init_platform2();\n    init_composite();\n    init_W3CTraceContextPropagator();\n    init_IdGenerator();\n    init_rpc_metadata();\n    init_AlwaysOffSampler();\n    init_AlwaysOnSampler();\n    init_ParentBasedSampler();\n    init_TraceIdRatioBasedSampler();\n    init_suppress_tracing();\n    init_TraceState();\n    init_environment();\n    init_merge();\n    init_sampling();\n    init_timeout();\n    init_url();\n    init_wrap();\n    init_callback();\n    init_version2();\n    init_exporter();\n    internal = {\n      _export\n    };\n  }\n});\n\n// node_modules/@opentelemetry/propagator-b3/build/esm/common.js\nvar B3_DEBUG_FLAG_KEY;\nvar init_common = __esm({\n  \"node_modules/@opentelemetry/propagator-b3/build/esm/common.js\"() {\n    init_esm();\n    B3_DEBUG_FLAG_KEY = createContextKey(\"OpenTelemetry Context Key B3 Debug Flag\");\n  }\n});\n\n// node_modules/@opentelemetry/propagator-b3/build/esm/constants.js\nvar B3_CONTEXT_HEADER, X_B3_TRACE_ID, X_B3_SPAN_ID, X_B3_SAMPLED, X_B3_PARENT_SPAN_ID, X_B3_FLAGS;\nvar init_constants2 = __esm({\n  \"node_modules/@opentelemetry/propagator-b3/build/esm/constants.js\"() {\n    B3_CONTEXT_HEADER = \"b3\";\n    X_B3_TRACE_ID = \"x-b3-traceid\";\n    X_B3_SPAN_ID = \"x-b3-spanid\";\n    X_B3_SAMPLED = \"x-b3-sampled\";\n    X_B3_PARENT_SPAN_ID = \"x-b3-parentspanid\";\n    X_B3_FLAGS = \"x-b3-flags\";\n  }\n});\n\n// node_modules/@opentelemetry/propagator-b3/build/esm/B3MultiPropagator.js\nfunction isValidSampledValue(sampled) {\n  return sampled === TraceFlags.SAMPLED || sampled === TraceFlags.NONE;\n}\nfunction parseHeader(header) {\n  return Array.isArray(header) ? header[0] : header;\n}\nfunction getHeaderValue(carrier, getter, key) {\n  var header = getter.get(carrier, key);\n  return parseHeader(header);\n}\nfunction getTraceId(carrier, getter) {\n  var traceId = getHeaderValue(carrier, getter, X_B3_TRACE_ID);\n  if (typeof traceId === \"string\") {\n    return traceId.padStart(32, \"0\");\n  }\n  return \"\";\n}\nfunction getSpanId(carrier, getter) {\n  var spanId = getHeaderValue(carrier, getter, X_B3_SPAN_ID);\n  if (typeof spanId === \"string\") {\n    return spanId;\n  }\n  return \"\";\n}\nfunction getDebug(carrier, getter) {\n  var debug = getHeaderValue(carrier, getter, X_B3_FLAGS);\n  return debug === \"1\" ? \"1\" : void 0;\n}\nfunction getTraceFlags(carrier, getter) {\n  var traceFlags = getHeaderValue(carrier, getter, X_B3_SAMPLED);\n  var debug = getDebug(carrier, getter);\n  if (debug === \"1\" || VALID_SAMPLED_VALUES.has(traceFlags)) {\n    return TraceFlags.SAMPLED;\n  }\n  if (traceFlags === void 0 || VALID_UNSAMPLED_VALUES.has(traceFlags)) {\n    return TraceFlags.NONE;\n  }\n  return;\n}\nvar VALID_SAMPLED_VALUES, VALID_UNSAMPLED_VALUES, B3MultiPropagator;\nvar init_B3MultiPropagator = __esm({\n  \"node_modules/@opentelemetry/propagator-b3/build/esm/B3MultiPropagator.js\"() {\n    init_esm();\n    init_esm3();\n    init_common();\n    init_constants2();\n    VALID_SAMPLED_VALUES = /* @__PURE__ */ new Set([true, \"true\", \"True\", \"1\", 1]);\n    VALID_UNSAMPLED_VALUES = /* @__PURE__ */ new Set([false, \"false\", \"False\", \"0\", 0]);\n    B3MultiPropagator = /** @class */\n    function() {\n      function B3MultiPropagator2() {\n      }\n      B3MultiPropagator2.prototype.inject = function(context2, carrier, setter) {\n        var spanContext = trace.getSpanContext(context2);\n        if (!spanContext || !isSpanContextValid(spanContext) || isTracingSuppressed(context2))\n          return;\n        var debug = context2.getValue(B3_DEBUG_FLAG_KEY);\n        setter.set(carrier, X_B3_TRACE_ID, spanContext.traceId);\n        setter.set(carrier, X_B3_SPAN_ID, spanContext.spanId);\n        if (debug === \"1\") {\n          setter.set(carrier, X_B3_FLAGS, debug);\n        } else if (spanContext.traceFlags !== void 0) {\n          setter.set(carrier, X_B3_SAMPLED, (TraceFlags.SAMPLED & spanContext.traceFlags) === TraceFlags.SAMPLED ? \"1\" : \"0\");\n        }\n      };\n      B3MultiPropagator2.prototype.extract = function(context2, carrier, getter) {\n        var traceId = getTraceId(carrier, getter);\n        var spanId = getSpanId(carrier, getter);\n        var traceFlags = getTraceFlags(carrier, getter);\n        var debug = getDebug(carrier, getter);\n        if (isValidTraceId(traceId) && isValidSpanId(spanId) && isValidSampledValue(traceFlags)) {\n          context2 = context2.setValue(B3_DEBUG_FLAG_KEY, debug);\n          return trace.setSpanContext(context2, {\n            traceId,\n            spanId,\n            isRemote: true,\n            traceFlags\n          });\n        }\n        return context2;\n      };\n      B3MultiPropagator2.prototype.fields = function() {\n        return [\n          X_B3_TRACE_ID,\n          X_B3_SPAN_ID,\n          X_B3_FLAGS,\n          X_B3_SAMPLED,\n          X_B3_PARENT_SPAN_ID\n        ];\n      };\n      return B3MultiPropagator2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/propagator-b3/build/esm/B3SinglePropagator.js\nfunction convertToTraceId128(traceId) {\n  return traceId.length === 32 ? traceId : \"\" + PADDING + traceId;\n}\nfunction convertToTraceFlags(samplingState) {\n  if (samplingState && SAMPLED_VALUES.has(samplingState)) {\n    return TraceFlags.SAMPLED;\n  }\n  return TraceFlags.NONE;\n}\nvar __read9, B3_CONTEXT_REGEX, PADDING, SAMPLED_VALUES, DEBUG_STATE, B3SinglePropagator;\nvar init_B3SinglePropagator = __esm({\n  \"node_modules/@opentelemetry/propagator-b3/build/esm/B3SinglePropagator.js\"() {\n    init_esm();\n    init_esm3();\n    init_common();\n    init_constants2();\n    __read9 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    B3_CONTEXT_REGEX = /((?:[0-9a-f]{16}){1,2})-([0-9a-f]{16})(?:-([01d](?![0-9a-f])))?(?:-([0-9a-f]{16}))?/;\n    PADDING = \"0\".repeat(16);\n    SAMPLED_VALUES = /* @__PURE__ */ new Set([\"d\", \"1\"]);\n    DEBUG_STATE = \"d\";\n    B3SinglePropagator = /** @class */\n    function() {\n      function B3SinglePropagator2() {\n      }\n      B3SinglePropagator2.prototype.inject = function(context2, carrier, setter) {\n        var spanContext = trace.getSpanContext(context2);\n        if (!spanContext || !isSpanContextValid(spanContext) || isTracingSuppressed(context2))\n          return;\n        var samplingState = context2.getValue(B3_DEBUG_FLAG_KEY) || spanContext.traceFlags & 1;\n        var value = spanContext.traceId + \"-\" + spanContext.spanId + \"-\" + samplingState;\n        setter.set(carrier, B3_CONTEXT_HEADER, value);\n      };\n      B3SinglePropagator2.prototype.extract = function(context2, carrier, getter) {\n        var header = getter.get(carrier, B3_CONTEXT_HEADER);\n        var b3Context = Array.isArray(header) ? header[0] : header;\n        if (typeof b3Context !== \"string\")\n          return context2;\n        var match = b3Context.match(B3_CONTEXT_REGEX);\n        if (!match)\n          return context2;\n        var _a2 = __read9(match, 4), extractedTraceId = _a2[1], spanId = _a2[2], samplingState = _a2[3];\n        var traceId = convertToTraceId128(extractedTraceId);\n        if (!isValidTraceId(traceId) || !isValidSpanId(spanId))\n          return context2;\n        var traceFlags = convertToTraceFlags(samplingState);\n        if (samplingState === DEBUG_STATE) {\n          context2 = context2.setValue(B3_DEBUG_FLAG_KEY, samplingState);\n        }\n        return trace.setSpanContext(context2, {\n          traceId,\n          spanId,\n          isRemote: true,\n          traceFlags\n        });\n      };\n      B3SinglePropagator2.prototype.fields = function() {\n        return [B3_CONTEXT_HEADER];\n      };\n      return B3SinglePropagator2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/propagator-b3/build/esm/types.js\nvar B3InjectEncoding;\nvar init_types3 = __esm({\n  \"node_modules/@opentelemetry/propagator-b3/build/esm/types.js\"() {\n    (function(B3InjectEncoding2) {\n      B3InjectEncoding2[B3InjectEncoding2[\"SINGLE_HEADER\"] = 0] = \"SINGLE_HEADER\";\n      B3InjectEncoding2[B3InjectEncoding2[\"MULTI_HEADER\"] = 1] = \"MULTI_HEADER\";\n    })(B3InjectEncoding || (B3InjectEncoding = {}));\n  }\n});\n\n// node_modules/@opentelemetry/propagator-b3/build/esm/B3Propagator.js\nvar B3Propagator;\nvar init_B3Propagator = __esm({\n  \"node_modules/@opentelemetry/propagator-b3/build/esm/B3Propagator.js\"() {\n    init_esm3();\n    init_B3MultiPropagator();\n    init_B3SinglePropagator();\n    init_constants2();\n    init_types3();\n    B3Propagator = /** @class */\n    function() {\n      function B3Propagator2(config) {\n        if (config === void 0) {\n          config = {};\n        }\n        this._b3MultiPropagator = new B3MultiPropagator();\n        this._b3SinglePropagator = new B3SinglePropagator();\n        if (config.injectEncoding === B3InjectEncoding.MULTI_HEADER) {\n          this._inject = this._b3MultiPropagator.inject;\n          this._fields = this._b3MultiPropagator.fields();\n        } else {\n          this._inject = this._b3SinglePropagator.inject;\n          this._fields = this._b3SinglePropagator.fields();\n        }\n      }\n      B3Propagator2.prototype.inject = function(context2, carrier, setter) {\n        if (isTracingSuppressed(context2)) {\n          return;\n        }\n        this._inject(context2, carrier, setter);\n      };\n      B3Propagator2.prototype.extract = function(context2, carrier, getter) {\n        var header = getter.get(carrier, B3_CONTEXT_HEADER);\n        var b3Context = Array.isArray(header) ? header[0] : header;\n        if (b3Context) {\n          return this._b3SinglePropagator.extract(context2, carrier, getter);\n        } else {\n          return this._b3MultiPropagator.extract(context2, carrier, getter);\n        }\n      };\n      B3Propagator2.prototype.fields = function() {\n        return this._fields;\n      };\n      return B3Propagator2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/propagator-b3/build/esm/index.js\nvar esm_exports4 = {};\n__export(esm_exports4, {\n  B3InjectEncoding: () => B3InjectEncoding,\n  B3Propagator: () => B3Propagator,\n  B3_CONTEXT_HEADER: () => B3_CONTEXT_HEADER,\n  X_B3_FLAGS: () => X_B3_FLAGS,\n  X_B3_PARENT_SPAN_ID: () => X_B3_PARENT_SPAN_ID,\n  X_B3_SAMPLED: () => X_B3_SAMPLED,\n  X_B3_SPAN_ID: () => X_B3_SPAN_ID,\n  X_B3_TRACE_ID: () => X_B3_TRACE_ID\n});\nvar init_esm4 = __esm({\n  \"node_modules/@opentelemetry/propagator-b3/build/esm/index.js\"() {\n    init_B3Propagator();\n    init_constants2();\n    init_types3();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/enums.js\nvar ExceptionEventName;\nvar init_enums = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/enums.js\"() {\n    ExceptionEventName = \"exception\";\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js\nvar __values5, __read10, Span;\nvar init_Span = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/Span.js\"() {\n    init_esm();\n    init_esm3();\n    init_esm2();\n    init_enums();\n    __values5 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n    __read10 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    Span = /** @class */\n    function() {\n      function Span4(parentTracer, context2, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock, attributes) {\n        if (links === void 0) {\n          links = [];\n        }\n        this.attributes = {};\n        this.links = [];\n        this.events = [];\n        this._droppedAttributesCount = 0;\n        this._droppedEventsCount = 0;\n        this._droppedLinksCount = 0;\n        this.status = {\n          code: SpanStatusCode.UNSET\n        };\n        this.endTime = [0, 0];\n        this._ended = false;\n        this._duration = [-1, -1];\n        this.name = spanName;\n        this._spanContext = spanContext;\n        this.parentSpanId = parentSpanId;\n        this.kind = kind;\n        this.links = links;\n        var now = Date.now();\n        this._performanceStartTime = otperformance.now();\n        this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());\n        this._startTimeProvided = startTime != null;\n        this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);\n        this.resource = parentTracer.resource;\n        this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n        this._spanLimits = parentTracer.getSpanLimits();\n        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n        if (attributes != null) {\n          this.setAttributes(attributes);\n        }\n        this._spanProcessor = parentTracer.getActiveSpanProcessor();\n        this._spanProcessor.onStart(this, context2);\n      }\n      Span4.prototype.spanContext = function() {\n        return this._spanContext;\n      };\n      Span4.prototype.setAttribute = function(key, value) {\n        if (value == null || this._isSpanEnded())\n          return this;\n        if (key.length === 0) {\n          diag2.warn(\"Invalid attribute key: \" + key);\n          return this;\n        }\n        if (!isAttributeValue(value)) {\n          diag2.warn(\"Invalid attribute value set for key: \" + key);\n          return this;\n        }\n        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n          this._droppedAttributesCount++;\n          return this;\n        }\n        this.attributes[key] = this._truncateToSize(value);\n        return this;\n      };\n      Span4.prototype.setAttributes = function(attributes) {\n        var e_1, _a2;\n        try {\n          for (var _b = __values5(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var _d = __read10(_c.value, 2), k = _d[0], v = _d[1];\n            this.setAttribute(k, v);\n          }\n        } catch (e_1_1) {\n          e_1 = { error: e_1_1 };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a2 = _b.return))\n              _a2.call(_b);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n        return this;\n      };\n      Span4.prototype.addEvent = function(name, attributesOrStartTime, timeStamp) {\n        if (this._isSpanEnded())\n          return this;\n        if (this._spanLimits.eventCountLimit === 0) {\n          diag2.warn(\"No events allowed.\");\n          this._droppedEventsCount++;\n          return this;\n        }\n        if (this.events.length >= this._spanLimits.eventCountLimit) {\n          if (this._droppedEventsCount === 0) {\n            diag2.debug(\"Dropping extra events.\");\n          }\n          this.events.shift();\n          this._droppedEventsCount++;\n        }\n        if (isTimeInput(attributesOrStartTime)) {\n          if (!isTimeInput(timeStamp)) {\n            timeStamp = attributesOrStartTime;\n          }\n          attributesOrStartTime = void 0;\n        }\n        var attributes = sanitizeAttributes(attributesOrStartTime);\n        this.events.push({\n          name,\n          attributes,\n          time: this._getTime(timeStamp),\n          droppedAttributesCount: 0\n        });\n        return this;\n      };\n      Span4.prototype.setStatus = function(status) {\n        if (this._isSpanEnded())\n          return this;\n        this.status = status;\n        return this;\n      };\n      Span4.prototype.updateName = function(name) {\n        if (this._isSpanEnded())\n          return this;\n        this.name = name;\n        return this;\n      };\n      Span4.prototype.end = function(endTime) {\n        if (this._isSpanEnded()) {\n          diag2.error(this.name + \" \" + this._spanContext.traceId + \"-\" + this._spanContext.spanId + \" - You can only call end() on a span once.\");\n          return;\n        }\n        this._ended = true;\n        this.endTime = this._getTime(endTime);\n        this._duration = hrTimeDuration(this.startTime, this.endTime);\n        if (this._duration[0] < 0) {\n          diag2.warn(\"Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.\", this.startTime, this.endTime);\n          this.endTime = this.startTime.slice();\n          this._duration = [0, 0];\n        }\n        if (this._droppedEventsCount > 0) {\n          diag2.warn(\"Dropped \" + this._droppedEventsCount + \" events because eventCountLimit reached\");\n        }\n        this._spanProcessor.onEnd(this);\n      };\n      Span4.prototype._getTime = function(inp) {\n        if (typeof inp === \"number\" && inp < otperformance.now()) {\n          return hrTime(inp + this._performanceOffset);\n        }\n        if (typeof inp === \"number\") {\n          return millisToHrTime(inp);\n        }\n        if (inp instanceof Date) {\n          return millisToHrTime(inp.getTime());\n        }\n        if (isTimeInputHrTime(inp)) {\n          return inp;\n        }\n        if (this._startTimeProvided) {\n          return millisToHrTime(Date.now());\n        }\n        var msDuration = otperformance.now() - this._performanceStartTime;\n        return addHrTimes(this.startTime, millisToHrTime(msDuration));\n      };\n      Span4.prototype.isRecording = function() {\n        return this._ended === false;\n      };\n      Span4.prototype.recordException = function(exception, time) {\n        var attributes = {};\n        if (typeof exception === \"string\") {\n          attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n        } else if (exception) {\n          if (exception.code) {\n            attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n          } else if (exception.name) {\n            attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n          }\n          if (exception.message) {\n            attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n          }\n          if (exception.stack) {\n            attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n          }\n        }\n        if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n          this.addEvent(ExceptionEventName, attributes, time);\n        } else {\n          diag2.warn(\"Failed to record an exception \" + exception);\n        }\n      };\n      Object.defineProperty(Span4.prototype, \"duration\", {\n        get: function() {\n          return this._duration;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Span4.prototype, \"ended\", {\n        get: function() {\n          return this._ended;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Span4.prototype, \"droppedAttributesCount\", {\n        get: function() {\n          return this._droppedAttributesCount;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Span4.prototype, \"droppedEventsCount\", {\n        get: function() {\n          return this._droppedEventsCount;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Span4.prototype, \"droppedLinksCount\", {\n        get: function() {\n          return this._droppedLinksCount;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Span4.prototype._isSpanEnded = function() {\n        if (this._ended) {\n          diag2.warn(\"Can not execute the operation on ended Span {traceId: \" + this._spanContext.traceId + \", spanId: \" + this._spanContext.spanId + \"}\");\n        }\n        return this._ended;\n      };\n      Span4.prototype._truncateToLimitUtil = function(value, limit) {\n        if (value.length <= limit) {\n          return value;\n        }\n        return value.substr(0, limit);\n      };\n      Span4.prototype._truncateToSize = function(value) {\n        var _this = this;\n        var limit = this._attributeValueLengthLimit;\n        if (limit <= 0) {\n          diag2.warn(\"Attribute value limit must be positive, got \" + limit);\n          return value;\n        }\n        if (typeof value === \"string\") {\n          return this._truncateToLimitUtil(value, limit);\n        }\n        if (Array.isArray(value)) {\n          return value.map(function(val) {\n            return typeof val === \"string\" ? _this._truncateToLimitUtil(val, limit) : val;\n          });\n        }\n        return value;\n      };\n      return Span4;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/Sampler.js\nvar SamplingDecision2;\nvar init_Sampler = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/Sampler.js\"() {\n    (function(SamplingDecision3) {\n      SamplingDecision3[SamplingDecision3[\"NOT_RECORD\"] = 0] = \"NOT_RECORD\";\n      SamplingDecision3[SamplingDecision3[\"RECORD\"] = 1] = \"RECORD\";\n      SamplingDecision3[SamplingDecision3[\"RECORD_AND_SAMPLED\"] = 2] = \"RECORD_AND_SAMPLED\";\n    })(SamplingDecision2 || (SamplingDecision2 = {}));\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOffSampler.js\nvar AlwaysOffSampler2;\nvar init_AlwaysOffSampler2 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOffSampler.js\"() {\n    init_Sampler();\n    AlwaysOffSampler2 = /** @class */\n    function() {\n      function AlwaysOffSampler3() {\n      }\n      AlwaysOffSampler3.prototype.shouldSample = function() {\n        return {\n          decision: SamplingDecision2.NOT_RECORD\n        };\n      };\n      AlwaysOffSampler3.prototype.toString = function() {\n        return \"AlwaysOffSampler\";\n      };\n      return AlwaysOffSampler3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOnSampler.js\nvar AlwaysOnSampler2;\nvar init_AlwaysOnSampler2 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/AlwaysOnSampler.js\"() {\n    init_Sampler();\n    AlwaysOnSampler2 = /** @class */\n    function() {\n      function AlwaysOnSampler3() {\n      }\n      AlwaysOnSampler3.prototype.shouldSample = function() {\n        return {\n          decision: SamplingDecision2.RECORD_AND_SAMPLED\n        };\n      };\n      AlwaysOnSampler3.prototype.toString = function() {\n        return \"AlwaysOnSampler\";\n      };\n      return AlwaysOnSampler3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/ParentBasedSampler.js\nvar ParentBasedSampler2;\nvar init_ParentBasedSampler2 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/ParentBasedSampler.js\"() {\n    init_esm();\n    init_esm3();\n    init_AlwaysOffSampler2();\n    init_AlwaysOnSampler2();\n    ParentBasedSampler2 = /** @class */\n    function() {\n      function ParentBasedSampler3(config) {\n        var _a2, _b, _c, _d;\n        this._root = config.root;\n        if (!this._root) {\n          globalErrorHandler(new Error(\"ParentBasedSampler must have a root sampler configured\"));\n          this._root = new AlwaysOnSampler2();\n        }\n        this._remoteParentSampled = (_a2 = config.remoteParentSampled) !== null && _a2 !== void 0 ? _a2 : new AlwaysOnSampler2();\n        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler2();\n        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler2();\n        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler2();\n      }\n      ParentBasedSampler3.prototype.shouldSample = function(context2, traceId, spanName, spanKind, attributes, links) {\n        var parentContext = trace.getSpanContext(context2);\n        if (!parentContext || !isSpanContextValid(parentContext)) {\n          return this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n        }\n        if (parentContext.isRemote) {\n          if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n            return this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n          }\n          return this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n        }\n        if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n          return this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n        }\n        return this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);\n      };\n      ParentBasedSampler3.prototype.toString = function() {\n        return \"ParentBased{root=\" + this._root.toString() + \", remoteParentSampled=\" + this._remoteParentSampled.toString() + \", remoteParentNotSampled=\" + this._remoteParentNotSampled.toString() + \", localParentSampled=\" + this._localParentSampled.toString() + \", localParentNotSampled=\" + this._localParentNotSampled.toString() + \"}\";\n      };\n      return ParentBasedSampler3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/TraceIdRatioBasedSampler.js\nvar TraceIdRatioBasedSampler2;\nvar init_TraceIdRatioBasedSampler2 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/sampler/TraceIdRatioBasedSampler.js\"() {\n    init_esm();\n    init_Sampler();\n    TraceIdRatioBasedSampler2 = /** @class */\n    function() {\n      function TraceIdRatioBasedSampler3(_ratio) {\n        if (_ratio === void 0) {\n          _ratio = 0;\n        }\n        this._ratio = _ratio;\n        this._ratio = this._normalize(_ratio);\n        this._upperBound = Math.floor(this._ratio * 4294967295);\n      }\n      TraceIdRatioBasedSampler3.prototype.shouldSample = function(context2, traceId) {\n        return {\n          decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision2.RECORD_AND_SAMPLED : SamplingDecision2.NOT_RECORD\n        };\n      };\n      TraceIdRatioBasedSampler3.prototype.toString = function() {\n        return \"TraceIdRatioBased{\" + this._ratio + \"}\";\n      };\n      TraceIdRatioBasedSampler3.prototype._normalize = function(ratio) {\n        if (typeof ratio !== \"number\" || isNaN(ratio))\n          return 0;\n        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n      };\n      TraceIdRatioBasedSampler3.prototype._accumulate = function(traceId) {\n        var accumulation = 0;\n        for (var i = 0; i < traceId.length / 8; i++) {\n          var pos = i * 8;\n          var part = parseInt(traceId.slice(pos, pos + 8), 16);\n          accumulation = (accumulation ^ part) >>> 0;\n        }\n        return accumulation;\n      };\n      return TraceIdRatioBasedSampler3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js\nfunction loadDefaultConfig() {\n  return {\n    sampler: buildSamplerFromEnv(env),\n    forceFlushTimeoutMillis: 3e4,\n    generalLimits: {\n      attributeValueLengthLimit: getEnv().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: getEnv().OTEL_ATTRIBUTE_COUNT_LIMIT\n    },\n    spanLimits: {\n      attributeValueLengthLimit: getEnv().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n      linkCountLimit: getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,\n      eventCountLimit: getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT,\n      attributePerEventCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n      attributePerLinkCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT\n    }\n  };\n}\nfunction buildSamplerFromEnv(environment) {\n  if (environment === void 0) {\n    environment = getEnv();\n  }\n  switch (environment.OTEL_TRACES_SAMPLER) {\n    case TracesSamplerValues.AlwaysOn:\n      return new AlwaysOnSampler2();\n    case TracesSamplerValues.AlwaysOff:\n      return new AlwaysOffSampler2();\n    case TracesSamplerValues.ParentBasedAlwaysOn:\n      return new ParentBasedSampler2({\n        root: new AlwaysOnSampler2()\n      });\n    case TracesSamplerValues.ParentBasedAlwaysOff:\n      return new ParentBasedSampler2({\n        root: new AlwaysOffSampler2()\n      });\n    case TracesSamplerValues.TraceIdRatio:\n      return new TraceIdRatioBasedSampler2(getSamplerProbabilityFromEnv(environment));\n    case TracesSamplerValues.ParentBasedTraceIdRatio:\n      return new ParentBasedSampler2({\n        root: new TraceIdRatioBasedSampler2(getSamplerProbabilityFromEnv(environment))\n      });\n    default:\n      diag2.error('OTEL_TRACES_SAMPLER value \"' + environment.OTEL_TRACES_SAMPLER + \" invalid, defaulting to \" + FALLBACK_OTEL_TRACES_SAMPLER + '\".');\n      return new AlwaysOnSampler2();\n  }\n}\nfunction getSamplerProbabilityFromEnv(environment) {\n  if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === \"\") {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG is blank, defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);\n  if (isNaN(probability)) {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG=\" + environment.OTEL_TRACES_SAMPLER_ARG + \" was given, but it is invalid, defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  if (probability < 0 || probability > 1) {\n    diag2.error(\"OTEL_TRACES_SAMPLER_ARG=\" + environment.OTEL_TRACES_SAMPLER_ARG + \" was given, but it is out of range ([0..1]), defaulting to \" + DEFAULT_RATIO + \".\");\n    return DEFAULT_RATIO;\n  }\n  return probability;\n}\nvar env, FALLBACK_OTEL_TRACES_SAMPLER, DEFAULT_RATIO;\nvar init_config = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/config.js\"() {\n    init_esm();\n    init_esm3();\n    init_AlwaysOffSampler2();\n    init_AlwaysOnSampler2();\n    init_ParentBasedSampler2();\n    init_TraceIdRatioBasedSampler2();\n    env = getEnv();\n    FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;\n    DEFAULT_RATIO = 1;\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/utility.js\nfunction mergeConfig(userConfig) {\n  var perInstanceDefaults = {\n    sampler: buildSamplerFromEnv()\n  };\n  var DEFAULT_CONFIG = loadDefaultConfig();\n  var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);\n  target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});\n  target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});\n  return target;\n}\nfunction reconfigureLimits(userConfig) {\n  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n  var spanLimits = Object.assign({}, userConfig.spanLimits);\n  var parsedEnvConfig = getEnvWithoutDefaults();\n  spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b = (_a2 = userConfig.spanLimits) === null || _a2 === void 0 ? void 0 : _a2.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;\n  spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;\n  return Object.assign({}, userConfig, { spanLimits });\n}\nvar init_utility = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/utility.js\"() {\n    init_config();\n    init_esm3();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/export/BatchSpanProcessorBase.js\nvar BatchSpanProcessorBase;\nvar init_BatchSpanProcessorBase = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/export/BatchSpanProcessorBase.js\"() {\n    init_esm();\n    init_esm3();\n    BatchSpanProcessorBase = /** @class */\n    function() {\n      function BatchSpanProcessorBase2(_exporter, config) {\n        this._exporter = _exporter;\n        this._isExporting = false;\n        this._finishedSpans = [];\n        this._droppedSpansCount = 0;\n        var env3 = getEnv();\n        this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === \"number\" ? config.maxExportBatchSize : env3.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n        this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === \"number\" ? config.maxQueueSize : env3.OTEL_BSP_MAX_QUEUE_SIZE;\n        this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === \"number\" ? config.scheduledDelayMillis : env3.OTEL_BSP_SCHEDULE_DELAY;\n        this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === \"number\" ? config.exportTimeoutMillis : env3.OTEL_BSP_EXPORT_TIMEOUT;\n        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n        if (this._maxExportBatchSize > this._maxQueueSize) {\n          diag2.warn(\"BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize\");\n          this._maxExportBatchSize = this._maxQueueSize;\n        }\n      }\n      BatchSpanProcessorBase2.prototype.forceFlush = function() {\n        if (this._shutdownOnce.isCalled) {\n          return this._shutdownOnce.promise;\n        }\n        return this._flushAll();\n      };\n      BatchSpanProcessorBase2.prototype.onStart = function(_span, _parentContext) {\n      };\n      BatchSpanProcessorBase2.prototype.onEnd = function(span) {\n        if (this._shutdownOnce.isCalled) {\n          return;\n        }\n        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n          return;\n        }\n        this._addToBuffer(span);\n      };\n      BatchSpanProcessorBase2.prototype.shutdown = function() {\n        return this._shutdownOnce.call();\n      };\n      BatchSpanProcessorBase2.prototype._shutdown = function() {\n        var _this = this;\n        return Promise.resolve().then(function() {\n          return _this.onShutdown();\n        }).then(function() {\n          return _this._flushAll();\n        }).then(function() {\n          return _this._exporter.shutdown();\n        });\n      };\n      BatchSpanProcessorBase2.prototype._addToBuffer = function(span) {\n        if (this._finishedSpans.length >= this._maxQueueSize) {\n          if (this._droppedSpansCount === 0) {\n            diag2.debug(\"maxQueueSize reached, dropping spans\");\n          }\n          this._droppedSpansCount++;\n          return;\n        }\n        if (this._droppedSpansCount > 0) {\n          diag2.warn(\"Dropped \" + this._droppedSpansCount + \" spans because maxQueueSize reached\");\n          this._droppedSpansCount = 0;\n        }\n        this._finishedSpans.push(span);\n        this._maybeStartTimer();\n      };\n      BatchSpanProcessorBase2.prototype._flushAll = function() {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n          var promises = [];\n          var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n          for (var i = 0, j = count; i < j; i++) {\n            promises.push(_this._flushOneBatch());\n          }\n          Promise.all(promises).then(function() {\n            resolve();\n          }).catch(reject);\n        });\n      };\n      BatchSpanProcessorBase2.prototype._flushOneBatch = function() {\n        var _this = this;\n        this._clearTimer();\n        if (this._finishedSpans.length === 0) {\n          return Promise.resolve();\n        }\n        return new Promise(function(resolve, reject) {\n          var timer = setTimeout(function() {\n            reject(new Error(\"Timeout\"));\n          }, _this._exportTimeoutMillis);\n          context.with(suppressTracing(context.active()), function() {\n            var spans;\n            if (_this._finishedSpans.length <= _this._maxExportBatchSize) {\n              spans = _this._finishedSpans;\n              _this._finishedSpans = [];\n            } else {\n              spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);\n            }\n            var doExport = function() {\n              return _this._exporter.export(spans, function(result) {\n                var _a2;\n                clearTimeout(timer);\n                if (result.code === ExportResultCode.SUCCESS) {\n                  resolve();\n                } else {\n                  reject((_a2 = result.error) !== null && _a2 !== void 0 ? _a2 : new Error(\"BatchSpanProcessor: span export failed\"));\n                }\n              });\n            };\n            var pendingResources = null;\n            for (var i = 0, len = spans.length; i < len; i++) {\n              var span = spans[i];\n              if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {\n                pendingResources !== null && pendingResources !== void 0 ? pendingResources : pendingResources = [];\n                pendingResources.push(span.resource.waitForAsyncAttributes());\n              }\n            }\n            if (pendingResources === null) {\n              doExport();\n            } else {\n              Promise.all(pendingResources).then(doExport, function(err) {\n                globalErrorHandler(err);\n                reject(err);\n              });\n            }\n          });\n        });\n      };\n      BatchSpanProcessorBase2.prototype._maybeStartTimer = function() {\n        var _this = this;\n        if (this._isExporting)\n          return;\n        var flush = function() {\n          _this._isExporting = true;\n          _this._flushOneBatch().finally(function() {\n            _this._isExporting = false;\n            if (_this._finishedSpans.length > 0) {\n              _this._clearTimer();\n              _this._maybeStartTimer();\n            }\n          }).catch(function(e) {\n            _this._isExporting = false;\n            globalErrorHandler(e);\n          });\n        };\n        if (this._finishedSpans.length >= this._maxExportBatchSize) {\n          return flush();\n        }\n        if (this._timer !== void 0)\n          return;\n        this._timer = setTimeout(function() {\n          return flush();\n        }, this._scheduledDelayMillis);\n        unrefTimer(this._timer);\n      };\n      BatchSpanProcessorBase2.prototype._clearTimer = function() {\n        if (this._timer !== void 0) {\n          clearTimeout(this._timer);\n          this._timer = void 0;\n        }\n      };\n      return BatchSpanProcessorBase2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/export/BatchSpanProcessor.js\nvar __extends3, BatchSpanProcessor;\nvar init_BatchSpanProcessor = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/export/BatchSpanProcessor.js\"() {\n    init_BatchSpanProcessorBase();\n    __extends3 = function() {\n      var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n          d2.__proto__ = b2;\n        } || function(d2, b2) {\n          for (var p in b2)\n            if (Object.prototype.hasOwnProperty.call(b2, p))\n              d2[p] = b2[p];\n        };\n        return extendStatics(d, b);\n      };\n      return function(d, b) {\n        if (typeof b !== \"function\" && b !== null)\n          throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n    BatchSpanProcessor = /** @class */\n    function(_super) {\n      __extends3(BatchSpanProcessor3, _super);\n      function BatchSpanProcessor3() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      BatchSpanProcessor3.prototype.onShutdown = function() {\n      };\n      return BatchSpanProcessor3;\n    }(BatchSpanProcessorBase);\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/RandomIdGenerator.js\nfunction getIdGenerator2(bytes) {\n  return function generateId() {\n    for (var i = 0; i < bytes / 4; i++) {\n      SHARED_BUFFER2.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);\n    }\n    for (var i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER2[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER2[bytes - 1] = 1;\n      }\n    }\n    return SHARED_BUFFER2.toString(\"hex\", 0, bytes);\n  };\n}\nvar SPAN_ID_BYTES2, TRACE_ID_BYTES2, RandomIdGenerator2, SHARED_BUFFER2;\nvar init_RandomIdGenerator2 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/RandomIdGenerator.js\"() {\n    SPAN_ID_BYTES2 = 8;\n    TRACE_ID_BYTES2 = 16;\n    RandomIdGenerator2 = /** @class */\n    function() {\n      function RandomIdGenerator3() {\n        this.generateTraceId = getIdGenerator2(TRACE_ID_BYTES2);\n        this.generateSpanId = getIdGenerator2(SPAN_ID_BYTES2);\n      }\n      return RandomIdGenerator3;\n    }();\n    SHARED_BUFFER2 = Buffer.allocUnsafe(TRACE_ID_BYTES2);\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/index.js\nvar init_node3 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/node/index.js\"() {\n    init_BatchSpanProcessor();\n    init_RandomIdGenerator2();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/index.js\nvar init_platform3 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/platform/index.js\"() {\n    init_node3();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js\nvar Tracer;\nvar init_Tracer = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/Tracer.js\"() {\n    init_esm();\n    init_esm3();\n    init_Span();\n    init_utility();\n    init_platform3();\n    Tracer = /** @class */\n    function() {\n      function Tracer2(instrumentationLibrary, config, _tracerProvider) {\n        this._tracerProvider = _tracerProvider;\n        var localConfig = mergeConfig(config);\n        this._sampler = localConfig.sampler;\n        this._generalLimits = localConfig.generalLimits;\n        this._spanLimits = localConfig.spanLimits;\n        this._idGenerator = config.idGenerator || new RandomIdGenerator2();\n        this.resource = _tracerProvider.resource;\n        this.instrumentationLibrary = instrumentationLibrary;\n      }\n      Tracer2.prototype.startSpan = function(name, options, context2) {\n        var _a2, _b, _c;\n        if (options === void 0) {\n          options = {};\n        }\n        if (context2 === void 0) {\n          context2 = context.active();\n        }\n        if (options.root) {\n          context2 = trace.deleteSpan(context2);\n        }\n        var parentSpan = trace.getSpan(context2);\n        if (isTracingSuppressed(context2)) {\n          diag2.debug(\"Instrumentation suppressed, returning Noop Span\");\n          var nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);\n          return nonRecordingSpan;\n        }\n        var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();\n        var spanId = this._idGenerator.generateSpanId();\n        var traceId;\n        var traceState;\n        var parentSpanId;\n        if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {\n          traceId = this._idGenerator.generateTraceId();\n        } else {\n          traceId = parentSpanContext.traceId;\n          traceState = parentSpanContext.traceState;\n          parentSpanId = parentSpanContext.spanId;\n        }\n        var spanKind = (_a2 = options.kind) !== null && _a2 !== void 0 ? _a2 : SpanKind.INTERNAL;\n        var links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(function(link) {\n          return {\n            context: link.context,\n            attributes: sanitizeAttributes(link.attributes)\n          };\n        });\n        var attributes = sanitizeAttributes(options.attributes);\n        var samplingResult = this._sampler.shouldSample(context2, traceId, name, spanKind, attributes, links);\n        traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;\n        var traceFlags = samplingResult.decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;\n        var spanContext = { traceId, spanId, traceFlags, traceState };\n        if (samplingResult.decision === SamplingDecision.NOT_RECORD) {\n          diag2.debug(\"Recording is off, propagating context in a non-recording span\");\n          var nonRecordingSpan = trace.wrapSpanContext(spanContext);\n          return nonRecordingSpan;\n        }\n        var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));\n        var span = new Span(this, context2, name, spanContext, spanKind, parentSpanId, links, options.startTime, void 0, initAttributes);\n        return span;\n      };\n      Tracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {\n        var opts;\n        var ctx;\n        var fn;\n        if (arguments.length < 2) {\n          return;\n        } else if (arguments.length === 2) {\n          fn = arg2;\n        } else if (arguments.length === 3) {\n          opts = arg2;\n          fn = arg3;\n        } else {\n          opts = arg2;\n          ctx = arg3;\n          fn = arg4;\n        }\n        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();\n        var span = this.startSpan(name, opts, parentContext);\n        var contextWithSpanSet = trace.setSpan(parentContext, span);\n        return context.with(contextWithSpanSet, fn, void 0, span);\n      };\n      Tracer2.prototype.getGeneralLimits = function() {\n        return this._generalLimits;\n      };\n      Tracer2.prototype.getSpanLimits = function() {\n        return this._spanLimits;\n      };\n      Tracer2.prototype.getActiveSpanProcessor = function() {\n        return this._tracerProvider.getActiveSpanProcessor();\n      };\n      return Tracer2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js\nfunction defaultServiceName() {\n  return \"unknown_service:\" + process.argv0;\n}\nvar init_default_service_name = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/utils.js\nvar normalizeArch, normalizeType;\nvar init_utils5 = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/utils.js\"() {\n    normalizeArch = function(nodeArchString) {\n      switch (nodeArchString) {\n        case \"arm\":\n          return \"arm32\";\n        case \"ppc\":\n          return \"ppc32\";\n        case \"x64\":\n          return \"amd64\";\n        default:\n          return nodeArchString;\n      }\n    };\n    normalizeType = function(nodePlatform) {\n      switch (nodePlatform) {\n        case \"sunos\":\n          return \"solaris\";\n        case \"win32\":\n          return \"windows\";\n        default:\n          return nodePlatform;\n      }\n    };\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/execAsync.js\nvar child_process, util, execAsync;\nvar init_execAsync = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/execAsync.js\"() {\n    child_process = __toESM(__webpack_require__(/*! child_process */ \"child_process\"));\n    util = __toESM(__webpack_require__(/*! util */ \"util\"));\n    execAsync = util.promisify(child_process.exec);\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-darwin.js\nvar getMachineId_darwin_exports = {};\n__export(getMachineId_darwin_exports, {\n  getMachineId: () => getMachineId\n});\nfunction getMachineId() {\n  return __awaiter(this, void 0, void 0, function() {\n    var result, idLine, parts, e_1;\n    return __generator(this, function(_a2) {\n      switch (_a2.label) {\n        case 0:\n          _a2.trys.push([0, 2, , 3]);\n          return [4, execAsync('ioreg -rd1 -c \"IOPlatformExpertDevice\"')];\n        case 1:\n          result = _a2.sent();\n          idLine = result.stdout.split(\"\\n\").find(function(line) {\n            return line.includes(\"IOPlatformUUID\");\n          });\n          if (!idLine) {\n            return [2, \"\"];\n          }\n          parts = idLine.split('\" = \"');\n          if (parts.length === 2) {\n            return [2, parts[1].slice(0, -1)];\n          }\n          return [3, 3];\n        case 2:\n          e_1 = _a2.sent();\n          diag2.debug(\"error reading machine id: \" + e_1);\n          return [3, 3];\n        case 3:\n          return [2, \"\"];\n      }\n    });\n  });\n}\nvar __awaiter, __generator;\nvar init_getMachineId_darwin = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-darwin.js\"() {\n    init_execAsync();\n    init_esm();\n    __awaiter = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-linux.js\nvar getMachineId_linux_exports = {};\n__export(getMachineId_linux_exports, {\n  getMachineId: () => getMachineId2\n});\nfunction getMachineId2() {\n  return __awaiter2(this, void 0, void 0, function() {\n    var paths, paths_1, paths_1_1, path3, result, e_1, e_2_1;\n    var e_2, _a2;\n    return __generator2(this, function(_b) {\n      switch (_b.label) {\n        case 0:\n          paths = [\"/etc/machine-id\", \"/var/lib/dbus/machine-id\"];\n          _b.label = 1;\n        case 1:\n          _b.trys.push([1, 8, 9, 10]);\n          paths_1 = __values6(paths), paths_1_1 = paths_1.next();\n          _b.label = 2;\n        case 2:\n          if (!!paths_1_1.done)\n            return [3, 7];\n          path3 = paths_1_1.value;\n          _b.label = 3;\n        case 3:\n          _b.trys.push([3, 5, , 6]);\n          return [4, import_fs.promises.readFile(path3, { encoding: \"utf8\" })];\n        case 4:\n          result = _b.sent();\n          return [2, result.trim()];\n        case 5:\n          e_1 = _b.sent();\n          diag2.debug(\"error reading machine id: \" + e_1);\n          return [3, 6];\n        case 6:\n          paths_1_1 = paths_1.next();\n          return [3, 2];\n        case 7:\n          return [3, 10];\n        case 8:\n          e_2_1 = _b.sent();\n          e_2 = { error: e_2_1 };\n          return [3, 10];\n        case 9:\n          try {\n            if (paths_1_1 && !paths_1_1.done && (_a2 = paths_1.return))\n              _a2.call(paths_1);\n          } finally {\n            if (e_2)\n              throw e_2.error;\n          }\n          return [\n            7\n            /*endfinally*/\n          ];\n        case 10:\n          return [2, \"\"];\n      }\n    });\n  });\n}\nvar import_fs, __awaiter2, __generator2, __values6;\nvar init_getMachineId_linux = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-linux.js\"() {\n    import_fs = __webpack_require__(/*! fs */ \"fs\");\n    init_esm();\n    __awaiter2 = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator2 = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n    __values6 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-bsd.js\nvar getMachineId_bsd_exports = {};\n__export(getMachineId_bsd_exports, {\n  getMachineId: () => getMachineId3\n});\nfunction getMachineId3() {\n  return __awaiter3(this, void 0, void 0, function() {\n    var result, e_1, result, e_2;\n    return __generator3(this, function(_a2) {\n      switch (_a2.label) {\n        case 0:\n          _a2.trys.push([0, 2, , 3]);\n          return [4, import_fs2.promises.readFile(\"/etc/hostid\", { encoding: \"utf8\" })];\n        case 1:\n          result = _a2.sent();\n          return [2, result.trim()];\n        case 2:\n          e_1 = _a2.sent();\n          diag2.debug(\"error reading machine id: \" + e_1);\n          return [3, 3];\n        case 3:\n          _a2.trys.push([3, 5, , 6]);\n          return [4, execAsync(\"kenv -q smbios.system.uuid\")];\n        case 4:\n          result = _a2.sent();\n          return [2, result.stdout.trim()];\n        case 5:\n          e_2 = _a2.sent();\n          diag2.debug(\"error reading machine id: \" + e_2);\n          return [3, 6];\n        case 6:\n          return [2, \"\"];\n      }\n    });\n  });\n}\nvar import_fs2, __awaiter3, __generator3;\nvar init_getMachineId_bsd = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-bsd.js\"() {\n    import_fs2 = __webpack_require__(/*! fs */ \"fs\");\n    init_execAsync();\n    init_esm();\n    __awaiter3 = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator3 = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-win.js\nvar getMachineId_win_exports = {};\n__export(getMachineId_win_exports, {\n  getMachineId: () => getMachineId4\n});\nfunction getMachineId4() {\n  return __awaiter4(this, void 0, void 0, function() {\n    var args, command, result, parts, e_1;\n    return __generator4(this, function(_a2) {\n      switch (_a2.label) {\n        case 0:\n          args = \"QUERY HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography /v MachineGuid\";\n          command = \"%windir%\\\\System32\\\\REG.exe\";\n          if (process2.arch === \"ia32\" && \"PROCESSOR_ARCHITEW6432\" in process2.env) {\n            command = \"%windir%\\\\sysnative\\\\cmd.exe /c \" + command;\n          }\n          _a2.label = 1;\n        case 1:\n          _a2.trys.push([1, 3, , 4]);\n          return [4, execAsync(command + \" \" + args)];\n        case 2:\n          result = _a2.sent();\n          parts = result.stdout.split(\"REG_SZ\");\n          if (parts.length === 2) {\n            return [2, parts[1].trim()];\n          }\n          return [3, 4];\n        case 3:\n          e_1 = _a2.sent();\n          diag2.debug(\"error reading machine id: \" + e_1);\n          return [3, 4];\n        case 4:\n          return [2, \"\"];\n      }\n    });\n  });\n}\nvar process2, __awaiter4, __generator4;\nvar init_getMachineId_win = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-win.js\"() {\n    process2 = __toESM(__webpack_require__(/*! process */ \"process\"));\n    init_execAsync();\n    init_esm();\n    __awaiter4 = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator4 = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-unsupported.js\nvar getMachineId_unsupported_exports = {};\n__export(getMachineId_unsupported_exports, {\n  getMachineId: () => getMachineId5\n});\nfunction getMachineId5() {\n  return __awaiter5(this, void 0, void 0, function() {\n    return __generator5(this, function(_a2) {\n      diag2.debug(\"could not read machine-id: unsupported platform\");\n      return [2, \"\"];\n    });\n  });\n}\nvar __awaiter5, __generator5;\nvar init_getMachineId_unsupported = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId-unsupported.js\"() {\n    init_esm();\n    __awaiter5 = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator5 = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId.js\nvar process3, getMachineId6;\nvar init_getMachineId = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/machine-id/getMachineId.js\"() {\n    process3 = __toESM(__webpack_require__(/*! process */ \"process\"));\n    switch (process3.platform) {\n      case \"darwin\":\n        getMachineId6 = (init_getMachineId_darwin(), __toCommonJS(getMachineId_darwin_exports)).getMachineId;\n        break;\n      case \"linux\":\n        getMachineId6 = (init_getMachineId_linux(), __toCommonJS(getMachineId_linux_exports)).getMachineId;\n        break;\n      case \"freebsd\":\n        getMachineId6 = (init_getMachineId_bsd(), __toCommonJS(getMachineId_bsd_exports)).getMachineId;\n        break;\n      case \"win32\":\n        getMachineId6 = (init_getMachineId_win(), __toCommonJS(getMachineId_win_exports)).getMachineId;\n        break;\n      default:\n        getMachineId6 = (init_getMachineId_unsupported(), __toCommonJS(getMachineId_unsupported_exports)).getMachineId;\n    }\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/HostDetectorSync.js\nvar import_os, HostDetectorSync, hostDetectorSync;\nvar init_HostDetectorSync = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/HostDetectorSync.js\"() {\n    init_esm2();\n    init_Resource();\n    import_os = __webpack_require__(/*! os */ \"os\");\n    init_utils5();\n    init_getMachineId();\n    HostDetectorSync = /** @class */\n    function() {\n      function HostDetectorSync2() {\n      }\n      HostDetectorSync2.prototype.detect = function(_config) {\n        var _a2;\n        var attributes = (_a2 = {}, _a2[SemanticResourceAttributes.HOST_NAME] = (0, import_os.hostname)(), _a2[SemanticResourceAttributes.HOST_ARCH] = normalizeArch((0, import_os.arch)()), _a2);\n        return new Resource(attributes, this._getAsyncAttributes());\n      };\n      HostDetectorSync2.prototype._getAsyncAttributes = function() {\n        return getMachineId6().then(function(machineId) {\n          var attributes = {};\n          if (machineId) {\n            attributes[SemanticResourceAttributes.HOST_ID] = machineId;\n          }\n          return attributes;\n        });\n      };\n      return HostDetectorSync2;\n    }();\n    hostDetectorSync = new HostDetectorSync();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/HostDetector.js\nvar HostDetector, hostDetector;\nvar init_HostDetector = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/HostDetector.js\"() {\n    init_HostDetectorSync();\n    HostDetector = /** @class */\n    function() {\n      function HostDetector2() {\n      }\n      HostDetector2.prototype.detect = function(_config) {\n        return Promise.resolve(hostDetectorSync.detect(_config));\n      };\n      return HostDetector2;\n    }();\n    hostDetector = new HostDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/OSDetectorSync.js\nvar import_os2, OSDetectorSync, osDetectorSync;\nvar init_OSDetectorSync = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/OSDetectorSync.js\"() {\n    init_esm2();\n    init_Resource();\n    import_os2 = __webpack_require__(/*! os */ \"os\");\n    init_utils5();\n    OSDetectorSync = /** @class */\n    function() {\n      function OSDetectorSync2() {\n      }\n      OSDetectorSync2.prototype.detect = function(_config) {\n        var _a2;\n        var attributes = (_a2 = {}, _a2[SemanticResourceAttributes.OS_TYPE] = normalizeType((0, import_os2.platform)()), _a2[SemanticResourceAttributes.OS_VERSION] = (0, import_os2.release)(), _a2);\n        return new Resource(attributes);\n      };\n      return OSDetectorSync2;\n    }();\n    osDetectorSync = new OSDetectorSync();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/OSDetector.js\nvar OSDetector, osDetector;\nvar init_OSDetector = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/OSDetector.js\"() {\n    init_OSDetectorSync();\n    OSDetector = /** @class */\n    function() {\n      function OSDetector2() {\n      }\n      OSDetector2.prototype.detect = function(_config) {\n        return Promise.resolve(osDetectorSync.detect(_config));\n      };\n      return OSDetector2;\n    }();\n    osDetector = new OSDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/ProcessDetectorSync.js\nvar os, __read11, __spreadArray6, ProcessDetectorSync, processDetectorSync;\nvar init_ProcessDetectorSync = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/ProcessDetectorSync.js\"() {\n    init_esm();\n    init_esm2();\n    init_Resource();\n    os = __toESM(__webpack_require__(/*! os */ \"os\"));\n    __read11 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __spreadArray6 = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n          if (ar || !(i in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    ProcessDetectorSync = /** @class */\n    function() {\n      function ProcessDetectorSync2() {\n      }\n      ProcessDetectorSync2.prototype.detect = function(_config) {\n        var _a2;\n        var attributes = (_a2 = {}, _a2[SemanticResourceAttributes.PROCESS_PID] = process.pid, _a2[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] = process.title, _a2[SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH] = process.execPath, _a2[SemanticResourceAttributes.PROCESS_COMMAND_ARGS] = __spreadArray6(__spreadArray6([\n          process.argv[0]\n        ], __read11(process.execArgv), false), __read11(process.argv.slice(1)), false), _a2[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = process.versions.node, _a2[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"nodejs\", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = \"Node.js\", _a2);\n        if (process.argv.length > 1) {\n          attributes[SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1];\n        }\n        try {\n          var userInfo2 = os.userInfo();\n          attributes[SemanticResourceAttributes.PROCESS_OWNER] = userInfo2.username;\n        } catch (e) {\n          diag2.debug(\"error obtaining process owner: \" + e);\n        }\n        return new Resource(attributes);\n      };\n      return ProcessDetectorSync2;\n    }();\n    processDetectorSync = new ProcessDetectorSync();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/ProcessDetector.js\nvar ProcessDetector, processDetector;\nvar init_ProcessDetector = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/ProcessDetector.js\"() {\n    init_ProcessDetectorSync();\n    ProcessDetector = /** @class */\n    function() {\n      function ProcessDetector2() {\n      }\n      ProcessDetector2.prototype.detect = function(config) {\n        return Promise.resolve(processDetectorSync.detect(config));\n      };\n      return ProcessDetector2;\n    }();\n    processDetector = new ProcessDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/node/index.js\nvar init_node4 = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/node/index.js\"() {\n    init_default_service_name();\n    init_HostDetector();\n    init_OSDetector();\n    init_HostDetectorSync();\n    init_OSDetectorSync();\n    init_ProcessDetector();\n    init_ProcessDetectorSync();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/platform/index.js\nvar init_platform4 = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/platform/index.js\"() {\n    init_node4();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/Resource.js\nvar __assign, __awaiter6, __generator6, __read12, Resource;\nvar init_Resource = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/Resource.js\"() {\n    init_esm();\n    init_esm2();\n    init_esm3();\n    init_platform4();\n    __assign = function() {\n      __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n              t[p] = s[p];\n        }\n        return t;\n      };\n      return __assign.apply(this, arguments);\n    };\n    __awaiter6 = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator6 = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n    __read12 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    Resource = /** @class */\n    function() {\n      function Resource3(attributes, asyncAttributesPromise) {\n        var _this = this;\n        var _a2;\n        this._attributes = attributes;\n        this.asyncAttributesPending = asyncAttributesPromise != null;\n        this._syncAttributes = (_a2 = this._attributes) !== null && _a2 !== void 0 ? _a2 : {};\n        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then(function(asyncAttributes) {\n          _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);\n          _this.asyncAttributesPending = false;\n          return asyncAttributes;\n        }, function(err) {\n          diag2.debug(\"a resource's async attributes promise rejected: %s\", err);\n          _this.asyncAttributesPending = false;\n          return {};\n        });\n      }\n      Resource3.empty = function() {\n        return Resource3.EMPTY;\n      };\n      Resource3.default = function() {\n        var _a2;\n        return new Resource3((_a2 = {}, _a2[SemanticResourceAttributes.SERVICE_NAME] = defaultServiceName(), _a2[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE], _a2[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_NAME], _a2[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_VERSION], _a2));\n      };\n      Object.defineProperty(Resource3.prototype, \"attributes\", {\n        get: function() {\n          var _a2;\n          if (this.asyncAttributesPending) {\n            diag2.error(\"Accessing resource attributes before async attributes settled\");\n          }\n          return (_a2 = this._attributes) !== null && _a2 !== void 0 ? _a2 : {};\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Resource3.prototype.waitForAsyncAttributes = function() {\n        return __awaiter6(this, void 0, void 0, function() {\n          return __generator6(this, function(_a2) {\n            switch (_a2.label) {\n              case 0:\n                if (!this.asyncAttributesPending)\n                  return [3, 2];\n                return [4, this._asyncAttributesPromise];\n              case 1:\n                _a2.sent();\n                _a2.label = 2;\n              case 2:\n                return [\n                  2\n                  /*return*/\n                ];\n            }\n          });\n        });\n      };\n      Resource3.prototype.merge = function(other) {\n        var _this = this;\n        var _a2;\n        if (!other)\n          return this;\n        var mergedSyncAttributes = __assign(__assign({}, this._syncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== void 0 ? _a2 : other.attributes);\n        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {\n          return new Resource3(mergedSyncAttributes);\n        }\n        var mergedAttributesPromise = Promise.all([\n          this._asyncAttributesPromise,\n          other._asyncAttributesPromise\n        ]).then(function(_a3) {\n          var _b;\n          var _c = __read12(_a3, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];\n          return __assign(__assign(__assign(__assign({}, _this._syncAttributes), thisAsyncAttributes), (_b = other._syncAttributes) !== null && _b !== void 0 ? _b : other.attributes), otherAsyncAttributes);\n        });\n        return new Resource3(mergedSyncAttributes, mergedAttributesPromise);\n      };\n      Resource3.EMPTY = new Resource3({});\n      return Resource3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/IResource.js\nvar init_IResource = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/IResource.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/types.js\nvar init_types4 = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/types.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/config.js\nvar init_config2 = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/config.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/detectors/BrowserDetector.js\nvar BrowserDetector, browserDetector;\nvar init_BrowserDetector = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/detectors/BrowserDetector.js\"() {\n    init_esm5();\n    BrowserDetector = /** @class */\n    function() {\n      function BrowserDetector2() {\n      }\n      BrowserDetector2.prototype.detect = function(config) {\n        return Promise.resolve(browserDetectorSync.detect(config));\n      };\n      return BrowserDetector2;\n    }();\n    browserDetector = new BrowserDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/detectors/EnvDetectorSync.js\nvar __values7, __read13, EnvDetectorSync, envDetectorSync;\nvar init_EnvDetectorSync = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/detectors/EnvDetectorSync.js\"() {\n    init_esm();\n    init_esm3();\n    init_esm2();\n    init_Resource();\n    __values7 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n    __read13 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    EnvDetectorSync = /** @class */\n    function() {\n      function EnvDetectorSync2() {\n        this._MAX_LENGTH = 255;\n        this._COMMA_SEPARATOR = \",\";\n        this._LABEL_KEY_VALUE_SPLITTER = \"=\";\n        this._ERROR_MESSAGE_INVALID_CHARS = \"should be a ASCII string with a length greater than 0 and not exceed \" + this._MAX_LENGTH + \" characters.\";\n        this._ERROR_MESSAGE_INVALID_VALUE = \"should be a ASCII string with a length not exceed \" + this._MAX_LENGTH + \" characters.\";\n      }\n      EnvDetectorSync2.prototype.detect = function(_config) {\n        var attributes = {};\n        var env3 = getEnv();\n        var rawAttributes = env3.OTEL_RESOURCE_ATTRIBUTES;\n        var serviceName = env3.OTEL_SERVICE_NAME;\n        if (rawAttributes) {\n          try {\n            var parsedAttributes = this._parseResourceAttributes(rawAttributes);\n            Object.assign(attributes, parsedAttributes);\n          } catch (e) {\n            diag2.debug(\"EnvDetector failed: \" + e.message);\n          }\n        }\n        if (serviceName) {\n          attributes[SemanticResourceAttributes.SERVICE_NAME] = serviceName;\n        }\n        return new Resource(attributes);\n      };\n      EnvDetectorSync2.prototype._parseResourceAttributes = function(rawEnvAttributes) {\n        var e_1, _a2;\n        if (!rawEnvAttributes)\n          return {};\n        var attributes = {};\n        var rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);\n        try {\n          for (var rawAttributes_1 = __values7(rawAttributes), rawAttributes_1_1 = rawAttributes_1.next(); !rawAttributes_1_1.done; rawAttributes_1_1 = rawAttributes_1.next()) {\n            var rawAttribute = rawAttributes_1_1.value;\n            var keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);\n            if (keyValuePair.length !== 2) {\n              continue;\n            }\n            var _b = __read13(keyValuePair, 2), key = _b[0], value = _b[1];\n            key = key.trim();\n            value = value.trim().split(/^\"|\"$/).join(\"\");\n            if (!this._isValidAndNotEmpty(key)) {\n              throw new Error(\"Attribute key \" + this._ERROR_MESSAGE_INVALID_CHARS);\n            }\n            if (!this._isValid(value)) {\n              throw new Error(\"Attribute value \" + this._ERROR_MESSAGE_INVALID_VALUE);\n            }\n            attributes[key] = decodeURIComponent(value);\n          }\n        } catch (e_1_1) {\n          e_1 = { error: e_1_1 };\n        } finally {\n          try {\n            if (rawAttributes_1_1 && !rawAttributes_1_1.done && (_a2 = rawAttributes_1.return))\n              _a2.call(rawAttributes_1);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n        return attributes;\n      };\n      EnvDetectorSync2.prototype._isValid = function(name) {\n        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);\n      };\n      EnvDetectorSync2.prototype._isBaggageOctetString = function(str) {\n        for (var i = 0; i < str.length; i++) {\n          var ch = str.charCodeAt(i);\n          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) {\n            return false;\n          }\n        }\n        return true;\n      };\n      EnvDetectorSync2.prototype._isValidAndNotEmpty = function(str) {\n        return str.length > 0 && this._isValid(str);\n      };\n      return EnvDetectorSync2;\n    }();\n    envDetectorSync = new EnvDetectorSync();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/detectors/EnvDetector.js\nvar EnvDetector, envDetector;\nvar init_EnvDetector = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/detectors/EnvDetector.js\"() {\n    init_EnvDetectorSync();\n    EnvDetector = /** @class */\n    function() {\n      function EnvDetector2() {\n      }\n      EnvDetector2.prototype.detect = function(config) {\n        return Promise.resolve(envDetectorSync.detect(config));\n      };\n      return EnvDetector2;\n    }();\n    envDetector = new EnvDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/detectors/BrowserDetectorSync.js\nvar __assign2, BrowserDetectorSync, browserDetectorSync;\nvar init_BrowserDetectorSync = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/detectors/BrowserDetectorSync.js\"() {\n    init_esm2();\n    init_esm5();\n    init_esm();\n    __assign2 = function() {\n      __assign2 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n              t[p] = s[p];\n        }\n        return t;\n      };\n      return __assign2.apply(this, arguments);\n    };\n    BrowserDetectorSync = /** @class */\n    function() {\n      function BrowserDetectorSync2() {\n      }\n      BrowserDetectorSync2.prototype.detect = function(config) {\n        var _a2;\n        var isBrowser = typeof navigator !== \"undefined\";\n        if (!isBrowser) {\n          return Resource.empty();\n        }\n        var browserResource = (_a2 = {}, _a2[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = \"browser\", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = \"Web Browser\", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = navigator.userAgent, _a2);\n        return this._getResourceAttributes(browserResource, config);\n      };\n      BrowserDetectorSync2.prototype._getResourceAttributes = function(browserResource, _config) {\n        if (browserResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === \"\") {\n          diag2.debug(\"BrowserDetector failed: Unable to find required browser resources. \");\n          return Resource.empty();\n        } else {\n          return new Resource(__assign2({}, browserResource));\n        }\n      };\n      return BrowserDetectorSync2;\n    }();\n    browserDetectorSync = new BrowserDetectorSync();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/detectors/index.js\nvar init_detectors = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/detectors/index.js\"() {\n    init_BrowserDetector();\n    init_EnvDetector();\n    init_BrowserDetectorSync();\n    init_EnvDetectorSync();\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/utils.js\nvar isPromiseLike;\nvar init_utils6 = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/utils.js\"() {\n    isPromiseLike = function(val) {\n      return val !== null && typeof val === \"object\" && typeof val.then === \"function\";\n    };\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/detect-resources.js\nvar __awaiter7, __generator7, detectResources, detectResourcesSync, logResources;\nvar init_detect_resources = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/detect-resources.js\"() {\n    init_Resource();\n    init_esm();\n    init_utils6();\n    __awaiter7 = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator7 = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n    detectResources = function(config) {\n      if (config === void 0) {\n        config = {};\n      }\n      return __awaiter7(void 0, void 0, void 0, function() {\n        var resources;\n        return __generator7(this, function(_a2) {\n          switch (_a2.label) {\n            case 0:\n              return [4, Promise.all((config.detectors || []).map(function(d) {\n                return __awaiter7(void 0, void 0, void 0, function() {\n                  var resource, e_1;\n                  return __generator7(this, function(_a3) {\n                    switch (_a3.label) {\n                      case 0:\n                        _a3.trys.push([0, 2, , 3]);\n                        return [4, d.detect(config)];\n                      case 1:\n                        resource = _a3.sent();\n                        diag2.debug(d.constructor.name + \" found resource.\", resource);\n                        return [2, resource];\n                      case 2:\n                        e_1 = _a3.sent();\n                        diag2.debug(d.constructor.name + \" failed: \" + e_1.message);\n                        return [2, Resource.empty()];\n                      case 3:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                });\n              }))];\n            case 1:\n              resources = _a2.sent();\n              logResources(resources);\n              return [2, resources.reduce(function(acc, resource) {\n                return acc.merge(resource);\n              }, Resource.empty())];\n          }\n        });\n      });\n    };\n    detectResourcesSync = function(config) {\n      var _a2;\n      if (config === void 0) {\n        config = {};\n      }\n      var resources = ((_a2 = config.detectors) !== null && _a2 !== void 0 ? _a2 : []).map(function(d) {\n        try {\n          var resourceOrPromise_1 = d.detect(config);\n          var resource_1;\n          if (isPromiseLike(resourceOrPromise_1)) {\n            var createPromise = function() {\n              return __awaiter7(void 0, void 0, void 0, function() {\n                var resolvedResource;\n                return __generator7(this, function(_a3) {\n                  switch (_a3.label) {\n                    case 0:\n                      return [4, resourceOrPromise_1];\n                    case 1:\n                      resolvedResource = _a3.sent();\n                      return [2, resolvedResource.attributes];\n                  }\n                });\n              });\n            };\n            resource_1 = new Resource({}, createPromise());\n          } else {\n            resource_1 = resourceOrPromise_1;\n          }\n          if (resource_1.waitForAsyncAttributes) {\n            void resource_1.waitForAsyncAttributes().then(function() {\n              return diag2.debug(d.constructor.name + \" found resource.\", resource_1);\n            });\n          } else {\n            diag2.debug(d.constructor.name + \" found resource.\", resource_1);\n          }\n          return resource_1;\n        } catch (e) {\n          diag2.error(d.constructor.name + \" failed: \" + e.message);\n          return Resource.empty();\n        }\n      });\n      var mergedResources = resources.reduce(function(acc, resource) {\n        return acc.merge(resource);\n      }, Resource.empty());\n      if (mergedResources.waitForAsyncAttributes) {\n        void mergedResources.waitForAsyncAttributes().then(function() {\n          logResources(resources);\n        });\n      }\n      return mergedResources;\n    };\n    logResources = function(resources) {\n      resources.forEach(function(resource) {\n        if (Object.keys(resource.attributes).length > 0) {\n          var resourceDebugString = JSON.stringify(resource.attributes, null, 4);\n          diag2.verbose(resourceDebugString);\n        }\n      });\n    };\n  }\n});\n\n// node_modules/@opentelemetry/resources/build/esm/index.js\nvar esm_exports5 = {};\n__export(esm_exports5, {\n  Resource: () => Resource,\n  browserDetector: () => browserDetector,\n  browserDetectorSync: () => browserDetectorSync,\n  defaultServiceName: () => defaultServiceName,\n  detectResources: () => detectResources,\n  detectResourcesSync: () => detectResourcesSync,\n  envDetector: () => envDetector,\n  envDetectorSync: () => envDetectorSync,\n  hostDetector: () => hostDetector,\n  hostDetectorSync: () => hostDetectorSync,\n  osDetector: () => osDetector,\n  osDetectorSync: () => osDetectorSync,\n  processDetector: () => processDetector,\n  processDetectorSync: () => processDetectorSync\n});\nvar init_esm5 = __esm({\n  \"node_modules/@opentelemetry/resources/build/esm/index.js\"() {\n    init_Resource();\n    init_IResource();\n    init_platform4();\n    init_types4();\n    init_config2();\n    init_detectors();\n    init_detect_resources();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/MultiSpanProcessor.js\nvar __values8, MultiSpanProcessor;\nvar init_MultiSpanProcessor = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/MultiSpanProcessor.js\"() {\n    init_esm3();\n    __values8 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n    MultiSpanProcessor = /** @class */\n    function() {\n      function MultiSpanProcessor2(_spanProcessors) {\n        this._spanProcessors = _spanProcessors;\n      }\n      MultiSpanProcessor2.prototype.forceFlush = function() {\n        var e_1, _a2;\n        var promises = [];\n        try {\n          for (var _b = __values8(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var spanProcessor = _c.value;\n            promises.push(spanProcessor.forceFlush());\n          }\n        } catch (e_1_1) {\n          e_1 = { error: e_1_1 };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a2 = _b.return))\n              _a2.call(_b);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n        return new Promise(function(resolve) {\n          Promise.all(promises).then(function() {\n            resolve();\n          }).catch(function(error) {\n            globalErrorHandler(error || new Error(\"MultiSpanProcessor: forceFlush failed\"));\n            resolve();\n          });\n        });\n      };\n      MultiSpanProcessor2.prototype.onStart = function(span, context2) {\n        var e_2, _a2;\n        try {\n          for (var _b = __values8(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var spanProcessor = _c.value;\n            spanProcessor.onStart(span, context2);\n          }\n        } catch (e_2_1) {\n          e_2 = { error: e_2_1 };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a2 = _b.return))\n              _a2.call(_b);\n          } finally {\n            if (e_2)\n              throw e_2.error;\n          }\n        }\n      };\n      MultiSpanProcessor2.prototype.onEnd = function(span) {\n        var e_3, _a2;\n        try {\n          for (var _b = __values8(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var spanProcessor = _c.value;\n            spanProcessor.onEnd(span);\n          }\n        } catch (e_3_1) {\n          e_3 = { error: e_3_1 };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a2 = _b.return))\n              _a2.call(_b);\n          } finally {\n            if (e_3)\n              throw e_3.error;\n          }\n        }\n      };\n      MultiSpanProcessor2.prototype.shutdown = function() {\n        var e_4, _a2;\n        var promises = [];\n        try {\n          for (var _b = __values8(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var spanProcessor = _c.value;\n            promises.push(spanProcessor.shutdown());\n          }\n        } catch (e_4_1) {\n          e_4 = { error: e_4_1 };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a2 = _b.return))\n              _a2.call(_b);\n          } finally {\n            if (e_4)\n              throw e_4.error;\n          }\n        }\n        return new Promise(function(resolve, reject) {\n          Promise.all(promises).then(function() {\n            resolve();\n          }, reject);\n        });\n      };\n      return MultiSpanProcessor2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/export/NoopSpanProcessor.js\nvar NoopSpanProcessor;\nvar init_NoopSpanProcessor = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/export/NoopSpanProcessor.js\"() {\n    NoopSpanProcessor = /** @class */\n    function() {\n      function NoopSpanProcessor2() {\n      }\n      NoopSpanProcessor2.prototype.onStart = function(_span, _context) {\n      };\n      NoopSpanProcessor2.prototype.onEnd = function(_span) {\n      };\n      NoopSpanProcessor2.prototype.shutdown = function() {\n        return Promise.resolve();\n      };\n      NoopSpanProcessor2.prototype.forceFlush = function() {\n        return Promise.resolve();\n      };\n      return NoopSpanProcessor2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js\nvar ForceFlushState, BasicTracerProvider;\nvar init_BasicTracerProvider = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js\"() {\n    init_esm();\n    init_esm3();\n    init_esm5();\n    init_esm6();\n    init_config();\n    init_MultiSpanProcessor();\n    init_NoopSpanProcessor();\n    init_platform3();\n    init_utility();\n    (function(ForceFlushState2) {\n      ForceFlushState2[ForceFlushState2[\"resolved\"] = 0] = \"resolved\";\n      ForceFlushState2[ForceFlushState2[\"timeout\"] = 1] = \"timeout\";\n      ForceFlushState2[ForceFlushState2[\"error\"] = 2] = \"error\";\n      ForceFlushState2[ForceFlushState2[\"unresolved\"] = 3] = \"unresolved\";\n    })(ForceFlushState || (ForceFlushState = {}));\n    BasicTracerProvider = /** @class */\n    function() {\n      function BasicTracerProvider2(config) {\n        if (config === void 0) {\n          config = {};\n        }\n        var _a2;\n        this._registeredSpanProcessors = [];\n        this._tracers = /* @__PURE__ */ new Map();\n        var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));\n        this.resource = (_a2 = mergedConfig.resource) !== null && _a2 !== void 0 ? _a2 : Resource.empty();\n        this.resource = Resource.default().merge(this.resource);\n        this._config = Object.assign({}, mergedConfig, {\n          resource: this.resource\n        });\n        var defaultExporter = this._buildExporterFromEnv();\n        if (defaultExporter !== void 0) {\n          var batchProcessor = new BatchSpanProcessor(defaultExporter);\n          this.activeSpanProcessor = batchProcessor;\n        } else {\n          this.activeSpanProcessor = new NoopSpanProcessor();\n        }\n      }\n      BasicTracerProvider2.prototype.getTracer = function(name, version, options) {\n        var key = name + \"@\" + (version || \"\") + \":\" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || \"\");\n        if (!this._tracers.has(key)) {\n          this._tracers.set(key, new Tracer({ name, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));\n        }\n        return this._tracers.get(key);\n      };\n      BasicTracerProvider2.prototype.addSpanProcessor = function(spanProcessor) {\n        if (this._registeredSpanProcessors.length === 0) {\n          this.activeSpanProcessor.shutdown().catch(function(err) {\n            return diag2.error(\"Error while trying to shutdown current span processor\", err);\n          });\n        }\n        this._registeredSpanProcessors.push(spanProcessor);\n        this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);\n      };\n      BasicTracerProvider2.prototype.getActiveSpanProcessor = function() {\n        return this.activeSpanProcessor;\n      };\n      BasicTracerProvider2.prototype.register = function(config) {\n        if (config === void 0) {\n          config = {};\n        }\n        trace.setGlobalTracerProvider(this);\n        if (config.propagator === void 0) {\n          config.propagator = this._buildPropagatorFromEnv();\n        }\n        if (config.contextManager) {\n          context.setGlobalContextManager(config.contextManager);\n        }\n        if (config.propagator) {\n          propagation.setGlobalPropagator(config.propagator);\n        }\n      };\n      BasicTracerProvider2.prototype.forceFlush = function() {\n        var timeout = this._config.forceFlushTimeoutMillis;\n        var promises = this._registeredSpanProcessors.map(function(spanProcessor) {\n          return new Promise(function(resolve) {\n            var state;\n            var timeoutInterval = setTimeout(function() {\n              resolve(new Error(\"Span processor did not completed within timeout period of \" + timeout + \" ms\"));\n              state = ForceFlushState.timeout;\n            }, timeout);\n            spanProcessor.forceFlush().then(function() {\n              clearTimeout(timeoutInterval);\n              if (state !== ForceFlushState.timeout) {\n                state = ForceFlushState.resolved;\n                resolve(state);\n              }\n            }).catch(function(error) {\n              clearTimeout(timeoutInterval);\n              state = ForceFlushState.error;\n              resolve(error);\n            });\n          });\n        });\n        return new Promise(function(resolve, reject) {\n          Promise.all(promises).then(function(results) {\n            var errors = results.filter(function(result) {\n              return result !== ForceFlushState.resolved;\n            });\n            if (errors.length > 0) {\n              reject(errors);\n            } else {\n              resolve();\n            }\n          }).catch(function(error) {\n            return reject([error]);\n          });\n        });\n      };\n      BasicTracerProvider2.prototype.shutdown = function() {\n        return this.activeSpanProcessor.shutdown();\n      };\n      BasicTracerProvider2.prototype._getPropagator = function(name) {\n        var _a2;\n        return (_a2 = this.constructor._registeredPropagators.get(name)) === null || _a2 === void 0 ? void 0 : _a2();\n      };\n      BasicTracerProvider2.prototype._getSpanExporter = function(name) {\n        var _a2;\n        return (_a2 = this.constructor._registeredExporters.get(name)) === null || _a2 === void 0 ? void 0 : _a2();\n      };\n      BasicTracerProvider2.prototype._buildPropagatorFromEnv = function() {\n        var _this = this;\n        var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));\n        var propagators = uniquePropagatorNames.map(function(name) {\n          var propagator = _this._getPropagator(name);\n          if (!propagator) {\n            diag2.warn('Propagator \"' + name + '\" requested through environment variable is unavailable.');\n          }\n          return propagator;\n        });\n        var validPropagators = propagators.reduce(function(list, item) {\n          if (item) {\n            list.push(item);\n          }\n          return list;\n        }, []);\n        if (validPropagators.length === 0) {\n          return;\n        } else if (uniquePropagatorNames.length === 1) {\n          return validPropagators[0];\n        } else {\n          return new CompositePropagator({\n            propagators: validPropagators\n          });\n        }\n      };\n      BasicTracerProvider2.prototype._buildExporterFromEnv = function() {\n        var exporterName = getEnv().OTEL_TRACES_EXPORTER;\n        if (exporterName === \"none\" || exporterName === \"\")\n          return;\n        var exporter = this._getSpanExporter(exporterName);\n        if (!exporter) {\n          diag2.error('Exporter \"' + exporterName + '\" requested through environment variable is unavailable.');\n        }\n        return exporter;\n      };\n      BasicTracerProvider2._registeredPropagators = /* @__PURE__ */ new Map([\n        [\"tracecontext\", function() {\n          return new W3CTraceContextPropagator();\n        }],\n        [\"baggage\", function() {\n          return new W3CBaggagePropagator();\n        }]\n      ]);\n      BasicTracerProvider2._registeredExporters = /* @__PURE__ */ new Map();\n      return BasicTracerProvider2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/export/ConsoleSpanExporter.js\nvar __values9, ConsoleSpanExporter;\nvar init_ConsoleSpanExporter = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/export/ConsoleSpanExporter.js\"() {\n    init_esm3();\n    __values9 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n    ConsoleSpanExporter = /** @class */\n    function() {\n      function ConsoleSpanExporter3() {\n      }\n      ConsoleSpanExporter3.prototype.export = function(spans, resultCallback) {\n        return this._sendSpans(spans, resultCallback);\n      };\n      ConsoleSpanExporter3.prototype.shutdown = function() {\n        this._sendSpans([]);\n        return this.forceFlush();\n      };\n      ConsoleSpanExporter3.prototype.forceFlush = function() {\n        return Promise.resolve();\n      };\n      ConsoleSpanExporter3.prototype._exportInfo = function(span) {\n        var _a2;\n        return {\n          traceId: span.spanContext().traceId,\n          parentId: span.parentSpanId,\n          traceState: (_a2 = span.spanContext().traceState) === null || _a2 === void 0 ? void 0 : _a2.serialize(),\n          name: span.name,\n          id: span.spanContext().spanId,\n          kind: span.kind,\n          timestamp: hrTimeToMicroseconds(span.startTime),\n          duration: hrTimeToMicroseconds(span.duration),\n          attributes: span.attributes,\n          status: span.status,\n          events: span.events,\n          links: span.links\n        };\n      };\n      ConsoleSpanExporter3.prototype._sendSpans = function(spans, done) {\n        var e_1, _a2;\n        try {\n          for (var spans_1 = __values9(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {\n            var span = spans_1_1.value;\n            console.dir(this._exportInfo(span), { depth: 3 });\n          }\n        } catch (e_1_1) {\n          e_1 = { error: e_1_1 };\n        } finally {\n          try {\n            if (spans_1_1 && !spans_1_1.done && (_a2 = spans_1.return))\n              _a2.call(spans_1);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n        if (done) {\n          return done({ code: ExportResultCode.SUCCESS });\n        }\n      };\n      return ConsoleSpanExporter3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/export/InMemorySpanExporter.js\nvar __read14, __spreadArray7, InMemorySpanExporter;\nvar init_InMemorySpanExporter = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/export/InMemorySpanExporter.js\"() {\n    init_esm3();\n    __read14 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __spreadArray7 = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n          if (ar || !(i in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    InMemorySpanExporter = /** @class */\n    function() {\n      function InMemorySpanExporter2() {\n        this._finishedSpans = [];\n        this._stopped = false;\n      }\n      InMemorySpanExporter2.prototype.export = function(spans, resultCallback) {\n        var _a2;\n        if (this._stopped)\n          return resultCallback({\n            code: ExportResultCode.FAILED,\n            error: new Error(\"Exporter has been stopped\")\n          });\n        (_a2 = this._finishedSpans).push.apply(_a2, __spreadArray7([], __read14(spans), false));\n        setTimeout(function() {\n          return resultCallback({ code: ExportResultCode.SUCCESS });\n        }, 0);\n      };\n      InMemorySpanExporter2.prototype.shutdown = function() {\n        this._stopped = true;\n        this._finishedSpans = [];\n        return this.forceFlush();\n      };\n      InMemorySpanExporter2.prototype.forceFlush = function() {\n        return Promise.resolve();\n      };\n      InMemorySpanExporter2.prototype.reset = function() {\n        this._finishedSpans = [];\n      };\n      InMemorySpanExporter2.prototype.getFinishedSpans = function() {\n        return this._finishedSpans;\n      };\n      return InMemorySpanExporter2;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/export/ReadableSpan.js\nvar init_ReadableSpan = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/export/ReadableSpan.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/export/SimpleSpanProcessor.js\nvar __awaiter8, __generator8, SimpleSpanProcessor;\nvar init_SimpleSpanProcessor = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/export/SimpleSpanProcessor.js\"() {\n    init_esm();\n    init_esm3();\n    __awaiter8 = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator8 = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n    SimpleSpanProcessor = /** @class */\n    function() {\n      function SimpleSpanProcessor3(_exporter) {\n        this._exporter = _exporter;\n        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n        this._unresolvedExports = /* @__PURE__ */ new Set();\n      }\n      SimpleSpanProcessor3.prototype.forceFlush = function() {\n        return __awaiter8(this, void 0, void 0, function() {\n          return __generator8(this, function(_a2) {\n            switch (_a2.label) {\n              case 0:\n                return [4, Promise.all(Array.from(this._unresolvedExports))];\n              case 1:\n                _a2.sent();\n                if (!this._exporter.forceFlush)\n                  return [3, 3];\n                return [4, this._exporter.forceFlush()];\n              case 2:\n                _a2.sent();\n                _a2.label = 3;\n              case 3:\n                return [\n                  2\n                  /*return*/\n                ];\n            }\n          });\n        });\n      };\n      SimpleSpanProcessor3.prototype.onStart = function(_span, _parentContext) {\n      };\n      SimpleSpanProcessor3.prototype.onEnd = function(span) {\n        var _this = this;\n        var _a2, _b;\n        if (this._shutdownOnce.isCalled) {\n          return;\n        }\n        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n          return;\n        }\n        var doExport = function() {\n          return internal._export(_this._exporter, [span]).then(function(result) {\n            var _a3;\n            if (result.code !== ExportResultCode.SUCCESS) {\n              globalErrorHandler((_a3 = result.error) !== null && _a3 !== void 0 ? _a3 : new Error(\"SimpleSpanProcessor: span export failed (status \" + result + \")\"));\n            }\n          }).catch(function(error) {\n            globalErrorHandler(error);\n          });\n        };\n        if (span.resource.asyncAttributesPending) {\n          var exportPromise_1 = (_b = (_a2 = span.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a2).then(function() {\n            if (exportPromise_1 != null) {\n              _this._unresolvedExports.delete(exportPromise_1);\n            }\n            return doExport();\n          }, function(err) {\n            return globalErrorHandler(err);\n          });\n          if (exportPromise_1 != null) {\n            this._unresolvedExports.add(exportPromise_1);\n          }\n        } else {\n          void doExport();\n        }\n      };\n      SimpleSpanProcessor3.prototype.shutdown = function() {\n        return this._shutdownOnce.call();\n      };\n      SimpleSpanProcessor3.prototype._shutdown = function() {\n        return this._exporter.shutdown();\n      };\n      return SimpleSpanProcessor3;\n    }();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/export/SpanExporter.js\nvar init_SpanExporter = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/export/SpanExporter.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/SpanProcessor.js\nvar init_SpanProcessor = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/SpanProcessor.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/TimedEvent.js\nvar init_TimedEvent = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/TimedEvent.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/types.js\nvar init_types5 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/types.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/IdGenerator.js\nvar init_IdGenerator2 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/IdGenerator.js\"() {\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\nvar esm_exports6 = {};\n__export(esm_exports6, {\n  AlwaysOffSampler: () => AlwaysOffSampler2,\n  AlwaysOnSampler: () => AlwaysOnSampler2,\n  BasicTracerProvider: () => BasicTracerProvider,\n  BatchSpanProcessor: () => BatchSpanProcessor,\n  ConsoleSpanExporter: () => ConsoleSpanExporter,\n  ForceFlushState: () => ForceFlushState,\n  InMemorySpanExporter: () => InMemorySpanExporter,\n  NoopSpanProcessor: () => NoopSpanProcessor,\n  ParentBasedSampler: () => ParentBasedSampler2,\n  RandomIdGenerator: () => RandomIdGenerator2,\n  SamplingDecision: () => SamplingDecision2,\n  SimpleSpanProcessor: () => SimpleSpanProcessor,\n  Span: () => Span,\n  TraceIdRatioBasedSampler: () => TraceIdRatioBasedSampler2,\n  Tracer: () => Tracer\n});\nvar init_esm6 = __esm({\n  \"node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\"() {\n    init_Tracer();\n    init_BasicTracerProvider();\n    init_platform3();\n    init_ConsoleSpanExporter();\n    init_InMemorySpanExporter();\n    init_ReadableSpan();\n    init_SimpleSpanProcessor();\n    init_SpanExporter();\n    init_NoopSpanProcessor();\n    init_AlwaysOffSampler2();\n    init_AlwaysOnSampler2();\n    init_ParentBasedSampler2();\n    init_TraceIdRatioBasedSampler2();\n    init_Sampler();\n    init_Span();\n    init_SpanProcessor();\n    init_TimedEvent();\n    init_types5();\n    init_IdGenerator2();\n  }\n});\n\n// node_modules/semver/internal/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/semver/internal/constants.js\"(exports, module2) {\n    var SEMVER_SPEC_VERSION = \"2.0.0\";\n    var MAX_LENGTH = 256;\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */\n    9007199254740991;\n    var MAX_SAFE_COMPONENT_LENGTH = 16;\n    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;\n    var RELEASE_TYPES = [\n      \"major\",\n      \"premajor\",\n      \"minor\",\n      \"preminor\",\n      \"patch\",\n      \"prepatch\",\n      \"prerelease\"\n    ];\n    module2.exports = {\n      MAX_LENGTH,\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_SAFE_INTEGER,\n      RELEASE_TYPES,\n      SEMVER_SPEC_VERSION,\n      FLAG_INCLUDE_PRERELEASE: 1,\n      FLAG_LOOSE: 2\n    };\n  }\n});\n\n// node_modules/semver/internal/debug.js\nvar require_debug = __commonJS({\n  \"node_modules/semver/internal/debug.js\"(exports, module2) {\n    var debug = typeof process === \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error(\"SEMVER\", ...args) : () => {\n    };\n    module2.exports = debug;\n  }\n});\n\n// node_modules/semver/internal/re.js\nvar require_re = __commonJS({\n  \"node_modules/semver/internal/re.js\"(exports, module2) {\n    var {\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_LENGTH\n    } = require_constants();\n    var debug = require_debug();\n    exports = module2.exports = {};\n    var re2 = exports.re = [];\n    var safeRe = exports.safeRe = [];\n    var src = exports.src = [];\n    var t = exports.t = {};\n    var R = 0;\n    var LETTERDASHNUMBER = \"[a-zA-Z0-9-]\";\n    var safeRegexReplacements = [\n      [\"\\\\s\", 1],\n      [\"\\\\d\", MAX_LENGTH],\n      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]\n    ];\n    var makeSafeRegex = (value) => {\n      for (const [token, max] of safeRegexReplacements) {\n        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);\n      }\n      return value;\n    };\n    var createToken = (name, value, isGlobal) => {\n      const safe = makeSafeRegex(value);\n      const index = R++;\n      debug(name, index, value);\n      t[name] = index;\n      src[index] = value;\n      re2[index] = new RegExp(value, isGlobal ? \"g\" : void 0);\n      safeRe[index] = new RegExp(safe, isGlobal ? \"g\" : void 0);\n    };\n    createToken(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\");\n    createToken(\"NUMERICIDENTIFIERLOOSE\", \"\\\\d+\");\n    createToken(\"NONNUMERICIDENTIFIER\", `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);\n    createToken(\"MAINVERSION\", `(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})`);\n    createToken(\"MAINVERSIONLOOSE\", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken(\"PRERELEASEIDENTIFIER\", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);\n    createToken(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);\n    createToken(\"PRERELEASE\", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n    createToken(\"PRERELEASELOOSE\", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n    createToken(\"BUILDIDENTIFIER\", `${LETTERDASHNUMBER}+`);\n    createToken(\"BUILD\", `(?:\\\\+(${src[t.BUILDIDENTIFIER]}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n    createToken(\"FULLPLAIN\", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);\n    createToken(\"FULL\", `^${src[t.FULLPLAIN]}$`);\n    createToken(\"LOOSEPLAIN\", `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);\n    createToken(\"LOOSE\", `^${src[t.LOOSEPLAIN]}$`);\n    createToken(\"GTLT\", \"((?:<|>)?=?)\");\n    createToken(\"XRANGEIDENTIFIERLOOSE\", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n    createToken(\"XRANGEIDENTIFIER\", `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n    createToken(\"XRANGEPLAIN\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n    createToken(\"XRANGELOOSE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COERCE\", `${\"(^|[^\\\\d])(\\\\d{1,\"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\\\d])`);\n    createToken(\"COERCERTL\", src[t.COERCE], true);\n    createToken(\"LONETILDE\", \"(?:~>?)\");\n    createToken(\"TILDETRIM\", `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n    exports.tildeTrimReplace = \"$1~\";\n    createToken(\"TILDE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"TILDELOOSE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"LONECARET\", \"(?:\\\\^)\");\n    createToken(\"CARETTRIM\", `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n    exports.caretTrimReplace = \"$1^\";\n    createToken(\"CARET\", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"CARETLOOSE\", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COMPARATORLOOSE\", `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n    createToken(\"COMPARATOR\", `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n    createToken(\"COMPARATORTRIM\", `(\\\\s*)${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n    exports.comparatorTrimReplace = \"$1$2$3\";\n    createToken(\"HYPHENRANGE\", `^\\\\s*(${src[t.XRANGEPLAIN]})\\\\s+-\\\\s+(${src[t.XRANGEPLAIN]})\\\\s*$`);\n    createToken(\"HYPHENRANGELOOSE\", `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${src[t.XRANGEPLAINLOOSE]})\\\\s*$`);\n    createToken(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\");\n    createToken(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\");\n    createToken(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n  }\n});\n\n// node_modules/semver/internal/parse-options.js\nvar require_parse_options = __commonJS({\n  \"node_modules/semver/internal/parse-options.js\"(exports, module2) {\n    var looseOption = Object.freeze({ loose: true });\n    var emptyOpts = Object.freeze({});\n    var parseOptions = (options) => {\n      if (!options) {\n        return emptyOpts;\n      }\n      if (typeof options !== \"object\") {\n        return looseOption;\n      }\n      return options;\n    };\n    module2.exports = parseOptions;\n  }\n});\n\n// node_modules/semver/internal/identifiers.js\nvar require_identifiers = __commonJS({\n  \"node_modules/semver/internal/identifiers.js\"(exports, module2) {\n    var numeric = /^[0-9]+$/;\n    var compareIdentifiers = (a, b) => {\n      const anum = numeric.test(a);\n      const bnum = numeric.test(b);\n      if (anum && bnum) {\n        a = +a;\n        b = +b;\n      }\n      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n    };\n    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);\n    module2.exports = {\n      compareIdentifiers,\n      rcompareIdentifiers\n    };\n  }\n});\n\n// node_modules/semver/classes/semver.js\nvar require_semver = __commonJS({\n  \"node_modules/semver/classes/semver.js\"(exports, module2) {\n    var debug = require_debug();\n    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();\n    var { safeRe: re2, t } = require_re();\n    var parseOptions = require_parse_options();\n    var { compareIdentifiers } = require_identifiers();\n    var SemVer = class _SemVer {\n      constructor(version, options) {\n        options = parseOptions(options);\n        if (version instanceof _SemVer) {\n          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {\n            return version;\n          } else {\n            version = version.version;\n          }\n        } else if (typeof version !== \"string\") {\n          throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`);\n        }\n        if (version.length > MAX_LENGTH) {\n          throw new TypeError(\n            `version is longer than ${MAX_LENGTH} characters`\n          );\n        }\n        debug(\"SemVer\", version, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        const m = version.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);\n        if (!m) {\n          throw new TypeError(`Invalid Version: ${version}`);\n        }\n        this.raw = version;\n        this.major = +m[1];\n        this.minor = +m[2];\n        this.patch = +m[3];\n        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n          throw new TypeError(\"Invalid major version\");\n        }\n        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n          throw new TypeError(\"Invalid minor version\");\n        }\n        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n          throw new TypeError(\"Invalid patch version\");\n        }\n        if (!m[4]) {\n          this.prerelease = [];\n        } else {\n          this.prerelease = m[4].split(\".\").map((id) => {\n            if (/^[0-9]+$/.test(id)) {\n              const num = +id;\n              if (num >= 0 && num < MAX_SAFE_INTEGER) {\n                return num;\n              }\n            }\n            return id;\n          });\n        }\n        this.build = m[5] ? m[5].split(\".\") : [];\n        this.format();\n      }\n      format() {\n        this.version = `${this.major}.${this.minor}.${this.patch}`;\n        if (this.prerelease.length) {\n          this.version += `-${this.prerelease.join(\".\")}`;\n        }\n        return this.version;\n      }\n      toString() {\n        return this.version;\n      }\n      compare(other) {\n        debug(\"SemVer.compare\", this.version, this.options, other);\n        if (!(other instanceof _SemVer)) {\n          if (typeof other === \"string\" && other === this.version) {\n            return 0;\n          }\n          other = new _SemVer(other, this.options);\n        }\n        if (other.version === this.version) {\n          return 0;\n        }\n        return this.compareMain(other) || this.comparePre(other);\n      }\n      compareMain(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n      }\n      comparePre(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        if (this.prerelease.length && !other.prerelease.length) {\n          return -1;\n        } else if (!this.prerelease.length && other.prerelease.length) {\n          return 1;\n        } else if (!this.prerelease.length && !other.prerelease.length) {\n          return 0;\n        }\n        let i = 0;\n        do {\n          const a = this.prerelease[i];\n          const b = other.prerelease[i];\n          debug(\"prerelease compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      compareBuild(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        let i = 0;\n        do {\n          const a = this.build[i];\n          const b = other.build[i];\n          debug(\"prerelease compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      // preminor will bump the version up to the next minor release, and immediately\n      // down to pre-release. premajor and prepatch work the same way.\n      inc(release2, identifier, identifierBase) {\n        switch (release2) {\n          case \"premajor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor = 0;\n            this.major++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"preminor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"prepatch\":\n            this.prerelease.length = 0;\n            this.inc(\"patch\", identifier, identifierBase);\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"prerelease\":\n            if (this.prerelease.length === 0) {\n              this.inc(\"patch\", identifier, identifierBase);\n            }\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"major\":\n            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n              this.major++;\n            }\n            this.minor = 0;\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"minor\":\n            if (this.patch !== 0 || this.prerelease.length === 0) {\n              this.minor++;\n            }\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"patch\":\n            if (this.prerelease.length === 0) {\n              this.patch++;\n            }\n            this.prerelease = [];\n            break;\n          case \"pre\": {\n            const base = Number(identifierBase) ? 1 : 0;\n            if (!identifier && identifierBase === false) {\n              throw new Error(\"invalid increment argument: identifier is empty\");\n            }\n            if (this.prerelease.length === 0) {\n              this.prerelease = [base];\n            } else {\n              let i = this.prerelease.length;\n              while (--i >= 0) {\n                if (typeof this.prerelease[i] === \"number\") {\n                  this.prerelease[i]++;\n                  i = -2;\n                }\n              }\n              if (i === -1) {\n                if (identifier === this.prerelease.join(\".\") && identifierBase === false) {\n                  throw new Error(\"invalid increment argument: identifier already exists\");\n                }\n                this.prerelease.push(base);\n              }\n            }\n            if (identifier) {\n              let prerelease = [identifier, base];\n              if (identifierBase === false) {\n                prerelease = [identifier];\n              }\n              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = prerelease;\n                }\n              } else {\n                this.prerelease = prerelease;\n              }\n            }\n            break;\n          }\n          default:\n            throw new Error(`invalid increment argument: ${release2}`);\n        }\n        this.raw = this.format();\n        if (this.build.length) {\n          this.raw += `+${this.build.join(\".\")}`;\n        }\n        return this;\n      }\n    };\n    module2.exports = SemVer;\n  }\n});\n\n// node_modules/semver/functions/parse.js\nvar require_parse = __commonJS({\n  \"node_modules/semver/functions/parse.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var parse4 = (version, options, throwErrors = false) => {\n      if (version instanceof SemVer) {\n        return version;\n      }\n      try {\n        return new SemVer(version, options);\n      } catch (er) {\n        if (!throwErrors) {\n          return null;\n        }\n        throw er;\n      }\n    };\n    module2.exports = parse4;\n  }\n});\n\n// node_modules/semver/functions/valid.js\nvar require_valid = __commonJS({\n  \"node_modules/semver/functions/valid.js\"(exports, module2) {\n    var parse4 = require_parse();\n    var valid = (version, options) => {\n      const v = parse4(version, options);\n      return v ? v.version : null;\n    };\n    module2.exports = valid;\n  }\n});\n\n// node_modules/semver/functions/clean.js\nvar require_clean = __commonJS({\n  \"node_modules/semver/functions/clean.js\"(exports, module2) {\n    var parse4 = require_parse();\n    var clean = (version, options) => {\n      const s = parse4(version.trim().replace(/^[=v]+/, \"\"), options);\n      return s ? s.version : null;\n    };\n    module2.exports = clean;\n  }\n});\n\n// node_modules/semver/functions/inc.js\nvar require_inc = __commonJS({\n  \"node_modules/semver/functions/inc.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var inc = (version, release2, options, identifier, identifierBase) => {\n      if (typeof options === \"string\") {\n        identifierBase = identifier;\n        identifier = options;\n        options = void 0;\n      }\n      try {\n        return new SemVer(\n          version instanceof SemVer ? version.version : version,\n          options\n        ).inc(release2, identifier, identifierBase).version;\n      } catch (er) {\n        return null;\n      }\n    };\n    module2.exports = inc;\n  }\n});\n\n// node_modules/semver/functions/diff.js\nvar require_diff = __commonJS({\n  \"node_modules/semver/functions/diff.js\"(exports, module2) {\n    var parse4 = require_parse();\n    var diff = (version1, version2) => {\n      const v1 = parse4(version1, null, true);\n      const v2 = parse4(version2, null, true);\n      const comparison = v1.compare(v2);\n      if (comparison === 0) {\n        return null;\n      }\n      const v1Higher = comparison > 0;\n      const highVersion = v1Higher ? v1 : v2;\n      const lowVersion = v1Higher ? v2 : v1;\n      const highHasPre = !!highVersion.prerelease.length;\n      const lowHasPre = !!lowVersion.prerelease.length;\n      if (lowHasPre && !highHasPre) {\n        if (!lowVersion.patch && !lowVersion.minor) {\n          return \"major\";\n        }\n        if (highVersion.patch) {\n          return \"patch\";\n        }\n        if (highVersion.minor) {\n          return \"minor\";\n        }\n        return \"major\";\n      }\n      const prefix = highHasPre ? \"pre\" : \"\";\n      if (v1.major !== v2.major) {\n        return prefix + \"major\";\n      }\n      if (v1.minor !== v2.minor) {\n        return prefix + \"minor\";\n      }\n      if (v1.patch !== v2.patch) {\n        return prefix + \"patch\";\n      }\n      return \"prerelease\";\n    };\n    module2.exports = diff;\n  }\n});\n\n// node_modules/semver/functions/major.js\nvar require_major = __commonJS({\n  \"node_modules/semver/functions/major.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var major2 = (a, loose) => new SemVer(a, loose).major;\n    module2.exports = major2;\n  }\n});\n\n// node_modules/semver/functions/minor.js\nvar require_minor = __commonJS({\n  \"node_modules/semver/functions/minor.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var minor = (a, loose) => new SemVer(a, loose).minor;\n    module2.exports = minor;\n  }\n});\n\n// node_modules/semver/functions/patch.js\nvar require_patch = __commonJS({\n  \"node_modules/semver/functions/patch.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var patch = (a, loose) => new SemVer(a, loose).patch;\n    module2.exports = patch;\n  }\n});\n\n// node_modules/semver/functions/prerelease.js\nvar require_prerelease = __commonJS({\n  \"node_modules/semver/functions/prerelease.js\"(exports, module2) {\n    var parse4 = require_parse();\n    var prerelease = (version, options) => {\n      const parsed = parse4(version, options);\n      return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n    };\n    module2.exports = prerelease;\n  }\n});\n\n// node_modules/semver/functions/compare.js\nvar require_compare = __commonJS({\n  \"node_modules/semver/functions/compare.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));\n    module2.exports = compare;\n  }\n});\n\n// node_modules/semver/functions/rcompare.js\nvar require_rcompare = __commonJS({\n  \"node_modules/semver/functions/rcompare.js\"(exports, module2) {\n    var compare = require_compare();\n    var rcompare = (a, b, loose) => compare(b, a, loose);\n    module2.exports = rcompare;\n  }\n});\n\n// node_modules/semver/functions/compare-loose.js\nvar require_compare_loose = __commonJS({\n  \"node_modules/semver/functions/compare-loose.js\"(exports, module2) {\n    var compare = require_compare();\n    var compareLoose = (a, b) => compare(a, b, true);\n    module2.exports = compareLoose;\n  }\n});\n\n// node_modules/semver/functions/compare-build.js\nvar require_compare_build = __commonJS({\n  \"node_modules/semver/functions/compare-build.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var compareBuild = (a, b, loose) => {\n      const versionA = new SemVer(a, loose);\n      const versionB = new SemVer(b, loose);\n      return versionA.compare(versionB) || versionA.compareBuild(versionB);\n    };\n    module2.exports = compareBuild;\n  }\n});\n\n// node_modules/semver/functions/sort.js\nvar require_sort = __commonJS({\n  \"node_modules/semver/functions/sort.js\"(exports, module2) {\n    var compareBuild = require_compare_build();\n    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));\n    module2.exports = sort;\n  }\n});\n\n// node_modules/semver/functions/rsort.js\nvar require_rsort = __commonJS({\n  \"node_modules/semver/functions/rsort.js\"(exports, module2) {\n    var compareBuild = require_compare_build();\n    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));\n    module2.exports = rsort;\n  }\n});\n\n// node_modules/semver/functions/gt.js\nvar require_gt = __commonJS({\n  \"node_modules/semver/functions/gt.js\"(exports, module2) {\n    var compare = require_compare();\n    var gt = (a, b, loose) => compare(a, b, loose) > 0;\n    module2.exports = gt;\n  }\n});\n\n// node_modules/semver/functions/lt.js\nvar require_lt = __commonJS({\n  \"node_modules/semver/functions/lt.js\"(exports, module2) {\n    var compare = require_compare();\n    var lt = (a, b, loose) => compare(a, b, loose) < 0;\n    module2.exports = lt;\n  }\n});\n\n// node_modules/semver/functions/eq.js\nvar require_eq = __commonJS({\n  \"node_modules/semver/functions/eq.js\"(exports, module2) {\n    var compare = require_compare();\n    var eq = (a, b, loose) => compare(a, b, loose) === 0;\n    module2.exports = eq;\n  }\n});\n\n// node_modules/semver/functions/neq.js\nvar require_neq = __commonJS({\n  \"node_modules/semver/functions/neq.js\"(exports, module2) {\n    var compare = require_compare();\n    var neq = (a, b, loose) => compare(a, b, loose) !== 0;\n    module2.exports = neq;\n  }\n});\n\n// node_modules/semver/functions/gte.js\nvar require_gte = __commonJS({\n  \"node_modules/semver/functions/gte.js\"(exports, module2) {\n    var compare = require_compare();\n    var gte = (a, b, loose) => compare(a, b, loose) >= 0;\n    module2.exports = gte;\n  }\n});\n\n// node_modules/semver/functions/lte.js\nvar require_lte = __commonJS({\n  \"node_modules/semver/functions/lte.js\"(exports, module2) {\n    var compare = require_compare();\n    var lte = (a, b, loose) => compare(a, b, loose) <= 0;\n    module2.exports = lte;\n  }\n});\n\n// node_modules/semver/functions/cmp.js\nvar require_cmp = __commonJS({\n  \"node_modules/semver/functions/cmp.js\"(exports, module2) {\n    var eq = require_eq();\n    var neq = require_neq();\n    var gt = require_gt();\n    var gte = require_gte();\n    var lt = require_lt();\n    var lte = require_lte();\n    var cmp = (a, op, b, loose) => {\n      switch (op) {\n        case \"===\":\n          if (typeof a === \"object\") {\n            a = a.version;\n          }\n          if (typeof b === \"object\") {\n            b = b.version;\n          }\n          return a === b;\n        case \"!==\":\n          if (typeof a === \"object\") {\n            a = a.version;\n          }\n          if (typeof b === \"object\") {\n            b = b.version;\n          }\n          return a !== b;\n        case \"\":\n        case \"=\":\n        case \"==\":\n          return eq(a, b, loose);\n        case \"!=\":\n          return neq(a, b, loose);\n        case \">\":\n          return gt(a, b, loose);\n        case \">=\":\n          return gte(a, b, loose);\n        case \"<\":\n          return lt(a, b, loose);\n        case \"<=\":\n          return lte(a, b, loose);\n        default:\n          throw new TypeError(`Invalid operator: ${op}`);\n      }\n    };\n    module2.exports = cmp;\n  }\n});\n\n// node_modules/semver/functions/coerce.js\nvar require_coerce = __commonJS({\n  \"node_modules/semver/functions/coerce.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var parse4 = require_parse();\n    var { safeRe: re2, t } = require_re();\n    var coerce = (version, options) => {\n      if (version instanceof SemVer) {\n        return version;\n      }\n      if (typeof version === \"number\") {\n        version = String(version);\n      }\n      if (typeof version !== \"string\") {\n        return null;\n      }\n      options = options || {};\n      let match = null;\n      if (!options.rtl) {\n        match = version.match(re2[t.COERCE]);\n      } else {\n        let next;\n        while ((next = re2[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n          if (!match || next.index + next[0].length !== match.index + match[0].length) {\n            match = next;\n          }\n          re2[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n        }\n        re2[t.COERCERTL].lastIndex = -1;\n      }\n      if (match === null) {\n        return null;\n      }\n      return parse4(`${match[2]}.${match[3] || \"0\"}.${match[4] || \"0\"}`, options);\n    };\n    module2.exports = coerce;\n  }\n});\n\n// node_modules/yallist/iterator.js\nvar require_iterator = __commonJS({\n  \"node_modules/yallist/iterator.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = function(Yallist) {\n      Yallist.prototype[Symbol.iterator] = function* () {\n        for (let walker = this.head; walker; walker = walker.next) {\n          yield walker.value;\n        }\n      };\n    };\n  }\n});\n\n// node_modules/yallist/yallist.js\nvar require_yallist = __commonJS({\n  \"node_modules/yallist/yallist.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = Yallist;\n    Yallist.Node = Node;\n    Yallist.create = Yallist;\n    function Yallist(list) {\n      var self2 = this;\n      if (!(self2 instanceof Yallist)) {\n        self2 = new Yallist();\n      }\n      self2.tail = null;\n      self2.head = null;\n      self2.length = 0;\n      if (list && typeof list.forEach === \"function\") {\n        list.forEach(function(item) {\n          self2.push(item);\n        });\n      } else if (arguments.length > 0) {\n        for (var i = 0, l = arguments.length; i < l; i++) {\n          self2.push(arguments[i]);\n        }\n      }\n      return self2;\n    }\n    Yallist.prototype.removeNode = function(node) {\n      if (node.list !== this) {\n        throw new Error(\"removing node which does not belong to this list\");\n      }\n      var next = node.next;\n      var prev = node.prev;\n      if (next) {\n        next.prev = prev;\n      }\n      if (prev) {\n        prev.next = next;\n      }\n      if (node === this.head) {\n        this.head = next;\n      }\n      if (node === this.tail) {\n        this.tail = prev;\n      }\n      node.list.length--;\n      node.next = null;\n      node.prev = null;\n      node.list = null;\n      return next;\n    };\n    Yallist.prototype.unshiftNode = function(node) {\n      if (node === this.head) {\n        return;\n      }\n      if (node.list) {\n        node.list.removeNode(node);\n      }\n      var head = this.head;\n      node.list = this;\n      node.next = head;\n      if (head) {\n        head.prev = node;\n      }\n      this.head = node;\n      if (!this.tail) {\n        this.tail = node;\n      }\n      this.length++;\n    };\n    Yallist.prototype.pushNode = function(node) {\n      if (node === this.tail) {\n        return;\n      }\n      if (node.list) {\n        node.list.removeNode(node);\n      }\n      var tail = this.tail;\n      node.list = this;\n      node.prev = tail;\n      if (tail) {\n        tail.next = node;\n      }\n      this.tail = node;\n      if (!this.head) {\n        this.head = node;\n      }\n      this.length++;\n    };\n    Yallist.prototype.push = function() {\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        push(this, arguments[i]);\n      }\n      return this.length;\n    };\n    Yallist.prototype.unshift = function() {\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        unshift(this, arguments[i]);\n      }\n      return this.length;\n    };\n    Yallist.prototype.pop = function() {\n      if (!this.tail) {\n        return void 0;\n      }\n      var res = this.tail.value;\n      this.tail = this.tail.prev;\n      if (this.tail) {\n        this.tail.next = null;\n      } else {\n        this.head = null;\n      }\n      this.length--;\n      return res;\n    };\n    Yallist.prototype.shift = function() {\n      if (!this.head) {\n        return void 0;\n      }\n      var res = this.head.value;\n      this.head = this.head.next;\n      if (this.head) {\n        this.head.prev = null;\n      } else {\n        this.tail = null;\n      }\n      this.length--;\n      return res;\n    };\n    Yallist.prototype.forEach = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this.head, i = 0; walker !== null; i++) {\n        fn.call(thisp, walker.value, i, this);\n        walker = walker.next;\n      }\n    };\n    Yallist.prototype.forEachReverse = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n        fn.call(thisp, walker.value, i, this);\n        walker = walker.prev;\n      }\n    };\n    Yallist.prototype.get = function(n) {\n      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n        walker = walker.next;\n      }\n      if (i === n && walker !== null) {\n        return walker.value;\n      }\n    };\n    Yallist.prototype.getReverse = function(n) {\n      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n        walker = walker.prev;\n      }\n      if (i === n && walker !== null) {\n        return walker.value;\n      }\n    };\n    Yallist.prototype.map = function(fn, thisp) {\n      thisp = thisp || this;\n      var res = new Yallist();\n      for (var walker = this.head; walker !== null; ) {\n        res.push(fn.call(thisp, walker.value, this));\n        walker = walker.next;\n      }\n      return res;\n    };\n    Yallist.prototype.mapReverse = function(fn, thisp) {\n      thisp = thisp || this;\n      var res = new Yallist();\n      for (var walker = this.tail; walker !== null; ) {\n        res.push(fn.call(thisp, walker.value, this));\n        walker = walker.prev;\n      }\n      return res;\n    };\n    Yallist.prototype.reduce = function(fn, initial) {\n      var acc;\n      var walker = this.head;\n      if (arguments.length > 1) {\n        acc = initial;\n      } else if (this.head) {\n        walker = this.head.next;\n        acc = this.head.value;\n      } else {\n        throw new TypeError(\"Reduce of empty list with no initial value\");\n      }\n      for (var i = 0; walker !== null; i++) {\n        acc = fn(acc, walker.value, i);\n        walker = walker.next;\n      }\n      return acc;\n    };\n    Yallist.prototype.reduceReverse = function(fn, initial) {\n      var acc;\n      var walker = this.tail;\n      if (arguments.length > 1) {\n        acc = initial;\n      } else if (this.tail) {\n        walker = this.tail.prev;\n        acc = this.tail.value;\n      } else {\n        throw new TypeError(\"Reduce of empty list with no initial value\");\n      }\n      for (var i = this.length - 1; walker !== null; i--) {\n        acc = fn(acc, walker.value, i);\n        walker = walker.prev;\n      }\n      return acc;\n    };\n    Yallist.prototype.toArray = function() {\n      var arr = new Array(this.length);\n      for (var i = 0, walker = this.head; walker !== null; i++) {\n        arr[i] = walker.value;\n        walker = walker.next;\n      }\n      return arr;\n    };\n    Yallist.prototype.toArrayReverse = function() {\n      var arr = new Array(this.length);\n      for (var i = 0, walker = this.tail; walker !== null; i++) {\n        arr[i] = walker.value;\n        walker = walker.prev;\n      }\n      return arr;\n    };\n    Yallist.prototype.slice = function(from, to) {\n      to = to || this.length;\n      if (to < 0) {\n        to += this.length;\n      }\n      from = from || 0;\n      if (from < 0) {\n        from += this.length;\n      }\n      var ret = new Yallist();\n      if (to < from || to < 0) {\n        return ret;\n      }\n      if (from < 0) {\n        from = 0;\n      }\n      if (to > this.length) {\n        to = this.length;\n      }\n      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n        walker = walker.next;\n      }\n      for (; walker !== null && i < to; i++, walker = walker.next) {\n        ret.push(walker.value);\n      }\n      return ret;\n    };\n    Yallist.prototype.sliceReverse = function(from, to) {\n      to = to || this.length;\n      if (to < 0) {\n        to += this.length;\n      }\n      from = from || 0;\n      if (from < 0) {\n        from += this.length;\n      }\n      var ret = new Yallist();\n      if (to < from || to < 0) {\n        return ret;\n      }\n      if (from < 0) {\n        from = 0;\n      }\n      if (to > this.length) {\n        to = this.length;\n      }\n      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n        walker = walker.prev;\n      }\n      for (; walker !== null && i > from; i--, walker = walker.prev) {\n        ret.push(walker.value);\n      }\n      return ret;\n    };\n    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {\n      if (start > this.length) {\n        start = this.length - 1;\n      }\n      if (start < 0) {\n        start = this.length + start;\n      }\n      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n        walker = walker.next;\n      }\n      var ret = [];\n      for (var i = 0; walker && i < deleteCount; i++) {\n        ret.push(walker.value);\n        walker = this.removeNode(walker);\n      }\n      if (walker === null) {\n        walker = this.tail;\n      }\n      if (walker !== this.head && walker !== this.tail) {\n        walker = walker.prev;\n      }\n      for (var i = 0; i < nodes.length; i++) {\n        walker = insert(this, walker, nodes[i]);\n      }\n      return ret;\n    };\n    Yallist.prototype.reverse = function() {\n      var head = this.head;\n      var tail = this.tail;\n      for (var walker = head; walker !== null; walker = walker.prev) {\n        var p = walker.prev;\n        walker.prev = walker.next;\n        walker.next = p;\n      }\n      this.head = tail;\n      this.tail = head;\n      return this;\n    };\n    function insert(self2, node, value) {\n      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);\n      if (inserted.next === null) {\n        self2.tail = inserted;\n      }\n      if (inserted.prev === null) {\n        self2.head = inserted;\n      }\n      self2.length++;\n      return inserted;\n    }\n    function push(self2, item) {\n      self2.tail = new Node(item, self2.tail, null, self2);\n      if (!self2.head) {\n        self2.head = self2.tail;\n      }\n      self2.length++;\n    }\n    function unshift(self2, item) {\n      self2.head = new Node(item, null, self2.head, self2);\n      if (!self2.tail) {\n        self2.tail = self2.head;\n      }\n      self2.length++;\n    }\n    function Node(value, prev, next, list) {\n      if (!(this instanceof Node)) {\n        return new Node(value, prev, next, list);\n      }\n      this.list = list;\n      this.value = value;\n      if (prev) {\n        prev.next = this;\n        this.prev = prev;\n      } else {\n        this.prev = null;\n      }\n      if (next) {\n        next.prev = this;\n        this.next = next;\n      } else {\n        this.next = null;\n      }\n    }\n    try {\n      require_iterator()(Yallist);\n    } catch (er) {\n    }\n  }\n});\n\n// node_modules/lru-cache/index.js\nvar require_lru_cache = __commonJS({\n  \"node_modules/lru-cache/index.js\"(exports, module2) {\n    \"use strict\";\n    var Yallist = require_yallist();\n    var MAX = Symbol(\"max\");\n    var LENGTH = Symbol(\"length\");\n    var LENGTH_CALCULATOR = Symbol(\"lengthCalculator\");\n    var ALLOW_STALE = Symbol(\"allowStale\");\n    var MAX_AGE = Symbol(\"maxAge\");\n    var DISPOSE = Symbol(\"dispose\");\n    var NO_DISPOSE_ON_SET = Symbol(\"noDisposeOnSet\");\n    var LRU_LIST = Symbol(\"lruList\");\n    var CACHE = Symbol(\"cache\");\n    var UPDATE_AGE_ON_GET = Symbol(\"updateAgeOnGet\");\n    var naiveLength = () => 1;\n    var LRUCache = class {\n      constructor(options) {\n        if (typeof options === \"number\")\n          options = { max: options };\n        if (!options)\n          options = {};\n        if (options.max && (typeof options.max !== \"number\" || options.max < 0))\n          throw new TypeError(\"max must be a non-negative number\");\n        const max = this[MAX] = options.max || Infinity;\n        const lc = options.length || naiveLength;\n        this[LENGTH_CALCULATOR] = typeof lc !== \"function\" ? naiveLength : lc;\n        this[ALLOW_STALE] = options.stale || false;\n        if (options.maxAge && typeof options.maxAge !== \"number\")\n          throw new TypeError(\"maxAge must be a number\");\n        this[MAX_AGE] = options.maxAge || 0;\n        this[DISPOSE] = options.dispose;\n        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;\n        this.reset();\n      }\n      // resize the cache when the max changes.\n      set max(mL) {\n        if (typeof mL !== \"number\" || mL < 0)\n          throw new TypeError(\"max must be a non-negative number\");\n        this[MAX] = mL || Infinity;\n        trim(this);\n      }\n      get max() {\n        return this[MAX];\n      }\n      set allowStale(allowStale) {\n        this[ALLOW_STALE] = !!allowStale;\n      }\n      get allowStale() {\n        return this[ALLOW_STALE];\n      }\n      set maxAge(mA) {\n        if (typeof mA !== \"number\")\n          throw new TypeError(\"maxAge must be a non-negative number\");\n        this[MAX_AGE] = mA;\n        trim(this);\n      }\n      get maxAge() {\n        return this[MAX_AGE];\n      }\n      // resize the cache when the lengthCalculator changes.\n      set lengthCalculator(lC) {\n        if (typeof lC !== \"function\")\n          lC = naiveLength;\n        if (lC !== this[LENGTH_CALCULATOR]) {\n          this[LENGTH_CALCULATOR] = lC;\n          this[LENGTH] = 0;\n          this[LRU_LIST].forEach((hit) => {\n            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n            this[LENGTH] += hit.length;\n          });\n        }\n        trim(this);\n      }\n      get lengthCalculator() {\n        return this[LENGTH_CALCULATOR];\n      }\n      get length() {\n        return this[LENGTH];\n      }\n      get itemCount() {\n        return this[LRU_LIST].length;\n      }\n      rforEach(fn, thisp) {\n        thisp = thisp || this;\n        for (let walker = this[LRU_LIST].tail; walker !== null; ) {\n          const prev = walker.prev;\n          forEachStep(this, fn, walker, thisp);\n          walker = prev;\n        }\n      }\n      forEach(fn, thisp) {\n        thisp = thisp || this;\n        for (let walker = this[LRU_LIST].head; walker !== null; ) {\n          const next = walker.next;\n          forEachStep(this, fn, walker, thisp);\n          walker = next;\n        }\n      }\n      keys() {\n        return this[LRU_LIST].toArray().map((k) => k.key);\n      }\n      values() {\n        return this[LRU_LIST].toArray().map((k) => k.value);\n      }\n      reset() {\n        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));\n        }\n        this[CACHE] = /* @__PURE__ */ new Map();\n        this[LRU_LIST] = new Yallist();\n        this[LENGTH] = 0;\n      }\n      dump() {\n        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {\n          k: hit.key,\n          v: hit.value,\n          e: hit.now + (hit.maxAge || 0)\n        }).toArray().filter((h) => h);\n      }\n      dumpLru() {\n        return this[LRU_LIST];\n      }\n      set(key, value, maxAge) {\n        maxAge = maxAge || this[MAX_AGE];\n        if (maxAge && typeof maxAge !== \"number\")\n          throw new TypeError(\"maxAge must be a number\");\n        const now = maxAge ? Date.now() : 0;\n        const len = this[LENGTH_CALCULATOR](value, key);\n        if (this[CACHE].has(key)) {\n          if (len > this[MAX]) {\n            del(this, this[CACHE].get(key));\n            return false;\n          }\n          const node = this[CACHE].get(key);\n          const item = node.value;\n          if (this[DISPOSE]) {\n            if (!this[NO_DISPOSE_ON_SET])\n              this[DISPOSE](key, item.value);\n          }\n          item.now = now;\n          item.maxAge = maxAge;\n          item.value = value;\n          this[LENGTH] += len - item.length;\n          item.length = len;\n          this.get(key);\n          trim(this);\n          return true;\n        }\n        const hit = new Entry(key, value, len, now, maxAge);\n        if (hit.length > this[MAX]) {\n          if (this[DISPOSE])\n            this[DISPOSE](key, value);\n          return false;\n        }\n        this[LENGTH] += hit.length;\n        this[LRU_LIST].unshift(hit);\n        this[CACHE].set(key, this[LRU_LIST].head);\n        trim(this);\n        return true;\n      }\n      has(key) {\n        if (!this[CACHE].has(key))\n          return false;\n        const hit = this[CACHE].get(key).value;\n        return !isStale(this, hit);\n      }\n      get(key) {\n        return get(this, key, true);\n      }\n      peek(key) {\n        return get(this, key, false);\n      }\n      pop() {\n        const node = this[LRU_LIST].tail;\n        if (!node)\n          return null;\n        del(this, node);\n        return node.value;\n      }\n      del(key) {\n        del(this, this[CACHE].get(key));\n      }\n      load(arr) {\n        this.reset();\n        const now = Date.now();\n        for (let l = arr.length - 1; l >= 0; l--) {\n          const hit = arr[l];\n          const expiresAt = hit.e || 0;\n          if (expiresAt === 0)\n            this.set(hit.k, hit.v);\n          else {\n            const maxAge = expiresAt - now;\n            if (maxAge > 0) {\n              this.set(hit.k, hit.v, maxAge);\n            }\n          }\n        }\n      }\n      prune() {\n        this[CACHE].forEach((value, key) => get(this, key, false));\n      }\n    };\n    var get = (self2, key, doUse) => {\n      const node = self2[CACHE].get(key);\n      if (node) {\n        const hit = node.value;\n        if (isStale(self2, hit)) {\n          del(self2, node);\n          if (!self2[ALLOW_STALE])\n            return void 0;\n        } else {\n          if (doUse) {\n            if (self2[UPDATE_AGE_ON_GET])\n              node.value.now = Date.now();\n            self2[LRU_LIST].unshiftNode(node);\n          }\n        }\n        return hit.value;\n      }\n    };\n    var isStale = (self2, hit) => {\n      if (!hit || !hit.maxAge && !self2[MAX_AGE])\n        return false;\n      const diff = Date.now() - hit.now;\n      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];\n    };\n    var trim = (self2) => {\n      if (self2[LENGTH] > self2[MAX]) {\n        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {\n          const prev = walker.prev;\n          del(self2, walker);\n          walker = prev;\n        }\n      }\n    };\n    var del = (self2, node) => {\n      if (node) {\n        const hit = node.value;\n        if (self2[DISPOSE])\n          self2[DISPOSE](hit.key, hit.value);\n        self2[LENGTH] -= hit.length;\n        self2[CACHE].delete(hit.key);\n        self2[LRU_LIST].removeNode(node);\n      }\n    };\n    var Entry = class {\n      constructor(key, value, length, now, maxAge) {\n        this.key = key;\n        this.value = value;\n        this.length = length;\n        this.now = now;\n        this.maxAge = maxAge || 0;\n      }\n    };\n    var forEachStep = (self2, fn, node, thisp) => {\n      let hit = node.value;\n      if (isStale(self2, hit)) {\n        del(self2, node);\n        if (!self2[ALLOW_STALE])\n          hit = void 0;\n      }\n      if (hit)\n        fn.call(thisp, hit.value, hit.key, self2);\n    };\n    module2.exports = LRUCache;\n  }\n});\n\n// node_modules/semver/classes/range.js\nvar require_range = __commonJS({\n  \"node_modules/semver/classes/range.js\"(exports, module2) {\n    var Range = class _Range {\n      constructor(range, options) {\n        options = parseOptions(options);\n        if (range instanceof _Range) {\n          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n            return range;\n          } else {\n            return new _Range(range.raw, options);\n          }\n        }\n        if (range instanceof Comparator) {\n          this.raw = range.value;\n          this.set = [[range]];\n          this.format();\n          return this;\n        }\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        this.raw = range.trim().split(/\\s+/).join(\" \");\n        this.set = this.raw.split(\"||\").map((r) => this.parseRange(r.trim())).filter((c) => c.length);\n        if (!this.set.length) {\n          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);\n        }\n        if (this.set.length > 1) {\n          const first = this.set[0];\n          this.set = this.set.filter((c) => !isNullSet(c[0]));\n          if (this.set.length === 0) {\n            this.set = [first];\n          } else if (this.set.length > 1) {\n            for (const c of this.set) {\n              if (c.length === 1 && isAny(c[0])) {\n                this.set = [c];\n                break;\n              }\n            }\n          }\n        }\n        this.format();\n      }\n      format() {\n        this.range = this.set.map((comps) => comps.join(\" \").trim()).join(\"||\").trim();\n        return this.range;\n      }\n      toString() {\n        return this.range;\n      }\n      parseRange(range) {\n        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);\n        const memoKey = memoOpts + \":\" + range;\n        const cached = cache.get(memoKey);\n        if (cached) {\n          return cached;\n        }\n        const loose = this.options.loose;\n        const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];\n        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));\n        debug(\"hyphen replace\", range);\n        range = range.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);\n        debug(\"comparator trim\", range);\n        range = range.replace(re2[t.TILDETRIM], tildeTrimReplace);\n        debug(\"tilde trim\", range);\n        range = range.replace(re2[t.CARETTRIM], caretTrimReplace);\n        debug(\"caret trim\", range);\n        let rangeList = range.split(\" \").map((comp) => parseComparator(comp, this.options)).join(\" \").split(/\\s+/).map((comp) => replaceGTE0(comp, this.options));\n        if (loose) {\n          rangeList = rangeList.filter((comp) => {\n            debug(\"loose invalid filter\", comp, this.options);\n            return !!comp.match(re2[t.COMPARATORLOOSE]);\n          });\n        }\n        debug(\"range list\", rangeList);\n        const rangeMap = /* @__PURE__ */ new Map();\n        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));\n        for (const comp of comparators) {\n          if (isNullSet(comp)) {\n            return [comp];\n          }\n          rangeMap.set(comp.value, comp);\n        }\n        if (rangeMap.size > 1 && rangeMap.has(\"\")) {\n          rangeMap.delete(\"\");\n        }\n        const result = [...rangeMap.values()];\n        cache.set(memoKey, result);\n        return result;\n      }\n      intersects(range, options) {\n        if (!(range instanceof _Range)) {\n          throw new TypeError(\"a Range is required\");\n        }\n        return this.set.some((thisComparators) => {\n          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {\n            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options);\n              });\n            });\n          });\n        });\n      }\n      // if ANY of the sets match ALL of its comparators, then pass\n      test(version) {\n        if (!version) {\n          return false;\n        }\n        if (typeof version === \"string\") {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n        for (let i = 0; i < this.set.length; i++) {\n          if (testSet(this.set[i], version, this.options)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n    module2.exports = Range;\n    var LRU = require_lru_cache();\n    var cache = new LRU({ max: 1e3 });\n    var parseOptions = require_parse_options();\n    var Comparator = require_comparator();\n    var debug = require_debug();\n    var SemVer = require_semver();\n    var {\n      safeRe: re2,\n      t,\n      comparatorTrimReplace,\n      tildeTrimReplace,\n      caretTrimReplace\n    } = require_re();\n    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();\n    var isNullSet = (c) => c.value === \"<0.0.0-0\";\n    var isAny = (c) => c.value === \"\";\n    var isSatisfiable = (comparators, options) => {\n      let result = true;\n      const remainingComparators = comparators.slice();\n      let testComparator = remainingComparators.pop();\n      while (result && remainingComparators.length) {\n        result = remainingComparators.every((otherComparator) => {\n          return testComparator.intersects(otherComparator, options);\n        });\n        testComparator = remainingComparators.pop();\n      }\n      return result;\n    };\n    var parseComparator = (comp, options) => {\n      debug(\"comp\", comp, options);\n      comp = replaceCarets(comp, options);\n      debug(\"caret\", comp);\n      comp = replaceTildes(comp, options);\n      debug(\"tildes\", comp);\n      comp = replaceXRanges(comp, options);\n      debug(\"xrange\", comp);\n      comp = replaceStars(comp, options);\n      debug(\"stars\", comp);\n      return comp;\n    };\n    var isX = (id) => !id || id.toLowerCase() === \"x\" || id === \"*\";\n    var replaceTildes = (comp, options) => {\n      return comp.trim().split(/\\s+/).map((c) => replaceTilde(c, options)).join(\" \");\n    };\n    var replaceTilde = (comp, options) => {\n      const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];\n      return comp.replace(r, (_, M, m, p, pr) => {\n        debug(\"tilde\", comp, _, M, m, p, pr);\n        let ret;\n        if (isX(M)) {\n          ret = \"\";\n        } else if (isX(m)) {\n          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;\n        } else if (isX(p)) {\n          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;\n        } else if (pr) {\n          debug(\"replaceTilde pr\", pr);\n          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n        } else {\n          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;\n        }\n        debug(\"tilde return\", ret);\n        return ret;\n      });\n    };\n    var replaceCarets = (comp, options) => {\n      return comp.trim().split(/\\s+/).map((c) => replaceCaret(c, options)).join(\" \");\n    };\n    var replaceCaret = (comp, options) => {\n      debug(\"caret\", comp, options);\n      const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];\n      const z = options.includePrerelease ? \"-0\" : \"\";\n      return comp.replace(r, (_, M, m, p, pr) => {\n        debug(\"caret\", comp, _, M, m, p, pr);\n        let ret;\n        if (isX(M)) {\n          ret = \"\";\n        } else if (isX(m)) {\n          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;\n        } else if (isX(p)) {\n          if (M === \"0\") {\n            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;\n          } else {\n            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;\n          }\n        } else if (pr) {\n          debug(\"replaceCaret pr\", pr);\n          if (M === \"0\") {\n            if (m === \"0\") {\n              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;\n            } else {\n              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;\n            }\n          } else {\n            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;\n          }\n        } else {\n          debug(\"no pr\");\n          if (M === \"0\") {\n            if (m === \"0\") {\n              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;\n            } else {\n              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;\n            }\n          } else {\n            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;\n          }\n        }\n        debug(\"caret return\", ret);\n        return ret;\n      });\n    };\n    var replaceXRanges = (comp, options) => {\n      debug(\"replaceXRanges\", comp, options);\n      return comp.split(/\\s+/).map((c) => replaceXRange(c, options)).join(\" \");\n    };\n    var replaceXRange = (comp, options) => {\n      comp = comp.trim();\n      const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];\n      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n        debug(\"xRange\", comp, ret, gtlt, M, m, p, pr);\n        const xM = isX(M);\n        const xm = xM || isX(m);\n        const xp = xm || isX(p);\n        const anyX = xp;\n        if (gtlt === \"=\" && anyX) {\n          gtlt = \"\";\n        }\n        pr = options.includePrerelease ? \"-0\" : \"\";\n        if (xM) {\n          if (gtlt === \">\" || gtlt === \"<\") {\n            ret = \"<0.0.0-0\";\n          } else {\n            ret = \"*\";\n          }\n        } else if (gtlt && anyX) {\n          if (xm) {\n            m = 0;\n          }\n          p = 0;\n          if (gtlt === \">\") {\n            gtlt = \">=\";\n            if (xm) {\n              M = +M + 1;\n              m = 0;\n              p = 0;\n            } else {\n              m = +m + 1;\n              p = 0;\n            }\n          } else if (gtlt === \"<=\") {\n            gtlt = \"<\";\n            if (xm) {\n              M = +M + 1;\n            } else {\n              m = +m + 1;\n            }\n          }\n          if (gtlt === \"<\") {\n            pr = \"-0\";\n          }\n          ret = `${gtlt + M}.${m}.${p}${pr}`;\n        } else if (xm) {\n          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;\n        } else if (xp) {\n          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;\n        }\n        debug(\"xRange return\", ret);\n        return ret;\n      });\n    };\n    var replaceStars = (comp, options) => {\n      debug(\"replaceStars\", comp, options);\n      return comp.trim().replace(re2[t.STAR], \"\");\n    };\n    var replaceGTE0 = (comp, options) => {\n      debug(\"replaceGTE0\", comp, options);\n      return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], \"\");\n    };\n    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {\n      if (isX(fM)) {\n        from = \"\";\n      } else if (isX(fm)) {\n        from = `>=${fM}.0.0${incPr ? \"-0\" : \"\"}`;\n      } else if (isX(fp)) {\n        from = `>=${fM}.${fm}.0${incPr ? \"-0\" : \"\"}`;\n      } else if (fpr) {\n        from = `>=${from}`;\n      } else {\n        from = `>=${from}${incPr ? \"-0\" : \"\"}`;\n      }\n      if (isX(tM)) {\n        to = \"\";\n      } else if (isX(tm)) {\n        to = `<${+tM + 1}.0.0-0`;\n      } else if (isX(tp)) {\n        to = `<${tM}.${+tm + 1}.0-0`;\n      } else if (tpr) {\n        to = `<=${tM}.${tm}.${tp}-${tpr}`;\n      } else if (incPr) {\n        to = `<${tM}.${tm}.${+tp + 1}-0`;\n      } else {\n        to = `<=${to}`;\n      }\n      return `${from} ${to}`.trim();\n    };\n    var testSet = (set, version, options) => {\n      for (let i = 0; i < set.length; i++) {\n        if (!set[i].test(version)) {\n          return false;\n        }\n      }\n      if (version.prerelease.length && !options.includePrerelease) {\n        for (let i = 0; i < set.length; i++) {\n          debug(set[i].semver);\n          if (set[i].semver === Comparator.ANY) {\n            continue;\n          }\n          if (set[i].semver.prerelease.length > 0) {\n            const allowed = set[i].semver;\n            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/semver/classes/comparator.js\nvar require_comparator = __commonJS({\n  \"node_modules/semver/classes/comparator.js\"(exports, module2) {\n    var ANY = Symbol(\"SemVer ANY\");\n    var Comparator = class _Comparator {\n      static get ANY() {\n        return ANY;\n      }\n      constructor(comp, options) {\n        options = parseOptions(options);\n        if (comp instanceof _Comparator) {\n          if (comp.loose === !!options.loose) {\n            return comp;\n          } else {\n            comp = comp.value;\n          }\n        }\n        comp = comp.trim().split(/\\s+/).join(\" \");\n        debug(\"comparator\", comp, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.parse(comp);\n        if (this.semver === ANY) {\n          this.value = \"\";\n        } else {\n          this.value = this.operator + this.semver.version;\n        }\n        debug(\"comp\", this);\n      }\n      parse(comp) {\n        const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];\n        const m = comp.match(r);\n        if (!m) {\n          throw new TypeError(`Invalid comparator: ${comp}`);\n        }\n        this.operator = m[1] !== void 0 ? m[1] : \"\";\n        if (this.operator === \"=\") {\n          this.operator = \"\";\n        }\n        if (!m[2]) {\n          this.semver = ANY;\n        } else {\n          this.semver = new SemVer(m[2], this.options.loose);\n        }\n      }\n      toString() {\n        return this.value;\n      }\n      test(version) {\n        debug(\"Comparator.test\", version, this.options.loose);\n        if (this.semver === ANY || version === ANY) {\n          return true;\n        }\n        if (typeof version === \"string\") {\n          try {\n            version = new SemVer(version, this.options);\n          } catch (er) {\n            return false;\n          }\n        }\n        return cmp(version, this.operator, this.semver, this.options);\n      }\n      intersects(comp, options) {\n        if (!(comp instanceof _Comparator)) {\n          throw new TypeError(\"a Comparator is required\");\n        }\n        if (this.operator === \"\") {\n          if (this.value === \"\") {\n            return true;\n          }\n          return new Range(comp.value, options).test(this.value);\n        } else if (comp.operator === \"\") {\n          if (comp.value === \"\") {\n            return true;\n          }\n          return new Range(this.value, options).test(comp.semver);\n        }\n        options = parseOptions(options);\n        if (options.includePrerelease && (this.value === \"<0.0.0-0\" || comp.value === \"<0.0.0-0\")) {\n          return false;\n        }\n        if (!options.includePrerelease && (this.value.startsWith(\"<0.0.0\") || comp.value.startsWith(\"<0.0.0\"))) {\n          return false;\n        }\n        if (this.operator.startsWith(\">\") && comp.operator.startsWith(\">\")) {\n          return true;\n        }\n        if (this.operator.startsWith(\"<\") && comp.operator.startsWith(\"<\")) {\n          return true;\n        }\n        if (this.semver.version === comp.semver.version && this.operator.includes(\"=\") && comp.operator.includes(\"=\")) {\n          return true;\n        }\n        if (cmp(this.semver, \"<\", comp.semver, options) && this.operator.startsWith(\">\") && comp.operator.startsWith(\"<\")) {\n          return true;\n        }\n        if (cmp(this.semver, \">\", comp.semver, options) && this.operator.startsWith(\"<\") && comp.operator.startsWith(\">\")) {\n          return true;\n        }\n        return false;\n      }\n    };\n    module2.exports = Comparator;\n    var parseOptions = require_parse_options();\n    var { safeRe: re2, t } = require_re();\n    var cmp = require_cmp();\n    var debug = require_debug();\n    var SemVer = require_semver();\n    var Range = require_range();\n  }\n});\n\n// node_modules/semver/functions/satisfies.js\nvar require_satisfies = __commonJS({\n  \"node_modules/semver/functions/satisfies.js\"(exports, module2) {\n    var Range = require_range();\n    var satisfies2 = (version, range, options) => {\n      try {\n        range = new Range(range, options);\n      } catch (er) {\n        return false;\n      }\n      return range.test(version);\n    };\n    module2.exports = satisfies2;\n  }\n});\n\n// node_modules/semver/ranges/to-comparators.js\nvar require_to_comparators = __commonJS({\n  \"node_modules/semver/ranges/to-comparators.js\"(exports, module2) {\n    var Range = require_range();\n    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(\" \").trim().split(\" \"));\n    module2.exports = toComparators;\n  }\n});\n\n// node_modules/semver/ranges/max-satisfying.js\nvar require_max_satisfying = __commonJS({\n  \"node_modules/semver/ranges/max-satisfying.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var Range = require_range();\n    var maxSatisfying = (versions, range, options) => {\n      let max = null;\n      let maxSV = null;\n      let rangeObj = null;\n      try {\n        rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n      versions.forEach((v) => {\n        if (rangeObj.test(v)) {\n          if (!max || maxSV.compare(v) === -1) {\n            max = v;\n            maxSV = new SemVer(max, options);\n          }\n        }\n      });\n      return max;\n    };\n    module2.exports = maxSatisfying;\n  }\n});\n\n// node_modules/semver/ranges/min-satisfying.js\nvar require_min_satisfying = __commonJS({\n  \"node_modules/semver/ranges/min-satisfying.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var Range = require_range();\n    var minSatisfying = (versions, range, options) => {\n      let min = null;\n      let minSV = null;\n      let rangeObj = null;\n      try {\n        rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n      versions.forEach((v) => {\n        if (rangeObj.test(v)) {\n          if (!min || minSV.compare(v) === 1) {\n            min = v;\n            minSV = new SemVer(min, options);\n          }\n        }\n      });\n      return min;\n    };\n    module2.exports = minSatisfying;\n  }\n});\n\n// node_modules/semver/ranges/min-version.js\nvar require_min_version = __commonJS({\n  \"node_modules/semver/ranges/min-version.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var Range = require_range();\n    var gt = require_gt();\n    var minVersion = (range, loose) => {\n      range = new Range(range, loose);\n      let minver = new SemVer(\"0.0.0\");\n      if (range.test(minver)) {\n        return minver;\n      }\n      minver = new SemVer(\"0.0.0-0\");\n      if (range.test(minver)) {\n        return minver;\n      }\n      minver = null;\n      for (let i = 0; i < range.set.length; ++i) {\n        const comparators = range.set[i];\n        let setMin = null;\n        comparators.forEach((comparator) => {\n          const compver = new SemVer(comparator.semver.version);\n          switch (comparator.operator) {\n            case \">\":\n              if (compver.prerelease.length === 0) {\n                compver.patch++;\n              } else {\n                compver.prerelease.push(0);\n              }\n              compver.raw = compver.format();\n            case \"\":\n            case \">=\":\n              if (!setMin || gt(compver, setMin)) {\n                setMin = compver;\n              }\n              break;\n            case \"<\":\n            case \"<=\":\n              break;\n            default:\n              throw new Error(`Unexpected operation: ${comparator.operator}`);\n          }\n        });\n        if (setMin && (!minver || gt(minver, setMin))) {\n          minver = setMin;\n        }\n      }\n      if (minver && range.test(minver)) {\n        return minver;\n      }\n      return null;\n    };\n    module2.exports = minVersion;\n  }\n});\n\n// node_modules/semver/ranges/valid.js\nvar require_valid2 = __commonJS({\n  \"node_modules/semver/ranges/valid.js\"(exports, module2) {\n    var Range = require_range();\n    var validRange = (range, options) => {\n      try {\n        return new Range(range, options).range || \"*\";\n      } catch (er) {\n        return null;\n      }\n    };\n    module2.exports = validRange;\n  }\n});\n\n// node_modules/semver/ranges/outside.js\nvar require_outside = __commonJS({\n  \"node_modules/semver/ranges/outside.js\"(exports, module2) {\n    var SemVer = require_semver();\n    var Comparator = require_comparator();\n    var { ANY } = Comparator;\n    var Range = require_range();\n    var satisfies2 = require_satisfies();\n    var gt = require_gt();\n    var lt = require_lt();\n    var lte = require_lte();\n    var gte = require_gte();\n    var outside = (version, range, hilo, options) => {\n      version = new SemVer(version, options);\n      range = new Range(range, options);\n      let gtfn, ltefn, ltfn, comp, ecomp;\n      switch (hilo) {\n        case \">\":\n          gtfn = gt;\n          ltefn = lte;\n          ltfn = lt;\n          comp = \">\";\n          ecomp = \">=\";\n          break;\n        case \"<\":\n          gtfn = lt;\n          ltefn = gte;\n          ltfn = gt;\n          comp = \"<\";\n          ecomp = \"<=\";\n          break;\n        default:\n          throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n      }\n      if (satisfies2(version, range, options)) {\n        return false;\n      }\n      for (let i = 0; i < range.set.length; ++i) {\n        const comparators = range.set[i];\n        let high = null;\n        let low = null;\n        comparators.forEach((comparator) => {\n          if (comparator.semver === ANY) {\n            comparator = new Comparator(\">=0.0.0\");\n          }\n          high = high || comparator;\n          low = low || comparator;\n          if (gtfn(comparator.semver, high.semver, options)) {\n            high = comparator;\n          } else if (ltfn(comparator.semver, low.semver, options)) {\n            low = comparator;\n          }\n        });\n        if (high.operator === comp || high.operator === ecomp) {\n          return false;\n        }\n        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n          return false;\n        } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    module2.exports = outside;\n  }\n});\n\n// node_modules/semver/ranges/gtr.js\nvar require_gtr = __commonJS({\n  \"node_modules/semver/ranges/gtr.js\"(exports, module2) {\n    var outside = require_outside();\n    var gtr = (version, range, options) => outside(version, range, \">\", options);\n    module2.exports = gtr;\n  }\n});\n\n// node_modules/semver/ranges/ltr.js\nvar require_ltr = __commonJS({\n  \"node_modules/semver/ranges/ltr.js\"(exports, module2) {\n    var outside = require_outside();\n    var ltr = (version, range, options) => outside(version, range, \"<\", options);\n    module2.exports = ltr;\n  }\n});\n\n// node_modules/semver/ranges/intersects.js\nvar require_intersects = __commonJS({\n  \"node_modules/semver/ranges/intersects.js\"(exports, module2) {\n    var Range = require_range();\n    var intersects = (r1, r2, options) => {\n      r1 = new Range(r1, options);\n      r2 = new Range(r2, options);\n      return r1.intersects(r2, options);\n    };\n    module2.exports = intersects;\n  }\n});\n\n// node_modules/semver/ranges/simplify.js\nvar require_simplify = __commonJS({\n  \"node_modules/semver/ranges/simplify.js\"(exports, module2) {\n    var satisfies2 = require_satisfies();\n    var compare = require_compare();\n    module2.exports = (versions, range, options) => {\n      const set = [];\n      let first = null;\n      let prev = null;\n      const v = versions.sort((a, b) => compare(a, b, options));\n      for (const version of v) {\n        const included = satisfies2(version, range, options);\n        if (included) {\n          prev = version;\n          if (!first) {\n            first = version;\n          }\n        } else {\n          if (prev) {\n            set.push([first, prev]);\n          }\n          prev = null;\n          first = null;\n        }\n      }\n      if (first) {\n        set.push([first, null]);\n      }\n      const ranges = [];\n      for (const [min, max] of set) {\n        if (min === max) {\n          ranges.push(min);\n        } else if (!max && min === v[0]) {\n          ranges.push(\"*\");\n        } else if (!max) {\n          ranges.push(`>=${min}`);\n        } else if (min === v[0]) {\n          ranges.push(`<=${max}`);\n        } else {\n          ranges.push(`${min} - ${max}`);\n        }\n      }\n      const simplified = ranges.join(\" || \");\n      const original = typeof range.raw === \"string\" ? range.raw : String(range);\n      return simplified.length < original.length ? simplified : range;\n    };\n  }\n});\n\n// node_modules/semver/ranges/subset.js\nvar require_subset = __commonJS({\n  \"node_modules/semver/ranges/subset.js\"(exports, module2) {\n    var Range = require_range();\n    var Comparator = require_comparator();\n    var { ANY } = Comparator;\n    var satisfies2 = require_satisfies();\n    var compare = require_compare();\n    var subset = (sub, dom, options = {}) => {\n      if (sub === dom) {\n        return true;\n      }\n      sub = new Range(sub, options);\n      dom = new Range(dom, options);\n      let sawNonNull = false;\n      OUTER:\n        for (const simpleSub of sub.set) {\n          for (const simpleDom of dom.set) {\n            const isSub = simpleSubset(simpleSub, simpleDom, options);\n            sawNonNull = sawNonNull || isSub !== null;\n            if (isSub) {\n              continue OUTER;\n            }\n          }\n          if (sawNonNull) {\n            return false;\n          }\n        }\n      return true;\n    };\n    var minimumVersionWithPreRelease = [new Comparator(\">=0.0.0-0\")];\n    var minimumVersion = [new Comparator(\">=0.0.0\")];\n    var simpleSubset = (sub, dom, options) => {\n      if (sub === dom) {\n        return true;\n      }\n      if (sub.length === 1 && sub[0].semver === ANY) {\n        if (dom.length === 1 && dom[0].semver === ANY) {\n          return true;\n        } else if (options.includePrerelease) {\n          sub = minimumVersionWithPreRelease;\n        } else {\n          sub = minimumVersion;\n        }\n      }\n      if (dom.length === 1 && dom[0].semver === ANY) {\n        if (options.includePrerelease) {\n          return true;\n        } else {\n          dom = minimumVersion;\n        }\n      }\n      const eqSet = /* @__PURE__ */ new Set();\n      let gt, lt;\n      for (const c of sub) {\n        if (c.operator === \">\" || c.operator === \">=\") {\n          gt = higherGT(gt, c, options);\n        } else if (c.operator === \"<\" || c.operator === \"<=\") {\n          lt = lowerLT(lt, c, options);\n        } else {\n          eqSet.add(c.semver);\n        }\n      }\n      if (eqSet.size > 1) {\n        return null;\n      }\n      let gtltComp;\n      if (gt && lt) {\n        gtltComp = compare(gt.semver, lt.semver, options);\n        if (gtltComp > 0) {\n          return null;\n        } else if (gtltComp === 0 && (gt.operator !== \">=\" || lt.operator !== \"<=\")) {\n          return null;\n        }\n      }\n      for (const eq of eqSet) {\n        if (gt && !satisfies2(eq, String(gt), options)) {\n          return null;\n        }\n        if (lt && !satisfies2(eq, String(lt), options)) {\n          return null;\n        }\n        for (const c of dom) {\n          if (!satisfies2(eq, String(c), options)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      let higher, lower;\n      let hasDomLT, hasDomGT;\n      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;\n      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;\n      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === \"<\" && needDomLTPre.prerelease[0] === 0) {\n        needDomLTPre = false;\n      }\n      for (const c of dom) {\n        hasDomGT = hasDomGT || c.operator === \">\" || c.operator === \">=\";\n        hasDomLT = hasDomLT || c.operator === \"<\" || c.operator === \"<=\";\n        if (gt) {\n          if (needDomGTPre) {\n            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {\n              needDomGTPre = false;\n            }\n          }\n          if (c.operator === \">\" || c.operator === \">=\") {\n            higher = higherGT(gt, c, options);\n            if (higher === c && higher !== gt) {\n              return false;\n            }\n          } else if (gt.operator === \">=\" && !satisfies2(gt.semver, String(c), options)) {\n            return false;\n          }\n        }\n        if (lt) {\n          if (needDomLTPre) {\n            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {\n              needDomLTPre = false;\n            }\n          }\n          if (c.operator === \"<\" || c.operator === \"<=\") {\n            lower = lowerLT(lt, c, options);\n            if (lower === c && lower !== lt) {\n              return false;\n            }\n          } else if (lt.operator === \"<=\" && !satisfies2(lt.semver, String(c), options)) {\n            return false;\n          }\n        }\n        if (!c.operator && (lt || gt) && gtltComp !== 0) {\n          return false;\n        }\n      }\n      if (gt && hasDomLT && !lt && gtltComp !== 0) {\n        return false;\n      }\n      if (lt && hasDomGT && !gt && gtltComp !== 0) {\n        return false;\n      }\n      if (needDomGTPre || needDomLTPre) {\n        return false;\n      }\n      return true;\n    };\n    var higherGT = (a, b, options) => {\n      if (!a) {\n        return b;\n      }\n      const comp = compare(a.semver, b.semver, options);\n      return comp > 0 ? a : comp < 0 ? b : b.operator === \">\" && a.operator === \">=\" ? b : a;\n    };\n    var lowerLT = (a, b, options) => {\n      if (!a) {\n        return b;\n      }\n      const comp = compare(a.semver, b.semver, options);\n      return comp < 0 ? a : comp > 0 ? b : b.operator === \"<\" && a.operator === \"<=\" ? b : a;\n    };\n    module2.exports = subset;\n  }\n});\n\n// node_modules/semver/index.js\nvar require_semver2 = __commonJS({\n  \"node_modules/semver/index.js\"(exports, module2) {\n    var internalRe = require_re();\n    var constants = require_constants();\n    var SemVer = require_semver();\n    var identifiers = require_identifiers();\n    var parse4 = require_parse();\n    var valid = require_valid();\n    var clean = require_clean();\n    var inc = require_inc();\n    var diff = require_diff();\n    var major2 = require_major();\n    var minor = require_minor();\n    var patch = require_patch();\n    var prerelease = require_prerelease();\n    var compare = require_compare();\n    var rcompare = require_rcompare();\n    var compareLoose = require_compare_loose();\n    var compareBuild = require_compare_build();\n    var sort = require_sort();\n    var rsort = require_rsort();\n    var gt = require_gt();\n    var lt = require_lt();\n    var eq = require_eq();\n    var neq = require_neq();\n    var gte = require_gte();\n    var lte = require_lte();\n    var cmp = require_cmp();\n    var coerce = require_coerce();\n    var Comparator = require_comparator();\n    var Range = require_range();\n    var satisfies2 = require_satisfies();\n    var toComparators = require_to_comparators();\n    var maxSatisfying = require_max_satisfying();\n    var minSatisfying = require_min_satisfying();\n    var minVersion = require_min_version();\n    var validRange = require_valid2();\n    var outside = require_outside();\n    var gtr = require_gtr();\n    var ltr = require_ltr();\n    var intersects = require_intersects();\n    var simplifyRange = require_simplify();\n    var subset = require_subset();\n    module2.exports = {\n      parse: parse4,\n      valid,\n      clean,\n      inc,\n      diff,\n      major: major2,\n      minor,\n      patch,\n      prerelease,\n      compare,\n      rcompare,\n      compareLoose,\n      compareBuild,\n      sort,\n      rsort,\n      gt,\n      lt,\n      eq,\n      neq,\n      gte,\n      lte,\n      cmp,\n      coerce,\n      Comparator,\n      Range,\n      satisfies: satisfies2,\n      toComparators,\n      maxSatisfying,\n      minSatisfying,\n      minVersion,\n      validRange,\n      outside,\n      gtr,\n      ltr,\n      intersects,\n      simplifyRange,\n      subset,\n      SemVer,\n      re: internalRe.re,\n      src: internalRe.src,\n      tokens: internalRe.t,\n      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n      RELEASE_TYPES: constants.RELEASE_TYPES,\n      compareIdentifiers: identifiers.compareIdentifiers,\n      rcompareIdentifiers: identifiers.rcompareIdentifiers\n    };\n  }\n});\n\n// node_modules/@opentelemetry/propagator-jaeger/build/esm/JaegerPropagator.js\nfunction deserializeSpanContext(serializedString) {\n  var headers = decodeURIComponent(serializedString).split(\":\");\n  if (headers.length !== 4) {\n    return null;\n  }\n  var _a2 = __read15(headers, 4), _traceId = _a2[0], _spanId = _a2[1], flags = _a2[3];\n  var traceId = _traceId.padStart(32, \"0\");\n  var spanId = _spanId.padStart(16, \"0\");\n  var traceFlags = VALID_HEX_RE.test(flags) ? parseInt(flags, 16) & 1 : 1;\n  return { traceId, spanId, isRemote: true, traceFlags };\n}\nvar __values10, __read15, UBER_TRACE_ID_HEADER, UBER_BAGGAGE_HEADER_PREFIX, JaegerPropagator, VALID_HEX_RE;\nvar init_JaegerPropagator = __esm({\n  \"node_modules/@opentelemetry/propagator-jaeger/build/esm/JaegerPropagator.js\"() {\n    init_esm();\n    init_esm3();\n    __values10 = function(o) {\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === \"number\")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = void 0;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n    };\n    __read15 = function(o, n) {\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i[\"return\"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    UBER_TRACE_ID_HEADER = \"uber-trace-id\";\n    UBER_BAGGAGE_HEADER_PREFIX = \"uberctx\";\n    JaegerPropagator = /** @class */\n    function() {\n      function JaegerPropagator2(config) {\n        if (typeof config === \"string\") {\n          this._jaegerTraceHeader = config;\n          this._jaegerBaggageHeaderPrefix = UBER_BAGGAGE_HEADER_PREFIX;\n        } else {\n          this._jaegerTraceHeader = (config === null || config === void 0 ? void 0 : config.customTraceHeader) || UBER_TRACE_ID_HEADER;\n          this._jaegerBaggageHeaderPrefix = (config === null || config === void 0 ? void 0 : config.customBaggageHeaderPrefix) || UBER_BAGGAGE_HEADER_PREFIX;\n        }\n      }\n      JaegerPropagator2.prototype.inject = function(context2, carrier, setter) {\n        var e_1, _a2;\n        var spanContext = trace.getSpanContext(context2);\n        var baggage = propagation.getBaggage(context2);\n        if (spanContext && isTracingSuppressed(context2) === false) {\n          var traceFlags = \"0\" + (spanContext.traceFlags || TraceFlags.NONE).toString(16);\n          setter.set(carrier, this._jaegerTraceHeader, spanContext.traceId + \":\" + spanContext.spanId + \":0:\" + traceFlags);\n        }\n        if (baggage) {\n          try {\n            for (var _b = __values10(baggage.getAllEntries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var _d = __read15(_c.value, 2), key = _d[0], entry = _d[1];\n              setter.set(carrier, this._jaegerBaggageHeaderPrefix + \"-\" + key, encodeURIComponent(entry.value));\n            }\n          } catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a2 = _b.return))\n                _a2.call(_b);\n            } finally {\n              if (e_1)\n                throw e_1.error;\n            }\n          }\n        }\n      };\n      JaegerPropagator2.prototype.extract = function(context2, carrier, getter) {\n        var e_2, _a2;\n        var _this = this;\n        var _b;\n        var uberTraceIdHeader = getter.get(carrier, this._jaegerTraceHeader);\n        var uberTraceId = Array.isArray(uberTraceIdHeader) ? uberTraceIdHeader[0] : uberTraceIdHeader;\n        var baggageValues = getter.keys(carrier).filter(function(key) {\n          return key.startsWith(_this._jaegerBaggageHeaderPrefix + \"-\");\n        }).map(function(key) {\n          var value = getter.get(carrier, key);\n          return {\n            key: key.substring(_this._jaegerBaggageHeaderPrefix.length + 1),\n            value: Array.isArray(value) ? value[0] : value\n          };\n        });\n        var newContext = context2;\n        if (typeof uberTraceId === \"string\") {\n          var spanContext = deserializeSpanContext(uberTraceId);\n          if (spanContext) {\n            newContext = trace.setSpanContext(newContext, spanContext);\n          }\n        }\n        if (baggageValues.length === 0)\n          return newContext;\n        var currentBaggage = (_b = propagation.getBaggage(context2)) !== null && _b !== void 0 ? _b : propagation.createBaggage();\n        try {\n          for (var baggageValues_1 = __values10(baggageValues), baggageValues_1_1 = baggageValues_1.next(); !baggageValues_1_1.done; baggageValues_1_1 = baggageValues_1.next()) {\n            var baggageEntry = baggageValues_1_1.value;\n            if (baggageEntry.value === void 0)\n              continue;\n            currentBaggage = currentBaggage.setEntry(baggageEntry.key, {\n              value: decodeURIComponent(baggageEntry.value)\n            });\n          }\n        } catch (e_2_1) {\n          e_2 = { error: e_2_1 };\n        } finally {\n          try {\n            if (baggageValues_1_1 && !baggageValues_1_1.done && (_a2 = baggageValues_1.return))\n              _a2.call(baggageValues_1);\n          } finally {\n            if (e_2)\n              throw e_2.error;\n          }\n        }\n        newContext = propagation.setBaggage(newContext, currentBaggage);\n        return newContext;\n      };\n      JaegerPropagator2.prototype.fields = function() {\n        return [this._jaegerTraceHeader];\n      };\n      return JaegerPropagator2;\n    }();\n    VALID_HEX_RE = /^[0-9a-f]{1,2}$/i;\n  }\n});\n\n// node_modules/@opentelemetry/propagator-jaeger/build/esm/index.js\nvar esm_exports7 = {};\n__export(esm_exports7, {\n  JaegerPropagator: () => JaegerPropagator,\n  UBER_BAGGAGE_HEADER_PREFIX: () => UBER_BAGGAGE_HEADER_PREFIX,\n  UBER_TRACE_ID_HEADER: () => UBER_TRACE_ID_HEADER\n});\nvar init_esm7 = __esm({\n  \"node_modules/@opentelemetry/propagator-jaeger/build/esm/index.js\"() {\n    init_JaegerPropagator();\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-node/build/src/NodeTracerProvider.js\nvar require_NodeTracerProvider = __commonJS({\n  \"node_modules/@opentelemetry/sdk-trace-node/build/src/NodeTracerProvider.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.NodeTracerProvider = void 0;\n    var context_async_hooks_1 = require_src();\n    var propagator_b3_1 = (init_esm4(), __toCommonJS(esm_exports4));\n    var sdk_trace_base_1 = (init_esm6(), __toCommonJS(esm_exports6));\n    var semver = require_semver2();\n    var propagator_jaeger_1 = (init_esm7(), __toCommonJS(esm_exports7));\n    var NodeTracerProvider2 = class extends sdk_trace_base_1.BasicTracerProvider {\n      constructor(config = {}) {\n        super(config);\n      }\n      register(config = {}) {\n        if (config.contextManager === void 0) {\n          const ContextManager = semver.gte(process.version, \"14.8.0\") ? context_async_hooks_1.AsyncLocalStorageContextManager : context_async_hooks_1.AsyncHooksContextManager;\n          config.contextManager = new ContextManager();\n          config.contextManager.enable();\n        }\n        super.register(config);\n      }\n    };\n    exports.NodeTracerProvider = NodeTracerProvider2;\n    NodeTracerProvider2._registeredPropagators = new Map([\n      ...sdk_trace_base_1.BasicTracerProvider._registeredPropagators,\n      [\n        \"b3\",\n        () => new propagator_b3_1.B3Propagator({ injectEncoding: propagator_b3_1.B3InjectEncoding.SINGLE_HEADER })\n      ],\n      [\n        \"b3multi\",\n        () => new propagator_b3_1.B3Propagator({ injectEncoding: propagator_b3_1.B3InjectEncoding.MULTI_HEADER })\n      ],\n      [\"jaeger\", () => new propagator_jaeger_1.JaegerPropagator()]\n    ]);\n  }\n});\n\n// node_modules/@opentelemetry/sdk-trace-node/build/src/index.js\nvar require_src2 = __commonJS({\n  \"node_modules/@opentelemetry/sdk-trace-node/build/src/index.js\"(exports) {\n    \"use strict\";\n    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      Object.defineProperty(o, k2, { enumerable: true, get: function() {\n        return m[k];\n      } });\n    } : function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      o[k2] = m[k];\n    });\n    var __exportStar = exports && exports.__exportStar || function(m, exports2) {\n      for (var p in m)\n        if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports2, p))\n          __createBinding(exports2, m, p);\n    };\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    __exportStar(require_NodeTracerProvider(), exports);\n    __exportStar((init_esm6(), __toCommonJS(esm_exports6)), exports);\n  }\n});\n\n// node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsEc2Detector.js\nvar require_AwsEc2Detector = __commonJS({\n  \"node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsEc2Detector.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.awsEc2Detector = void 0;\n    var resources_1 = (init_esm5(), __toCommonJS(esm_exports5));\n    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));\n    var http2 = __webpack_require__(/*! http */ \"http\");\n    var AwsEc2Detector = class {\n      constructor() {\n        this.AWS_IDMS_ENDPOINT = \"169.254.169.254\";\n        this.AWS_INSTANCE_TOKEN_DOCUMENT_PATH = \"/latest/api/token\";\n        this.AWS_INSTANCE_IDENTITY_DOCUMENT_PATH = \"/latest/dynamic/instance-identity/document\";\n        this.AWS_INSTANCE_HOST_DOCUMENT_PATH = \"/latest/meta-data/hostname\";\n        this.AWS_METADATA_TTL_HEADER = \"X-aws-ec2-metadata-token-ttl-seconds\";\n        this.AWS_METADATA_TOKEN_HEADER = \"X-aws-ec2-metadata-token\";\n        this.MILLISECOND_TIME_OUT = 5e3;\n      }\n      /**\n       * Attempts to connect and obtain an AWS instance Identity document. If the\n       * connection is successful it returns a promise containing a {@link Resource}\n       * populated with instance metadata. Returns a promise containing an\n       * empty {@link Resource} if the connection or parsing of the identity\n       * document fails.\n       *\n       * @param config (unused) The resource detection config\n       */\n      async detect(_config) {\n        const token = await this._fetchToken();\n        const { accountId, instanceId, instanceType, region, availabilityZone } = await this._fetchIdentity(token);\n        const hostname2 = await this._fetchHost(token);\n        return new resources_1.Resource({\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_PROVIDER]: semantic_conventions_1.CLOUDPROVIDERVALUES_AWS,\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_EC2,\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_ACCOUNT_ID]: accountId,\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_REGION]: region,\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE]: availabilityZone,\n          [semantic_conventions_1.SEMRESATTRS_HOST_ID]: instanceId,\n          [semantic_conventions_1.SEMRESATTRS_HOST_TYPE]: instanceType,\n          [semantic_conventions_1.SEMRESATTRS_HOST_NAME]: hostname2\n        });\n      }\n      async _fetchToken() {\n        const options = {\n          host: this.AWS_IDMS_ENDPOINT,\n          path: this.AWS_INSTANCE_TOKEN_DOCUMENT_PATH,\n          method: \"PUT\",\n          timeout: this.MILLISECOND_TIME_OUT,\n          headers: {\n            [this.AWS_METADATA_TTL_HEADER]: \"60\"\n          }\n        };\n        return await this._fetchString(options);\n      }\n      async _fetchIdentity(token) {\n        const options = {\n          host: this.AWS_IDMS_ENDPOINT,\n          path: this.AWS_INSTANCE_IDENTITY_DOCUMENT_PATH,\n          method: \"GET\",\n          timeout: this.MILLISECOND_TIME_OUT,\n          headers: {\n            [this.AWS_METADATA_TOKEN_HEADER]: token\n          }\n        };\n        const identity2 = await this._fetchString(options);\n        return JSON.parse(identity2);\n      }\n      async _fetchHost(token) {\n        const options = {\n          host: this.AWS_IDMS_ENDPOINT,\n          path: this.AWS_INSTANCE_HOST_DOCUMENT_PATH,\n          method: \"GET\",\n          timeout: this.MILLISECOND_TIME_OUT,\n          headers: {\n            [this.AWS_METADATA_TOKEN_HEADER]: token\n          }\n        };\n        return await this._fetchString(options);\n      }\n      /**\n       * Establishes an HTTP connection to AWS instance document url.\n       * If the application is running on an EC2 instance, we should be able\n       * to get back a valid JSON document. Parses that document and stores\n       * the identity properties in a local map.\n       */\n      async _fetchString(options) {\n        return new Promise((resolve, reject) => {\n          const timeoutId = setTimeout(() => {\n            req.abort();\n            reject(new Error(\"EC2 metadata api request timed out.\"));\n          }, 1e3);\n          const req = http2.request(options, (res) => {\n            clearTimeout(timeoutId);\n            const { statusCode } = res;\n            res.setEncoding(\"utf8\");\n            let rawData = \"\";\n            res.on(\"data\", (chunk) => rawData += chunk);\n            res.on(\"end\", () => {\n              if (statusCode && statusCode >= 200 && statusCode < 300) {\n                try {\n                  resolve(rawData);\n                } catch (e) {\n                  reject(e);\n                }\n              } else {\n                reject(new Error(\"Failed to load page, status code: \" + statusCode));\n              }\n            });\n          });\n          req.on(\"error\", (err) => {\n            clearTimeout(timeoutId);\n            reject(err);\n          });\n          req.end();\n        });\n      }\n    };\n    exports.awsEc2Detector = new AwsEc2Detector();\n  }\n});\n\n// node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsBeanstalkDetector.js\nvar require_AwsBeanstalkDetector = __commonJS({\n  \"node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsBeanstalkDetector.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.awsBeanstalkDetector = exports.AwsBeanstalkDetector = void 0;\n    var api_1 = (init_esm(), __toCommonJS(esm_exports));\n    var resources_1 = (init_esm5(), __toCommonJS(esm_exports5));\n    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));\n    var fs3 = __webpack_require__(/*! fs */ \"fs\");\n    var util2 = __webpack_require__(/*! util */ \"util\");\n    var DEFAULT_BEANSTALK_CONF_PATH = \"/var/elasticbeanstalk/xray/environment.conf\";\n    var WIN_OS_BEANSTALK_CONF_PATH = \"C:\\\\Program Files\\\\Amazon\\\\XRay\\\\environment.conf\";\n    var AwsBeanstalkDetector = class _AwsBeanstalkDetector {\n      constructor() {\n        if (process.platform === \"win32\") {\n          this.BEANSTALK_CONF_PATH = WIN_OS_BEANSTALK_CONF_PATH;\n        } else {\n          this.BEANSTALK_CONF_PATH = DEFAULT_BEANSTALK_CONF_PATH;\n        }\n      }\n      async detect(_config) {\n        try {\n          await _AwsBeanstalkDetector.fileAccessAsync(this.BEANSTALK_CONF_PATH, fs3.constants.R_OK);\n          const rawData = await _AwsBeanstalkDetector.readFileAsync(this.BEANSTALK_CONF_PATH, \"utf8\");\n          const parsedData = JSON.parse(rawData);\n          return new resources_1.Resource({\n            [semantic_conventions_1.SEMRESATTRS_CLOUD_PROVIDER]: semantic_conventions_1.CLOUDPROVIDERVALUES_AWS,\n            [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,\n            [semantic_conventions_1.SEMRESATTRS_SERVICE_NAME]: semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,\n            [semantic_conventions_1.SEMRESATTRS_SERVICE_NAMESPACE]: parsedData.environment_name,\n            [semantic_conventions_1.SEMRESATTRS_SERVICE_VERSION]: parsedData.version_label,\n            [semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID]: parsedData.deployment_id\n          });\n        } catch (e) {\n          api_1.diag.debug(`AwsBeanstalkDetector failed: ${e.message}`);\n          return resources_1.Resource.empty();\n        }\n      }\n    };\n    exports.AwsBeanstalkDetector = AwsBeanstalkDetector;\n    AwsBeanstalkDetector.readFileAsync = util2.promisify(fs3.readFile);\n    AwsBeanstalkDetector.fileAccessAsync = util2.promisify(fs3.access);\n    exports.awsBeanstalkDetector = new AwsBeanstalkDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsEcsDetector.js\nvar require_AwsEcsDetector = __commonJS({\n  \"node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsEcsDetector.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.awsEcsDetector = exports.AwsEcsDetector = void 0;\n    var api_1 = (init_esm(), __toCommonJS(esm_exports));\n    var resources_1 = (init_esm5(), __toCommonJS(esm_exports5));\n    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));\n    var http2 = __webpack_require__(/*! http */ \"http\");\n    var util2 = __webpack_require__(/*! util */ \"util\");\n    var fs3 = __webpack_require__(/*! fs */ \"fs\");\n    var os2 = __webpack_require__(/*! os */ \"os\");\n    var core_1 = (init_esm3(), __toCommonJS(esm_exports3));\n    var HTTP_TIMEOUT_IN_MS = 1e3;\n    var AwsEcsDetector = class _AwsEcsDetector {\n      async detect() {\n        const env3 = (0, core_1.getEnv)();\n        if (!env3.ECS_CONTAINER_METADATA_URI_V4 && !env3.ECS_CONTAINER_METADATA_URI) {\n          api_1.diag.debug(\"AwsEcsDetector failed: Process is not on ECS\");\n          return resources_1.Resource.empty();\n        }\n        let resource = new resources_1.Resource({\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_PROVIDER]: semantic_conventions_1.CLOUDPROVIDERVALUES_AWS,\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_ECS\n        }).merge(await _AwsEcsDetector._getContainerIdAndHostnameResource());\n        const metadataUrl = (0, core_1.getEnv)().ECS_CONTAINER_METADATA_URI_V4;\n        if (metadataUrl) {\n          const [containerMetadata, taskMetadata] = await Promise.all([\n            _AwsEcsDetector._getUrlAsJson(metadataUrl),\n            _AwsEcsDetector._getUrlAsJson(`${metadataUrl}/task`)\n          ]);\n          const metadatav4Resource = await _AwsEcsDetector._getMetadataV4Resource(containerMetadata, taskMetadata);\n          const logsResource = await _AwsEcsDetector._getLogResource(containerMetadata);\n          resource = resource.merge(metadatav4Resource).merge(logsResource);\n        }\n        return resource;\n      }\n      /**\n       * Read container ID from cgroup file\n       * In ECS, even if we fail to find target file\n       * or target file does not contain container ID\n       * we do not throw an error but throw warning message\n       * and then return null string\n       */\n      static async _getContainerIdAndHostnameResource() {\n        const hostName = os2.hostname();\n        let containerId = \"\";\n        try {\n          const rawData = await _AwsEcsDetector.readFileAsync(_AwsEcsDetector.DEFAULT_CGROUP_PATH, \"utf8\");\n          const splitData = rawData.trim().split(\"\\n\");\n          for (const str of splitData) {\n            if (str.length > _AwsEcsDetector.CONTAINER_ID_LENGTH) {\n              containerId = str.substring(str.length - _AwsEcsDetector.CONTAINER_ID_LENGTH);\n              break;\n            }\n          }\n        } catch (e) {\n          api_1.diag.warn(\"AwsEcsDetector failed to read container ID\", e);\n        }\n        if (hostName || containerId) {\n          return new resources_1.Resource({\n            [semantic_conventions_1.SEMRESATTRS_CONTAINER_NAME]: hostName || \"\",\n            [semantic_conventions_1.SEMRESATTRS_CONTAINER_ID]: containerId || \"\"\n          });\n        }\n        return resources_1.Resource.empty();\n      }\n      static async _getMetadataV4Resource(containerMetadata, taskMetadata) {\n        const launchType = taskMetadata[\"LaunchType\"];\n        const taskArn = taskMetadata[\"TaskARN\"];\n        const baseArn = taskArn.substring(0, taskArn.lastIndexOf(\":\"));\n        const cluster = taskMetadata[\"Cluster\"];\n        const accountId = _AwsEcsDetector._getAccountFromArn(taskArn);\n        const region = _AwsEcsDetector._getRegionFromArn(taskArn);\n        const availabilityZone = taskMetadata === null || taskMetadata === void 0 ? void 0 : taskMetadata[\"AvailabilityZone\"];\n        const clusterArn = cluster.startsWith(\"arn:\") ? cluster : `${baseArn}:cluster/${cluster}`;\n        const containerArn = containerMetadata[\"ContainerARN\"];\n        const attributes = {\n          [semantic_conventions_1.SEMRESATTRS_AWS_ECS_CONTAINER_ARN]: containerArn,\n          [semantic_conventions_1.SEMRESATTRS_AWS_ECS_CLUSTER_ARN]: clusterArn,\n          [semantic_conventions_1.SEMRESATTRS_AWS_ECS_LAUNCHTYPE]: launchType === null || launchType === void 0 ? void 0 : launchType.toLowerCase(),\n          [semantic_conventions_1.SEMRESATTRS_AWS_ECS_TASK_ARN]: taskArn,\n          [semantic_conventions_1.SEMRESATTRS_AWS_ECS_TASK_FAMILY]: taskMetadata[\"Family\"],\n          [semantic_conventions_1.SEMRESATTRS_AWS_ECS_TASK_REVISION]: taskMetadata[\"Revision\"],\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_ACCOUNT_ID]: accountId,\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_REGION]: region\n        };\n        if (availabilityZone) {\n          attributes[semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE] = availabilityZone;\n        }\n        return new resources_1.Resource(attributes);\n      }\n      static async _getLogResource(containerMetadata) {\n        if (containerMetadata[\"LogDriver\"] !== \"awslogs\" || !containerMetadata[\"LogOptions\"]) {\n          return resources_1.Resource.EMPTY;\n        }\n        const containerArn = containerMetadata[\"ContainerARN\"];\n        const logOptions = containerMetadata[\"LogOptions\"];\n        const logsRegion = logOptions[\"awslogs-region\"] || _AwsEcsDetector._getRegionFromArn(containerArn);\n        const awsAccount = _AwsEcsDetector._getAccountFromArn(containerArn);\n        const logsGroupName = logOptions[\"awslogs-group\"];\n        const logsGroupArn = `arn:aws:logs:${logsRegion}:${awsAccount}:log-group:${logsGroupName}`;\n        const logsStreamName = logOptions[\"awslogs-stream\"];\n        const logsStreamArn = `arn:aws:logs:${logsRegion}:${awsAccount}:log-group:${logsGroupName}:log-stream:${logsStreamName}`;\n        return new resources_1.Resource({\n          [semantic_conventions_1.SEMRESATTRS_AWS_LOG_GROUP_NAMES]: [logsGroupName],\n          [semantic_conventions_1.SEMRESATTRS_AWS_LOG_GROUP_ARNS]: [logsGroupArn],\n          [semantic_conventions_1.SEMRESATTRS_AWS_LOG_STREAM_NAMES]: [logsStreamName],\n          [semantic_conventions_1.SEMRESATTRS_AWS_LOG_STREAM_ARNS]: [logsStreamArn]\n        });\n      }\n      static _getAccountFromArn(containerArn) {\n        const match = /arn:aws:ecs:[^:]+:([^:]+):.*/.exec(containerArn);\n        return match[1];\n      }\n      static _getRegionFromArn(containerArn) {\n        const match = /arn:aws:ecs:([^:]+):.*/.exec(containerArn);\n        return match[1];\n      }\n      static _getUrlAsJson(url4) {\n        return new Promise((resolve, reject) => {\n          const request3 = http2.get(url4, (response) => {\n            if (response.statusCode && response.statusCode >= 400) {\n              reject(new Error(`Request to '${url4}' failed with status ${response.statusCode}`));\n            }\n            let responseBody = \"\";\n            response.on(\"data\", (chunk) => responseBody += chunk.toString());\n            response.on(\"end\", () => resolve(responseBody));\n            request3.on(\"error\", reject);\n          });\n          request3.setTimeout(HTTP_TIMEOUT_IN_MS, () => {\n            request3.destroy();\n          });\n          request3.on(\"error\", reject);\n          request3.end();\n        }).then((responseBodyRaw) => JSON.parse(responseBodyRaw));\n      }\n    };\n    exports.AwsEcsDetector = AwsEcsDetector;\n    AwsEcsDetector.CONTAINER_ID_LENGTH = 64;\n    AwsEcsDetector.DEFAULT_CGROUP_PATH = \"/proc/self/cgroup\";\n    AwsEcsDetector.readFileAsync = util2.promisify(fs3.readFile);\n    exports.awsEcsDetector = new AwsEcsDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsEksDetector.js\nvar require_AwsEksDetector = __commonJS({\n  \"node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsEksDetector.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.awsEksDetector = exports.AwsEksDetector = void 0;\n    var resources_1 = (init_esm5(), __toCommonJS(esm_exports5));\n    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));\n    var https2 = __webpack_require__(/*! https */ \"https\");\n    var fs3 = __webpack_require__(/*! fs */ \"fs\");\n    var util2 = __webpack_require__(/*! util */ \"util\");\n    var api_1 = (init_esm(), __toCommonJS(esm_exports));\n    var AwsEksDetector = class _AwsEksDetector {\n      constructor() {\n        this.K8S_SVC_URL = \"kubernetes.default.svc\";\n        this.K8S_TOKEN_PATH = \"/var/run/secrets/kubernetes.io/serviceaccount/token\";\n        this.K8S_CERT_PATH = \"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\";\n        this.AUTH_CONFIGMAP_PATH = \"/api/v1/namespaces/kube-system/configmaps/aws-auth\";\n        this.CW_CONFIGMAP_PATH = \"/api/v1/namespaces/amazon-cloudwatch/configmaps/cluster-info\";\n        this.CONTAINER_ID_LENGTH = 64;\n        this.DEFAULT_CGROUP_PATH = \"/proc/self/cgroup\";\n        this.TIMEOUT_MS = 2e3;\n        this.UTF8_UNICODE = \"utf8\";\n      }\n      /**\n       * The AwsEksDetector can be used to detect if a process is running on Amazon\n       * Elastic Kubernetes and returns a promise containing a {@link Resource}\n       * populated with instance metadata. Returns a promise containing an\n       * empty {@link Resource} if the connection to kubernetes process\n       * or aws config maps fails\n       * @param config The resource detection config\n       */\n      async detect(_config) {\n        try {\n          await _AwsEksDetector.fileAccessAsync(this.K8S_TOKEN_PATH);\n          const k8scert = await _AwsEksDetector.readFileAsync(this.K8S_CERT_PATH);\n          if (!await this._isEks(k8scert)) {\n            return resources_1.Resource.empty();\n          }\n          const containerId = await this._getContainerId();\n          const clusterName = await this._getClusterName(k8scert);\n          return !containerId && !clusterName ? resources_1.Resource.empty() : new resources_1.Resource({\n            [semantic_conventions_1.SEMRESATTRS_CLOUD_PROVIDER]: semantic_conventions_1.CLOUDPROVIDERVALUES_AWS,\n            [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_EKS,\n            [semantic_conventions_1.SEMRESATTRS_K8S_CLUSTER_NAME]: clusterName || \"\",\n            [semantic_conventions_1.SEMRESATTRS_CONTAINER_ID]: containerId || \"\"\n          });\n        } catch (e) {\n          api_1.diag.warn(\"Process is not running on K8S\", e);\n          return resources_1.Resource.empty();\n        }\n      }\n      /**\n       * Attempts to make a connection to AWS Config map which will\n       * determine whether the process is running on an EKS\n       * process if the config map is empty or not\n       */\n      async _isEks(cert) {\n        const options = {\n          ca: cert,\n          headers: {\n            Authorization: await this._getK8sCredHeader()\n          },\n          hostname: this.K8S_SVC_URL,\n          method: \"GET\",\n          path: this.AUTH_CONFIGMAP_PATH,\n          timeout: this.TIMEOUT_MS\n        };\n        return !!await this._fetchString(options);\n      }\n      /**\n       * Attempts to make a connection to Amazon Cloudwatch\n       * Config Maps to grab cluster name\n       */\n      async _getClusterName(cert) {\n        const options = {\n          ca: cert,\n          headers: {\n            Authorization: await this._getK8sCredHeader()\n          },\n          host: this.K8S_SVC_URL,\n          method: \"GET\",\n          path: this.CW_CONFIGMAP_PATH,\n          timeout: this.TIMEOUT_MS\n        };\n        const response = await this._fetchString(options);\n        try {\n          return JSON.parse(response).data[\"cluster.name\"];\n        } catch (e) {\n          api_1.diag.warn(\"Cannot get cluster name on EKS\", e);\n        }\n        return \"\";\n      }\n      /**\n       * Reads the Kubernetes token path and returns kubernetes\n       * credential header\n       */\n      async _getK8sCredHeader() {\n        try {\n          const content = await _AwsEksDetector.readFileAsync(this.K8S_TOKEN_PATH, this.UTF8_UNICODE);\n          return \"Bearer \" + content;\n        } catch (e) {\n          api_1.diag.warn(\"Unable to read Kubernetes client token.\", e);\n        }\n        return \"\";\n      }\n      /**\n       * Read container ID from cgroup file generated from docker which lists the full\n       * untruncated docker container ID at the end of each line.\n       *\n       * The predefined structure of calling /proc/self/cgroup when in a docker container has the structure:\n       *\n       * #:xxxxxx:/\n       *\n       * or\n       *\n       * #:xxxxxx:/docker/64characterID\n       *\n       * This function takes advantage of that fact by just reading the 64-character ID from the end of the\n       * first line. In EKS, even if we fail to find target file or target file does\n       * not contain container ID we do not throw an error but throw warning message\n       * and then return null string\n       */\n      async _getContainerId() {\n        try {\n          const rawData = await _AwsEksDetector.readFileAsync(this.DEFAULT_CGROUP_PATH, this.UTF8_UNICODE);\n          const splitData = rawData.trim().split(\"\\n\");\n          for (const str of splitData) {\n            if (str.length > this.CONTAINER_ID_LENGTH) {\n              return str.substring(str.length - this.CONTAINER_ID_LENGTH);\n            }\n          }\n        } catch (e) {\n          api_1.diag.warn(`AwsEksDetector failed to read container ID: ${e.message}`);\n        }\n        return void 0;\n      }\n      /**\n       * Establishes an HTTP connection to AWS instance document url.\n       * If the application is running on an EKS instance, we should be able\n       * to get back a valid JSON document. Parses that document and stores\n       * the identity properties in a local map.\n       */\n      async _fetchString(options) {\n        return await new Promise((resolve, reject) => {\n          const timeoutId = setTimeout(() => {\n            req.abort();\n            reject(new Error(\"EKS metadata api request timed out.\"));\n          }, 2e3);\n          const req = https2.request(options, (res) => {\n            clearTimeout(timeoutId);\n            const { statusCode } = res;\n            res.setEncoding(this.UTF8_UNICODE);\n            let rawData = \"\";\n            res.on(\"data\", (chunk) => rawData += chunk);\n            res.on(\"end\", () => {\n              if (statusCode && statusCode >= 200 && statusCode < 300) {\n                try {\n                  resolve(rawData);\n                } catch (e) {\n                  reject(e);\n                }\n              } else {\n                reject(new Error(\"Failed to load page, status code: \" + statusCode));\n              }\n            });\n          });\n          req.on(\"error\", (err) => {\n            clearTimeout(timeoutId);\n            reject(err);\n          });\n          req.end();\n        });\n      }\n    };\n    exports.AwsEksDetector = AwsEksDetector;\n    AwsEksDetector.readFileAsync = util2.promisify(fs3.readFile);\n    AwsEksDetector.fileAccessAsync = util2.promisify(fs3.access);\n    exports.awsEksDetector = new AwsEksDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsLambdaDetector.js\nvar require_AwsLambdaDetector = __commonJS({\n  \"node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/AwsLambdaDetector.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.awsLambdaDetector = exports.AwsLambdaDetector = void 0;\n    var resources_1 = (init_esm5(), __toCommonJS(esm_exports5));\n    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));\n    var AwsLambdaDetector = class {\n      async detect(_config) {\n        const functionName = process.env.AWS_LAMBDA_FUNCTION_NAME;\n        if (!functionName) {\n          return resources_1.Resource.empty();\n        }\n        const functionVersion = process.env.AWS_LAMBDA_FUNCTION_VERSION;\n        const region = process.env.AWS_REGION;\n        const attributes = {\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_PROVIDER]: String(semantic_conventions_1.CLOUDPROVIDERVALUES_AWS),\n          [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: String(semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_LAMBDA)\n        };\n        if (region) {\n          attributes[semantic_conventions_1.SEMRESATTRS_CLOUD_REGION] = region;\n        }\n        if (functionName) {\n          attributes[semantic_conventions_1.SEMRESATTRS_FAAS_NAME] = functionName;\n        }\n        if (functionVersion) {\n          attributes[semantic_conventions_1.SEMRESATTRS_FAAS_VERSION] = functionVersion;\n        }\n        return new resources_1.Resource(attributes);\n      }\n    };\n    exports.AwsLambdaDetector = AwsLambdaDetector;\n    exports.awsLambdaDetector = new AwsLambdaDetector();\n  }\n});\n\n// node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/index.js\nvar require_detectors = __commonJS({\n  \"node_modules/@opentelemetry/resource-detector-aws/build/src/detectors/index.js\"(exports) {\n    \"use strict\";\n    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      Object.defineProperty(o, k2, { enumerable: true, get: function() {\n        return m[k];\n      } });\n    } : function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      o[k2] = m[k];\n    });\n    var __exportStar = exports && exports.__exportStar || function(m, exports2) {\n      for (var p in m)\n        if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports2, p))\n          __createBinding(exports2, m, p);\n    };\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    __exportStar(require_AwsEc2Detector(), exports);\n    __exportStar(require_AwsBeanstalkDetector(), exports);\n    __exportStar(require_AwsEcsDetector(), exports);\n    __exportStar(require_AwsEksDetector(), exports);\n    __exportStar(require_AwsLambdaDetector(), exports);\n  }\n});\n\n// node_modules/@opentelemetry/resource-detector-aws/build/src/index.js\nvar require_src3 = __commonJS({\n  \"node_modules/@opentelemetry/resource-detector-aws/build/src/index.js\"(exports) {\n    \"use strict\";\n    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      Object.defineProperty(o, k2, { enumerable: true, get: function() {\n        return m[k];\n      } });\n    } : function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      o[k2] = m[k];\n    });\n    var __exportStar = exports && exports.__exportStar || function(m, exports2) {\n      for (var p in m)\n        if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports2, p))\n          __createBinding(exports2, m, p);\n    };\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    __exportStar(require_detectors(), exports);\n  }\n});\n\n// node_modules/shimmer/index.js\nvar require_shimmer = __commonJS({\n  \"node_modules/shimmer/index.js\"(exports, module2) {\n    \"use strict\";\n    function isFunction2(funktion) {\n      return typeof funktion === \"function\";\n    }\n    var logger = console.error.bind(console);\n    function defineProperty(obj, name, value) {\n      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);\n      Object.defineProperty(obj, name, {\n        configurable: true,\n        enumerable,\n        writable: true,\n        value\n      });\n    }\n    function shimmer2(options) {\n      if (options && options.logger) {\n        if (!isFunction2(options.logger))\n          logger(\"new logger isn't a function, not replacing\");\n        else\n          logger = options.logger;\n      }\n    }\n    function wrap3(nodule, name, wrapper) {\n      if (!nodule || !nodule[name]) {\n        logger(\"no original function \" + name + \" to wrap\");\n        return;\n      }\n      if (!wrapper) {\n        logger(\"no wrapper function\");\n        logger(new Error().stack);\n        return;\n      }\n      if (!isFunction2(nodule[name]) || !isFunction2(wrapper)) {\n        logger(\"original object and wrapper must be functions\");\n        return;\n      }\n      var original = nodule[name];\n      var wrapped = wrapper(original, name);\n      defineProperty(wrapped, \"__original\", original);\n      defineProperty(wrapped, \"__unwrap\", function() {\n        if (nodule[name] === wrapped)\n          defineProperty(nodule, name, original);\n      });\n      defineProperty(wrapped, \"__wrapped\", true);\n      defineProperty(nodule, name, wrapped);\n      return wrapped;\n    }\n    function massWrap2(nodules, names, wrapper) {\n      if (!nodules) {\n        logger(\"must provide one or more modules to patch\");\n        logger(new Error().stack);\n        return;\n      } else if (!Array.isArray(nodules)) {\n        nodules = [nodules];\n      }\n      if (!(names && Array.isArray(names))) {\n        logger(\"must provide one or more functions to wrap on modules\");\n        return;\n      }\n      nodules.forEach(function(nodule) {\n        names.forEach(function(name) {\n          wrap3(nodule, name, wrapper);\n        });\n      });\n    }\n    function unwrap3(nodule, name) {\n      if (!nodule || !nodule[name]) {\n        logger(\"no function to unwrap.\");\n        logger(new Error().stack);\n        return;\n      }\n      if (!nodule[name].__unwrap) {\n        logger(\"no original to unwrap to -- has \" + name + \" already been unwrapped?\");\n      } else {\n        return nodule[name].__unwrap();\n      }\n    }\n    function massUnwrap2(nodules, names) {\n      if (!nodules) {\n        logger(\"must provide one or more modules to patch\");\n        logger(new Error().stack);\n        return;\n      } else if (!Array.isArray(nodules)) {\n        nodules = [nodules];\n      }\n      if (!(names && Array.isArray(names))) {\n        logger(\"must provide one or more functions to unwrap on modules\");\n        return;\n      }\n      nodules.forEach(function(nodule) {\n        names.forEach(function(name) {\n          unwrap3(nodule, name);\n        });\n      });\n    }\n    shimmer2.wrap = wrap3;\n    shimmer2.massWrap = massWrap2;\n    shimmer2.unwrap = unwrap3;\n    shimmer2.massUnwrap = massUnwrap2;\n    module2.exports = shimmer2;\n  }\n});\n\n// node_modules/resolve/lib/homedir.js\nvar require_homedir = __commonJS({\n  \"node_modules/resolve/lib/homedir.js\"(exports, module2) {\n    \"use strict\";\n    var os2 = __webpack_require__(/*! os */ \"os\");\n    module2.exports = os2.homedir || function homedir() {\n      var home = process.env.HOME;\n      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;\n      if (process.platform === \"win32\") {\n        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;\n      }\n      if (process.platform === \"darwin\") {\n        return home || (user ? \"/Users/\" + user : null);\n      }\n      if (process.platform === \"linux\") {\n        return home || (process.getuid() === 0 ? \"/root\" : user ? \"/home/\" + user : null);\n      }\n      return home || null;\n    };\n  }\n});\n\n// node_modules/resolve/lib/caller.js\nvar require_caller = __commonJS({\n  \"node_modules/resolve/lib/caller.js\"(exports, module2) {\n    module2.exports = function() {\n      var origPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = function(_, stack2) {\n        return stack2;\n      };\n      var stack = new Error().stack;\n      Error.prepareStackTrace = origPrepareStackTrace;\n      return stack[2].getFileName();\n    };\n  }\n});\n\n// node_modules/path-parse/index.js\nvar require_path_parse = __commonJS({\n  \"node_modules/path-parse/index.js\"(exports, module2) {\n    \"use strict\";\n    var isWindows = process.platform === \"win32\";\n    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?[\\\\\\/]?)(?:[^\\\\\\/]*[\\\\\\/])*)((\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))[\\\\\\/]*$/;\n    var win32 = {};\n    function win32SplitPath(filename) {\n      return splitWindowsRe.exec(filename).slice(1);\n    }\n    win32.parse = function(pathString) {\n      if (typeof pathString !== \"string\") {\n        throw new TypeError(\n          \"Parameter 'pathString' must be a string, not \" + typeof pathString\n        );\n      }\n      var allParts = win32SplitPath(pathString);\n      if (!allParts || allParts.length !== 5) {\n        throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n      }\n      return {\n        root: allParts[1],\n        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),\n        base: allParts[2],\n        ext: allParts[4],\n        name: allParts[3]\n      };\n    };\n    var splitPathRe = /^((\\/?)(?:[^\\/]*\\/)*)((\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))[\\/]*$/;\n    var posix = {};\n    function posixSplitPath(filename) {\n      return splitPathRe.exec(filename).slice(1);\n    }\n    posix.parse = function(pathString) {\n      if (typeof pathString !== \"string\") {\n        throw new TypeError(\n          \"Parameter 'pathString' must be a string, not \" + typeof pathString\n        );\n      }\n      var allParts = posixSplitPath(pathString);\n      if (!allParts || allParts.length !== 5) {\n        throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n      }\n      return {\n        root: allParts[1],\n        dir: allParts[0].slice(0, -1),\n        base: allParts[2],\n        ext: allParts[4],\n        name: allParts[3]\n      };\n    };\n    if (isWindows)\n      module2.exports = win32.parse;\n    else\n      module2.exports = posix.parse;\n    module2.exports.posix = posix.parse;\n    module2.exports.win32 = win32.parse;\n  }\n});\n\n// node_modules/resolve/lib/node-modules-paths.js\nvar require_node_modules_paths = __commonJS({\n  \"node_modules/resolve/lib/node-modules-paths.js\"(exports, module2) {\n    var path3 = __webpack_require__(/*! path */ \"path\");\n    var parse4 = path3.parse || require_path_parse();\n    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {\n      var prefix = \"/\";\n      if (/^([A-Za-z]:)/.test(absoluteStart)) {\n        prefix = \"\";\n      } else if (/^\\\\\\\\/.test(absoluteStart)) {\n        prefix = \"\\\\\\\\\";\n      }\n      var paths = [absoluteStart];\n      var parsed = parse4(absoluteStart);\n      while (parsed.dir !== paths[paths.length - 1]) {\n        paths.push(parsed.dir);\n        parsed = parse4(parsed.dir);\n      }\n      return paths.reduce(function(dirs, aPath) {\n        return dirs.concat(modules.map(function(moduleDir) {\n          return path3.resolve(prefix, aPath, moduleDir);\n        }));\n      }, []);\n    };\n    module2.exports = function nodeModulesPaths(start, opts, request3) {\n      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : [\"node_modules\"];\n      if (opts && typeof opts.paths === \"function\") {\n        return opts.paths(\n          request3,\n          start,\n          function() {\n            return getNodeModulesDirs(start, modules);\n          },\n          opts\n        );\n      }\n      var dirs = getNodeModulesDirs(start, modules);\n      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;\n    };\n  }\n});\n\n// node_modules/resolve/lib/normalize-options.js\nvar require_normalize_options = __commonJS({\n  \"node_modules/resolve/lib/normalize-options.js\"(exports, module2) {\n    module2.exports = function(x, opts) {\n      return opts || {};\n    };\n  }\n});\n\n// node_modules/has/src/index.js\nvar require_src4 = __commonJS({\n  \"node_modules/has/src/index.js\"(exports, module2) {\n    \"use strict\";\n    var hasOwnProperty2 = {}.hasOwnProperty;\n    var call = Function.prototype.call;\n    module2.exports = call.bind ? call.bind(hasOwnProperty2) : function(O, P) {\n      return call.call(hasOwnProperty2, O, P);\n    };\n  }\n});\n\n// node_modules/is-core-module/core.json\nvar require_core = __commonJS({\n  \"node_modules/is-core-module/core.json\"(exports, module2) {\n    module2.exports = {\n      assert: true,\n      \"node:assert\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"assert/strict\": \">= 15\",\n      \"node:assert/strict\": \">= 16\",\n      async_hooks: \">= 8\",\n      \"node:async_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n      buffer_ieee754: \">= 0.5 && < 0.9.7\",\n      buffer: true,\n      \"node:buffer\": [\">= 14.18 && < 15\", \">= 16\"],\n      child_process: true,\n      \"node:child_process\": [\">= 14.18 && < 15\", \">= 16\"],\n      cluster: \">= 0.5\",\n      \"node:cluster\": [\">= 14.18 && < 15\", \">= 16\"],\n      console: true,\n      \"node:console\": [\">= 14.18 && < 15\", \">= 16\"],\n      constants: true,\n      \"node:constants\": [\">= 14.18 && < 15\", \">= 16\"],\n      crypto: true,\n      \"node:crypto\": [\">= 14.18 && < 15\", \">= 16\"],\n      _debug_agent: \">= 1 && < 8\",\n      _debugger: \"< 8\",\n      dgram: true,\n      \"node:dgram\": [\">= 14.18 && < 15\", \">= 16\"],\n      diagnostics_channel: [\">= 14.17 && < 15\", \">= 15.1\"],\n      \"node:diagnostics_channel\": [\">= 14.18 && < 15\", \">= 16\"],\n      dns: true,\n      \"node:dns\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"dns/promises\": \">= 15\",\n      \"node:dns/promises\": \">= 16\",\n      domain: \">= 0.7.12\",\n      \"node:domain\": [\">= 14.18 && < 15\", \">= 16\"],\n      events: true,\n      \"node:events\": [\">= 14.18 && < 15\", \">= 16\"],\n      freelist: \"< 6\",\n      fs: true,\n      \"node:fs\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"fs/promises\": [\">= 10 && < 10.1\", \">= 14\"],\n      \"node:fs/promises\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_agent: \">= 0.11.1\",\n      \"node:_http_agent\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_client: \">= 0.11.1\",\n      \"node:_http_client\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_common: \">= 0.11.1\",\n      \"node:_http_common\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_incoming: \">= 0.11.1\",\n      \"node:_http_incoming\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_outgoing: \">= 0.11.1\",\n      \"node:_http_outgoing\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_server: \">= 0.11.1\",\n      \"node:_http_server\": [\">= 14.18 && < 15\", \">= 16\"],\n      http: true,\n      \"node:http\": [\">= 14.18 && < 15\", \">= 16\"],\n      http2: \">= 8.8\",\n      \"node:http2\": [\">= 14.18 && < 15\", \">= 16\"],\n      https: true,\n      \"node:https\": [\">= 14.18 && < 15\", \">= 16\"],\n      inspector: \">= 8\",\n      \"node:inspector\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"inspector/promises\": [\">= 19\"],\n      \"node:inspector/promises\": [\">= 19\"],\n      _linklist: \"< 8\",\n      module: true,\n      \"node:module\": [\">= 14.18 && < 15\", \">= 16\"],\n      net: true,\n      \"node:net\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"node-inspect/lib/_inspect\": \">= 7.6 && < 12\",\n      \"node-inspect/lib/internal/inspect_client\": \">= 7.6 && < 12\",\n      \"node-inspect/lib/internal/inspect_repl\": \">= 7.6 && < 12\",\n      os: true,\n      \"node:os\": [\">= 14.18 && < 15\", \">= 16\"],\n      path: true,\n      \"node:path\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"path/posix\": \">= 15.3\",\n      \"node:path/posix\": \">= 16\",\n      \"path/win32\": \">= 15.3\",\n      \"node:path/win32\": \">= 16\",\n      perf_hooks: \">= 8.5\",\n      \"node:perf_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n      process: \">= 1\",\n      \"node:process\": [\">= 14.18 && < 15\", \">= 16\"],\n      punycode: \">= 0.5\",\n      \"node:punycode\": [\">= 14.18 && < 15\", \">= 16\"],\n      querystring: true,\n      \"node:querystring\": [\">= 14.18 && < 15\", \">= 16\"],\n      readline: true,\n      \"node:readline\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"readline/promises\": \">= 17\",\n      \"node:readline/promises\": \">= 17\",\n      repl: true,\n      \"node:repl\": [\">= 14.18 && < 15\", \">= 16\"],\n      smalloc: \">= 0.11.5 && < 3\",\n      _stream_duplex: \">= 0.9.4\",\n      \"node:_stream_duplex\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_transform: \">= 0.9.4\",\n      \"node:_stream_transform\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_wrap: \">= 1.4.1\",\n      \"node:_stream_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_passthrough: \">= 0.9.4\",\n      \"node:_stream_passthrough\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_readable: \">= 0.9.4\",\n      \"node:_stream_readable\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_writable: \">= 0.9.4\",\n      \"node:_stream_writable\": [\">= 14.18 && < 15\", \">= 16\"],\n      stream: true,\n      \"node:stream\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"stream/consumers\": \">= 16.7\",\n      \"node:stream/consumers\": \">= 16.7\",\n      \"stream/promises\": \">= 15\",\n      \"node:stream/promises\": \">= 16\",\n      \"stream/web\": \">= 16.5\",\n      \"node:stream/web\": \">= 16.5\",\n      string_decoder: true,\n      \"node:string_decoder\": [\">= 14.18 && < 15\", \">= 16\"],\n      sys: [\">= 0.4 && < 0.7\", \">= 0.8\"],\n      \"node:sys\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"test/reporters\": \">= 19.9 && < 20.2\",\n      \"node:test/reporters\": [\">= 18.17 && < 19\", \">= 19.9\", \">= 20\"],\n      \"node:test\": [\">= 16.17 && < 17\", \">= 18\"],\n      timers: true,\n      \"node:timers\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"timers/promises\": \">= 15\",\n      \"node:timers/promises\": \">= 16\",\n      _tls_common: \">= 0.11.13\",\n      \"node:_tls_common\": [\">= 14.18 && < 15\", \">= 16\"],\n      _tls_legacy: \">= 0.11.3 && < 10\",\n      _tls_wrap: \">= 0.11.3\",\n      \"node:_tls_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n      tls: true,\n      \"node:tls\": [\">= 14.18 && < 15\", \">= 16\"],\n      trace_events: \">= 10\",\n      \"node:trace_events\": [\">= 14.18 && < 15\", \">= 16\"],\n      tty: true,\n      \"node:tty\": [\">= 14.18 && < 15\", \">= 16\"],\n      url: true,\n      \"node:url\": [\">= 14.18 && < 15\", \">= 16\"],\n      util: true,\n      \"node:util\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"util/types\": \">= 15.3\",\n      \"node:util/types\": \">= 16\",\n      \"v8/tools/arguments\": \">= 10 && < 12\",\n      \"v8/tools/codemap\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/consarray\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/csvparser\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/logreader\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/profile_view\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/splaytree\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      v8: \">= 1\",\n      \"node:v8\": [\">= 14.18 && < 15\", \">= 16\"],\n      vm: true,\n      \"node:vm\": [\">= 14.18 && < 15\", \">= 16\"],\n      wasi: [\">= 13.4 && < 13.5\", \">= 18.17 && < 19\", \">= 20\"],\n      \"node:wasi\": [\">= 18.17 && < 19\", \">= 20\"],\n      worker_threads: \">= 11.7\",\n      \"node:worker_threads\": [\">= 14.18 && < 15\", \">= 16\"],\n      zlib: \">= 0.5\",\n      \"node:zlib\": [\">= 14.18 && < 15\", \">= 16\"]\n    };\n  }\n});\n\n// node_modules/is-core-module/index.js\nvar require_is_core_module = __commonJS({\n  \"node_modules/is-core-module/index.js\"(exports, module2) {\n    \"use strict\";\n    var has = require_src4();\n    function specifierIncluded(current, specifier) {\n      var nodeParts = current.split(\".\");\n      var parts = specifier.split(\" \");\n      var op = parts.length > 1 ? parts[0] : \"=\";\n      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(\".\");\n      for (var i = 0; i < 3; ++i) {\n        var cur = parseInt(nodeParts[i] || 0, 10);\n        var ver = parseInt(versionParts[i] || 0, 10);\n        if (cur === ver) {\n          continue;\n        }\n        if (op === \"<\") {\n          return cur < ver;\n        }\n        if (op === \">=\") {\n          return cur >= ver;\n        }\n        return false;\n      }\n      return op === \">=\";\n    }\n    function matchesRange(current, range) {\n      var specifiers = range.split(/ ?&& ?/);\n      if (specifiers.length === 0) {\n        return false;\n      }\n      for (var i = 0; i < specifiers.length; ++i) {\n        if (!specifierIncluded(current, specifiers[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function versionIncluded(nodeVersion, specifierValue) {\n      if (typeof specifierValue === \"boolean\") {\n        return specifierValue;\n      }\n      var current = typeof nodeVersion === \"undefined\" ? process.versions && process.versions.node : nodeVersion;\n      if (typeof current !== \"string\") {\n        throw new TypeError(typeof nodeVersion === \"undefined\" ? \"Unable to determine current node version\" : \"If provided, a valid node version is required\");\n      }\n      if (specifierValue && typeof specifierValue === \"object\") {\n        for (var i = 0; i < specifierValue.length; ++i) {\n          if (matchesRange(current, specifierValue[i])) {\n            return true;\n          }\n        }\n        return false;\n      }\n      return matchesRange(current, specifierValue);\n    }\n    var data = require_core();\n    module2.exports = function isCore(x, nodeVersion) {\n      return has(data, x) && versionIncluded(nodeVersion, data[x]);\n    };\n  }\n});\n\n// node_modules/resolve/lib/async.js\nvar require_async = __commonJS({\n  \"node_modules/resolve/lib/async.js\"(exports, module2) {\n    var fs3 = __webpack_require__(/*! fs */ \"fs\");\n    var getHomedir = require_homedir();\n    var path3 = __webpack_require__(/*! path */ \"path\");\n    var caller = require_caller();\n    var nodeModulesPaths = require_node_modules_paths();\n    var normalizeOptions = require_normalize_options();\n    var isCore = require_is_core_module();\n    var realpathFS = process.platform !== \"win32\" && fs3.realpath && typeof fs3.realpath.native === \"function\" ? fs3.realpath.native : fs3.realpath;\n    var homedir = getHomedir();\n    var defaultPaths = function() {\n      return [\n        path3.join(homedir, \".node_modules\"),\n        path3.join(homedir, \".node_libraries\")\n      ];\n    };\n    var defaultIsFile = function isFile(file, cb) {\n      fs3.stat(file, function(err, stat) {\n        if (!err) {\n          return cb(null, stat.isFile() || stat.isFIFO());\n        }\n        if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\")\n          return cb(null, false);\n        return cb(err);\n      });\n    };\n    var defaultIsDir = function isDirectory(dir, cb) {\n      fs3.stat(dir, function(err, stat) {\n        if (!err) {\n          return cb(null, stat.isDirectory());\n        }\n        if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\")\n          return cb(null, false);\n        return cb(err);\n      });\n    };\n    var defaultRealpath = function realpath(x, cb) {\n      realpathFS(x, function(realpathErr, realPath) {\n        if (realpathErr && realpathErr.code !== \"ENOENT\")\n          cb(realpathErr);\n        else\n          cb(null, realpathErr ? x : realPath);\n      });\n    };\n    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {\n      if (opts && opts.preserveSymlinks === false) {\n        realpath(x, cb);\n      } else {\n        cb(null, x);\n      }\n    };\n    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {\n      readFile(pkgfile, function(readFileErr, body) {\n        if (readFileErr)\n          cb(readFileErr);\n        else {\n          try {\n            var pkg = JSON.parse(body);\n            cb(null, pkg);\n          } catch (jsonErr) {\n            cb(null);\n          }\n        }\n      });\n    };\n    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {\n      var dirs = nodeModulesPaths(start, opts, x);\n      for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path3.join(dirs[i], x);\n      }\n      return dirs;\n    };\n    module2.exports = function resolve(x, options, callback) {\n      var cb = callback;\n      var opts = options;\n      if (typeof options === \"function\") {\n        cb = opts;\n        opts = {};\n      }\n      if (typeof x !== \"string\") {\n        var err = new TypeError(\"Path must be a string.\");\n        return process.nextTick(function() {\n          cb(err);\n        });\n      }\n      opts = normalizeOptions(x, opts);\n      var isFile = opts.isFile || defaultIsFile;\n      var isDirectory = opts.isDirectory || defaultIsDir;\n      var readFile = opts.readFile || fs3.readFile;\n      var realpath = opts.realpath || defaultRealpath;\n      var readPackage = opts.readPackage || defaultReadPackage;\n      if (opts.readFile && opts.readPackage) {\n        var conflictErr = new TypeError(\"`readFile` and `readPackage` are mutually exclusive.\");\n        return process.nextTick(function() {\n          cb(conflictErr);\n        });\n      }\n      var packageIterator = opts.packageIterator;\n      var extensions = opts.extensions || [\".js\"];\n      var includeCoreModules = opts.includeCoreModules !== false;\n      var basedir = opts.basedir || path3.dirname(caller());\n      var parent = opts.filename || basedir;\n      opts.paths = opts.paths || defaultPaths();\n      var absoluteStart = path3.resolve(basedir);\n      maybeRealpath(\n        realpath,\n        absoluteStart,\n        opts,\n        function(err2, realStart) {\n          if (err2)\n            cb(err2);\n          else\n            init(realStart);\n        }\n      );\n      var res;\n      function init(basedir2) {\n        if (/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/.test(x)) {\n          res = path3.resolve(basedir2, x);\n          if (x === \".\" || x === \"..\" || x.slice(-1) === \"/\")\n            res += \"/\";\n          if (/\\/$/.test(x) && res === basedir2) {\n            loadAsDirectory(res, opts.package, onfile);\n          } else\n            loadAsFile(res, opts.package, onfile);\n        } else if (includeCoreModules && isCore(x)) {\n          return cb(null, x);\n        } else\n          loadNodeModules(x, basedir2, function(err2, n, pkg) {\n            if (err2)\n              cb(err2);\n            else if (n) {\n              return maybeRealpath(realpath, n, opts, function(err3, realN) {\n                if (err3) {\n                  cb(err3);\n                } else {\n                  cb(null, realN, pkg);\n                }\n              });\n            } else {\n              var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n              moduleError.code = \"MODULE_NOT_FOUND\";\n              cb(moduleError);\n            }\n          });\n      }\n      function onfile(err2, m, pkg) {\n        if (err2)\n          cb(err2);\n        else if (m)\n          cb(null, m, pkg);\n        else\n          loadAsDirectory(res, function(err3, d, pkg2) {\n            if (err3)\n              cb(err3);\n            else if (d) {\n              maybeRealpath(realpath, d, opts, function(err4, realD) {\n                if (err4) {\n                  cb(err4);\n                } else {\n                  cb(null, realD, pkg2);\n                }\n              });\n            } else {\n              var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n              moduleError.code = \"MODULE_NOT_FOUND\";\n              cb(moduleError);\n            }\n          });\n      }\n      function loadAsFile(x2, thePackage, callback2) {\n        var loadAsFilePackage = thePackage;\n        var cb2 = callback2;\n        if (typeof loadAsFilePackage === \"function\") {\n          cb2 = loadAsFilePackage;\n          loadAsFilePackage = void 0;\n        }\n        var exts = [\"\"].concat(extensions);\n        load(exts, x2, loadAsFilePackage);\n        function load(exts2, x3, loadPackage) {\n          if (exts2.length === 0)\n            return cb2(null, void 0, loadPackage);\n          var file = x3 + exts2[0];\n          var pkg = loadPackage;\n          if (pkg)\n            onpkg(null, pkg);\n          else\n            loadpkg(path3.dirname(file), onpkg);\n          function onpkg(err2, pkg_, dir) {\n            pkg = pkg_;\n            if (err2)\n              return cb2(err2);\n            if (dir && pkg && opts.pathFilter) {\n              var rfile = path3.relative(dir, file);\n              var rel = rfile.slice(0, rfile.length - exts2[0].length);\n              var r = opts.pathFilter(pkg, x3, rel);\n              if (r)\n                return load(\n                  [\"\"].concat(extensions.slice()),\n                  path3.resolve(dir, r),\n                  pkg\n                );\n            }\n            isFile(file, onex);\n          }\n          function onex(err2, ex) {\n            if (err2)\n              return cb2(err2);\n            if (ex)\n              return cb2(null, file, pkg);\n            load(exts2.slice(1), x3, pkg);\n          }\n        }\n      }\n      function loadpkg(dir, cb2) {\n        if (dir === \"\" || dir === \"/\")\n          return cb2(null);\n        if (process.platform === \"win32\" && /^\\w:[/\\\\]*$/.test(dir)) {\n          return cb2(null);\n        }\n        if (/[/\\\\]node_modules[/\\\\]*$/.test(dir))\n          return cb2(null);\n        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {\n          if (unwrapErr)\n            return loadpkg(path3.dirname(dir), cb2);\n          var pkgfile = path3.join(pkgdir, \"package.json\");\n          isFile(pkgfile, function(err2, ex) {\n            if (!ex)\n              return loadpkg(path3.dirname(dir), cb2);\n            readPackage(readFile, pkgfile, function(err3, pkgParam) {\n              if (err3)\n                cb2(err3);\n              var pkg = pkgParam;\n              if (pkg && opts.packageFilter) {\n                pkg = opts.packageFilter(pkg, pkgfile);\n              }\n              cb2(null, pkg, dir);\n            });\n          });\n        });\n      }\n      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {\n        var cb2 = callback2;\n        var fpkg = loadAsDirectoryPackage;\n        if (typeof fpkg === \"function\") {\n          cb2 = fpkg;\n          fpkg = opts.package;\n        }\n        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {\n          if (unwrapErr)\n            return cb2(unwrapErr);\n          var pkgfile = path3.join(pkgdir, \"package.json\");\n          isFile(pkgfile, function(err2, ex) {\n            if (err2)\n              return cb2(err2);\n            if (!ex)\n              return loadAsFile(path3.join(x2, \"index\"), fpkg, cb2);\n            readPackage(readFile, pkgfile, function(err3, pkgParam) {\n              if (err3)\n                return cb2(err3);\n              var pkg = pkgParam;\n              if (pkg && opts.packageFilter) {\n                pkg = opts.packageFilter(pkg, pkgfile);\n              }\n              if (pkg && pkg.main) {\n                if (typeof pkg.main !== \"string\") {\n                  var mainError = new TypeError(\"package \\u201C\" + pkg.name + \"\\u201D `main` must be a string\");\n                  mainError.code = \"INVALID_PACKAGE_MAIN\";\n                  return cb2(mainError);\n                }\n                if (pkg.main === \".\" || pkg.main === \"./\") {\n                  pkg.main = \"index\";\n                }\n                loadAsFile(path3.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {\n                  if (err4)\n                    return cb2(err4);\n                  if (m)\n                    return cb2(null, m, pkg2);\n                  if (!pkg2)\n                    return loadAsFile(path3.join(x2, \"index\"), pkg2, cb2);\n                  var dir = path3.resolve(x2, pkg2.main);\n                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {\n                    if (err5)\n                      return cb2(err5);\n                    if (n)\n                      return cb2(null, n, pkg3);\n                    loadAsFile(path3.join(x2, \"index\"), pkg3, cb2);\n                  });\n                });\n                return;\n              }\n              loadAsFile(path3.join(x2, \"/index\"), pkg, cb2);\n            });\n          });\n        });\n      }\n      function processDirs(cb2, dirs) {\n        if (dirs.length === 0)\n          return cb2(null, void 0);\n        var dir = dirs[0];\n        isDirectory(path3.dirname(dir), isdir);\n        function isdir(err2, isdir2) {\n          if (err2)\n            return cb2(err2);\n          if (!isdir2)\n            return processDirs(cb2, dirs.slice(1));\n          loadAsFile(dir, opts.package, onfile2);\n        }\n        function onfile2(err2, m, pkg) {\n          if (err2)\n            return cb2(err2);\n          if (m)\n            return cb2(null, m, pkg);\n          loadAsDirectory(dir, opts.package, ondir);\n        }\n        function ondir(err2, n, pkg) {\n          if (err2)\n            return cb2(err2);\n          if (n)\n            return cb2(null, n, pkg);\n          processDirs(cb2, dirs.slice(1));\n        }\n      }\n      function loadNodeModules(x2, start, cb2) {\n        var thunk = function() {\n          return getPackageCandidates(x2, start, opts);\n        };\n        processDirs(\n          cb2,\n          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()\n        );\n      }\n    };\n  }\n});\n\n// node_modules/resolve/lib/core.json\nvar require_core2 = __commonJS({\n  \"node_modules/resolve/lib/core.json\"(exports, module2) {\n    module2.exports = {\n      assert: true,\n      \"node:assert\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"assert/strict\": \">= 15\",\n      \"node:assert/strict\": \">= 16\",\n      async_hooks: \">= 8\",\n      \"node:async_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n      buffer_ieee754: \">= 0.5 && < 0.9.7\",\n      buffer: true,\n      \"node:buffer\": [\">= 14.18 && < 15\", \">= 16\"],\n      child_process: true,\n      \"node:child_process\": [\">= 14.18 && < 15\", \">= 16\"],\n      cluster: \">= 0.5\",\n      \"node:cluster\": [\">= 14.18 && < 15\", \">= 16\"],\n      console: true,\n      \"node:console\": [\">= 14.18 && < 15\", \">= 16\"],\n      constants: true,\n      \"node:constants\": [\">= 14.18 && < 15\", \">= 16\"],\n      crypto: true,\n      \"node:crypto\": [\">= 14.18 && < 15\", \">= 16\"],\n      _debug_agent: \">= 1 && < 8\",\n      _debugger: \"< 8\",\n      dgram: true,\n      \"node:dgram\": [\">= 14.18 && < 15\", \">= 16\"],\n      diagnostics_channel: [\">= 14.17 && < 15\", \">= 15.1\"],\n      \"node:diagnostics_channel\": [\">= 14.18 && < 15\", \">= 16\"],\n      dns: true,\n      \"node:dns\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"dns/promises\": \">= 15\",\n      \"node:dns/promises\": \">= 16\",\n      domain: \">= 0.7.12\",\n      \"node:domain\": [\">= 14.18 && < 15\", \">= 16\"],\n      events: true,\n      \"node:events\": [\">= 14.18 && < 15\", \">= 16\"],\n      freelist: \"< 6\",\n      fs: true,\n      \"node:fs\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"fs/promises\": [\">= 10 && < 10.1\", \">= 14\"],\n      \"node:fs/promises\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_agent: \">= 0.11.1\",\n      \"node:_http_agent\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_client: \">= 0.11.1\",\n      \"node:_http_client\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_common: \">= 0.11.1\",\n      \"node:_http_common\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_incoming: \">= 0.11.1\",\n      \"node:_http_incoming\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_outgoing: \">= 0.11.1\",\n      \"node:_http_outgoing\": [\">= 14.18 && < 15\", \">= 16\"],\n      _http_server: \">= 0.11.1\",\n      \"node:_http_server\": [\">= 14.18 && < 15\", \">= 16\"],\n      http: true,\n      \"node:http\": [\">= 14.18 && < 15\", \">= 16\"],\n      http2: \">= 8.8\",\n      \"node:http2\": [\">= 14.18 && < 15\", \">= 16\"],\n      https: true,\n      \"node:https\": [\">= 14.18 && < 15\", \">= 16\"],\n      inspector: \">= 8\",\n      \"node:inspector\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"inspector/promises\": [\">= 19\"],\n      \"node:inspector/promises\": [\">= 19\"],\n      _linklist: \"< 8\",\n      module: true,\n      \"node:module\": [\">= 14.18 && < 15\", \">= 16\"],\n      net: true,\n      \"node:net\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"node-inspect/lib/_inspect\": \">= 7.6 && < 12\",\n      \"node-inspect/lib/internal/inspect_client\": \">= 7.6 && < 12\",\n      \"node-inspect/lib/internal/inspect_repl\": \">= 7.6 && < 12\",\n      os: true,\n      \"node:os\": [\">= 14.18 && < 15\", \">= 16\"],\n      path: true,\n      \"node:path\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"path/posix\": \">= 15.3\",\n      \"node:path/posix\": \">= 16\",\n      \"path/win32\": \">= 15.3\",\n      \"node:path/win32\": \">= 16\",\n      perf_hooks: \">= 8.5\",\n      \"node:perf_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n      process: \">= 1\",\n      \"node:process\": [\">= 14.18 && < 15\", \">= 16\"],\n      punycode: \">= 0.5\",\n      \"node:punycode\": [\">= 14.18 && < 15\", \">= 16\"],\n      querystring: true,\n      \"node:querystring\": [\">= 14.18 && < 15\", \">= 16\"],\n      readline: true,\n      \"node:readline\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"readline/promises\": \">= 17\",\n      \"node:readline/promises\": \">= 17\",\n      repl: true,\n      \"node:repl\": [\">= 14.18 && < 15\", \">= 16\"],\n      smalloc: \">= 0.11.5 && < 3\",\n      _stream_duplex: \">= 0.9.4\",\n      \"node:_stream_duplex\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_transform: \">= 0.9.4\",\n      \"node:_stream_transform\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_wrap: \">= 1.4.1\",\n      \"node:_stream_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_passthrough: \">= 0.9.4\",\n      \"node:_stream_passthrough\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_readable: \">= 0.9.4\",\n      \"node:_stream_readable\": [\">= 14.18 && < 15\", \">= 16\"],\n      _stream_writable: \">= 0.9.4\",\n      \"node:_stream_writable\": [\">= 14.18 && < 15\", \">= 16\"],\n      stream: true,\n      \"node:stream\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"stream/consumers\": \">= 16.7\",\n      \"node:stream/consumers\": \">= 16.7\",\n      \"stream/promises\": \">= 15\",\n      \"node:stream/promises\": \">= 16\",\n      \"stream/web\": \">= 16.5\",\n      \"node:stream/web\": \">= 16.5\",\n      string_decoder: true,\n      \"node:string_decoder\": [\">= 14.18 && < 15\", \">= 16\"],\n      sys: [\">= 0.4 && < 0.7\", \">= 0.8\"],\n      \"node:sys\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"test/reporters\": \">= 19.9 && < 20.2\",\n      \"node:test/reporters\": [\">= 18.17 && < 19\", \">= 19.9\", \">= 20\"],\n      \"node:test\": [\">= 16.17 && < 17\", \">= 18\"],\n      timers: true,\n      \"node:timers\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"timers/promises\": \">= 15\",\n      \"node:timers/promises\": \">= 16\",\n      _tls_common: \">= 0.11.13\",\n      \"node:_tls_common\": [\">= 14.18 && < 15\", \">= 16\"],\n      _tls_legacy: \">= 0.11.3 && < 10\",\n      _tls_wrap: \">= 0.11.3\",\n      \"node:_tls_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n      tls: true,\n      \"node:tls\": [\">= 14.18 && < 15\", \">= 16\"],\n      trace_events: \">= 10\",\n      \"node:trace_events\": [\">= 14.18 && < 15\", \">= 16\"],\n      tty: true,\n      \"node:tty\": [\">= 14.18 && < 15\", \">= 16\"],\n      url: true,\n      \"node:url\": [\">= 14.18 && < 15\", \">= 16\"],\n      util: true,\n      \"node:util\": [\">= 14.18 && < 15\", \">= 16\"],\n      \"util/types\": \">= 15.3\",\n      \"node:util/types\": \">= 16\",\n      \"v8/tools/arguments\": \">= 10 && < 12\",\n      \"v8/tools/codemap\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/consarray\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/csvparser\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/logreader\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/profile_view\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      \"v8/tools/splaytree\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n      v8: \">= 1\",\n      \"node:v8\": [\">= 14.18 && < 15\", \">= 16\"],\n      vm: true,\n      \"node:vm\": [\">= 14.18 && < 15\", \">= 16\"],\n      wasi: [\">= 13.4 && < 13.5\", \">= 18.17 && < 19\", \">= 20\"],\n      \"node:wasi\": [\">= 18.17 && < 19\", \">= 20\"],\n      worker_threads: \">= 11.7\",\n      \"node:worker_threads\": [\">= 14.18 && < 15\", \">= 16\"],\n      zlib: \">= 0.5\",\n      \"node:zlib\": [\">= 14.18 && < 15\", \">= 16\"]\n    };\n  }\n});\n\n// node_modules/resolve/lib/core.js\nvar require_core3 = __commonJS({\n  \"node_modules/resolve/lib/core.js\"(exports, module2) {\n    \"use strict\";\n    var isCoreModule = require_is_core_module();\n    var data = require_core2();\n    var core = {};\n    for (mod in data) {\n      if (Object.prototype.hasOwnProperty.call(data, mod)) {\n        core[mod] = isCoreModule(mod);\n      }\n    }\n    var mod;\n    module2.exports = core;\n  }\n});\n\n// node_modules/resolve/lib/is-core.js\nvar require_is_core = __commonJS({\n  \"node_modules/resolve/lib/is-core.js\"(exports, module2) {\n    var isCoreModule = require_is_core_module();\n    module2.exports = function isCore(x) {\n      return isCoreModule(x);\n    };\n  }\n});\n\n// node_modules/resolve/lib/sync.js\nvar require_sync = __commonJS({\n  \"node_modules/resolve/lib/sync.js\"(exports, module2) {\n    var isCore = require_is_core_module();\n    var fs3 = __webpack_require__(/*! fs */ \"fs\");\n    var path3 = __webpack_require__(/*! path */ \"path\");\n    var getHomedir = require_homedir();\n    var caller = require_caller();\n    var nodeModulesPaths = require_node_modules_paths();\n    var normalizeOptions = require_normalize_options();\n    var realpathFS = process.platform !== \"win32\" && fs3.realpathSync && typeof fs3.realpathSync.native === \"function\" ? fs3.realpathSync.native : fs3.realpathSync;\n    var homedir = getHomedir();\n    var defaultPaths = function() {\n      return [\n        path3.join(homedir, \".node_modules\"),\n        path3.join(homedir, \".node_libraries\")\n      ];\n    };\n    var defaultIsFile = function isFile(file) {\n      try {\n        var stat = fs3.statSync(file, { throwIfNoEntry: false });\n      } catch (e) {\n        if (e && (e.code === \"ENOENT\" || e.code === \"ENOTDIR\"))\n          return false;\n        throw e;\n      }\n      return !!stat && (stat.isFile() || stat.isFIFO());\n    };\n    var defaultIsDir = function isDirectory(dir) {\n      try {\n        var stat = fs3.statSync(dir, { throwIfNoEntry: false });\n      } catch (e) {\n        if (e && (e.code === \"ENOENT\" || e.code === \"ENOTDIR\"))\n          return false;\n        throw e;\n      }\n      return !!stat && stat.isDirectory();\n    };\n    var defaultRealpathSync = function realpathSync(x) {\n      try {\n        return realpathFS(x);\n      } catch (realpathErr) {\n        if (realpathErr.code !== \"ENOENT\") {\n          throw realpathErr;\n        }\n      }\n      return x;\n    };\n    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {\n      if (opts && opts.preserveSymlinks === false) {\n        return realpathSync(x);\n      }\n      return x;\n    };\n    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {\n      var body = readFileSync(pkgfile);\n      try {\n        var pkg = JSON.parse(body);\n        return pkg;\n      } catch (jsonErr) {\n      }\n    };\n    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {\n      var dirs = nodeModulesPaths(start, opts, x);\n      for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path3.join(dirs[i], x);\n      }\n      return dirs;\n    };\n    module2.exports = function resolveSync(x, options) {\n      if (typeof x !== \"string\") {\n        throw new TypeError(\"Path must be a string.\");\n      }\n      var opts = normalizeOptions(x, options);\n      var isFile = opts.isFile || defaultIsFile;\n      var readFileSync = opts.readFileSync || fs3.readFileSync;\n      var isDirectory = opts.isDirectory || defaultIsDir;\n      var realpathSync = opts.realpathSync || defaultRealpathSync;\n      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;\n      if (opts.readFileSync && opts.readPackageSync) {\n        throw new TypeError(\"`readFileSync` and `readPackageSync` are mutually exclusive.\");\n      }\n      var packageIterator = opts.packageIterator;\n      var extensions = opts.extensions || [\".js\"];\n      var includeCoreModules = opts.includeCoreModules !== false;\n      var basedir = opts.basedir || path3.dirname(caller());\n      var parent = opts.filename || basedir;\n      opts.paths = opts.paths || defaultPaths();\n      var absoluteStart = maybeRealpathSync(realpathSync, path3.resolve(basedir), opts);\n      if (/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/.test(x)) {\n        var res = path3.resolve(absoluteStart, x);\n        if (x === \".\" || x === \"..\" || x.slice(-1) === \"/\")\n          res += \"/\";\n        var m = loadAsFileSync(res) || loadAsDirectorySync(res);\n        if (m)\n          return maybeRealpathSync(realpathSync, m, opts);\n      } else if (includeCoreModules && isCore(x)) {\n        return x;\n      } else {\n        var n = loadNodeModulesSync(x, absoluteStart);\n        if (n)\n          return maybeRealpathSync(realpathSync, n, opts);\n      }\n      var err = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n      err.code = \"MODULE_NOT_FOUND\";\n      throw err;\n      function loadAsFileSync(x2) {\n        var pkg = loadpkg(path3.dirname(x2));\n        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {\n          var rfile = path3.relative(pkg.dir, x2);\n          var r = opts.pathFilter(pkg.pkg, x2, rfile);\n          if (r) {\n            x2 = path3.resolve(pkg.dir, r);\n          }\n        }\n        if (isFile(x2)) {\n          return x2;\n        }\n        for (var i = 0; i < extensions.length; i++) {\n          var file = x2 + extensions[i];\n          if (isFile(file)) {\n            return file;\n          }\n        }\n      }\n      function loadpkg(dir) {\n        if (dir === \"\" || dir === \"/\")\n          return;\n        if (process.platform === \"win32\" && /^\\w:[/\\\\]*$/.test(dir)) {\n          return;\n        }\n        if (/[/\\\\]node_modules[/\\\\]*$/.test(dir))\n          return;\n        var pkgfile = path3.join(maybeRealpathSync(realpathSync, dir, opts), \"package.json\");\n        if (!isFile(pkgfile)) {\n          return loadpkg(path3.dirname(dir));\n        }\n        var pkg = readPackageSync(readFileSync, pkgfile);\n        if (pkg && opts.packageFilter) {\n          pkg = opts.packageFilter(\n            pkg,\n            /*pkgfile,*/\n            dir\n          );\n        }\n        return { pkg, dir };\n      }\n      function loadAsDirectorySync(x2) {\n        var pkgfile = path3.join(maybeRealpathSync(realpathSync, x2, opts), \"/package.json\");\n        if (isFile(pkgfile)) {\n          try {\n            var pkg = readPackageSync(readFileSync, pkgfile);\n          } catch (e) {\n          }\n          if (pkg && opts.packageFilter) {\n            pkg = opts.packageFilter(\n              pkg,\n              /*pkgfile,*/\n              x2\n            );\n          }\n          if (pkg && pkg.main) {\n            if (typeof pkg.main !== \"string\") {\n              var mainError = new TypeError(\"package \\u201C\" + pkg.name + \"\\u201D `main` must be a string\");\n              mainError.code = \"INVALID_PACKAGE_MAIN\";\n              throw mainError;\n            }\n            if (pkg.main === \".\" || pkg.main === \"./\") {\n              pkg.main = \"index\";\n            }\n            try {\n              var m2 = loadAsFileSync(path3.resolve(x2, pkg.main));\n              if (m2)\n                return m2;\n              var n2 = loadAsDirectorySync(path3.resolve(x2, pkg.main));\n              if (n2)\n                return n2;\n            } catch (e) {\n            }\n          }\n        }\n        return loadAsFileSync(path3.join(x2, \"/index\"));\n      }\n      function loadNodeModulesSync(x2, start) {\n        var thunk = function() {\n          return getPackageCandidates(x2, start, opts);\n        };\n        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();\n        for (var i = 0; i < dirs.length; i++) {\n          var dir = dirs[i];\n          if (isDirectory(path3.dirname(dir))) {\n            var m2 = loadAsFileSync(dir);\n            if (m2)\n              return m2;\n            var n2 = loadAsDirectorySync(dir);\n            if (n2)\n              return n2;\n          }\n        }\n      }\n    };\n  }\n});\n\n// node_modules/resolve/index.js\nvar require_resolve = __commonJS({\n  \"node_modules/resolve/index.js\"(exports, module2) {\n    var async = require_async();\n    async.core = require_core3();\n    async.isCore = require_is_core();\n    async.sync = require_sync();\n    module2.exports = async;\n  }\n});\n\n// node_modules/ms/index.js\nvar require_ms = __commonJS({\n  \"node_modules/ms/index.js\"(exports, module2) {\n    var s = 1e3;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    module2.exports = function(val, options) {\n      options = options || {};\n      var type = typeof val;\n      if (type === \"string\" && val.length > 0) {\n        return parse4(val);\n      } else if (type === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n      }\n      throw new Error(\n        \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val)\n      );\n    };\n    function parse4(str) {\n      str = String(str);\n      if (str.length > 100) {\n        return;\n      }\n      var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        str\n      );\n      if (!match) {\n        return;\n      }\n      var n = parseFloat(match[1]);\n      var type = (match[2] || \"ms\").toLowerCase();\n      switch (type) {\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n          return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n          return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n          return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n          return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n          return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n          return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n          return n;\n        default:\n          return void 0;\n      }\n    }\n    function fmtShort(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n      }\n      if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n      }\n      if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n      }\n      if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n      }\n      return ms + \"ms\";\n    }\n    function fmtLong(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n      }\n      if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n      }\n      if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n      }\n      if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n      }\n      return ms + \" ms\";\n    }\n    function plural(ms, msAbs, n, name) {\n      var isPlural = msAbs >= n * 1.5;\n      return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n  }\n});\n\n// node_modules/debug/src/common.js\nvar require_common = __commonJS({\n  \"node_modules/debug/src/common.js\"(exports, module2) {\n    function setup(env3) {\n      createDebug.debug = createDebug;\n      createDebug.default = createDebug;\n      createDebug.coerce = coerce;\n      createDebug.disable = disable;\n      createDebug.enable = enable;\n      createDebug.enabled = enabled;\n      createDebug.humanize = require_ms();\n      createDebug.destroy = destroy;\n      Object.keys(env3).forEach((key) => {\n        createDebug[key] = env3[key];\n      });\n      createDebug.names = [];\n      createDebug.skips = [];\n      createDebug.formatters = {};\n      function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\n          hash |= 0;\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n      }\n      createDebug.selectColor = selectColor;\n      function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n          if (!debug.enabled) {\n            return;\n          }\n          const self2 = debug;\n          const curr = Number(/* @__PURE__ */ new Date());\n          const ms = curr - (prevTime || curr);\n          self2.diff = ms;\n          self2.prev = prevTime;\n          self2.curr = curr;\n          prevTime = curr;\n          args[0] = createDebug.coerce(args[0]);\n          if (typeof args[0] !== \"string\") {\n            args.unshift(\"%O\");\n          }\n          let index = 0;\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n            if (match === \"%%\") {\n              return \"%\";\n            }\n            index++;\n            const formatter = createDebug.formatters[format];\n            if (typeof formatter === \"function\") {\n              const val = args[index];\n              match = formatter.call(self2, val);\n              args.splice(index, 1);\n              index--;\n            }\n            return match;\n          });\n          createDebug.formatArgs.call(self2, args);\n          const logFn = self2.log || createDebug.log;\n          logFn.apply(self2, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy;\n        Object.defineProperty(debug, \"enabled\", {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n            if (enableOverride !== null) {\n              return enableOverride;\n            }\n            if (namespacesCache !== createDebug.namespaces) {\n              namespacesCache = createDebug.namespaces;\n              enabledCache = createDebug.enabled(namespace);\n            }\n            return enabledCache;\n          },\n          set: (v) => {\n            enableOverride = v;\n          }\n        });\n        if (typeof createDebug.init === \"function\") {\n          createDebug.init(debug);\n        }\n        return debug;\n      }\n      function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n      }\n      function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for (i = 0; i < len; i++) {\n          if (!split[i]) {\n            continue;\n          }\n          namespaces = split[i].replace(/\\*/g, \".*?\");\n          if (namespaces[0] === \"-\") {\n            createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n          } else {\n            createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n          }\n        }\n      }\n      function disable() {\n        const namespaces = [\n          ...createDebug.names.map(toNamespace),\n          ...createDebug.skips.map(toNamespace).map((namespace) => \"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n      }\n      function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n          return true;\n        }\n        let i;\n        let len;\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\n          if (createDebug.skips[i].test(name)) {\n            return false;\n          }\n        }\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\n          if (createDebug.names[i].test(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n      }\n      function coerce(val) {\n        if (val instanceof Error) {\n          return val.stack || val.message;\n        }\n        return val;\n      }\n      function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n      }\n      createDebug.enable(createDebug.load());\n      return createDebug;\n    }\n    module2.exports = setup;\n  }\n});\n\n// node_modules/debug/src/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/debug/src/browser.js\"(exports, module2) {\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.storage = localstorage();\n    exports.destroy = (() => {\n      let warned = false;\n      return () => {\n        if (!warned) {\n          warned = true;\n          console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n      };\n    })();\n    exports.colors = [\n      \"#0000CC\",\n      \"#0000FF\",\n      \"#0033CC\",\n      \"#0033FF\",\n      \"#0066CC\",\n      \"#0066FF\",\n      \"#0099CC\",\n      \"#0099FF\",\n      \"#00CC00\",\n      \"#00CC33\",\n      \"#00CC66\",\n      \"#00CC99\",\n      \"#00CCCC\",\n      \"#00CCFF\",\n      \"#3300CC\",\n      \"#3300FF\",\n      \"#3333CC\",\n      \"#3333FF\",\n      \"#3366CC\",\n      \"#3366FF\",\n      \"#3399CC\",\n      \"#3399FF\",\n      \"#33CC00\",\n      \"#33CC33\",\n      \"#33CC66\",\n      \"#33CC99\",\n      \"#33CCCC\",\n      \"#33CCFF\",\n      \"#6600CC\",\n      \"#6600FF\",\n      \"#6633CC\",\n      \"#6633FF\",\n      \"#66CC00\",\n      \"#66CC33\",\n      \"#9900CC\",\n      \"#9900FF\",\n      \"#9933CC\",\n      \"#9933FF\",\n      \"#99CC00\",\n      \"#99CC33\",\n      \"#CC0000\",\n      \"#CC0033\",\n      \"#CC0066\",\n      \"#CC0099\",\n      \"#CC00CC\",\n      \"#CC00FF\",\n      \"#CC3300\",\n      \"#CC3333\",\n      \"#CC3366\",\n      \"#CC3399\",\n      \"#CC33CC\",\n      \"#CC33FF\",\n      \"#CC6600\",\n      \"#CC6633\",\n      \"#CC9900\",\n      \"#CC9933\",\n      \"#CCCC00\",\n      \"#CCCC33\",\n      \"#FF0000\",\n      \"#FF0033\",\n      \"#FF0066\",\n      \"#FF0099\",\n      \"#FF00CC\",\n      \"#FF00FF\",\n      \"#FF3300\",\n      \"#FF3333\",\n      \"#FF3366\",\n      \"#FF3399\",\n      \"#FF33CC\",\n      \"#FF33FF\",\n      \"#FF6600\",\n      \"#FF6633\",\n      \"#FF9900\",\n      \"#FF9933\",\n      \"#FFCC00\",\n      \"#FFCC33\"\n    ];\n    function useColors() {\n      if (typeof window !== \"undefined\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs)) {\n        return true;\n      }\n      if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n      }\n      return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n      typeof window !== \"undefined\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n      typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n      typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n    function formatArgs(args) {\n      args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module2.exports.humanize(this.diff);\n      if (!this.useColors) {\n        return;\n      }\n      const c = \"color: \" + this.color;\n      args.splice(1, 0, c, \"color: inherit\");\n      let index = 0;\n      let lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        if (match === \"%%\") {\n          return;\n        }\n        index++;\n        if (match === \"%c\") {\n          lastC = index;\n        }\n      });\n      args.splice(lastC, 0, c);\n    }\n    exports.log = console.debug || console.log || (() => {\n    });\n    function save(namespaces) {\n      try {\n        if (namespaces) {\n          exports.storage.setItem(\"debug\", namespaces);\n        } else {\n          exports.storage.removeItem(\"debug\");\n        }\n      } catch (error) {\n      }\n    }\n    function load() {\n      let r;\n      try {\n        r = exports.storage.getItem(\"debug\");\n      } catch (error) {\n      }\n      if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n      }\n      return r;\n    }\n    function localstorage() {\n      try {\n        return localStorage;\n      } catch (error) {\n      }\n    }\n    module2.exports = require_common()(exports);\n    var { formatters } = module2.exports;\n    formatters.j = function(v) {\n      try {\n        return JSON.stringify(v);\n      } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n      }\n    };\n  }\n});\n\n// node_modules/has-flag/index.js\nvar require_has_flag = __commonJS({\n  \"node_modules/has-flag/index.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = (flag, argv) => {\n      argv = argv || process.argv;\n      const prefix = flag.startsWith(\"-\") ? \"\" : flag.length === 1 ? \"-\" : \"--\";\n      const pos = argv.indexOf(prefix + flag);\n      const terminatorPos = argv.indexOf(\"--\");\n      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n    };\n  }\n});\n\n// node_modules/supports-color/index.js\nvar require_supports_color = __commonJS({\n  \"node_modules/supports-color/index.js\"(exports, module2) {\n    \"use strict\";\n    var os2 = __webpack_require__(/*! os */ \"os\");\n    var hasFlag = require_has_flag();\n    var env3 = process.env;\n    var forceColor;\n    if (hasFlag(\"no-color\") || hasFlag(\"no-colors\") || hasFlag(\"color=false\")) {\n      forceColor = false;\n    } else if (hasFlag(\"color\") || hasFlag(\"colors\") || hasFlag(\"color=true\") || hasFlag(\"color=always\")) {\n      forceColor = true;\n    }\n    if (\"FORCE_COLOR\" in env3) {\n      forceColor = env3.FORCE_COLOR.length === 0 || parseInt(env3.FORCE_COLOR, 10) !== 0;\n    }\n    function translateLevel(level) {\n      if (level === 0) {\n        return false;\n      }\n      return {\n        level,\n        hasBasic: true,\n        has256: level >= 2,\n        has16m: level >= 3\n      };\n    }\n    function supportsColor(stream) {\n      if (forceColor === false) {\n        return 0;\n      }\n      if (hasFlag(\"color=16m\") || hasFlag(\"color=full\") || hasFlag(\"color=truecolor\")) {\n        return 3;\n      }\n      if (hasFlag(\"color=256\")) {\n        return 2;\n      }\n      if (stream && !stream.isTTY && forceColor !== true) {\n        return 0;\n      }\n      const min = forceColor ? 1 : 0;\n      if (process.platform === \"win32\") {\n        const osRelease = os2.release().split(\".\");\n        if (Number(process.versions.node.split(\".\")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n          return Number(osRelease[2]) >= 14931 ? 3 : 2;\n        }\n        return 1;\n      }\n      if (\"CI\" in env3) {\n        if ([\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\"].some((sign) => sign in env3) || env3.CI_NAME === \"codeship\") {\n          return 1;\n        }\n        return min;\n      }\n      if (\"TEAMCITY_VERSION\" in env3) {\n        return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;\n      }\n      if (env3.COLORTERM === \"truecolor\") {\n        return 3;\n      }\n      if (\"TERM_PROGRAM\" in env3) {\n        const version = parseInt((env3.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);\n        switch (env3.TERM_PROGRAM) {\n          case \"iTerm.app\":\n            return version >= 3 ? 3 : 2;\n          case \"Apple_Terminal\":\n            return 2;\n        }\n      }\n      if (/-256(color)?$/i.test(env3.TERM)) {\n        return 2;\n      }\n      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {\n        return 1;\n      }\n      if (\"COLORTERM\" in env3) {\n        return 1;\n      }\n      if (env3.TERM === \"dumb\") {\n        return min;\n      }\n      return min;\n    }\n    function getSupportLevel(stream) {\n      const level = supportsColor(stream);\n      return translateLevel(level);\n    }\n    module2.exports = {\n      supportsColor: getSupportLevel,\n      stdout: getSupportLevel(process.stdout),\n      stderr: getSupportLevel(process.stderr)\n    };\n  }\n});\n\n// node_modules/debug/src/node.js\nvar require_node = __commonJS({\n  \"node_modules/debug/src/node.js\"(exports, module2) {\n    var tty = __webpack_require__(/*! tty */ \"tty\");\n    var util2 = __webpack_require__(/*! util */ \"util\");\n    exports.init = init;\n    exports.log = log;\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.destroy = util2.deprecate(\n      () => {\n      },\n      \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"\n    );\n    exports.colors = [6, 2, 3, 4, 5, 1];\n    try {\n      const supportsColor = require_supports_color();\n      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n          20,\n          21,\n          26,\n          27,\n          32,\n          33,\n          38,\n          39,\n          40,\n          41,\n          42,\n          43,\n          44,\n          45,\n          56,\n          57,\n          62,\n          63,\n          68,\n          69,\n          74,\n          75,\n          76,\n          77,\n          78,\n          79,\n          80,\n          81,\n          92,\n          93,\n          98,\n          99,\n          112,\n          113,\n          128,\n          129,\n          134,\n          135,\n          148,\n          149,\n          160,\n          161,\n          162,\n          163,\n          164,\n          165,\n          166,\n          167,\n          168,\n          169,\n          170,\n          171,\n          172,\n          173,\n          178,\n          179,\n          184,\n          185,\n          196,\n          197,\n          198,\n          199,\n          200,\n          201,\n          202,\n          203,\n          204,\n          205,\n          206,\n          207,\n          208,\n          209,\n          214,\n          215,\n          220,\n          221\n        ];\n      }\n    } catch (error) {\n    }\n    exports.inspectOpts = Object.keys(process.env).filter((key) => {\n      return /^debug_/i.test(key);\n    }).reduce((obj, key) => {\n      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {\n        return k.toUpperCase();\n      });\n      let val = process.env[key];\n      if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n      } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n      } else if (val === \"null\") {\n        val = null;\n      } else {\n        val = Number(val);\n      }\n      obj[prop] = val;\n      return obj;\n    }, {});\n    function useColors() {\n      return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n    }\n    function formatArgs(args) {\n      const { namespace: name, useColors: useColors2 } = this;\n      if (useColors2) {\n        const c = this.color;\n        const colorCode = \"\\x1B[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\x1B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module2.exports.humanize(this.diff) + \"\\x1B[0m\");\n      } else {\n        args[0] = getDate() + name + \" \" + args[0];\n      }\n    }\n    function getDate() {\n      if (exports.inspectOpts.hideDate) {\n        return \"\";\n      }\n      return (/* @__PURE__ */ new Date()).toISOString() + \" \";\n    }\n    function log(...args) {\n      return process.stderr.write(util2.format(...args) + \"\\n\");\n    }\n    function save(namespaces) {\n      if (namespaces) {\n        process.env.DEBUG = namespaces;\n      } else {\n        delete process.env.DEBUG;\n      }\n    }\n    function load() {\n      return process.env.DEBUG;\n    }\n    function init(debug) {\n      debug.inspectOpts = {};\n      const keys = Object.keys(exports.inspectOpts);\n      for (let i = 0; i < keys.length; i++) {\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n      }\n    }\n    module2.exports = require_common()(exports);\n    var { formatters } = module2.exports;\n    formatters.o = function(v) {\n      this.inspectOpts.colors = this.useColors;\n      return util2.inspect(v, this.inspectOpts).split(\"\\n\").map((str) => str.trim()).join(\" \");\n    };\n    formatters.O = function(v) {\n      this.inspectOpts.colors = this.useColors;\n      return util2.inspect(v, this.inspectOpts);\n    };\n  }\n});\n\n// node_modules/debug/src/index.js\nvar require_src5 = __commonJS({\n  \"node_modules/debug/src/index.js\"(exports, module2) {\n    if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n      module2.exports = require_browser();\n    } else {\n      module2.exports = require_node();\n    }\n  }\n});\n\n// node_modules/module-details-from-path/index.js\nvar require_module_details_from_path = __commonJS({\n  \"node_modules/module-details-from-path/index.js\"(exports, module2) {\n    \"use strict\";\n    var path3 = __webpack_require__(/*! path */ \"path\");\n    module2.exports = function(file) {\n      var segments = file.split(path3.sep);\n      var index = segments.lastIndexOf(\"node_modules\");\n      if (index === -1)\n        return;\n      if (!segments[index + 1])\n        return;\n      var scoped = segments[index + 1][0] === \"@\";\n      var name = scoped ? segments[index + 1] + \"/\" + segments[index + 2] : segments[index + 1];\n      var offset = scoped ? 3 : 2;\n      return {\n        name,\n        basedir: segments.slice(0, index + offset).join(path3.sep),\n        path: segments.slice(index + offset).join(path3.sep)\n      };\n    };\n  }\n});\n\n// node_modules/require-in-the-middle/package.json\nvar require_package = __commonJS({\n  \"node_modules/require-in-the-middle/package.json\"(exports, module2) {\n    module2.exports = {\n      name: \"require-in-the-middle\",\n      version: \"7.2.0\",\n      description: \"Module to hook into the Node.js require function\",\n      main: \"index.js\",\n      types: \"types/index.d.ts\",\n      dependencies: {\n        debug: \"^4.1.1\",\n        \"module-details-from-path\": \"^1.0.3\",\n        resolve: \"^1.22.1\"\n      },\n      devDependencies: {\n        \"@babel/core\": \"^7.9.0\",\n        \"@babel/preset-env\": \"^7.9.5\",\n        \"@babel/preset-typescript\": \"^7.9.0\",\n        \"@babel/register\": \"^7.9.0\",\n        \"ipp-printer\": \"^1.0.0\",\n        patterns: \"^1.0.3\",\n        roundround: \"^0.2.0\",\n        semver: \"^6.3.0\",\n        standard: \"^14.3.1\",\n        tape: \"^4.11.0\"\n      },\n      scripts: {\n        test: \"npm run test:lint && npm run test:tape && npm run test:babel\",\n        \"test:lint\": \"standard\",\n        \"test:tape\": \"tape test/*.js\",\n        \"test:babel\": \"node test/babel/babel-register.js\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"git+https://github.com/elastic/require-in-the-middle.git\"\n      },\n      keywords: [\n        \"require\",\n        \"hook\",\n        \"shim\",\n        \"shimmer\",\n        \"shimming\",\n        \"patch\",\n        \"monkey\",\n        \"monkeypatch\",\n        \"module\",\n        \"load\"\n      ],\n      files: [\n        \"types\"\n      ],\n      author: \"Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)\",\n      license: \"MIT\",\n      bugs: {\n        url: \"https://github.com/elastic/require-in-the-middle/issues\"\n      },\n      homepage: \"https://github.com/elastic/require-in-the-middle#readme\",\n      engines: {\n        node: \">=8.6.0\"\n      }\n    };\n  }\n});\n\n// node_modules/require-in-the-middle/index.js\nvar require_require_in_the_middle = __commonJS({\n  \"node_modules/require-in-the-middle/index.js\"(exports, module2) {\n    \"use strict\";\n    var path3 = __webpack_require__(/*! path */ \"path\");\n    var Module = __webpack_require__(/*! module */ \"module\");\n    var resolve = require_resolve();\n    var debug = require_src5()(\"require-in-the-middle\");\n    var moduleDetailsFromPath = require_module_details_from_path();\n    module2.exports = Hook3;\n    module2.exports.Hook = Hook3;\n    var isCore;\n    if (Module.isBuiltin) {\n      isCore = Module.isBuiltin;\n    } else {\n      const [major2, minor] = process.versions.node.split(\".\").map(Number);\n      if (major2 === 8 && minor < 8) {\n        isCore = (moduleName) => {\n          if (moduleName === \"http2\") {\n            return true;\n          }\n          return !!resolve.core[moduleName];\n        };\n      } else {\n        isCore = (moduleName) => {\n          return !!resolve.core[moduleName];\n        };\n      }\n    }\n    var normalize3 = /([/\\\\]index)?(\\.js)?$/;\n    var ExportsCache = class {\n      constructor() {\n        this._localCache = /* @__PURE__ */ new Map();\n        this._kRitmExports = Symbol(\"RitmExports\");\n      }\n      has(filename, isBuiltin) {\n        if (this._localCache.has(filename)) {\n          return true;\n        } else if (!isBuiltin) {\n          const mod = __webpack_require__.c[filename];\n          return !!(mod && this._kRitmExports in mod);\n        } else {\n          return false;\n        }\n      }\n      get(filename, isBuiltin) {\n        const cachedExports = this._localCache.get(filename);\n        if (cachedExports !== void 0) {\n          return cachedExports;\n        } else if (!isBuiltin) {\n          const mod = __webpack_require__.c[filename];\n          return mod && mod[this._kRitmExports];\n        }\n      }\n      set(filename, exports2, isBuiltin) {\n        if (isBuiltin) {\n          this._localCache.set(filename, exports2);\n        } else if (filename in __webpack_require__.c) {\n          __webpack_require__.c[filename][this._kRitmExports] = exports2;\n        } else {\n          debug('non-core module is unexpectedly not in require.cache: \"%s\"', filename);\n          this._localCache.set(filename, exports2);\n        }\n      }\n    };\n    function Hook3(modules, options, onrequire) {\n      if (this instanceof Hook3 === false)\n        return new Hook3(modules, options, onrequire);\n      if (typeof modules === \"function\") {\n        onrequire = modules;\n        modules = null;\n        options = null;\n      } else if (typeof options === \"function\") {\n        onrequire = options;\n        options = null;\n      }\n      if (typeof Module._resolveFilename !== \"function\") {\n        console.error(\"Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!\", typeof Module._resolveFilename);\n        console.error(\"Please report this error as an issue related to Node.js %s at %s\", process.version, require_package().bugs.url);\n        return;\n      }\n      this._cache = new ExportsCache();\n      this._unhooked = false;\n      this._origRequire = Module.prototype.require;\n      const self2 = this;\n      const patching = /* @__PURE__ */ new Set();\n      const internals = options ? options.internals === true : false;\n      const hasWhitelist = Array.isArray(modules);\n      debug(\"registering require hook\");\n      this._require = Module.prototype.require = function(id) {\n        if (self2._unhooked === true) {\n          debug(\"ignoring require call - module is soft-unhooked\");\n          return self2._origRequire.apply(this, arguments);\n        }\n        const core = isCore(id);\n        let filename;\n        if (core) {\n          filename = id;\n          if (id.startsWith(\"node:\")) {\n            const idWithoutPrefix = id.slice(5);\n            if (isCore(idWithoutPrefix)) {\n              filename = idWithoutPrefix;\n            }\n          }\n        } else {\n          try {\n            filename = Module._resolveFilename(id, this);\n          } catch (resolveErr) {\n            debug('Module._resolveFilename(\"%s\") threw %j, calling original Module.require', id, resolveErr.message);\n            return self2._origRequire.apply(this, arguments);\n          }\n        }\n        let moduleName, basedir;\n        debug(\"processing %s module require('%s'): %s\", core === true ? \"core\" : \"non-core\", id, filename);\n        if (self2._cache.has(filename, core) === true) {\n          debug(\"returning already patched cached module: %s\", filename);\n          return self2._cache.get(filename, core);\n        }\n        const isPatching = patching.has(filename);\n        if (isPatching === false) {\n          patching.add(filename);\n        }\n        const exports2 = self2._origRequire.apply(this, arguments);\n        if (isPatching === true) {\n          debug(\"module is in the process of being patched already - ignoring: %s\", filename);\n          return exports2;\n        }\n        patching.delete(filename);\n        if (core === true) {\n          if (hasWhitelist === true && modules.includes(filename) === false) {\n            debug(\"ignoring core module not on whitelist: %s\", filename);\n            return exports2;\n          }\n          moduleName = filename;\n        } else if (hasWhitelist === true && modules.includes(filename)) {\n          const parsedPath = path3.parse(filename);\n          moduleName = parsedPath.name;\n          basedir = parsedPath.dir;\n        } else {\n          const stat = moduleDetailsFromPath(filename);\n          if (stat === void 0) {\n            debug(\"could not parse filename: %s\", filename);\n            return exports2;\n          }\n          moduleName = stat.name;\n          basedir = stat.basedir;\n          const fullModuleName = resolveModuleName(stat);\n          debug(\"resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)\", moduleName, id, fullModuleName, basedir);\n          if (hasWhitelist === true && modules.includes(moduleName) === false) {\n            if (modules.includes(fullModuleName) === false)\n              return exports2;\n            moduleName = fullModuleName;\n          } else {\n            let res;\n            try {\n              res = resolve.sync(moduleName, { basedir });\n            } catch (e) {\n              debug(\"could not resolve module: %s\", moduleName);\n              self2._cache.set(filename, exports2, core);\n              return exports2;\n            }\n            if (res !== filename) {\n              if (internals === true) {\n                moduleName = moduleName + path3.sep + path3.relative(basedir, filename);\n                debug(\"preparing to process require of internal file: %s\", moduleName);\n              } else {\n                debug(\"ignoring require of non-main module file: %s\", res);\n                self2._cache.set(filename, exports2, core);\n                return exports2;\n              }\n            }\n          }\n        }\n        self2._cache.set(filename, exports2, core);\n        debug(\"calling require hook: %s\", moduleName);\n        const patchedExports = onrequire(exports2, moduleName, basedir);\n        self2._cache.set(filename, patchedExports, core);\n        debug(\"returning module: %s\", moduleName);\n        return patchedExports;\n      };\n    }\n    Hook3.prototype.unhook = function() {\n      this._unhooked = true;\n      if (this._require === Module.prototype.require) {\n        Module.prototype.require = this._origRequire;\n        debug(\"unhook successful\");\n      } else {\n        debug(\"unhook unsuccessful\");\n      }\n    };\n    function resolveModuleName(stat) {\n      const normalizedPath = path3.sep !== \"/\" ? stat.path.split(path3.sep).join(\"/\") : stat.path;\n      return path3.posix.join(stat.name, normalizedPath).replace(normalize3, \"\");\n    }\n  }\n});\n\n// node_modules/import-in-the-middle/lib/register.js\nvar require_register = __commonJS({\n  \"node_modules/import-in-the-middle/lib/register.js\"(exports) {\n    var importHooks = [];\n    var setters = /* @__PURE__ */ new WeakMap();\n    var specifiers = /* @__PURE__ */ new Map();\n    var toHook = [];\n    var proxyHandler = {\n      set(target, name, value) {\n        return setters.get(target)[name](value);\n      },\n      defineProperty(target, property, descriptor) {\n        if (!(\"value\" in descriptor)) {\n          throw new Error(\"Getters/setters are not supported for exports property descriptors.\");\n        }\n        return setters.get(target)[property](descriptor.value);\n      }\n    };\n    function register(name, namespace, set, specifier) {\n      specifiers.set(name, specifier);\n      setters.set(namespace, set);\n      const proxy = new Proxy(namespace, proxyHandler);\n      importHooks.forEach((hook) => hook(name, proxy));\n      toHook.push([name, proxy]);\n    }\n    exports.register = register;\n    exports.importHooks = importHooks;\n    exports.specifiers = specifiers;\n    exports.toHook = toHook;\n  }\n});\n\n// node_modules/import-in-the-middle/index.js\nvar require_import_in_the_middle = __commonJS({\n  \"node_modules/import-in-the-middle/index.js\"(exports, module2) {\n    var path3 = __webpack_require__(/*! path */ \"path\");\n    var parse4 = require_module_details_from_path();\n    var { fileURLToPath } = __webpack_require__(/*! url */ \"url\");\n    var {\n      importHooks,\n      specifiers,\n      toHook\n    } = require_register();\n    function addHook(hook) {\n      importHooks.push(hook);\n      toHook.forEach(([name, namespace]) => hook(name, namespace));\n    }\n    function removeHook(hook) {\n      const index = importHooks.indexOf(hook);\n      if (index > -1) {\n        importHooks.splice(index, 1);\n      }\n    }\n    function callHookFn(hookFn, namespace, name, baseDir) {\n      const newDefault = hookFn(namespace, name, baseDir);\n      if (newDefault && newDefault !== namespace) {\n        namespace.default = newDefault;\n      }\n    }\n    function Hook3(modules, options, hookFn) {\n      if (this instanceof Hook3 === false)\n        return new Hook3(modules, options, hookFn);\n      if (typeof modules === \"function\") {\n        hookFn = modules;\n        modules = null;\n        options = null;\n      } else if (typeof options === \"function\") {\n        hookFn = options;\n        options = null;\n      }\n      const internals = options ? options.internals === true : false;\n      this._iitmHook = (name, namespace) => {\n        const filename = name;\n        const isBuiltin = name.startsWith(\"node:\");\n        let baseDir;\n        if (isBuiltin) {\n          name = name.replace(/^node:/, \"\");\n        } else {\n          if (name.startsWith(\"file://\")) {\n            try {\n              name = fileURLToPath(name);\n            } catch (e) {\n            }\n          }\n          const details = parse4(name);\n          if (details) {\n            name = details.name;\n            baseDir = details.basedir;\n          }\n        }\n        if (modules) {\n          for (const moduleName of modules) {\n            if (moduleName === name) {\n              if (baseDir) {\n                if (internals) {\n                  name = name + path3.sep + path3.relative(baseDir, fileURLToPath(filename));\n                } else {\n                  if (!baseDir.endsWith(specifiers.get(filename)))\n                    continue;\n                }\n              }\n              callHookFn(hookFn, namespace, name, baseDir);\n            }\n          }\n        } else {\n          callHookFn(hookFn, namespace, name, baseDir);\n        }\n      };\n      addHook(this._iitmHook);\n    }\n    Hook3.prototype.unhook = function() {\n      removeHook(this._iitmHook);\n    };\n    module2.exports = Hook3;\n    module2.exports.addHook = addHook;\n    module2.exports.removeHook = removeHook;\n  }\n});\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  BaselimeSDK: () => BaselimeSDK,\n  BetterHttpInstrumentation: () => BetterHttpInstrumentation,\n  HttpPlugin: () => HttpPlugin,\n  StripePlugin: () => StripePlugin,\n  VercelPlugin: () => VercelPlugin\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/baselime.ts\nvar import_sdk_trace_node = __toESM(require_src2(), 1);\ninit_esm();\ninit_esm5();\nvar import_resource_detector_aws = __toESM(require_src3(), 1);\n\n// src/resources/vercel.ts\ninit_esm5();\ninit_esm2();\nvar VercelDetector = class {\n  detect(_config) {\n    if (!process.env.VERCEL) {\n      return Resource.empty();\n    }\n    const deploymentUrl = String(process.env.VERCEL_URL);\n    if (!deploymentUrl) {\n      return Resource.empty();\n    }\n    const gitBranchUrl = String(process.env.VERCEL_BRANCH_URL);\n    let serviceName;\n    let serviceNamespace;\n    if (gitBranchUrl) {\n      try {\n        serviceName = gitBranchUrl.split(\"-git-\")[0];\n        serviceNamespace = serviceName;\n      } catch (e) {\n      }\n    }\n    const attributes = {\n      [SEMRESATTRS_CLOUD_PROVIDER]: String(\n        \"Vercel\"\n      ),\n      [SEMRESATTRS_CLOUD_PLATFORM]: String(\n        \"Vercel Functions\"\n      ),\n      [SEMRESATTRS_CLOUD_REGION]: String(process.env.VERCEL_REGION),\n      \"vercel.environment\": String(process.env.VERCEL_ENV),\n      \"vercel.url\": String(process.env.VERCEL_URL),\n      \"vercel.url.branch\": String(process.env.VERCEL_BRANCH_URL),\n      \"vercel.git.provider\": String(process.env.VERCEL_GIT_PROVIDER),\n      \"vercel.git.repo\": String(process.env.VERCEL_GIT_REPO_SLUG),\n      \"vercel.git.commit\": String(process.env.VERCEL_GIT_COMMIT_SHA),\n      \"vercel.git.message\": String(process.env.VERCEL_GIT_COMMIT_MESSAGE),\n      \"vercel.git.author\": String(process.env.VERCEL_GIT_COMMIT_AUTHOR_NAME),\n      \"service.name\": serviceName,\n      \"service.namespace\": serviceNamespace\n    };\n    return new Resource(attributes);\n  }\n};\n\n// node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/node/OTLPTraceExporter.js\ninit_esm3();\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js\ninit_esm();\ninit_esm3();\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/util.js\ninit_esm();\ninit_esm3();\nvar __read16 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error) {\n    e = { error };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar DEFAULT_TRACE_TIMEOUT = 1e4;\nvar DEFAULT_EXPORT_MAX_ATTEMPTS = 5;\nvar DEFAULT_EXPORT_INITIAL_BACKOFF = 1e3;\nvar DEFAULT_EXPORT_MAX_BACKOFF = 5e3;\nvar DEFAULT_EXPORT_BACKOFF_MULTIPLIER = 1.5;\nfunction parseHeaders(partialHeaders) {\n  if (partialHeaders === void 0) {\n    partialHeaders = {};\n  }\n  var headers = {};\n  Object.entries(partialHeaders).forEach(function(_a2) {\n    var _b = __read16(_a2, 2), key = _b[0], value = _b[1];\n    if (typeof value !== \"undefined\") {\n      headers[key] = String(value);\n    } else {\n      diag2.warn('Header \"' + key + '\" has invalid value (' + value + \") and will be ignored\");\n    }\n  });\n  return headers;\n}\nfunction appendResourcePathToUrl(url4, path3) {\n  if (!url4.endsWith(\"/\")) {\n    url4 = url4 + \"/\";\n  }\n  return url4 + path3;\n}\nfunction appendRootPathToUrlIfNeeded(url4) {\n  try {\n    var parsedUrl = new URL(url4);\n    if (parsedUrl.pathname === \"\") {\n      parsedUrl.pathname = parsedUrl.pathname + \"/\";\n    }\n    return parsedUrl.toString();\n  } catch (_a2) {\n    diag2.warn(\"Could not parse export URL: '\" + url4 + \"'\");\n    return url4;\n  }\n}\nfunction configureExporterTimeout(timeoutMillis) {\n  if (typeof timeoutMillis === \"number\") {\n    if (timeoutMillis <= 0) {\n      return invalidTimeout(timeoutMillis, DEFAULT_TRACE_TIMEOUT);\n    }\n    return timeoutMillis;\n  } else {\n    return getExporterTimeoutFromEnv();\n  }\n}\nfunction getExporterTimeoutFromEnv() {\n  var _a2;\n  var definedTimeout = Number((_a2 = getEnv().OTEL_EXPORTER_OTLP_TRACES_TIMEOUT) !== null && _a2 !== void 0 ? _a2 : getEnv().OTEL_EXPORTER_OTLP_TIMEOUT);\n  if (definedTimeout <= 0) {\n    return invalidTimeout(definedTimeout, DEFAULT_TRACE_TIMEOUT);\n  } else {\n    return definedTimeout;\n  }\n}\nfunction invalidTimeout(timeout, defaultTimeout) {\n  diag2.warn(\"Timeout must be greater than 0\", timeout);\n  return defaultTimeout;\n}\nfunction isExportRetryable(statusCode) {\n  var retryCodes = [429, 502, 503, 504];\n  return retryCodes.includes(statusCode);\n}\nfunction parseRetryAfterToMills(retryAfter) {\n  if (retryAfter == null) {\n    return -1;\n  }\n  var seconds = Number.parseInt(retryAfter, 10);\n  if (Number.isInteger(seconds)) {\n    return seconds > 0 ? seconds * 1e3 : -1;\n  }\n  var delay = new Date(retryAfter).getTime() - Date.now();\n  if (delay >= 0) {\n    return delay;\n  }\n  return 0;\n}\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js\nvar OTLPExporterBase = (\n  /** @class */\n  function() {\n    function OTLPExporterBase2(config) {\n      if (config === void 0) {\n        config = {};\n      }\n      this._sendingPromises = [];\n      this.url = this.getDefaultUrl(config);\n      if (typeof config.hostname === \"string\") {\n        this.hostname = config.hostname;\n      }\n      this.shutdown = this.shutdown.bind(this);\n      this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n      this._concurrencyLimit = typeof config.concurrencyLimit === \"number\" ? config.concurrencyLimit : 30;\n      this.timeoutMillis = configureExporterTimeout(config.timeoutMillis);\n      this.onInit(config);\n    }\n    OTLPExporterBase2.prototype.export = function(items, resultCallback) {\n      if (this._shutdownOnce.isCalled) {\n        resultCallback({\n          code: ExportResultCode.FAILED,\n          error: new Error(\"Exporter has been shutdown\")\n        });\n        return;\n      }\n      if (this._sendingPromises.length >= this._concurrencyLimit) {\n        resultCallback({\n          code: ExportResultCode.FAILED,\n          error: new Error(\"Concurrent export limit reached\")\n        });\n        return;\n      }\n      this._export(items).then(function() {\n        resultCallback({ code: ExportResultCode.SUCCESS });\n      }).catch(function(error) {\n        resultCallback({ code: ExportResultCode.FAILED, error });\n      });\n    };\n    OTLPExporterBase2.prototype._export = function(items) {\n      var _this = this;\n      return new Promise(function(resolve, reject) {\n        try {\n          diag2.debug(\"items to be sent\", items);\n          _this.send(items, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    };\n    OTLPExporterBase2.prototype.shutdown = function() {\n      return this._shutdownOnce.call();\n    };\n    OTLPExporterBase2.prototype.forceFlush = function() {\n      return Promise.all(this._sendingPromises).then(function() {\n      });\n    };\n    OTLPExporterBase2.prototype._shutdown = function() {\n      diag2.debug(\"shutdown started\");\n      this.onShutdown();\n      return this.forceFlush();\n    };\n    return OTLPExporterBase2;\n  }()\n);\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/util.js\nvar url = __toESM(__webpack_require__(/*! url */ \"url\"));\nvar http = __toESM(__webpack_require__(/*! http */ \"http\"));\nvar https = __toESM(__webpack_require__(/*! https */ \"https\"));\nvar zlib = __toESM(__webpack_require__(/*! zlib */ \"zlib\"));\nvar import_stream = __webpack_require__(/*! stream */ \"stream\");\ninit_esm();\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/types.js\nvar CompressionAlgorithm;\n(function(CompressionAlgorithm2) {\n  CompressionAlgorithm2[\"NONE\"] = \"none\";\n  CompressionAlgorithm2[\"GZIP\"] = \"gzip\";\n})(CompressionAlgorithm || (CompressionAlgorithm = {}));\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/util.js\ninit_esm3();\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/types.js\nvar __extends4 = function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p))\n          d2[p] = b2[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar OTLPExporterError = (\n  /** @class */\n  function(_super) {\n    __extends4(OTLPExporterError2, _super);\n    function OTLPExporterError2(message, code, data) {\n      var _this = _super.call(this, message) || this;\n      _this.name = \"OTLPExporterError\";\n      _this.data = data;\n      _this.code = code;\n      return _this;\n    }\n    return OTLPExporterError2;\n  }(Error)\n);\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/util.js\nvar __assign3 = function() {\n  __assign3 = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign3.apply(this, arguments);\n};\nfunction sendWithHttp(collector, data, contentType, onSuccess, onError) {\n  var exporterTimeout = collector.timeoutMillis;\n  var parsedUrl = new url.URL(collector.url);\n  var nodeVersion = Number(process.versions.node.split(\".\")[0]);\n  var retryTimer;\n  var req;\n  var reqIsDestroyed = false;\n  var exporterTimer = setTimeout(function() {\n    clearTimeout(retryTimer);\n    reqIsDestroyed = true;\n    if (req.destroyed) {\n      var err = new OTLPExporterError(\"Request Timeout\");\n      onError(err);\n    } else {\n      nodeVersion >= 14 ? req.destroy() : req.abort();\n    }\n  }, exporterTimeout);\n  var options = {\n    hostname: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.pathname,\n    method: \"POST\",\n    headers: __assign3({ \"Content-Type\": contentType }, collector.headers),\n    agent: collector.agent\n  };\n  var request3 = parsedUrl.protocol === \"http:\" ? http.request : https.request;\n  var sendWithRetry = function(retries, minDelay) {\n    if (retries === void 0) {\n      retries = DEFAULT_EXPORT_MAX_ATTEMPTS;\n    }\n    if (minDelay === void 0) {\n      minDelay = DEFAULT_EXPORT_INITIAL_BACKOFF;\n    }\n    req = request3(options, function(res) {\n      var responseData = \"\";\n      res.on(\"data\", function(chunk) {\n        return responseData += chunk;\n      });\n      res.on(\"aborted\", function() {\n        if (reqIsDestroyed) {\n          var err = new OTLPExporterError(\"Request Timeout\");\n          onError(err);\n        }\n      });\n      res.on(\"end\", function() {\n        if (reqIsDestroyed === false) {\n          if (res.statusCode && res.statusCode < 299) {\n            diag2.debug(\"statusCode: \" + res.statusCode, responseData);\n            onSuccess();\n            clearTimeout(exporterTimer);\n            clearTimeout(retryTimer);\n          } else if (res.statusCode && isExportRetryable(res.statusCode) && retries > 0) {\n            var retryTime = void 0;\n            minDelay = DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay;\n            if (res.headers[\"retry-after\"]) {\n              retryTime = parseRetryAfterToMills(res.headers[\"retry-after\"]);\n            } else {\n              retryTime = Math.round(Math.random() * (DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay);\n            }\n            retryTimer = setTimeout(function() {\n              sendWithRetry(retries - 1, minDelay);\n            }, retryTime);\n          } else {\n            var error = new OTLPExporterError(res.statusMessage, res.statusCode, responseData);\n            onError(error);\n            clearTimeout(exporterTimer);\n            clearTimeout(retryTimer);\n          }\n        }\n      });\n    });\n    req.on(\"error\", function(error) {\n      if (reqIsDestroyed) {\n        var err = new OTLPExporterError(\"Request Timeout\", error.code);\n        onError(err);\n      } else {\n        onError(error);\n      }\n      clearTimeout(exporterTimer);\n      clearTimeout(retryTimer);\n    });\n    req.on(\"abort\", function() {\n      if (reqIsDestroyed) {\n        var err = new OTLPExporterError(\"Request Timeout\");\n        onError(err);\n      }\n      clearTimeout(exporterTimer);\n      clearTimeout(retryTimer);\n    });\n    switch (collector.compression) {\n      case CompressionAlgorithm.GZIP: {\n        req.setHeader(\"Content-Encoding\", \"gzip\");\n        var dataStream = readableFromBuffer(data);\n        dataStream.on(\"error\", onError).pipe(zlib.createGzip()).on(\"error\", onError).pipe(req);\n        break;\n      }\n      default:\n        req.end(data);\n        break;\n    }\n  };\n  sendWithRetry();\n}\nfunction readableFromBuffer(buff) {\n  var readable = new import_stream.Readable();\n  readable.push(buff);\n  readable.push(null);\n  return readable;\n}\nfunction createHttpAgent(config) {\n  if (config.httpAgentOptions && config.keepAlive === false) {\n    diag2.warn(\"httpAgentOptions is used only when keepAlive is true\");\n    return void 0;\n  }\n  if (config.keepAlive === false || !config.url)\n    return void 0;\n  try {\n    var parsedUrl = new url.URL(config.url);\n    var Agent3 = parsedUrl.protocol === \"http:\" ? http.Agent : https.Agent;\n    return new Agent3(__assign3({ keepAlive: true }, config.httpAgentOptions));\n  } catch (err) {\n    diag2.error(\"collector exporter failed to create http agent. err: \" + err.message);\n    return void 0;\n  }\n}\nfunction configureCompression(compression) {\n  if (compression) {\n    return compression;\n  } else {\n    var definedCompression = getEnv().OTEL_EXPORTER_OTLP_TRACES_COMPRESSION || getEnv().OTEL_EXPORTER_OTLP_COMPRESSION;\n    return definedCompression === CompressionAlgorithm.GZIP ? CompressionAlgorithm.GZIP : CompressionAlgorithm.NONE;\n  }\n}\n\n// node_modules/@opentelemetry/otlp-exporter-base/build/esm/platform/node/OTLPExporterNodeBase.js\ninit_esm();\ninit_esm3();\nvar __extends5 = function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p))\n          d2[p] = b2[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar OTLPExporterNodeBase = (\n  /** @class */\n  function(_super) {\n    __extends5(OTLPExporterNodeBase2, _super);\n    function OTLPExporterNodeBase2(config) {\n      if (config === void 0) {\n        config = {};\n      }\n      var _this = _super.call(this, config) || this;\n      _this.DEFAULT_HEADERS = {};\n      if (config.metadata) {\n        diag2.warn(\"Metadata cannot be set when using http\");\n      }\n      _this.headers = Object.assign(_this.DEFAULT_HEADERS, parseHeaders(config.headers), utils_exports.parseKeyPairsIntoRecord(getEnv().OTEL_EXPORTER_OTLP_HEADERS));\n      _this.agent = createHttpAgent(config);\n      _this.compression = configureCompression(config.compression);\n      return _this;\n    }\n    OTLPExporterNodeBase2.prototype.onInit = function(_config) {\n    };\n    OTLPExporterNodeBase2.prototype.send = function(objects, onSuccess, onError) {\n      var _this = this;\n      if (this._shutdownOnce.isCalled) {\n        diag2.debug(\"Shutdown already started. Cannot send objects\");\n        return;\n      }\n      var serviceRequest = this.convert(objects);\n      var promise = new Promise(function(resolve, reject) {\n        sendWithHttp(_this, JSON.stringify(serviceRequest), \"application/json\", resolve, reject);\n      }).then(onSuccess, onError);\n      this._sendingPromises.push(promise);\n      var popPromise = function() {\n        var index = _this._sendingPromises.indexOf(promise);\n        _this._sendingPromises.splice(index, 1);\n      };\n      promise.then(popPromise, popPromise);\n    };\n    OTLPExporterNodeBase2.prototype.onShutdown = function() {\n    };\n    return OTLPExporterNodeBase2;\n  }(OTLPExporterBase)\n);\n\n// node_modules/@opentelemetry/otlp-transformer/build/esm/common/index.js\ninit_esm3();\nfunction hrTimeToNanos(hrTime2) {\n  var NANOSECONDS = BigInt(1e9);\n  return BigInt(hrTime2[0]) * NANOSECONDS + BigInt(hrTime2[1]);\n}\nfunction toLongBits(value) {\n  var low = Number(BigInt.asUintN(32, value));\n  var high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return { low, high };\n}\nfunction encodeAsLongBits(hrTime2) {\n  var nanos = hrTimeToNanos(hrTime2);\n  return toLongBits(nanos);\n}\nfunction encodeAsString(hrTime2) {\n  var nanos = hrTimeToNanos(hrTime2);\n  return nanos.toString();\n}\nvar encodeTimestamp = typeof BigInt !== \"undefined\" ? encodeAsString : hrTimeToNanoseconds;\nfunction identity(value) {\n  return value;\n}\nfunction optionalHexToBinary(str) {\n  if (str === void 0)\n    return void 0;\n  return hexToBinary(str);\n}\nvar DEFAULT_ENCODER = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary\n};\nfunction getOtlpEncoder(options) {\n  var _a2, _b;\n  if (options === void 0) {\n    return DEFAULT_ENCODER;\n  }\n  var useLongBits = (_a2 = options.useLongBits) !== null && _a2 !== void 0 ? _a2 : true;\n  var useHex = (_b = options.useHex) !== null && _b !== void 0 ? _b : false;\n  return {\n    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,\n    encodeSpanContext: useHex ? identity : hexToBinary,\n    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary\n  };\n}\n\n// node_modules/@opentelemetry/otlp-transformer/build/esm/common/internal.js\nvar __read17 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error) {\n    e = { error };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nfunction toAttributes(attributes) {\n  return Object.keys(attributes).map(function(key) {\n    return toKeyValue(key, attributes[key]);\n  });\n}\nfunction toKeyValue(key, value) {\n  return {\n    key,\n    value: toAnyValue(value)\n  };\n}\nfunction toAnyValue(value) {\n  var t = typeof value;\n  if (t === \"string\")\n    return { stringValue: value };\n  if (t === \"number\") {\n    if (!Number.isInteger(value))\n      return { doubleValue: value };\n    return { intValue: value };\n  }\n  if (t === \"boolean\")\n    return { boolValue: value };\n  if (value instanceof Uint8Array)\n    return { bytesValue: value };\n  if (Array.isArray(value))\n    return { arrayValue: { values: value.map(toAnyValue) } };\n  if (t === \"object\" && value != null)\n    return {\n      kvlistValue: {\n        values: Object.entries(value).map(function(_a2) {\n          var _b = __read17(_a2, 2), k = _b[0], v = _b[1];\n          return toKeyValue(k, v);\n        })\n      }\n    };\n  return {};\n}\n\n// node_modules/@opentelemetry/otlp-transformer/build/esm/trace/internal.js\nfunction sdkSpanToOtlpSpan(span, encoder) {\n  var _a2;\n  var ctx = span.spanContext();\n  var status = span.status;\n  return {\n    traceId: encoder.encodeSpanContext(ctx.traceId),\n    spanId: encoder.encodeSpanContext(ctx.spanId),\n    parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),\n    traceState: (_a2 = ctx.traceState) === null || _a2 === void 0 ? void 0 : _a2.serialize(),\n    name: span.name,\n    // Span kind is offset by 1 because the API does not define a value for unset\n    kind: span.kind == null ? 0 : span.kind + 1,\n    startTimeUnixNano: encoder.encodeHrTime(span.startTime),\n    endTimeUnixNano: encoder.encodeHrTime(span.endTime),\n    attributes: toAttributes(span.attributes),\n    droppedAttributesCount: span.droppedAttributesCount,\n    events: span.events.map(function(event) {\n      return toOtlpSpanEvent(event, encoder);\n    }),\n    droppedEventsCount: span.droppedEventsCount,\n    status: {\n      // API and proto enums share the same values\n      code: status.code,\n      message: status.message\n    },\n    links: span.links.map(function(link) {\n      return toOtlpLink(link, encoder);\n    }),\n    droppedLinksCount: span.droppedLinksCount\n  };\n}\nfunction toOtlpLink(link, encoder) {\n  var _a2;\n  return {\n    attributes: link.attributes ? toAttributes(link.attributes) : [],\n    spanId: encoder.encodeSpanContext(link.context.spanId),\n    traceId: encoder.encodeSpanContext(link.context.traceId),\n    traceState: (_a2 = link.context.traceState) === null || _a2 === void 0 ? void 0 : _a2.serialize(),\n    droppedAttributesCount: link.droppedAttributesCount || 0\n  };\n}\nfunction toOtlpSpanEvent(timedEvent, encoder) {\n  return {\n    attributes: timedEvent.attributes ? toAttributes(timedEvent.attributes) : [],\n    name: timedEvent.name,\n    timeUnixNano: encoder.encodeHrTime(timedEvent.time),\n    droppedAttributesCount: timedEvent.droppedAttributesCount || 0\n  };\n}\n\n// node_modules/@opentelemetry/otlp-transformer/build/esm/trace/index.js\nvar __values11 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read18 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error) {\n    e = { error };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nfunction createExportTraceServiceRequest(spans, options) {\n  var encoder = getOtlpEncoder(options);\n  return {\n    resourceSpans: spanRecordsToResourceSpans(spans, encoder)\n  };\n}\nfunction createResourceMap(readableSpans) {\n  var e_1, _a2;\n  var resourceMap = /* @__PURE__ */ new Map();\n  try {\n    for (var readableSpans_1 = __values11(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {\n      var record = readableSpans_1_1.value;\n      var ilmMap = resourceMap.get(record.resource);\n      if (!ilmMap) {\n        ilmMap = /* @__PURE__ */ new Map();\n        resourceMap.set(record.resource, ilmMap);\n      }\n      var instrumentationLibraryKey = record.instrumentationLibrary.name + \"@\" + (record.instrumentationLibrary.version || \"\") + \":\" + (record.instrumentationLibrary.schemaUrl || \"\");\n      var records = ilmMap.get(instrumentationLibraryKey);\n      if (!records) {\n        records = [];\n        ilmMap.set(instrumentationLibraryKey, records);\n      }\n      records.push(record);\n    }\n  } catch (e_1_1) {\n    e_1 = { error: e_1_1 };\n  } finally {\n    try {\n      if (readableSpans_1_1 && !readableSpans_1_1.done && (_a2 = readableSpans_1.return))\n        _a2.call(readableSpans_1);\n    } finally {\n      if (e_1)\n        throw e_1.error;\n    }\n  }\n  return resourceMap;\n}\nfunction spanRecordsToResourceSpans(readableSpans, encoder) {\n  var resourceMap = createResourceMap(readableSpans);\n  var out = [];\n  var entryIterator = resourceMap.entries();\n  var entry = entryIterator.next();\n  while (!entry.done) {\n    var _a2 = __read18(entry.value, 2), resource = _a2[0], ilmMap = _a2[1];\n    var scopeResourceSpans = [];\n    var ilmIterator = ilmMap.values();\n    var ilmEntry = ilmIterator.next();\n    while (!ilmEntry.done) {\n      var scopeSpans = ilmEntry.value;\n      if (scopeSpans.length > 0) {\n        var _b = scopeSpans[0].instrumentationLibrary, name_1 = _b.name, version = _b.version, schemaUrl = _b.schemaUrl;\n        var spans = scopeSpans.map(function(readableSpan) {\n          return sdkSpanToOtlpSpan(readableSpan, encoder);\n        });\n        scopeResourceSpans.push({\n          scope: { name: name_1, version },\n          spans,\n          schemaUrl\n        });\n      }\n      ilmEntry = ilmIterator.next();\n    }\n    var transformedSpans = {\n      resource: {\n        attributes: toAttributes(resource.attributes),\n        droppedAttributesCount: 0\n      },\n      scopeSpans: scopeResourceSpans,\n      schemaUrl: void 0\n    };\n    out.push(transformedSpans);\n    entry = entryIterator.next();\n  }\n  return out;\n}\n\n// node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/version.js\nvar VERSION4 = \"0.50.0\";\n\n// node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/node/OTLPTraceExporter.js\nvar __extends6 = function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p))\n          d2[p] = b2[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign4 = function() {\n  __assign4 = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign4.apply(this, arguments);\n};\nvar DEFAULT_COLLECTOR_RESOURCE_PATH = \"v1/traces\";\nvar DEFAULT_COLLECTOR_URL = \"http://localhost:4318/\" + DEFAULT_COLLECTOR_RESOURCE_PATH;\nvar USER_AGENT = {\n  \"User-Agent\": \"OTel-OTLP-Exporter-JavaScript/\" + VERSION4\n};\nvar OTLPTraceExporter = (\n  /** @class */\n  function(_super) {\n    __extends6(OTLPTraceExporter2, _super);\n    function OTLPTraceExporter2(config) {\n      if (config === void 0) {\n        config = {};\n      }\n      var _this = _super.call(this, config) || this;\n      _this.headers = __assign4(__assign4(__assign4(__assign4({}, _this.headers), USER_AGENT), utils_exports.parseKeyPairsIntoRecord(getEnv().OTEL_EXPORTER_OTLP_TRACES_HEADERS)), parseHeaders(config === null || config === void 0 ? void 0 : config.headers));\n      return _this;\n    }\n    OTLPTraceExporter2.prototype.convert = function(spans) {\n      return createExportTraceServiceRequest(spans, {\n        useHex: true,\n        useLongBits: false\n      });\n    };\n    OTLPTraceExporter2.prototype.getDefaultUrl = function(config) {\n      return typeof config.url === \"string\" ? config.url : getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT.length > 0 ? appendRootPathToUrlIfNeeded(getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT) : getEnv().OTEL_EXPORTER_OTLP_ENDPOINT.length > 0 ? appendResourcePathToUrl(getEnv().OTEL_EXPORTER_OTLP_ENDPOINT, DEFAULT_COLLECTOR_RESOURCE_PATH) : DEFAULT_COLLECTOR_URL;\n    };\n    return OTLPTraceExporter2;\n  }(OTLPExporterNodeBase)\n);\n\n// node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js\ninit_esm();\n\n// node_modules/@opentelemetry/api-logs/build/esm/NoopLogger.js\nvar NoopLogger = (\n  /** @class */\n  function() {\n    function NoopLogger2() {\n    }\n    NoopLogger2.prototype.emit = function(_logRecord) {\n    };\n    return NoopLogger2;\n  }()\n);\nvar NOOP_LOGGER = new NoopLogger();\n\n// node_modules/@opentelemetry/api-logs/build/esm/NoopLoggerProvider.js\nvar NoopLoggerProvider = (\n  /** @class */\n  function() {\n    function NoopLoggerProvider2() {\n    }\n    NoopLoggerProvider2.prototype.getLogger = function(_name, _version, _options) {\n      return new NoopLogger();\n    };\n    return NoopLoggerProvider2;\n  }()\n);\nvar NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();\n\n// node_modules/@opentelemetry/api-logs/build/esm/platform/node/globalThis.js\nvar _globalThis4 = typeof globalThis === \"object\" ? globalThis : global;\n\n// node_modules/@opentelemetry/api-logs/build/esm/internal/global-utils.js\nvar GLOBAL_LOGS_API_KEY = Symbol.for(\"io.opentelemetry.js.api.logs\");\nvar _global2 = _globalThis4;\nfunction makeGetter(requiredVersion, instance, fallback) {\n  return function(version) {\n    return version === requiredVersion ? instance : fallback;\n  };\n}\nvar API_BACKWARDS_COMPATIBILITY_VERSION = 1;\n\n// node_modules/@opentelemetry/api-logs/build/esm/api/logs.js\nvar LogsAPI = (\n  /** @class */\n  function() {\n    function LogsAPI2() {\n    }\n    LogsAPI2.getInstance = function() {\n      if (!this._instance) {\n        this._instance = new LogsAPI2();\n      }\n      return this._instance;\n    };\n    LogsAPI2.prototype.setGlobalLoggerProvider = function(provider) {\n      if (_global2[GLOBAL_LOGS_API_KEY]) {\n        return this.getLoggerProvider();\n      }\n      _global2[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);\n      return provider;\n    };\n    LogsAPI2.prototype.getLoggerProvider = function() {\n      var _a2, _b;\n      return (_b = (_a2 = _global2[GLOBAL_LOGS_API_KEY]) === null || _a2 === void 0 ? void 0 : _a2.call(_global2, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_LOGGER_PROVIDER;\n    };\n    LogsAPI2.prototype.getLogger = function(name, version, options) {\n      return this.getLoggerProvider().getLogger(name, version, options);\n    };\n    LogsAPI2.prototype.disable = function() {\n      delete _global2[GLOBAL_LOGS_API_KEY];\n    };\n    return LogsAPI2;\n  }()\n);\n\n// node_modules/@opentelemetry/api-logs/build/esm/index.js\nvar logs = LogsAPI.getInstance();\n\n// node_modules/@opentelemetry/instrumentation/build/esm/autoLoaderUtils.js\nfunction parseInstrumentationOptions(options) {\n  if (options === void 0) {\n    options = [];\n  }\n  var instrumentations = [];\n  for (var i = 0, j = options.length; i < j; i++) {\n    var option = options[i];\n    if (Array.isArray(option)) {\n      var results = parseInstrumentationOptions(option);\n      instrumentations = instrumentations.concat(results.instrumentations);\n    } else if (typeof option === \"function\") {\n      instrumentations.push(new option());\n    } else if (option.instrumentationName) {\n      instrumentations.push(option);\n    }\n  }\n  return { instrumentations };\n}\nfunction enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {\n  for (var i = 0, j = instrumentations.length; i < j; i++) {\n    var instrumentation = instrumentations[i];\n    if (tracerProvider) {\n      instrumentation.setTracerProvider(tracerProvider);\n    }\n    if (meterProvider) {\n      instrumentation.setMeterProvider(meterProvider);\n    }\n    if (loggerProvider && instrumentation.setLoggerProvider) {\n      instrumentation.setLoggerProvider(loggerProvider);\n    }\n    if (!instrumentation.getConfig().enabled) {\n      instrumentation.enable();\n    }\n  }\n}\nfunction disableInstrumentations(instrumentations) {\n  instrumentations.forEach(function(instrumentation) {\n    return instrumentation.disable();\n  });\n}\n\n// node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js\nfunction registerInstrumentations(options) {\n  var instrumentations = parseInstrumentationOptions(options.instrumentations).instrumentations;\n  var tracerProvider = options.tracerProvider || trace.getTracerProvider();\n  var meterProvider = options.meterProvider || metrics.getMeterProvider();\n  var loggerProvider = options.loggerProvider || logs.getLoggerProvider();\n  enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider);\n  return function() {\n    disableInstrumentations(instrumentations);\n  };\n}\n\n// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js\nvar path2 = __toESM(__webpack_require__(/*! path */ \"path\"));\nvar import_util6 = __webpack_require__(/*! util */ \"util\");\nvar import_semver2 = __toESM(require_semver2());\nvar import_shimmer = __toESM(require_shimmer());\n\n// node_modules/@opentelemetry/instrumentation/build/esm/instrumentation.js\ninit_esm();\nvar shimmer = __toESM(require_shimmer());\nvar __assign5 = function() {\n  __assign5 = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign5.apply(this, arguments);\n};\nvar InstrumentationAbstract = (\n  /** @class */\n  function() {\n    function InstrumentationAbstract2(instrumentationName, instrumentationVersion, config) {\n      if (config === void 0) {\n        config = {};\n      }\n      this.instrumentationName = instrumentationName;\n      this.instrumentationVersion = instrumentationVersion;\n      this._wrap = shimmer.wrap;\n      this._unwrap = shimmer.unwrap;\n      this._massWrap = shimmer.massWrap;\n      this._massUnwrap = shimmer.massUnwrap;\n      this._config = __assign5({ enabled: true }, config);\n      this._diag = diag2.createComponentLogger({\n        namespace: instrumentationName\n      });\n      this._tracer = trace.getTracer(instrumentationName, instrumentationVersion);\n      this._meter = metrics.getMeter(instrumentationName, instrumentationVersion);\n      this._logger = logs.getLogger(instrumentationName, instrumentationVersion);\n      this._updateMetricInstruments();\n    }\n    Object.defineProperty(InstrumentationAbstract2.prototype, \"meter\", {\n      /* Returns meter */\n      get: function() {\n        return this._meter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    InstrumentationAbstract2.prototype.setMeterProvider = function(meterProvider) {\n      this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);\n      this._updateMetricInstruments();\n    };\n    Object.defineProperty(InstrumentationAbstract2.prototype, \"logger\", {\n      /* Returns logger */\n      get: function() {\n        return this._logger;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    InstrumentationAbstract2.prototype.setLoggerProvider = function(loggerProvider) {\n      this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);\n    };\n    InstrumentationAbstract2.prototype.getModuleDefinitions = function() {\n      var _a2;\n      var initResult = (_a2 = this.init()) !== null && _a2 !== void 0 ? _a2 : [];\n      if (!Array.isArray(initResult)) {\n        return [initResult];\n      }\n      return initResult;\n    };\n    InstrumentationAbstract2.prototype._updateMetricInstruments = function() {\n      return;\n    };\n    InstrumentationAbstract2.prototype.getConfig = function() {\n      return this._config;\n    };\n    InstrumentationAbstract2.prototype.setConfig = function(config) {\n      if (config === void 0) {\n        config = {};\n      }\n      this._config = Object.assign({}, config);\n    };\n    InstrumentationAbstract2.prototype.setTracerProvider = function(tracerProvider) {\n      this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);\n    };\n    Object.defineProperty(InstrumentationAbstract2.prototype, \"tracer\", {\n      /* Returns tracer */\n      get: function() {\n        return this._tracer;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return InstrumentationAbstract2;\n  }()\n);\n\n// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/RequireInTheMiddleSingleton.js\nvar import_require_in_the_middle = __toESM(require_require_in_the_middle());\nvar path = __toESM(__webpack_require__(/*! path */ \"path\"));\n\n// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/ModuleNameTrie.js\nvar __values12 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read19 = function(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error) {\n    e = { error };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray8 = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar ModuleNameSeparator = \"/\";\nvar ModuleNameTrieNode = (\n  /** @class */\n  function() {\n    function ModuleNameTrieNode2() {\n      this.hooks = [];\n      this.children = /* @__PURE__ */ new Map();\n    }\n    return ModuleNameTrieNode2;\n  }()\n);\nvar ModuleNameTrie = (\n  /** @class */\n  function() {\n    function ModuleNameTrie2() {\n      this._trie = new ModuleNameTrieNode();\n      this._counter = 0;\n    }\n    ModuleNameTrie2.prototype.insert = function(hook) {\n      var e_1, _a2;\n      var trieNode = this._trie;\n      try {\n        for (var _b = __values12(hook.moduleName.split(ModuleNameSeparator)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var moduleNamePart = _c.value;\n          var nextNode = trieNode.children.get(moduleNamePart);\n          if (!nextNode) {\n            nextNode = new ModuleNameTrieNode();\n            trieNode.children.set(moduleNamePart, nextNode);\n          }\n          trieNode = nextNode;\n        }\n      } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a2 = _b.return))\n            _a2.call(_b);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      trieNode.hooks.push({ hook, insertedId: this._counter++ });\n    };\n    ModuleNameTrie2.prototype.search = function(moduleName, _a2) {\n      var e_2, _b;\n      var _c = _a2 === void 0 ? {} : _a2, maintainInsertionOrder = _c.maintainInsertionOrder, fullOnly = _c.fullOnly;\n      var trieNode = this._trie;\n      var results = [];\n      var foundFull = true;\n      try {\n        for (var _d = __values12(moduleName.split(ModuleNameSeparator)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var moduleNamePart = _e.value;\n          var nextNode = trieNode.children.get(moduleNamePart);\n          if (!nextNode) {\n            foundFull = false;\n            break;\n          }\n          if (!fullOnly) {\n            results.push.apply(results, __spreadArray8([], __read19(nextNode.hooks), false));\n          }\n          trieNode = nextNode;\n        }\n      } catch (e_2_1) {\n        e_2 = { error: e_2_1 };\n      } finally {\n        try {\n          if (_e && !_e.done && (_b = _d.return))\n            _b.call(_d);\n        } finally {\n          if (e_2)\n            throw e_2.error;\n        }\n      }\n      if (fullOnly && foundFull) {\n        results.push.apply(results, __spreadArray8([], __read19(trieNode.hooks), false));\n      }\n      if (results.length === 0) {\n        return [];\n      }\n      if (results.length === 1) {\n        return [results[0].hook];\n      }\n      if (maintainInsertionOrder) {\n        results.sort(function(a, b) {\n          return a.insertedId - b.insertedId;\n        });\n      }\n      return results.map(function(_a3) {\n        var hook = _a3.hook;\n        return hook;\n      });\n    };\n    return ModuleNameTrie2;\n  }()\n);\n\n// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/RequireInTheMiddleSingleton.js\nvar __values13 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar isMocha = [\n  \"afterEach\",\n  \"after\",\n  \"beforeEach\",\n  \"before\",\n  \"describe\",\n  \"it\"\n].every(function(fn) {\n  return typeof global[fn] === \"function\";\n});\nvar RequireInTheMiddleSingleton = (\n  /** @class */\n  function() {\n    function RequireInTheMiddleSingleton2() {\n      this._moduleNameTrie = new ModuleNameTrie();\n      this._initialize();\n    }\n    RequireInTheMiddleSingleton2.prototype._initialize = function() {\n      var _this = this;\n      new import_require_in_the_middle.Hook(\n        // Intercept all `require` calls; we will filter the matching ones below\n        null,\n        { internals: true },\n        function(exports, name, basedir) {\n          var e_1, _a2;\n          var normalizedModuleName = normalizePathSeparators(name);\n          var matches = _this._moduleNameTrie.search(normalizedModuleName, {\n            maintainInsertionOrder: true,\n            // For core modules (e.g. `fs`), do not match on sub-paths (e.g. `fs/promises').\n            // This matches the behavior of `require-in-the-middle`.\n            // `basedir` is always `undefined` for core modules.\n            fullOnly: basedir === void 0\n          });\n          try {\n            for (var matches_1 = __values13(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {\n              var onRequire = matches_1_1.value.onRequire;\n              exports = onRequire(exports, name, basedir);\n            }\n          } catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n          } finally {\n            try {\n              if (matches_1_1 && !matches_1_1.done && (_a2 = matches_1.return))\n                _a2.call(matches_1);\n            } finally {\n              if (e_1)\n                throw e_1.error;\n            }\n          }\n          return exports;\n        }\n      );\n    };\n    RequireInTheMiddleSingleton2.prototype.register = function(moduleName, onRequire) {\n      var hooked = { moduleName, onRequire };\n      this._moduleNameTrie.insert(hooked);\n      return hooked;\n    };\n    RequireInTheMiddleSingleton2.getInstance = function() {\n      var _a2;\n      if (isMocha)\n        return new RequireInTheMiddleSingleton2();\n      return this._instance = (_a2 = this._instance) !== null && _a2 !== void 0 ? _a2 : new RequireInTheMiddleSingleton2();\n    };\n    return RequireInTheMiddleSingleton2;\n  }()\n);\nfunction normalizePathSeparators(moduleNameOrPath) {\n  return path.sep !== ModuleNameSeparator ? moduleNameOrPath.split(path.sep).join(ModuleNameSeparator) : moduleNameOrPath;\n}\n\n// node_modules/@opentelemetry/instrumentation/build/esm/platform/node/instrumentation.js\nvar import_import_in_the_middle = __toESM(require_import_in_the_middle());\ninit_esm();\nvar import_require_in_the_middle2 = __toESM(require_require_in_the_middle());\nvar __extends7 = function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p))\n          d2[p] = b2[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values14 = function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar InstrumentationBase = (\n  /** @class */\n  function(_super) {\n    __extends7(InstrumentationBase2, _super);\n    function InstrumentationBase2(instrumentationName, instrumentationVersion, config) {\n      if (config === void 0) {\n        config = {};\n      }\n      var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;\n      _this._hooks = [];\n      _this._requireInTheMiddleSingleton = RequireInTheMiddleSingleton.getInstance();\n      _this._enabled = false;\n      _this._wrap = function(moduleExports, name, wrapper) {\n        if (!import_util6.types.isProxy(moduleExports)) {\n          return (0, import_shimmer.wrap)(moduleExports, name, wrapper);\n        } else {\n          var wrapped = (0, import_shimmer.wrap)(Object.assign({}, moduleExports), name, wrapper);\n          return Object.defineProperty(moduleExports, name, {\n            value: wrapped\n          });\n        }\n      };\n      _this._unwrap = function(moduleExports, name) {\n        if (!import_util6.types.isProxy(moduleExports)) {\n          return (0, import_shimmer.unwrap)(moduleExports, name);\n        } else {\n          return Object.defineProperty(moduleExports, name, {\n            value: moduleExports[name]\n          });\n        }\n      };\n      _this._massWrap = function(moduleExportsArray, names, wrapper) {\n        if (!moduleExportsArray) {\n          diag2.error(\"must provide one or more modules to patch\");\n          return;\n        } else if (!Array.isArray(moduleExportsArray)) {\n          moduleExportsArray = [moduleExportsArray];\n        }\n        if (!(names && Array.isArray(names))) {\n          diag2.error(\"must provide one or more functions to wrap on modules\");\n          return;\n        }\n        moduleExportsArray.forEach(function(moduleExports) {\n          names.forEach(function(name) {\n            _this._wrap(moduleExports, name, wrapper);\n          });\n        });\n      };\n      _this._massUnwrap = function(moduleExportsArray, names) {\n        if (!moduleExportsArray) {\n          diag2.error(\"must provide one or more modules to patch\");\n          return;\n        } else if (!Array.isArray(moduleExportsArray)) {\n          moduleExportsArray = [moduleExportsArray];\n        }\n        if (!(names && Array.isArray(names))) {\n          diag2.error(\"must provide one or more functions to wrap on modules\");\n          return;\n        }\n        moduleExportsArray.forEach(function(moduleExports) {\n          names.forEach(function(name) {\n            _this._unwrap(moduleExports, name);\n          });\n        });\n      };\n      var modules = _this.init();\n      if (modules && !Array.isArray(modules)) {\n        modules = [modules];\n      }\n      _this._modules = modules || [];\n      if (_this._modules.length === 0) {\n        diag2.debug(\"No modules instrumentation has been defined for \" + (\"'\" + _this.instrumentationName + \"@\" + _this.instrumentationVersion + \"'\") + \", nothing will be patched\");\n      }\n      if (_this._config.enabled) {\n        _this.enable();\n      }\n      return _this;\n    }\n    InstrumentationBase2.prototype._warnOnPreloadedModules = function() {\n      var _this = this;\n      this._modules.forEach(function(module2) {\n        var name = module2.name;\n        try {\n          var resolvedModule = /*require.resolve*/(__webpack_require__(\"(instrument)/../../node_modules/.pnpm/@baselime+node-opentelemetry@0.5.8_@trpc+server@10.45.2/node_modules/@baselime/node-opentelemetry/dist sync recursive\").resolve(name));\n          if (__webpack_require__.c[resolvedModule]) {\n            _this._diag.warn(\"Module \" + name + \" has been loaded before \" + _this.instrumentationName + \" so it might not work, please initialize it before requiring \" + name);\n          }\n        } catch (_a2) {\n        }\n      });\n    };\n    InstrumentationBase2.prototype._extractPackageVersion = function(baseDir) {\n      try {\n        var version = __webpack_require__(\"(instrument)/../../node_modules/.pnpm/@baselime+node-opentelemetry@0.5.8_@trpc+server@10.45.2/node_modules/@baselime/node-opentelemetry/dist sync recursive\")(path2.join(baseDir, \"package.json\")).version;\n        return typeof version === \"string\" ? version : void 0;\n      } catch (error) {\n        diag2.warn(\"Failed extracting version\", baseDir);\n      }\n      return void 0;\n    };\n    InstrumentationBase2.prototype._onRequire = function(module2, exports, name, baseDir) {\n      var _this = this;\n      var _a2;\n      if (!baseDir) {\n        if (typeof module2.patch === \"function\") {\n          module2.moduleExports = exports;\n          if (this._enabled) {\n            return module2.patch(exports);\n          }\n        }\n        return exports;\n      }\n      var version = this._extractPackageVersion(baseDir);\n      module2.moduleVersion = version;\n      if (module2.name === name) {\n        if (isSupported(module2.supportedVersions, version, module2.includePrerelease)) {\n          if (typeof module2.patch === \"function\") {\n            module2.moduleExports = exports;\n            if (this._enabled) {\n              return module2.patch(exports, module2.moduleVersion);\n            }\n          }\n        }\n        return exports;\n      }\n      var files = (_a2 = module2.files) !== null && _a2 !== void 0 ? _a2 : [];\n      var normalizedName = path2.normalize(name);\n      var supportedFileInstrumentations = files.filter(function(f) {\n        return f.name === normalizedName;\n      }).filter(function(f) {\n        return isSupported(f.supportedVersions, version, module2.includePrerelease);\n      });\n      return supportedFileInstrumentations.reduce(function(patchedExports, file) {\n        file.moduleExports = patchedExports;\n        if (_this._enabled) {\n          return file.patch(patchedExports, module2.moduleVersion);\n        }\n        return patchedExports;\n      }, exports);\n    };\n    InstrumentationBase2.prototype.enable = function() {\n      var e_1, _a2, e_2, _b, e_3, _c;\n      var _this = this;\n      if (this._enabled) {\n        return;\n      }\n      this._enabled = true;\n      if (this._hooks.length > 0) {\n        try {\n          for (var _d = __values14(this._modules), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var module_1 = _e.value;\n            if (typeof module_1.patch === \"function\" && module_1.moduleExports) {\n              module_1.patch(module_1.moduleExports, module_1.moduleVersion);\n            }\n            try {\n              for (var _f = (e_2 = void 0, __values14(module_1.files)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var file = _g.value;\n                if (file.moduleExports) {\n                  file.patch(file.moduleExports, module_1.moduleVersion);\n                }\n              }\n            } catch (e_2_1) {\n              e_2 = { error: e_2_1 };\n            } finally {\n              try {\n                if (_g && !_g.done && (_b = _f.return))\n                  _b.call(_f);\n              } finally {\n                if (e_2)\n                  throw e_2.error;\n              }\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = { error: e_1_1 };\n        } finally {\n          try {\n            if (_e && !_e.done && (_a2 = _d.return))\n              _a2.call(_d);\n          } finally {\n            if (e_1)\n              throw e_1.error;\n          }\n        }\n        return;\n      }\n      this._warnOnPreloadedModules();\n      var _loop_1 = function(module_22) {\n        var hookFn = function(exports, name, baseDir) {\n          return _this._onRequire(module_22, exports, name, baseDir);\n        };\n        var onRequire = function(exports, name, baseDir) {\n          return _this._onRequire(module_22, exports, name, baseDir);\n        };\n        var hook = path2.isAbsolute(module_22.name) ? new import_require_in_the_middle2.Hook([module_22.name], { internals: true }, onRequire) : this_1._requireInTheMiddleSingleton.register(module_22.name, onRequire);\n        this_1._hooks.push(hook);\n        var esmHook = new import_import_in_the_middle.default([module_22.name], { internals: false }, hookFn);\n        this_1._hooks.push(esmHook);\n      };\n      var this_1 = this;\n      try {\n        for (var _h = __values14(this._modules), _j = _h.next(); !_j.done; _j = _h.next()) {\n          var module_2 = _j.value;\n          _loop_1(module_2);\n        }\n      } catch (e_3_1) {\n        e_3 = { error: e_3_1 };\n      } finally {\n        try {\n          if (_j && !_j.done && (_c = _h.return))\n            _c.call(_h);\n        } finally {\n          if (e_3)\n            throw e_3.error;\n        }\n      }\n    };\n    InstrumentationBase2.prototype.disable = function() {\n      var e_4, _a2, e_5, _b;\n      if (!this._enabled) {\n        return;\n      }\n      this._enabled = false;\n      try {\n        for (var _c = __values14(this._modules), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var module_3 = _d.value;\n          if (typeof module_3.unpatch === \"function\" && module_3.moduleExports) {\n            module_3.unpatch(module_3.moduleExports, module_3.moduleVersion);\n          }\n          try {\n            for (var _e = (e_5 = void 0, __values14(module_3.files)), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var file = _f.value;\n              if (file.moduleExports) {\n                file.unpatch(file.moduleExports, module_3.moduleVersion);\n              }\n            }\n          } catch (e_5_1) {\n            e_5 = { error: e_5_1 };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return))\n                _b.call(_e);\n            } finally {\n              if (e_5)\n                throw e_5.error;\n            }\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = { error: e_4_1 };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a2 = _c.return))\n            _a2.call(_c);\n        } finally {\n          if (e_4)\n            throw e_4.error;\n        }\n      }\n    };\n    InstrumentationBase2.prototype.isEnabled = function() {\n      return this._enabled;\n    };\n    return InstrumentationBase2;\n  }(InstrumentationAbstract)\n);\nfunction isSupported(supportedVersions, version, includePrerelease) {\n  if (typeof version === \"undefined\") {\n    return supportedVersions.includes(\"*\");\n  }\n  return supportedVersions.some(function(supportedVersion) {\n    return (0, import_semver2.satisfies)(version, supportedVersion, { includePrerelease });\n  });\n}\n\n// node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleDefinition.js\nvar InstrumentationNodeModuleDefinition = (\n  /** @class */\n  function() {\n    function InstrumentationNodeModuleDefinition2(name, supportedVersions, patch, unpatch, files) {\n      this.name = name;\n      this.supportedVersions = supportedVersions;\n      this.patch = patch;\n      this.unpatch = unpatch;\n      this.files = files || [];\n    }\n    return InstrumentationNodeModuleDefinition2;\n  }()\n);\n\n// node_modules/@opentelemetry/instrumentation/build/esm/utils.js\nfunction safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {\n  var error;\n  var result;\n  try {\n    result = execute();\n  } catch (e) {\n    error = e;\n  } finally {\n    onFinish(error, result);\n    if (error && !preventThrowingError) {\n      throw error;\n    }\n    return result;\n  }\n}\nfunction isWrapped2(func) {\n  return typeof func === \"function\" && typeof func.__original === \"function\" && typeof func.__unwrap === \"function\" && func.__wrapped === true;\n}\n\n// src/baselime.ts\nvar import_fs3 = __webpack_require__(/*! fs */ \"fs\");\n\n// src/resources/service.ts\ninit_esm5();\nvar ServiceDetector = class {\n  serviceName;\n  attributes;\n  constructor(config) {\n    this.serviceName = config?.serviceName || process.env.OTEL_SERVICE_NAME;\n    this.attributes = config?.attributes instanceof Resource ? config.attributes.attributes : config?.attributes || {};\n  }\n  detect(_config) {\n    if (!this.serviceName || !this.attributes) {\n      return Resource.empty();\n    }\n    const attributes = {\n      \"service.name\": this.serviceName,\n      \"service.namespace\": this.serviceName,\n      ...this.attributes\n    };\n    return new Resource(attributes);\n  }\n};\n\n// src/resources/koyeb.ts\ninit_esm5();\ninit_esm2();\nvar KoyebDetector = class {\n  detect(_config) {\n    if (!process.env.KOYEB_APP_NAME) {\n      return Resource.empty();\n    }\n    const portProtocols = Object.keys(process.env).filter((key) => key.startsWith(\"KOYEB_PORT_\"));\n    const protocols = portProtocols.reduce((sum, el) => ({\n      ...sum,\n      [el.replace(\"_\", \".\").toLowerCase()]: process.env[el]\n    }), {});\n    const attributes = {\n      [SemanticResourceAttributes.CLOUD_PROVIDER]: String(\n        \"Koyeb\"\n      ),\n      [SemanticResourceAttributes.CLOUD_PLATFORM]: String(\n        \"Koyeb MicroVM\"\n      ),\n      [SemanticResourceAttributes.CLOUD_REGION]: String(process.env.KOYEB_DC),\n      \"koyeb.app.name\": String(process.env.KOYEB_APP_NAME),\n      \"koyeb.app.id\": String(process.env.KOYEB_APP_ID),\n      \"koyeb.organization.name\": String(process.env.KOYEB_ORGANIZATION_NAME),\n      \"koyeb.organization.id\": String(process.env.KOYEB_ORGANIZATION_ID),\n      \"koyeb.service.name\": String(process.env.KOYEB_SERVICE_NAME),\n      \"koyeb.service.id\": String(process.env.KOYEB_SERVICE_ID),\n      \"koyeb.service.privateDomain\": String(process.env.KOYEB_SERVICE_PRIVATE_DOMAIN),\n      \"koyeb.publicDomain\": String(process.env.KOYEB_PUBLIC_DOMAIN),\n      \"koyeb.region\": String(process.env.KOYEB_REGION),\n      \"koyeb.regionalDeploymentId\": String(process.env.KOYEB_REGIONAL_DEPLOYMENT_ID),\n      \"koyeb.instance.id\": String(process.env.KOYEB_INSTANCE_ID),\n      \"koyeb.instance.type\": String(process.env.KOYEB_INSTANCE_TYPE),\n      \"koyeb.instance.memory\": String(process.env.KOYEB_INSTANCE_MEMORY_MB),\n      \"koyeb.privileged\": process.env.KOYEB_PRIVILEGED === \"true\",\n      \"koyeb.hypervisor.id\": String(process.env.KOYEB_HYPERVISOR_ID),\n      \"koyeb.dc\": String(process.env.KOYEB_DC),\n      \"koyeb.docker.ref\": String(process.env.KOYEB_DOCKER_REF),\n      \"koyeb.git.sha\": String(process.env.KOYEB_GIT_SHA),\n      \"koyeb.git.branch\": String(process.env.KOYEB_GIT_BRANCH),\n      \"koyeb.git.commit.author\": String(process.env.KOYEB_GIT_COMMIT_AUTHOR),\n      \"koyeb.git.commit.message\": String(process.env.KOYEB_GIT_COMMIT_MESSAGE),\n      \"koyeb.git.repository\": String(process.env.KOYEB_GIT_REPOSITORY),\n      ...protocols,\n      // SET OTEL SPECIAL ATTRIBUTES\n      \"service.name\": String(process.env.KOYEB_APP_NAME),\n      \"service.namespace\": String(process.env.KOYEB_SERVICE_NAME)\n    };\n    return new Resource(attributes);\n  }\n};\n\n// src/baselime.ts\nvar BaselimeSDK = class {\n  options;\n  attributes;\n  constructor(options) {\n    options.serverless = options.serverless || false;\n    options.collectorUrl = options.collectorUrl || process.env.COLLECTOR_URL || \"https://otel.baselime.io/v1\";\n    options.baselimeKey = options.baselimeKey || process.env.BASELIME_API_KEY || process.env.BASELIME_KEY;\n    this.options = options;\n  }\n  start() {\n    if (process.env.OTEL_LOG_LEVEL === \"debug\") {\n      esm_default.diag.setLogger(new DiagConsoleLogger(), DiagLogLevel.ALL);\n    }\n    const provider = new import_sdk_trace_node.NodeTracerProvider({\n      sampler: this.options.sampler,\n      resource: detectResourcesSync({\n        detectors: [\n          import_resource_detector_aws.awsLambdaDetector,\n          new VercelDetector(),\n          new KoyebDetector(),\n          ...this.options.resourceDetectors || [],\n          new ServiceDetector({ serviceName: this.options.service, attributes: this.options.resourceAttributes })\n        ]\n      }),\n      forceFlushTimeoutMillis: 5e3\n    });\n    let exporter = void 0;\n    if (!this.options.baselimeKey) {\n      console.warn(\"No Baselime API key provided. Traces will not be sent to Baselime.\");\n    }\n    if (this.options.baselimeKey) {\n      let collectorUrl = this.options.collectorUrl;\n      if ((0, import_fs3.existsSync)(\"/opt/extensions/baselime\")) {\n        collectorUrl = \"http://sandbox:4323/otel\";\n      }\n      exporter = new OTLPTraceExporter({\n        url: collectorUrl,\n        headers: {\n          \"x-api-key\": this.options.baselimeKey || process.env.BASELIME_KEY || process.env.BASELIME_OTEL_KEY\n        },\n        timeoutMillis: 1e3\n      });\n    }\n    if (this.options.log) {\n      exporter = new import_sdk_trace_node.ConsoleSpanExporter();\n    }\n    if (exporter) {\n      const spanProcessor = this.options.serverless ? new import_sdk_trace_node.SimpleSpanProcessor(exporter) : new import_sdk_trace_node.BatchSpanProcessor(exporter, {\n        maxQueueSize: 100,\n        maxExportBatchSize: 5\n      });\n      provider.addSpanProcessor(spanProcessor);\n    }\n    provider.register();\n    registerInstrumentations({\n      instrumentations: [\n        ...this.options.instrumentations || []\n      ]\n    });\n    return provider;\n  }\n};\n\n// src/http.ts\nvar import_http = __webpack_require__(/*! http */ \"http\");\n\n// node_modules/flat/index.js\nfunction isBuffer(obj) {\n  return obj && obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\nfunction keyIdentity(key) {\n  return key;\n}\nfunction flatten(target, opts) {\n  opts = opts || {};\n  const delimiter = opts.delimiter || \".\";\n  const maxDepth = opts.maxDepth;\n  const transformKey = opts.transformKey || keyIdentity;\n  const output = {};\n  function step(object, prev, currentDepth) {\n    currentDepth = currentDepth || 1;\n    Object.keys(object).forEach(function(key) {\n      const value = object[key];\n      const isarray = opts.safe && Array.isArray(value);\n      const type = Object.prototype.toString.call(value);\n      const isbuffer = isBuffer(value);\n      const isobject = type === \"[object Object]\" || type === \"[object Array]\";\n      const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1);\n      }\n      output[newKey] = value;\n    });\n  }\n  step(target);\n  return output;\n}\n\n// src/http/index.ts\ninit_esm();\ninit_esm3();\nvar url3 = __toESM(__webpack_require__(/*! url */ \"url\"), 1);\n\n// src/http/utils.ts\ninit_esm();\ninit_esm2();\ninit_esm3();\nvar url2 = __toESM(__webpack_require__(/*! url */ \"url\"), 1);\nvar getAbsoluteUrl = (requestUrl, headers, fallbackProtocol = \"http:\") => {\n  const reqUrlObject = requestUrl || {};\n  const protocol = reqUrlObject.protocol || fallbackProtocol;\n  const port = (reqUrlObject.port || \"\").toString();\n  const path3 = reqUrlObject.path || \"/\";\n  let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || \"localhost\";\n  if (host.indexOf(\":\") === -1 && port && port !== \"80\" && port !== \"443\") {\n    host += `:${port}`;\n  }\n  return `${protocol}//${host}${path3}`;\n};\nvar parseResponseStatus = (kind, statusCode) => {\n  const upperBound = kind === SpanKind.CLIENT ? 400 : 500;\n  if (statusCode && statusCode >= 100 && statusCode < upperBound) {\n    return SpanStatusCode.UNSET;\n  }\n  return SpanStatusCode.ERROR;\n};\nvar satisfiesPattern = (constant, pattern) => {\n  if (typeof pattern === \"string\") {\n    return pattern === constant;\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(constant);\n  } else if (typeof pattern === \"function\") {\n    return pattern(constant);\n  } else {\n    throw new TypeError(\"Pattern is in unsupported datatype\");\n  }\n};\nvar isIgnored = (constant, list, onException) => {\n  if (!list) {\n    return false;\n  }\n  try {\n    for (const pattern of list) {\n      if (satisfiesPattern(constant, pattern)) {\n        return true;\n      }\n    }\n  } catch (e) {\n    if (onException) {\n      onException(e);\n    }\n  }\n  return false;\n};\nvar setSpanWithError = (span, error) => {\n  const message = error.message;\n  span.setAttributes({\n    [\"http.error_name\" /* HTTP_ERROR_NAME */]: error.name,\n    [\"http.error_message\" /* HTTP_ERROR_MESSAGE */]: message\n  });\n  span.setStatus({ code: SpanStatusCode.ERROR, message });\n  span.recordException(error);\n};\nvar setRequestContentLengthAttribute = (request3, attributes) => {\n  const length = getContentLength(request3.headers);\n  if (length === null)\n    return;\n  if (isCompressed(request3.headers)) {\n    attributes[SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH] = length;\n  } else {\n    attributes[SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;\n  }\n};\nvar setResponseContentLengthAttribute = (response, attributes) => {\n  const length = getContentLength(response.headers);\n  if (length === null)\n    return;\n  if (isCompressed(response.headers)) {\n    attributes[SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = length;\n  } else {\n    attributes[SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;\n  }\n};\nfunction getContentLength(headers) {\n  const contentLengthHeader = headers[\"content-length\"];\n  if (contentLengthHeader === void 0)\n    return null;\n  const contentLength = parseInt(contentLengthHeader, 10);\n  if (isNaN(contentLength))\n    return null;\n  return contentLength;\n}\nvar isCompressed = (headers) => {\n  const encoding = headers[\"content-encoding\"];\n  return !!encoding && encoding !== \"identity\";\n};\nvar getRequestInfo = (options, extraOptions) => {\n  let pathname = \"/\";\n  let origin = \"\";\n  let optionsParsed;\n  if (typeof options === \"string\") {\n    optionsParsed = url2.parse(options);\n    pathname = optionsParsed.pathname || \"/\";\n    origin = `${optionsParsed.protocol || \"http:\"}//${optionsParsed.host}`;\n    if (extraOptions !== void 0) {\n      Object.assign(optionsParsed, extraOptions);\n    }\n  } else if (options instanceof url2.URL) {\n    optionsParsed = {\n      protocol: options.protocol,\n      hostname: typeof options.hostname === \"string\" && options.hostname.startsWith(\"[\") ? options.hostname.slice(1, -1) : options.hostname,\n      path: `${options.pathname || \"\"}${options.search || \"\"}`\n    };\n    if (options.port !== \"\") {\n      optionsParsed.port = Number(options.port);\n    }\n    if (options.username || options.password) {\n      optionsParsed.auth = `${options.username}:${options.password}`;\n    }\n    pathname = options.pathname;\n    origin = options.origin;\n    if (extraOptions !== void 0) {\n      Object.assign(optionsParsed, extraOptions);\n    }\n  } else {\n    optionsParsed = Object.assign(\n      { protocol: options.host ? \"http:\" : void 0 },\n      options\n    );\n    pathname = options.pathname;\n    if (!pathname && optionsParsed.path) {\n      pathname = url2.parse(optionsParsed.path).pathname || \"/\";\n    }\n    const hostname2 = optionsParsed.host || (optionsParsed.port != null ? `${optionsParsed.hostname}${optionsParsed.port}` : optionsParsed.hostname);\n    origin = `${optionsParsed.protocol || \"http:\"}//${hostname2}`;\n  }\n  const method = optionsParsed.method ? optionsParsed.method.toUpperCase() : \"GET\";\n  return { origin, pathname, method, optionsParsed };\n};\nvar isValidOptionsType = (options) => {\n  if (!options) {\n    return false;\n  }\n  const type = typeof options;\n  return type === \"string\" || type === \"object\" && !Array.isArray(options);\n};\nvar extractHostnameAndPort = (requestOptions) => {\n  if (requestOptions.hostname && requestOptions.port) {\n    return { hostname: requestOptions.hostname, port: requestOptions.port };\n  }\n  const matches = requestOptions.host?.match(/^([^:/ ]+)(:\\d{1,5})?/) || null;\n  const hostname2 = requestOptions.hostname || (matches === null ? \"localhost\" : matches[1]);\n  let port = requestOptions.port;\n  if (!port) {\n    if (matches && matches[2]) {\n      port = matches[2].substring(1);\n    } else {\n      port = requestOptions.protocol === \"https:\" ? \"443\" : \"80\";\n    }\n  }\n  return { hostname: hostname2, port };\n};\nvar getOutgoingRequestAttributes = (requestOptions, options) => {\n  const hostname2 = options.hostname;\n  const port = options.port;\n  const requestMethod = requestOptions.method;\n  const method = requestMethod ? requestMethod.toUpperCase() : \"GET\";\n  const headers = requestOptions.headers || {};\n  const userAgent = headers[\"user-agent\"];\n  const attributes = {\n    [SemanticAttributes.HTTP_URL]: getAbsoluteUrl(\n      requestOptions,\n      headers,\n      `${options.component}:`\n    ),\n    [SemanticAttributes.HTTP_METHOD]: method,\n    [SemanticAttributes.HTTP_TARGET]: requestOptions.path || \"/\",\n    [SemanticAttributes.NET_PEER_NAME]: hostname2,\n    [SemanticAttributes.HTTP_HOST]: requestOptions.headers?.host ?? `${hostname2}:${port}`\n  };\n  if (userAgent !== void 0) {\n    attributes[SemanticAttributes.HTTP_USER_AGENT] = userAgent;\n  }\n  return Object.assign(attributes, options.hookAttributes);\n};\nvar getOutgoingRequestMetricAttributes = (spanAttributes) => {\n  const metricAttributes = {};\n  metricAttributes[SemanticAttributes.HTTP_METHOD] = spanAttributes[SemanticAttributes.HTTP_METHOD];\n  metricAttributes[SemanticAttributes.NET_PEER_NAME] = spanAttributes[SemanticAttributes.NET_PEER_NAME];\n  return metricAttributes;\n};\nvar getAttributesFromHttpKind = (kind) => {\n  const attributes = {};\n  if (kind) {\n    attributes[SemanticAttributes.HTTP_FLAVOR] = kind;\n    if (kind.toUpperCase() !== \"QUIC\") {\n      attributes[SemanticAttributes.NET_TRANSPORT] = NetTransportValues.IP_TCP;\n    } else {\n      attributes[SemanticAttributes.NET_TRANSPORT] = NetTransportValues.IP_UDP;\n    }\n  }\n  return attributes;\n};\nvar getOutgoingRequestAttributesOnResponse = (response) => {\n  const { statusCode, statusMessage, httpVersion, socket } = response;\n  const attributes = {};\n  if (socket) {\n    const { remoteAddress, remotePort } = socket;\n    attributes[SemanticAttributes.NET_PEER_IP] = remoteAddress;\n    attributes[SemanticAttributes.NET_PEER_PORT] = remotePort;\n  }\n  setResponseContentLengthAttribute(response, attributes);\n  if (statusCode) {\n    attributes[SemanticAttributes.HTTP_STATUS_CODE] = statusCode;\n    attributes[\"http.status_text\" /* HTTP_STATUS_TEXT */] = (statusMessage || \"\").toUpperCase();\n  }\n  const httpKindAttributes = getAttributesFromHttpKind(httpVersion);\n  return Object.assign(attributes, httpKindAttributes);\n};\nvar getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) => {\n  const metricAttributes = {};\n  metricAttributes[SemanticAttributes.NET_PEER_PORT] = spanAttributes[SemanticAttributes.NET_PEER_PORT];\n  metricAttributes[SemanticAttributes.HTTP_STATUS_CODE] = spanAttributes[SemanticAttributes.HTTP_STATUS_CODE];\n  metricAttributes[SemanticAttributes.HTTP_FLAVOR] = spanAttributes[SemanticAttributes.HTTP_FLAVOR];\n  return metricAttributes;\n};\nvar getIncomingRequestAttributes = (request3, options) => {\n  const headers = request3.headers;\n  const userAgent = headers[\"user-agent\"];\n  const ips = headers[\"x-forwarded-for\"];\n  const method = request3.method || \"GET\";\n  const httpVersion = request3.httpVersion;\n  const requestUrl = request3.url ? url2.parse(request3.url) : null;\n  const host = requestUrl?.host || headers.host;\n  const hostname2 = requestUrl?.hostname || host?.replace(/^(.*)(:[0-9]{1,5})/, \"$1\") || \"localhost\";\n  const serverName = options.serverName;\n  const attributes = {\n    [SemanticAttributes.HTTP_URL]: getAbsoluteUrl(\n      requestUrl,\n      headers,\n      `${options.component}:`\n    ),\n    [SemanticAttributes.HTTP_HOST]: host,\n    [SemanticAttributes.NET_HOST_NAME]: hostname2,\n    [SemanticAttributes.HTTP_METHOD]: method,\n    [SemanticAttributes.HTTP_SCHEME]: options.component\n  };\n  if (typeof ips === \"string\") {\n    attributes[SemanticAttributes.HTTP_CLIENT_IP] = ips.split(\",\")[0];\n  }\n  if (typeof serverName === \"string\") {\n    attributes[SemanticAttributes.HTTP_SERVER_NAME] = serverName;\n  }\n  if (requestUrl) {\n    attributes[SemanticAttributes.HTTP_TARGET] = requestUrl.path || \"/\";\n  }\n  if (userAgent !== void 0) {\n    attributes[SemanticAttributes.HTTP_USER_AGENT] = userAgent;\n  }\n  setRequestContentLengthAttribute(request3, attributes);\n  const httpKindAttributes = getAttributesFromHttpKind(httpVersion);\n  return Object.assign(attributes, httpKindAttributes, options.hookAttributes);\n};\nvar getIncomingRequestMetricAttributes = (spanAttributes) => {\n  const metricAttributes = {};\n  metricAttributes[SemanticAttributes.HTTP_SCHEME] = spanAttributes[SemanticAttributes.HTTP_SCHEME];\n  metricAttributes[SemanticAttributes.HTTP_METHOD] = spanAttributes[SemanticAttributes.HTTP_METHOD];\n  metricAttributes[SemanticAttributes.NET_HOST_NAME] = spanAttributes[SemanticAttributes.NET_HOST_NAME];\n  metricAttributes[SemanticAttributes.HTTP_FLAVOR] = spanAttributes[SemanticAttributes.HTTP_FLAVOR];\n  return metricAttributes;\n};\nvar getIncomingRequestAttributesOnResponse = (request3, response) => {\n  const { socket } = request3;\n  const { statusCode, statusMessage } = response;\n  const rpcMetadata = getRPCMetadata(context.active());\n  const attributes = {};\n  if (socket) {\n    const { localAddress, localPort, remoteAddress, remotePort } = socket;\n    attributes[SemanticAttributes.NET_HOST_IP] = localAddress;\n    attributes[SemanticAttributes.NET_HOST_PORT] = localPort;\n    attributes[SemanticAttributes.NET_PEER_IP] = remoteAddress;\n    attributes[SemanticAttributes.NET_PEER_PORT] = remotePort;\n  }\n  attributes[SemanticAttributes.HTTP_STATUS_CODE] = statusCode;\n  attributes[\"http.status_text\" /* HTTP_STATUS_TEXT */] = (statusMessage || \"\").toUpperCase();\n  if (rpcMetadata?.type === RPCType.HTTP && rpcMetadata.route !== void 0) {\n    attributes[SemanticAttributes.HTTP_ROUTE] = rpcMetadata.route;\n  }\n  return attributes;\n};\nvar getIncomingRequestMetricAttributesOnResponse = (spanAttributes) => {\n  const metricAttributes = {};\n  metricAttributes[SemanticAttributes.HTTP_STATUS_CODE] = spanAttributes[SemanticAttributes.HTTP_STATUS_CODE];\n  metricAttributes[SemanticAttributes.NET_HOST_PORT] = spanAttributes[SemanticAttributes.NET_HOST_PORT];\n  if (spanAttributes[SemanticAttributes.HTTP_ROUTE] !== void 0) {\n    metricAttributes[SemanticAttributes.HTTP_ROUTE] = spanAttributes[SemanticAttributes.HTTP_ROUTE];\n  }\n  return metricAttributes;\n};\nfunction headerCapture(type, headers) {\n  const normalizedHeaders = new Map(\n    headers.map((header) => [\n      header.toLowerCase(),\n      header.toLowerCase().replace(/-/g, \"_\")\n    ])\n  );\n  return (span, getHeader) => {\n    for (const [capturedHeader, normalizedHeader] of normalizedHeaders) {\n      const value = getHeader(capturedHeader);\n      if (value === void 0) {\n        continue;\n      }\n      const key = `http.${type}.header.${normalizedHeader}`;\n      if (typeof value === \"string\") {\n        span.setAttribute(key, [value]);\n      } else if (Array.isArray(value)) {\n        span.setAttribute(key, value);\n      } else {\n        span.setAttribute(key, [value]);\n      }\n    }\n  };\n}\n\n// src/http/index.ts\ninit_esm3();\nvar import_events = __webpack_require__(/*! events */ \"events\");\ninit_esm2();\nvar HttpInstrumentation = class extends InstrumentationBase {\n  /** keep track on spans not ended */\n  _spanNotEnded = /* @__PURE__ */ new WeakSet();\n  _headerCapture;\n  _httpServerDurationHistogram;\n  _httpClientDurationHistogram;\n  constructor(config) {\n    super(\"@opentelemetry/instrumentation-http\", \"1.0\", config);\n    this._headerCapture = this._createHeaderCapture();\n  }\n  _updateMetricInstruments() {\n    this._httpServerDurationHistogram = this.meter.createHistogram(\n      \"http.server.duration\",\n      {\n        description: \"Measures the duration of inbound HTTP requests.\",\n        unit: \"ms\",\n        valueType: ValueType.DOUBLE\n      }\n    );\n    this._httpClientDurationHistogram = this.meter.createHistogram(\n      \"http.client.duration\",\n      {\n        description: \"Measures the duration of outbound HTTP requests.\",\n        unit: \"ms\",\n        valueType: ValueType.DOUBLE\n      }\n    );\n  }\n  _getConfig() {\n    return this._config;\n  }\n  setConfig(config) {\n    super.setConfig(config);\n    this._headerCapture = this._createHeaderCapture();\n  }\n  init() {\n    return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n  }\n  _getHttpInstrumentation() {\n    const version = process.versions.node;\n    return new InstrumentationNodeModuleDefinition(\n      \"http\",\n      [\"*\"],\n      (moduleExports) => {\n        this._diag.debug(`Applying patch for http@${version}`);\n        if (isWrapped2(moduleExports.request)) {\n          this._unwrap(moduleExports, \"request\");\n        }\n        this._wrap(\n          moduleExports,\n          \"request\",\n          this._getPatchOutgoingRequestFunction(\"http\")\n        );\n        if (isWrapped2(moduleExports.get)) {\n          this._unwrap(moduleExports, \"get\");\n        }\n        this._wrap(\n          moduleExports,\n          \"get\",\n          this._getPatchOutgoingGetFunction(moduleExports.request)\n        );\n        if (isWrapped2(moduleExports.Server.prototype.emit)) {\n          this._unwrap(moduleExports.Server.prototype, \"emit\");\n        }\n        this._wrap(\n          moduleExports.Server.prototype,\n          \"emit\",\n          this._getPatchIncomingRequestFunction(\"http\")\n        );\n        return moduleExports;\n      },\n      (moduleExports) => {\n        if (moduleExports === void 0)\n          return;\n        this._diag.debug(`Removing patch for http@${version}`);\n        this._unwrap(moduleExports, \"request\");\n        this._unwrap(moduleExports, \"get\");\n        this._unwrap(moduleExports.Server.prototype, \"emit\");\n      }\n    );\n  }\n  _getHttpsInstrumentation() {\n    const version = process.versions.node;\n    return new InstrumentationNodeModuleDefinition(\n      \"https\",\n      [\"*\"],\n      (moduleExports) => {\n        this._diag.debug(`Applying patch for https@${version}`);\n        if (isWrapped2(moduleExports.request)) {\n          this._unwrap(moduleExports, \"request\");\n        }\n        this._wrap(\n          moduleExports,\n          \"request\",\n          this._getPatchHttpsOutgoingRequestFunction(\"https\")\n        );\n        if (isWrapped2(moduleExports.get)) {\n          this._unwrap(moduleExports, \"get\");\n        }\n        this._wrap(\n          moduleExports,\n          \"get\",\n          this._getPatchHttpsOutgoingGetFunction(moduleExports.request)\n        );\n        if (isWrapped2(moduleExports.Server.prototype.emit)) {\n          this._unwrap(moduleExports.Server.prototype, \"emit\");\n        }\n        this._wrap(\n          moduleExports.Server.prototype,\n          \"emit\",\n          this._getPatchIncomingRequestFunction(\"https\")\n        );\n        return moduleExports;\n      },\n      (moduleExports) => {\n        if (moduleExports === void 0)\n          return;\n        this._diag.debug(`Removing patch for https@${version}`);\n        this._unwrap(moduleExports, \"request\");\n        this._unwrap(moduleExports, \"get\");\n        this._unwrap(moduleExports.Server.prototype, \"emit\");\n      }\n    );\n  }\n  /**\n   * Creates spans for incoming requests, restoring spans' context if applied.\n   */\n  _getPatchIncomingRequestFunction(component) {\n    return (original) => {\n      return this._incomingRequestFunction(component, original);\n    };\n  }\n  /**\n   * Creates spans for outgoing requests, sending spans' context for distributed\n   * tracing.\n   */\n  _getPatchOutgoingRequestFunction(component) {\n    return (original) => {\n      return this._outgoingRequestFunction(component, original);\n    };\n  }\n  _getPatchOutgoingGetFunction(clientRequest) {\n    return (_original) => {\n      return function outgoingGetRequest(options, ...args) {\n        const req = clientRequest(options, ...args);\n        req.end();\n        return req;\n      };\n    };\n  }\n  /** Patches HTTPS outgoing requests */\n  _getPatchHttpsOutgoingRequestFunction(component) {\n    return (original) => {\n      const instrumentation = this;\n      return function httpsOutgoingRequest(options, ...args) {\n        if (component === \"https\" && typeof options === \"object\" && options?.constructor?.name !== \"URL\") {\n          options = Object.assign({}, options);\n          instrumentation._setDefaultOptions(options);\n        }\n        return instrumentation._getPatchOutgoingRequestFunction(component)(\n          original\n        )(options, ...args);\n      };\n    };\n  }\n  _setDefaultOptions(options) {\n    options.protocol = options.protocol || \"https:\";\n    options.port = options.port || 443;\n  }\n  /** Patches HTTPS outgoing get requests */\n  _getPatchHttpsOutgoingGetFunction(clientRequest) {\n    return (original) => {\n      const instrumentation = this;\n      return function httpsOutgoingRequest(options, ...args) {\n        return instrumentation._getPatchOutgoingGetFunction(clientRequest)(\n          original\n        )(options, ...args);\n      };\n    };\n  }\n  /**\n   * Attach event listeners to a client request to end span and add span attributes.\n   *\n   * @param request The original request object.\n   * @param span representing the current operation\n   * @param startTime representing the start time of the request to calculate duration in Metric\n   * @param metricAttributes metric attributes\n   */\n  _traceClientRequest(request3, span, startTime, metricAttributes) {\n    if (this._getConfig().requestHook) {\n      this._callRequestHook(span, request3);\n    }\n    let responseFinished = false;\n    request3.prependListener(\n      \"response\",\n      (response) => {\n        this._diag.debug(\"outgoingRequest on response()\");\n        if (request3.listenerCount(\"response\") <= 1) {\n          response.resume();\n        }\n        const responseAttributes = getOutgoingRequestAttributesOnResponse(response);\n        span.setAttributes(responseAttributes);\n        metricAttributes = Object.assign(\n          metricAttributes,\n          getOutgoingRequestMetricAttributesOnResponse(responseAttributes)\n        );\n        if (this._getConfig().responseHook) {\n          this._callResponseHook(span, response, this, startTime, metricAttributes);\n        }\n        this._headerCapture.client.captureRequestHeaders(\n          span,\n          (header) => request3.getHeader(header)\n        );\n        this._headerCapture.client.captureResponseHeaders(\n          span,\n          (header) => response.headers[header]\n        );\n        context.bind(context.active(), response);\n        const endHandler = () => {\n          this._diag.debug(\"outgoingRequest on end()\");\n          if (responseFinished) {\n            return;\n          }\n          responseFinished = true;\n          let status;\n          if (response.aborted && !response.complete) {\n            status = { code: SpanStatusCode.ERROR };\n          } else {\n            status = {\n              code: parseResponseStatus(\n                SpanKind.CLIENT,\n                response.statusCode\n              )\n            };\n          }\n          span.setStatus(status);\n          if (this._getConfig().applyCustomAttributesOnSpan) {\n            safeExecuteInTheMiddle(\n              () => this._getConfig().applyCustomAttributesOnSpan(\n                span,\n                request3,\n                response\n              ),\n              () => {\n              },\n              true\n            );\n          }\n          if (!this._getConfig().responseHook) {\n            this._closeHttpSpan(\n              span,\n              SpanKind.CLIENT,\n              startTime,\n              metricAttributes\n            );\n          }\n        };\n        response.on(\"end\", endHandler);\n        response.on(import_events.errorMonitor, (error) => {\n          this._diag.debug(\"outgoingRequest on error()\", error);\n          if (responseFinished) {\n            return;\n          }\n          responseFinished = true;\n          setSpanWithError(span, error);\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error.message\n          });\n          this._closeHttpSpan(\n            span,\n            SpanKind.CLIENT,\n            startTime,\n            metricAttributes\n          );\n        });\n      }\n    );\n    request3.on(\"close\", () => {\n      this._diag.debug(\"outgoingRequest on request close()\");\n      if (request3.aborted || responseFinished) {\n        return;\n      }\n      responseFinished = true;\n      this._closeHttpSpan(span, SpanKind.CLIENT, startTime, metricAttributes);\n    });\n    request3.on(import_events.errorMonitor, (error) => {\n      this._diag.debug(\"outgoingRequest on request error()\", error);\n      if (responseFinished) {\n        return;\n      }\n      responseFinished = true;\n      setSpanWithError(span, error);\n      this._closeHttpSpan(span, SpanKind.CLIENT, startTime, metricAttributes);\n    });\n    this._diag.debug(\"http.ClientRequest return request\");\n    return request3;\n  }\n  _incomingRequestFunction(component, original) {\n    const instrumentation = this;\n    return function incomingRequest(event, ...args) {\n      if (event !== \"request\") {\n        return original.apply(this, [event, ...args]);\n      }\n      const request3 = args[0];\n      const response = args[1];\n      const pathname = request3.url ? url3.parse(request3.url).pathname || \"/\" : \"/\";\n      const method = request3.method || \"GET\";\n      instrumentation._diag.debug(\n        `${component} instrumentation incomingRequest`\n      );\n      if (isIgnored(\n        pathname,\n        instrumentation._getConfig().ignoreIncomingPaths,\n        (e) => instrumentation._diag.error(\"caught ignoreIncomingPaths error: \", e)\n      ) || safeExecuteInTheMiddle(\n        () => instrumentation._getConfig().ignoreIncomingRequestHook?.(request3),\n        (e) => {\n          if (e != null) {\n            instrumentation._diag.error(\n              \"caught ignoreIncomingRequestHook error: \",\n              e\n            );\n          }\n        },\n        true\n      )) {\n        return context.with(suppressTracing(context.active()), () => {\n          context.bind(context.active(), request3);\n          context.bind(context.active(), response);\n          return original.apply(this, [event, ...args]);\n        });\n      }\n      const headers = request3.headers;\n      const spanAttributes = getIncomingRequestAttributes(request3, {\n        component,\n        serverName: instrumentation._getConfig().serverName,\n        hookAttributes: instrumentation._callStartSpanHook(\n          request3,\n          instrumentation._getConfig().startIncomingSpanHook\n        )\n      });\n      const spanOptions = {\n        kind: SpanKind.SERVER,\n        attributes: spanAttributes\n      };\n      const startTime = hrTime();\n      const metricAttributes = getIncomingRequestMetricAttributes(spanAttributes);\n      const ctx = propagation.extract(ROOT_CONTEXT, headers);\n      const span = instrumentation._startHttpSpan(method, spanOptions, ctx);\n      const rpcMetadata = {\n        type: RPCType.HTTP,\n        span\n      };\n      return context.with(\n        setRPCMetadata(trace.setSpan(ctx, span), rpcMetadata),\n        () => {\n          context.bind(context.active(), request3);\n          context.bind(context.active(), response);\n          if (instrumentation._getConfig().requestHook) {\n            instrumentation._callRequestHook(span, request3);\n          }\n          if (instrumentation._getConfig().responseHook) {\n            instrumentation._callResponseHook(span, response, instrumentation, startTime, metricAttributes);\n          }\n          instrumentation._headerCapture.server.captureRequestHeaders(\n            span,\n            (header) => request3.headers[header]\n          );\n          let hasError = false;\n          response.on(\"close\", () => {\n            if (hasError) {\n              return;\n            }\n            instrumentation._onServerResponseFinish(\n              request3,\n              response,\n              span,\n              metricAttributes,\n              startTime\n            );\n          });\n          response.on(import_events.errorMonitor, (err) => {\n            hasError = true;\n            instrumentation._onServerResponseError(\n              span,\n              metricAttributes,\n              startTime,\n              err\n            );\n          });\n          return safeExecuteInTheMiddle(\n            () => original.apply(this, [event, ...args]),\n            (error) => {\n              if (error) {\n                setSpanWithError(span, error);\n                instrumentation._closeHttpSpan(\n                  span,\n                  SpanKind.SERVER,\n                  startTime,\n                  metricAttributes\n                );\n                throw error;\n              }\n            }\n          );\n        }\n      );\n    };\n  }\n  _outgoingRequestFunction(component, original) {\n    const instrumentation = this;\n    return function outgoingRequest(options, ...args) {\n      if (!isValidOptionsType(options)) {\n        return original.apply(this, [options, ...args]);\n      }\n      const extraOptions = typeof args[0] === \"object\" && (typeof options === \"string\" || options instanceof url3.URL) ? args.shift() : void 0;\n      const { origin, pathname, method, optionsParsed } = getRequestInfo(\n        options,\n        extraOptions\n      );\n      if (isIgnored(\n        origin + pathname,\n        instrumentation._getConfig().ignoreOutgoingUrls,\n        (e) => instrumentation._diag.error(\"caught ignoreOutgoingUrls error: \", e)\n      ) || safeExecuteInTheMiddle(\n        () => instrumentation._getConfig().ignoreOutgoingRequestHook?.(optionsParsed),\n        (e) => {\n          if (e != null) {\n            instrumentation._diag.error(\n              \"caught ignoreOutgoingRequestHook error: \",\n              e\n            );\n          }\n        },\n        true\n      )) {\n        return original.apply(this, [optionsParsed, ...args]);\n      }\n      const { hostname: hostname2, port } = extractHostnameAndPort(optionsParsed);\n      const attributes = getOutgoingRequestAttributes(optionsParsed, {\n        component,\n        port,\n        hostname: hostname2,\n        hookAttributes: instrumentation._callStartSpanHook(\n          optionsParsed,\n          instrumentation._getConfig().startOutgoingSpanHook\n        )\n      });\n      const startTime = hrTime();\n      const metricAttributes = getOutgoingRequestMetricAttributes(attributes);\n      const spanOptions = {\n        kind: SpanKind.CLIENT,\n        attributes\n      };\n      const span = instrumentation._startHttpSpan(method, spanOptions);\n      const parentContext = context.active();\n      const requestContext = trace.setSpan(parentContext, span);\n      if (!optionsParsed.headers) {\n        optionsParsed.headers = {};\n      } else {\n        optionsParsed.headers = Object.assign({}, optionsParsed.headers);\n      }\n      propagation.inject(requestContext, optionsParsed.headers);\n      return context.with(requestContext, () => {\n        const cb = args[args.length - 1];\n        if (typeof cb === \"function\") {\n          args[args.length - 1] = context.bind(parentContext, cb);\n        }\n        const request3 = safeExecuteInTheMiddle(\n          () => original.apply(this, [optionsParsed, ...args]),\n          (error) => {\n            if (error) {\n              setSpanWithError(span, error);\n              instrumentation._closeHttpSpan(\n                span,\n                SpanKind.CLIENT,\n                startTime,\n                metricAttributes\n              );\n              throw error;\n            }\n          }\n        );\n        instrumentation._diag.debug(\n          `${component} instrumentation outgoingRequest`\n        );\n        context.bind(parentContext, request3);\n        return instrumentation._traceClientRequest(\n          request3,\n          span,\n          startTime,\n          metricAttributes\n        );\n      });\n    };\n  }\n  _onServerResponseFinish(request3, response, span, metricAttributes, startTime) {\n    const attributes = getIncomingRequestAttributesOnResponse(\n      request3,\n      response\n    );\n    metricAttributes = Object.assign(\n      metricAttributes,\n      getIncomingRequestMetricAttributesOnResponse(attributes)\n    );\n    this._headerCapture.server.captureResponseHeaders(\n      span,\n      (header) => response.getHeader(header)\n    );\n    span.setAttributes(attributes).setStatus({\n      code: parseResponseStatus(SpanKind.SERVER, response.statusCode)\n    });\n    const route = attributes[SemanticAttributes.HTTP_ROUTE];\n    if (route) {\n      span.updateName(`${request3.method || \"GET\"} ${route}`);\n    }\n    if (this._getConfig().applyCustomAttributesOnSpan) {\n      safeExecuteInTheMiddle(\n        () => this._getConfig().applyCustomAttributesOnSpan(\n          span,\n          request3,\n          response\n        ),\n        () => {\n        },\n        true\n      );\n    }\n    this._closeHttpSpan(span, SpanKind.SERVER, startTime, metricAttributes);\n  }\n  _onServerResponseError(span, metricAttributes, startTime, error) {\n    setSpanWithError(span, error);\n    this._closeHttpSpan(span, SpanKind.SERVER, startTime, metricAttributes);\n  }\n  _startHttpSpan(name, options, ctx = context.active()) {\n    const requireParent = options.kind === SpanKind.CLIENT ? this._getConfig().requireParentforOutgoingSpans : this._getConfig().requireParentforIncomingSpans;\n    let span;\n    const currentSpan = trace.getSpan(ctx);\n    if (requireParent === true && currentSpan === void 0) {\n      span = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);\n    } else if (requireParent === true && currentSpan?.spanContext().isRemote) {\n      span = currentSpan;\n    } else {\n      span = this.tracer.startSpan(name, options, ctx);\n    }\n    this._spanNotEnded.add(span);\n    return span;\n  }\n  _closeHttpSpan(span, spanKind, startTime, metricAttributes) {\n    if (!this._spanNotEnded.has(span)) {\n      return;\n    }\n    span.end();\n    this._spanNotEnded.delete(span);\n    const duration = hrTimeToMilliseconds(hrTimeDuration(startTime, hrTime()));\n    if (spanKind === SpanKind.SERVER) {\n      this._httpServerDurationHistogram.record(duration, metricAttributes);\n    } else if (spanKind === SpanKind.CLIENT) {\n      this._httpClientDurationHistogram.record(duration, metricAttributes);\n    }\n  }\n  _callResponseHook(span, response, instrumentation, startTime, metricAttributes) {\n    safeExecuteInTheMiddle(\n      () => this._getConfig().responseHook(span, response, () => {\n        instrumentation._closeHttpSpan(\n          span,\n          SpanKind.SERVER,\n          startTime,\n          metricAttributes\n        );\n      }),\n      () => {\n      },\n      true\n    );\n  }\n  _callRequestHook(span, request3) {\n    safeExecuteInTheMiddle(\n      () => this._getConfig().requestHook(span, request3),\n      () => {\n      },\n      true\n    );\n  }\n  _callStartSpanHook(request3, hookFunc) {\n    if (typeof hookFunc === \"function\") {\n      return safeExecuteInTheMiddle(\n        () => hookFunc(request3),\n        () => {\n        },\n        true\n      );\n    }\n  }\n  _createHeaderCapture() {\n    const config = this._getConfig();\n    return {\n      client: {\n        captureRequestHeaders: headerCapture(\n          \"request\",\n          config.headersToSpanAttributes?.client?.requestHeaders ?? []\n        ),\n        captureResponseHeaders: headerCapture(\n          \"response\",\n          config.headersToSpanAttributes?.client?.responseHeaders ?? []\n        )\n      },\n      server: {\n        captureRequestHeaders: headerCapture(\n          \"request\",\n          config.headersToSpanAttributes?.server?.requestHeaders ?? []\n        ),\n        captureResponseHeaders: headerCapture(\n          \"response\",\n          config.headersToSpanAttributes?.server?.responseHeaders ?? []\n        )\n      }\n    };\n  }\n};\n\n// src/http.ts\nvar import_querystring = __webpack_require__(/*! querystring */ \"querystring\");\nvar import_stream2 = __webpack_require__(/*! stream */ \"stream\");\nfunction _betterHttpInstrumentation(options = {}) {\n  options.plugins = options.plugins || [];\n  return {\n    requestHook(span, request3) {\n      if (request3 instanceof import_http.ClientRequest) {\n        const plugin2 = options.plugins.find((plugin3) => plugin3?.shouldParseRequest(request3));\n        if (plugin2) {\n          span.setAttribute(\"http.plugin.name\", plugin2.name);\n          const headers = request3.getHeaders();\n          if (options.captureHeaders) {\n            span.setAttributes(flatten({ request: { headers } }));\n          }\n          if (plugin2.captureBody) {\n            getClientRequestBody(request3, (body) => {\n              const requestData = _parseBodySafe(body, headers);\n              span.setAttributes(flatten({ request: { body: requestData } }));\n            });\n          }\n        } else {\n          const headers = request3.getHeaders();\n          if (options.captureHeaders) {\n            span.setAttributes(flatten({ request: { headers } }));\n          }\n          if (options.captureBody && shouldCaptureBody(request3.host)) {\n            getClientRequestBody(request3, (body) => {\n              const requestData = _parseBodySafe(body, headers);\n              span.setAttributes(flatten({ request: { body: requestData } }));\n            });\n          }\n        }\n      }\n      if (request3 instanceof import_http.IncomingMessage) {\n        const plugin2 = options.plugins.find((plugin3) => plugin3.shouldParseRequest && plugin3.shouldParseRequest(request3));\n        span.setAttribute(\"http.plugin.name\", plugin2.name);\n        if (plugin2.parseIncommingMessage) {\n          const attributes = plugin2.parseIncommingMessage(request3);\n          span.setAttributes(flatten(attributes));\n        }\n      }\n      if (options.requestHook) {\n        options.requestHook(span, request3);\n      }\n    },\n    responseHook(span, response, cb) {\n      if (response instanceof import_http.IncomingMessage) {\n        try {\n          const headers = response.headers;\n          if (options.captureHeaders) {\n            span.setAttributes(flatten({ response: { headers } }));\n          }\n          if (options.captureBody && shouldCaptureBody(response.url || \"\")) {\n            getClientResponseBody(response, (body) => {\n              const responseData = _parseBodySafe(body, headers);\n              span.setAttributes(flatten({ response: { body: responseData } }));\n              cb();\n            });\n          } else {\n            cb();\n          }\n        } catch (e) {\n          cb();\n        }\n      }\n      if (options.responseHook) {\n        options.responseHook(span, response, cb);\n      }\n    }\n  };\n}\nvar ignoredHosts = [\n  \"localhost\",\n  \"otel.baselime\"\n];\nfunction getClientRequestBody(r, cb) {\n  const chunks = [];\n  const oldWrite = r.write.bind(r);\n  r.write = (data) => {\n    try {\n      if (typeof data === \"string\") {\n        chunks.push(Buffer.from(data));\n        if (data[data.length - 1] === \"}\") {\n          const body = Buffer.concat(chunks).toString(\"utf8\");\n          cb(body);\n        }\n      } else {\n        chunks.push(data);\n        if (data[data.length - 1] === 125) {\n          const body = Buffer.concat(chunks).toString(\"utf8\");\n          cb(body);\n        }\n      }\n    } catch (e) {\n    }\n    return oldWrite(data);\n  };\n  const oldEnd = r.end.bind(r);\n  r.end = (data) => {\n    try {\n      if (data) {\n        if (typeof data === \"string\") {\n          chunks.push(Buffer.from(data));\n        } else {\n          chunks.push(data);\n        }\n      }\n      if (chunks.length > 0) {\n        const body = Buffer.concat(chunks).toString(\"utf8\");\n        cb(body);\n      }\n    } catch (e) {\n    }\n    return oldEnd(data);\n  };\n}\nfunction getClientResponseBody(r, cb) {\n  const chunks = [];\n  const pt = new import_stream2.PassThrough();\n  pt.on(\"data\", (chunk) => {\n    try {\n      if (typeof chunk === \"string\") {\n        chunks.push(Buffer.from(chunk));\n      } else {\n        chunks.push(chunk);\n      }\n    } catch (e) {\n    }\n  }).on(\"end\", () => {\n    try {\n      if (chunks.length > 0) {\n        const body = Buffer.concat(chunks).toString(\"utf8\");\n        cb(body);\n      }\n    } catch (e) {\n    }\n  });\n  const originalState = r.readableFlowing;\n  r.pipe(pt);\n  r.readableFlowing = originalState;\n}\nfunction shouldCaptureBody(host) {\n  return !ignoredHosts.find((ignoredHost) => host.includes(ignoredHost));\n}\nfunction _parseBodySafe(body, headers) {\n  let requestData = body;\n  try {\n    if (headers[\"content-type\"] && typeof headers[\"content-type\"] === \"string\") {\n      if (headers[\"content-type\"].includes(\"application/json\") || headers[\"content-type\"].includes(\"application/x-amz-json\")) {\n        requestData = JSON.parse(body);\n      } else if (headers[\"content-type\"].includes(\"application/x-www-form-urlencoded\")) {\n        requestData = (0, import_querystring.parse)(body);\n      }\n    }\n  } catch (_) {\n  }\n  return requestData;\n}\nvar BetterHttpInstrumentation = class extends HttpInstrumentation {\n  constructor(options = {}) {\n    super({\n      ..._betterHttpInstrumentation(options),\n      ignoreIncomingRequestHook: options.ignoreIncomingRequestHook,\n      ignoreOutgoingRequestHook: options.ignoreOutgoingRequestHook,\n      startIncomingSpanHook: options.startIncomingSpanHook,\n      startOutgoingSpanHook: options.startOutgoingSpanHook\n    });\n  }\n};\n\n// src/http-plugins/stripe.ts\nvar import_http3 = __webpack_require__(/*! http */ \"http\");\n\n// src/http-plugins/plugin.ts\nvar HttpPlugin = class {\n  captureBody = false;\n  name = \"base-plugin-should-extend\";\n  constructor() {\n  }\n  shouldParseRequest(request3) {\n    return false;\n  }\n  shouldParseResponse(response) {\n    return false;\n  }\n};\n\n// src/http-plugins/stripe.ts\nvar StripePlugin = class extends HttpPlugin {\n  captureBody = true;\n  name = \"stripe\";\n  shouldParseRequest(request3) {\n    if (request3 instanceof import_http3.ClientRequest && request3.host?.includes(\"api.stripe.com\")) {\n      return true;\n    }\n    return false;\n  }\n  parseClientRequest(request3) {\n    const method = request3.method;\n    const [version, entity, entityIdOrOperation, operation] = request3.path.split(\"/\");\n    return {\n      stripe: {\n        version,\n        method,\n        entity,\n        entityIdOrOperation,\n        operation\n      }\n    };\n  }\n};\nvar plugin = new StripePlugin();\n\n// src/http-plugins/vercel.ts\nvar import_http4 = __webpack_require__(/*! http */ \"http\");\nvar VercelPlugin = class extends HttpPlugin {\n  name = \"vercel\";\n  shouldParseRequest(request3) {\n    if (request3 instanceof import_http4.IncomingMessage && request3.headers[\"x-vercel-id\"]) {\n      return true;\n    }\n    return false;\n  }\n  parseIncommingMessage(request3) {\n    const headers = request3.headers;\n    const vercelRequestId = headers[\"x-vercel-id\"];\n    if (typeof vercelRequestId === \"string\") {\n      const requestIdParts = vercelRequestId.split(\"::\");\n      const requestId = requestIdParts[requestIdParts.length - 1];\n      const user = {\n        ip: headers[\"x-forwarded-for\"],\n        country: headers[\"x-vercel-ip-country\"],\n        region: headers[\"x-vercel-ip-region\"],\n        city: headers[\"x-vercel-ip-city\"],\n        latitude: headers[\"x-vercel-ip-latitude\"],\n        longitude: headers[\"x-vercel-ip-longitude\"],\n        timezone: headers[\"x-vercel-ip-timezone\"]\n      };\n      return {\n        requestId,\n        faas: { execution: requestId },\n        user\n      };\n    }\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYmFzZWxpbWUrbm9kZS1vcGVudGVsZW1ldHJ5QDAuNS44X0B0cnBjK3NlcnZlckAxMC40NS4yL25vZGVfbW9kdWxlcy9AYmFzZWxpbWUvbm9kZS1vcGVudGVsZW1ldHJ5L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdDQUFnQztBQUNyQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNENBQTRDO0FBQ2pEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNEJBQTRCO0FBQ2pDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx3Q0FBd0M7QUFDN0M7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RCw2REFBNkQsTUFBTSxtQ0FBbUMsS0FBSztBQUMzRztBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsc0JBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsZ0NBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGNBQWM7QUFDZCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGVBQWU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixjQUFjO0FBQ2QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssa0RBQWtEO0FBQ3ZEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDhCQUFZO0FBQzVDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDRDQUE0QztBQUNqRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrQkFBa0I7QUFDbEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRCwrREFBK0QsTUFBTSxvQ0FBb0MsS0FBSztBQUM5RztBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsNEJBQTRCLEdBQUcsVUFBVSxHQUFHO0FBQzVDLDZCQUE2QixHQUFHLFVBQVUsR0FBRztBQUM3QywyQkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBCQUEwQjtBQUMvQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtVEFBbVQ7QUFDL1U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGNBQWM7QUFDZCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHLEVBQUUsSUFBSSxZQUFZLEdBQUcsd0NBQXdDLEdBQUc7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0Q0FBNEM7QUFDakQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixjQUFjO0FBQ2QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFVBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtCQUFrQjtBQUNsQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1FQUFtRSxxRkFBcUY7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDhDQUE4QztBQUNuRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtVEFBbVQ7QUFDL1U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLG9DQUFlO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLGtCQUFNO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QVE7QUFDUixjQUFjO0FBQ2QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixjQUFjO0FBQ2QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHlCQUF5QjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrQkFBa0I7QUFDbEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQkFBcUI7QUFDNUIsbUJBQW1CLG9EQUFvRDtBQUN2RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQSx3Q0FBd0M7QUFDeEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsVUFBVTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysa0JBQWtCO0FBQ2xCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsVUFBVTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysa0JBQWtCO0FBQ2xCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrQkFBa0I7QUFDbEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsVUFBVTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysa0JBQWtCO0FBQ2xCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBDQUEwQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsK0ZBQStGO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsaUJBQWlCO0FBQzVGO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQSxVQUFVO0FBQ1Ysa0JBQWtCO0FBQ2xCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixjQUFjO0FBQ2QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0NBQWtDLGdDQUFnQztBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE9BQU8scUJBQXFCO0FBQzVCLG1CQUFtQixvREFBb0Q7QUFDdkU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSxZQUFZLE9BQU8sSUFBSSxLQUFLLFlBQVksTUFBTSxZQUFZLE9BQU8sSUFBSSxLQUFLO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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R0FBRyxXQUFXO0FBQ2pFO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsR0FBRztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwrQ0FBK0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9CQUFvQjtBQUMzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCLElBQUk7QUFDL0IsVUFBVTtBQUNWLDJCQUEyQixJQUFJO0FBQy9CLFVBQVU7QUFDVix5QkFBeUIsS0FBSyxJQUFJLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsY0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLGtCQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVO0FBQ1YsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsY0FBSTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBSztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0ZBQWdGO0FBQ2hIO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1C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QUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxrQkFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQU1MIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYmFzZWxpbWUrbm9kZS1vcGVudGVsZW1ldHJ5QDAuNS44X0B0cnBjK3NlcnZlckAxMC40NS4yL25vZGVfbW9kdWxlcy9AYmFzZWxpbWUvbm9kZS1vcGVudGVsZW1ldHJ5L2Rpc3QvaW5kZXguY2pzfGluc3RydW1lbnQ/OTA3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXNtID0gKGZuLCByZXMpID0+IGZ1bmN0aW9uIF9faW5pdCgpIHtcbiAgcmV0dXJuIGZuICYmIChyZXMgPSAoMCwgZm5bX19nZXRPd25Qcm9wTmFtZXMoZm4pWzBdXSkoZm4gPSAwKSksIHJlcztcbn07XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9nbG9iYWxUaGlzLmpzXG52YXIgX2dsb2JhbFRoaXM7XG52YXIgaW5pdF9nbG9iYWxUaGlzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvZ2xvYmFsVGhpcy5qc1wiKCkge1xuICAgIF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgPyBnbG9iYWxUaGlzIDogZ2xvYmFsO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9pbmRleC5qc1xudmFyIGluaXRfbm9kZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2luZGV4LmpzXCIoKSB7XG4gICAgaW5pdF9nbG9iYWxUaGlzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9wbGF0Zm9ybS9pbmRleC5qc1xudmFyIGluaXRfcGxhdGZvcm0gPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vcGxhdGZvcm0vaW5kZXguanNcIigpIHtcbiAgICBpbml0X25vZGUoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3ZlcnNpb24uanNcbnZhciBWRVJTSU9OO1xudmFyIGluaXRfdmVyc2lvbiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS92ZXJzaW9uLmpzXCIoKSB7XG4gICAgVkVSU0lPTiA9IFwiMS44LjBcIjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2ludGVybmFsL3NlbXZlci5qc1xuZnVuY3Rpb24gX21ha2VDb21wYXRpYmlsaXR5Q2hlY2sob3duVmVyc2lvbikge1xuICB2YXIgYWNjZXB0ZWRWZXJzaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtvd25WZXJzaW9uXSk7XG4gIHZhciByZWplY3RlZFZlcnNpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdmFyIG15VmVyc2lvbk1hdGNoID0gb3duVmVyc2lvbi5tYXRjaChyZSk7XG4gIGlmICghbXlWZXJzaW9uTWF0Y2gpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuICB2YXIgb3duVmVyc2lvblBhcnNlZCA9IHtcbiAgICBtYWpvcjogK215VmVyc2lvbk1hdGNoWzFdLFxuICAgIG1pbm9yOiArbXlWZXJzaW9uTWF0Y2hbMl0sXG4gICAgcGF0Y2g6ICtteVZlcnNpb25NYXRjaFszXSxcbiAgICBwcmVyZWxlYXNlOiBteVZlcnNpb25NYXRjaFs0XVxuICB9O1xuICBpZiAob3duVmVyc2lvblBhcnNlZC5wcmVyZWxlYXNlICE9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNFeGFjdG1hdGNoKGdsb2JhbFZlcnNpb24pIHtcbiAgICAgIHJldHVybiBnbG9iYWxWZXJzaW9uID09PSBvd25WZXJzaW9uO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX3JlamVjdCh2KSB7XG4gICAgcmVqZWN0ZWRWZXJzaW9ucy5hZGQodik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIF9hY2NlcHQodikge1xuICAgIGFjY2VwdGVkVmVyc2lvbnMuYWRkKHYpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBpc0NvbXBhdGlibGUyKGdsb2JhbFZlcnNpb24pIHtcbiAgICBpZiAoYWNjZXB0ZWRWZXJzaW9ucy5oYXMoZ2xvYmFsVmVyc2lvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVqZWN0ZWRWZXJzaW9ucy5oYXMoZ2xvYmFsVmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdsb2JhbFZlcnNpb25NYXRjaCA9IGdsb2JhbFZlcnNpb24ubWF0Y2gocmUpO1xuICAgIGlmICghZ2xvYmFsVmVyc2lvbk1hdGNoKSB7XG4gICAgICByZXR1cm4gX3JlamVjdChnbG9iYWxWZXJzaW9uKTtcbiAgICB9XG4gICAgdmFyIGdsb2JhbFZlcnNpb25QYXJzZWQgPSB7XG4gICAgICBtYWpvcjogK2dsb2JhbFZlcnNpb25NYXRjaFsxXSxcbiAgICAgIG1pbm9yOiArZ2xvYmFsVmVyc2lvbk1hdGNoWzJdLFxuICAgICAgcGF0Y2g6ICtnbG9iYWxWZXJzaW9uTWF0Y2hbM10sXG4gICAgICBwcmVyZWxlYXNlOiBnbG9iYWxWZXJzaW9uTWF0Y2hbNF1cbiAgICB9O1xuICAgIGlmIChnbG9iYWxWZXJzaW9uUGFyc2VkLnByZXJlbGVhc2UgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9yZWplY3QoZ2xvYmFsVmVyc2lvbik7XG4gICAgfVxuICAgIGlmIChvd25WZXJzaW9uUGFyc2VkLm1ham9yICE9PSBnbG9iYWxWZXJzaW9uUGFyc2VkLm1ham9yKSB7XG4gICAgICByZXR1cm4gX3JlamVjdChnbG9iYWxWZXJzaW9uKTtcbiAgICB9XG4gICAgaWYgKG93blZlcnNpb25QYXJzZWQubWFqb3IgPT09IDApIHtcbiAgICAgIGlmIChvd25WZXJzaW9uUGFyc2VkLm1pbm9yID09PSBnbG9iYWxWZXJzaW9uUGFyc2VkLm1pbm9yICYmIG93blZlcnNpb25QYXJzZWQucGF0Y2ggPD0gZ2xvYmFsVmVyc2lvblBhcnNlZC5wYXRjaCkge1xuICAgICAgICByZXR1cm4gX2FjY2VwdChnbG9iYWxWZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVqZWN0KGdsb2JhbFZlcnNpb24pO1xuICAgIH1cbiAgICBpZiAob3duVmVyc2lvblBhcnNlZC5taW5vciA8PSBnbG9iYWxWZXJzaW9uUGFyc2VkLm1pbm9yKSB7XG4gICAgICByZXR1cm4gX2FjY2VwdChnbG9iYWxWZXJzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWplY3QoZ2xvYmFsVmVyc2lvbik7XG4gIH07XG59XG52YXIgcmUsIGlzQ29tcGF0aWJsZTtcbnZhciBpbml0X3NlbXZlciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9pbnRlcm5hbC9zZW12ZXIuanNcIigpIHtcbiAgICBpbml0X3ZlcnNpb24oKTtcbiAgICByZSA9IC9eKFxcZCspXFwuKFxcZCspXFwuKFxcZCspKC0oLispKT8kLztcbiAgICBpc0NvbXBhdGlibGUgPSBfbWFrZUNvbXBhdGliaWxpdHlDaGVjayhWRVJTSU9OKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2ludGVybmFsL2dsb2JhbC11dGlscy5qc1xuZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWwodHlwZSwgaW5zdGFuY2UsIGRpYWczLCBhbGxvd092ZXJyaWRlKSB7XG4gIHZhciBfYTI7XG4gIGlmIChhbGxvd092ZXJyaWRlID09PSB2b2lkIDApIHtcbiAgICBhbGxvd092ZXJyaWRlID0gZmFsc2U7XG4gIH1cbiAgdmFyIGFwaSA9IF9nbG9iYWxbR0xPQkFMX09QRU5URUxFTUVUUllfQVBJX0tFWV0gPSAoX2EyID0gX2dsb2JhbFtHTE9CQUxfT1BFTlRFTEVNRVRSWV9BUElfS0VZXSkgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiB7XG4gICAgdmVyc2lvbjogVkVSU0lPTlxuICB9O1xuICBpZiAoIWFsbG93T3ZlcnJpZGUgJiYgYXBpW3R5cGVdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIkBvcGVudGVsZW1ldHJ5L2FwaTogQXR0ZW1wdGVkIGR1cGxpY2F0ZSByZWdpc3RyYXRpb24gb2YgQVBJOiBcIiArIHR5cGUpO1xuICAgIGRpYWczLmVycm9yKGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcGkudmVyc2lvbiAhPT0gVkVSU0lPTikge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJAb3BlbnRlbGVtZXRyeS9hcGk6IFJlZ2lzdHJhdGlvbiBvZiB2ZXJzaW9uIHZcIiArIGFwaS52ZXJzaW9uICsgXCIgZm9yIFwiICsgdHlwZSArIFwiIGRvZXMgbm90IG1hdGNoIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBBUEkgdlwiICsgVkVSU0lPTik7XG4gICAgZGlhZzMuZXJyb3IoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXBpW3R5cGVdID0gaW5zdGFuY2U7XG4gIGRpYWczLmRlYnVnKFwiQG9wZW50ZWxlbWV0cnkvYXBpOiBSZWdpc3RlcmVkIGEgZ2xvYmFsIGZvciBcIiArIHR5cGUgKyBcIiB2XCIgKyBWRVJTSU9OICsgXCIuXCIpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbCh0eXBlKSB7XG4gIHZhciBfYTIsIF9iO1xuICB2YXIgZ2xvYmFsVmVyc2lvbiA9IChfYTIgPSBfZ2xvYmFsW0dMT0JBTF9PUEVOVEVMRU1FVFJZX0FQSV9LRVldKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi52ZXJzaW9uO1xuICBpZiAoIWdsb2JhbFZlcnNpb24gfHwgIWlzQ29tcGF0aWJsZShnbG9iYWxWZXJzaW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gKF9iID0gX2dsb2JhbFtHTE9CQUxfT1BFTlRFTEVNRVRSWV9BUElfS0VZXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3R5cGVdO1xufVxuZnVuY3Rpb24gdW5yZWdpc3Rlckdsb2JhbCh0eXBlLCBkaWFnMykge1xuICBkaWFnMy5kZWJ1ZyhcIkBvcGVudGVsZW1ldHJ5L2FwaTogVW5yZWdpc3RlcmluZyBhIGdsb2JhbCBmb3IgXCIgKyB0eXBlICsgXCIgdlwiICsgVkVSU0lPTiArIFwiLlwiKTtcbiAgdmFyIGFwaSA9IF9nbG9iYWxbR0xPQkFMX09QRU5URUxFTUVUUllfQVBJX0tFWV07XG4gIGlmIChhcGkpIHtcbiAgICBkZWxldGUgYXBpW3R5cGVdO1xuICB9XG59XG52YXIgbWFqb3IsIEdMT0JBTF9PUEVOVEVMRU1FVFJZX0FQSV9LRVksIF9nbG9iYWw7XG52YXIgaW5pdF9nbG9iYWxfdXRpbHMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vaW50ZXJuYWwvZ2xvYmFsLXV0aWxzLmpzXCIoKSB7XG4gICAgaW5pdF9wbGF0Zm9ybSgpO1xuICAgIGluaXRfdmVyc2lvbigpO1xuICAgIGluaXRfc2VtdmVyKCk7XG4gICAgbWFqb3IgPSBWRVJTSU9OLnNwbGl0KFwiLlwiKVswXTtcbiAgICBHTE9CQUxfT1BFTlRFTEVNRVRSWV9BUElfS0VZID0gU3ltYm9sLmZvcihcIm9wZW50ZWxlbWV0cnkuanMuYXBpLlwiICsgbWFqb3IpO1xuICAgIF9nbG9iYWwgPSBfZ2xvYmFsVGhpcztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvQ29tcG9uZW50TG9nZ2VyLmpzXG5mdW5jdGlvbiBsb2dQcm94eShmdW5jTmFtZSwgbmFtZXNwYWNlLCBhcmdzKSB7XG4gIHZhciBsb2dnZXIgPSBnZXRHbG9iYWwoXCJkaWFnXCIpO1xuICBpZiAoIWxvZ2dlcikge1xuICAgIHJldHVybjtcbiAgfVxuICBhcmdzLnVuc2hpZnQobmFtZXNwYWNlKTtcbiAgcmV0dXJuIGxvZ2dlcltmdW5jTmFtZV0uYXBwbHkobG9nZ2VyLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncyksIGZhbHNlKSk7XG59XG52YXIgX19yZWFkLCBfX3NwcmVhZEFycmF5LCBEaWFnQ29tcG9uZW50TG9nZ2VyO1xudmFyIGluaXRfQ29tcG9uZW50TG9nZ2VyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvQ29tcG9uZW50TG9nZ2VyLmpzXCIoKSB7XG4gICAgaW5pdF9nbG9iYWxfdXRpbHMoKTtcbiAgICBfX3JlYWQgPSBmdW5jdGlvbihvLCBuKSB7XG4gICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3IgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICAgICAgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFyO1xuICAgIH07XG4gICAgX19zcHJlYWRBcnJheSA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpXG4gICAgICAgICAgICAgIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbiAgICB9O1xuICAgIERpYWdDb21wb25lbnRMb2dnZXIgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBEaWFnQ29tcG9uZW50TG9nZ2VyMihwcm9wcykge1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2UgfHwgXCJEaWFnQ29tcG9uZW50TG9nZ2VyXCI7XG4gICAgICB9XG4gICAgICBEaWFnQ29tcG9uZW50TG9nZ2VyMi5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ1Byb3h5KFwiZGVidWdcIiwgdGhpcy5fbmFtZXNwYWNlLCBhcmdzKTtcbiAgICAgIH07XG4gICAgICBEaWFnQ29tcG9uZW50TG9nZ2VyMi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ1Byb3h5KFwiZXJyb3JcIiwgdGhpcy5fbmFtZXNwYWNlLCBhcmdzKTtcbiAgICAgIH07XG4gICAgICBEaWFnQ29tcG9uZW50TG9nZ2VyMi5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nUHJveHkoXCJpbmZvXCIsIHRoaXMuX25hbWVzcGFjZSwgYXJncyk7XG4gICAgICB9O1xuICAgICAgRGlhZ0NvbXBvbmVudExvZ2dlcjIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ1Byb3h5KFwid2FyblwiLCB0aGlzLl9uYW1lc3BhY2UsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIERpYWdDb21wb25lbnRMb2dnZXIyLnByb3RvdHlwZS52ZXJib3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dQcm94eShcInZlcmJvc2VcIiwgdGhpcy5fbmFtZXNwYWNlLCBhcmdzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRGlhZ0NvbXBvbmVudExvZ2dlcjI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vZGlhZy90eXBlcy5qc1xudmFyIERpYWdMb2dMZXZlbDtcbnZhciBpbml0X3R5cGVzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvdHlwZXMuanNcIigpIHtcbiAgICAoZnVuY3Rpb24oRGlhZ0xvZ0xldmVsMikge1xuICAgICAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgICBEaWFnTG9nTGV2ZWwyW0RpYWdMb2dMZXZlbDJbXCJFUlJPUlwiXSA9IDMwXSA9IFwiRVJST1JcIjtcbiAgICAgIERpYWdMb2dMZXZlbDJbRGlhZ0xvZ0xldmVsMltcIldBUk5cIl0gPSA1MF0gPSBcIldBUk5cIjtcbiAgICAgIERpYWdMb2dMZXZlbDJbRGlhZ0xvZ0xldmVsMltcIklORk9cIl0gPSA2MF0gPSBcIklORk9cIjtcbiAgICAgIERpYWdMb2dMZXZlbDJbRGlhZ0xvZ0xldmVsMltcIkRFQlVHXCJdID0gNzBdID0gXCJERUJVR1wiO1xuICAgICAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiVkVSQk9TRVwiXSA9IDgwXSA9IFwiVkVSQk9TRVwiO1xuICAgICAgRGlhZ0xvZ0xldmVsMltEaWFnTG9nTGV2ZWwyW1wiQUxMXCJdID0gOTk5OV0gPSBcIkFMTFwiO1xuICAgIH0pKERpYWdMb2dMZXZlbCB8fCAoRGlhZ0xvZ0xldmVsID0ge30pKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvaW50ZXJuYWwvbG9nTGV2ZWxMb2dnZXIuanNcbmZ1bmN0aW9uIGNyZWF0ZUxvZ0xldmVsRGlhZ0xvZ2dlcihtYXhMZXZlbCwgbG9nZ2VyKSB7XG4gIGlmIChtYXhMZXZlbCA8IERpYWdMb2dMZXZlbC5OT05FKSB7XG4gICAgbWF4TGV2ZWwgPSBEaWFnTG9nTGV2ZWwuTk9ORTtcbiAgfSBlbHNlIGlmIChtYXhMZXZlbCA+IERpYWdMb2dMZXZlbC5BTEwpIHtcbiAgICBtYXhMZXZlbCA9IERpYWdMb2dMZXZlbC5BTEw7XG4gIH1cbiAgbG9nZ2VyID0gbG9nZ2VyIHx8IHt9O1xuICBmdW5jdGlvbiBfZmlsdGVyRnVuYyhmdW5jTmFtZSwgdGhlTGV2ZWwpIHtcbiAgICB2YXIgdGhlRnVuYyA9IGxvZ2dlcltmdW5jTmFtZV07XG4gICAgaWYgKHR5cGVvZiB0aGVGdW5jID09PSBcImZ1bmN0aW9uXCIgJiYgbWF4TGV2ZWwgPj0gdGhlTGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGVGdW5jLmJpbmQobG9nZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlcnJvcjogX2ZpbHRlckZ1bmMoXCJlcnJvclwiLCBEaWFnTG9nTGV2ZWwuRVJST1IpLFxuICAgIHdhcm46IF9maWx0ZXJGdW5jKFwid2FyblwiLCBEaWFnTG9nTGV2ZWwuV0FSTiksXG4gICAgaW5mbzogX2ZpbHRlckZ1bmMoXCJpbmZvXCIsIERpYWdMb2dMZXZlbC5JTkZPKSxcbiAgICBkZWJ1ZzogX2ZpbHRlckZ1bmMoXCJkZWJ1Z1wiLCBEaWFnTG9nTGV2ZWwuREVCVUcpLFxuICAgIHZlcmJvc2U6IF9maWx0ZXJGdW5jKFwidmVyYm9zZVwiLCBEaWFnTG9nTGV2ZWwuVkVSQk9TRSlcbiAgfTtcbn1cbnZhciBpbml0X2xvZ0xldmVsTG9nZ2VyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvaW50ZXJuYWwvbG9nTGV2ZWxMb2dnZXIuanNcIigpIHtcbiAgICBpbml0X3R5cGVzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9hcGkvZGlhZy5qc1xudmFyIF9fcmVhZDIsIF9fc3ByZWFkQXJyYXkyLCBBUElfTkFNRSwgRGlhZ0FQSTtcbnZhciBpbml0X2RpYWcgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYXBpL2RpYWcuanNcIigpIHtcbiAgICBpbml0X0NvbXBvbmVudExvZ2dlcigpO1xuICAgIGluaXRfbG9nTGV2ZWxMb2dnZXIoKTtcbiAgICBpbml0X3R5cGVzKCk7XG4gICAgaW5pdF9nbG9iYWxfdXRpbHMoKTtcbiAgICBfX3JlYWQyID0gZnVuY3Rpb24obywgbikge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9O1xuICAgIF9fc3ByZWFkQXJyYXkyID0gZnVuY3Rpb24odG8sIGZyb20sIHBhY2spIHtcbiAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICAgICAgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuICAgIH07XG4gICAgQVBJX05BTUUgPSBcImRpYWdcIjtcbiAgICBEaWFnQVBJID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gRGlhZ0FQSTIoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9sb2dQcm94eShmdW5jTmFtZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9nZ2VyID0gZ2V0R2xvYmFsKFwiZGlhZ1wiKTtcbiAgICAgICAgICAgIGlmICghbG9nZ2VyKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyW2Z1bmNOYW1lXS5hcHBseShsb2dnZXIsIF9fc3ByZWFkQXJyYXkyKFtdLCBfX3JlYWQyKGFyZ3MpLCBmYWxzZSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGYyID0gdGhpcztcbiAgICAgICAgdmFyIHNldExvZ2dlciA9IGZ1bmN0aW9uKGxvZ2dlciwgb3B0aW9uc09yTG9nTGV2ZWwpIHtcbiAgICAgICAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgICAgICAgaWYgKG9wdGlvbnNPckxvZ0xldmVsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG9wdGlvbnNPckxvZ0xldmVsID0geyBsb2dMZXZlbDogRGlhZ0xvZ0xldmVsLklORk8gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvZ2dlciA9PT0gc2VsZjIpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGRpYWcgYXMgdGhlIGxvZ2dlciBmb3IgaXRzZWxmLiBQbGVhc2UgdXNlIGEgRGlhZ0xvZ2dlciBpbXBsZW1lbnRhdGlvbiBsaWtlIENvbnNvbGVEaWFnTG9nZ2VyIG9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICAgICAgc2VsZjIuZXJyb3IoKF9hMiA9IGVyci5zdGFjaykgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yTG9nTGV2ZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnNPckxvZ0xldmVsID0ge1xuICAgICAgICAgICAgICBsb2dMZXZlbDogb3B0aW9uc09yTG9nTGV2ZWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvbGRMb2dnZXIgPSBnZXRHbG9iYWwoXCJkaWFnXCIpO1xuICAgICAgICAgIHZhciBuZXdMb2dnZXIgPSBjcmVhdGVMb2dMZXZlbERpYWdMb2dnZXIoKF9iID0gb3B0aW9uc09yTG9nTGV2ZWwubG9nTGV2ZWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERpYWdMb2dMZXZlbC5JTkZPLCBsb2dnZXIpO1xuICAgICAgICAgIGlmIChvbGRMb2dnZXIgJiYgIW9wdGlvbnNPckxvZ0xldmVsLnN1cHByZXNzT3ZlcnJpZGVNZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSAoX2MgPSBuZXcgRXJyb3IoKS5zdGFjaykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCI8ZmFpbGVkIHRvIGdlbmVyYXRlIHN0YWNrdHJhY2U+XCI7XG4gICAgICAgICAgICBvbGRMb2dnZXIud2FybihcIkN1cnJlbnQgbG9nZ2VyIHdpbGwgYmUgb3ZlcndyaXR0ZW4gZnJvbSBcIiArIHN0YWNrKTtcbiAgICAgICAgICAgIG5ld0xvZ2dlci53YXJuKFwiQ3VycmVudCBsb2dnZXIgd2lsbCBvdmVyd3JpdGUgb25lIGFscmVhZHkgcmVnaXN0ZXJlZCBmcm9tIFwiICsgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJHbG9iYWwoXCJkaWFnXCIsIG5ld0xvZ2dlciwgc2VsZjIsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmMi5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG4gICAgICAgIHNlbGYyLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB1bnJlZ2lzdGVyR2xvYmFsKEFQSV9OQU1FLCBzZWxmMik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYyLmNyZWF0ZUNvbXBvbmVudExvZ2dlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERpYWdDb21wb25lbnRMb2dnZXIob3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYyLnZlcmJvc2UgPSBfbG9nUHJveHkoXCJ2ZXJib3NlXCIpO1xuICAgICAgICBzZWxmMi5kZWJ1ZyA9IF9sb2dQcm94eShcImRlYnVnXCIpO1xuICAgICAgICBzZWxmMi5pbmZvID0gX2xvZ1Byb3h5KFwiaW5mb1wiKTtcbiAgICAgICAgc2VsZjIud2FybiA9IF9sb2dQcm94eShcIndhcm5cIik7XG4gICAgICAgIHNlbGYyLmVycm9yID0gX2xvZ1Byb3h5KFwiZXJyb3JcIik7XG4gICAgICB9XG4gICAgICBEaWFnQVBJMi5pbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgRGlhZ0FQSTIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIERpYWdBUEkyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2JhZ2dhZ2UvaW50ZXJuYWwvYmFnZ2FnZS1pbXBsLmpzXG52YXIgX19yZWFkMywgX192YWx1ZXMsIEJhZ2dhZ2VJbXBsO1xudmFyIGluaXRfYmFnZ2FnZV9pbXBsID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2JhZ2dhZ2UvaW50ZXJuYWwvYmFnZ2FnZS1pbXBsLmpzXCIoKSB7XG4gICAgX19yZWFkMyA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghbSlcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0geyBlcnJvciB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgICAgICBtLmNhbGwoaSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXI7XG4gICAgfTtcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgICBpZiAobSlcbiAgICAgICAgcmV0dXJuIG0uY2FsbChvKTtcbiAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpXG4gICAgICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIH07XG4gICAgQmFnZ2FnZUltcGwgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBCYWdnYWdlSW1wbDIoZW50cmllcykge1xuICAgICAgICB0aGlzLl9lbnRyaWVzID0gZW50cmllcyA/IG5ldyBNYXAoZW50cmllcykgOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgQmFnZ2FnZUltcGwyLnByb3RvdHlwZS5nZXRFbnRyeSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9lbnRyaWVzLmdldChrZXkpO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpO1xuICAgICAgfTtcbiAgICAgIEJhZ2dhZ2VJbXBsMi5wcm90b3R5cGUuZ2V0QWxsRW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9lbnRyaWVzLmVudHJpZXMoKSkubWFwKGZ1bmN0aW9uKF9hMikge1xuICAgICAgICAgIHZhciBfYiA9IF9fcmVhZDMoX2EyLCAyKSwgayA9IF9iWzBdLCB2ID0gX2JbMV07XG4gICAgICAgICAgcmV0dXJuIFtrLCB2XTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQmFnZ2FnZUltcGwyLnByb3RvdHlwZS5zZXRFbnRyeSA9IGZ1bmN0aW9uKGtleSwgZW50cnkpIHtcbiAgICAgICAgdmFyIG5ld0JhZ2dhZ2UgPSBuZXcgQmFnZ2FnZUltcGwyKHRoaXMuX2VudHJpZXMpO1xuICAgICAgICBuZXdCYWdnYWdlLl9lbnRyaWVzLnNldChrZXksIGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIG5ld0JhZ2dhZ2U7XG4gICAgICB9O1xuICAgICAgQmFnZ2FnZUltcGwyLnByb3RvdHlwZS5yZW1vdmVFbnRyeSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgbmV3QmFnZ2FnZSA9IG5ldyBCYWdnYWdlSW1wbDIodGhpcy5fZW50cmllcyk7XG4gICAgICAgIG5ld0JhZ2dhZ2UuX2VudHJpZXMuZGVsZXRlKGtleSk7XG4gICAgICAgIHJldHVybiBuZXdCYWdnYWdlO1xuICAgICAgfTtcbiAgICAgIEJhZ2dhZ2VJbXBsMi5wcm90b3R5cGUucmVtb3ZlRW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTI7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAga2V5c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdCYWdnYWdlID0gbmV3IEJhZ2dhZ2VJbXBsMih0aGlzLl9lbnRyaWVzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBrZXlzXzEgPSBfX3ZhbHVlcyhrZXlzKSwga2V5c18xXzEgPSBrZXlzXzEubmV4dCgpOyAha2V5c18xXzEuZG9uZTsga2V5c18xXzEgPSBrZXlzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c18xXzEudmFsdWU7XG4gICAgICAgICAgICBuZXdCYWdnYWdlLl9lbnRyaWVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoa2V5c18xXzEgJiYgIWtleXNfMV8xLmRvbmUgJiYgKF9hMiA9IGtleXNfMS5yZXR1cm4pKVxuICAgICAgICAgICAgICBfYTIuY2FsbChrZXlzXzEpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8xKVxuICAgICAgICAgICAgICB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdCYWdnYWdlO1xuICAgICAgfTtcbiAgICAgIEJhZ2dhZ2VJbXBsMi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYWdnYWdlSW1wbDIoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQmFnZ2FnZUltcGwyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2JhZ2dhZ2UvaW50ZXJuYWwvc3ltYm9sLmpzXG52YXIgYmFnZ2FnZUVudHJ5TWV0YWRhdGFTeW1ib2w7XG52YXIgaW5pdF9zeW1ib2wgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYmFnZ2FnZS9pbnRlcm5hbC9zeW1ib2wuanNcIigpIHtcbiAgICBiYWdnYWdlRW50cnlNZXRhZGF0YVN5bWJvbCA9IFN5bWJvbChcIkJhZ2dhZ2VFbnRyeU1ldGFkYXRhXCIpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYmFnZ2FnZS91dGlscy5qc1xuZnVuY3Rpb24gY3JlYXRlQmFnZ2FnZShlbnRyaWVzKSB7XG4gIGlmIChlbnRyaWVzID09PSB2b2lkIDApIHtcbiAgICBlbnRyaWVzID0ge307XG4gIH1cbiAgcmV0dXJuIG5ldyBCYWdnYWdlSW1wbChuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGVudHJpZXMpKSk7XG59XG5mdW5jdGlvbiBiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmcoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgZGlhZy5lcnJvcihcIkNhbm5vdCBjcmVhdGUgYmFnZ2FnZSBtZXRhZGF0YSBmcm9tIHVua25vd24gdHlwZTogXCIgKyB0eXBlb2Ygc3RyKTtcbiAgICBzdHIgPSBcIlwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgX19UWVBFX186IGJhZ2dhZ2VFbnRyeU1ldGFkYXRhU3ltYm9sLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xufVxudmFyIGRpYWc7XG52YXIgaW5pdF91dGlscyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9iYWdnYWdlL3V0aWxzLmpzXCIoKSB7XG4gICAgaW5pdF9kaWFnKCk7XG4gICAgaW5pdF9iYWdnYWdlX2ltcGwoKTtcbiAgICBpbml0X3N5bWJvbCgpO1xuICAgIGRpYWcgPSBEaWFnQVBJLmluc3RhbmNlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9jb250ZXh0L2NvbnRleHQuanNcbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRLZXkoZGVzY3JpcHRpb24pIHtcbiAgcmV0dXJuIFN5bWJvbC5mb3IoZGVzY3JpcHRpb24pO1xufVxudmFyIEJhc2VDb250ZXh0LCBST09UX0NPTlRFWFQ7XG52YXIgaW5pdF9jb250ZXh0ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2NvbnRleHQvY29udGV4dC5qc1wiKCkge1xuICAgIEJhc2VDb250ZXh0ID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gQmFzZUNvbnRleHQyKHBhcmVudENvbnRleHQpIHtcbiAgICAgICAgdmFyIHNlbGYyID0gdGhpcztcbiAgICAgICAgc2VsZjIuX2N1cnJlbnRDb250ZXh0ID0gcGFyZW50Q29udGV4dCA/IG5ldyBNYXAocGFyZW50Q29udGV4dCkgOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBzZWxmMi5nZXRWYWx1ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHJldHVybiBzZWxmMi5fY3VycmVudENvbnRleHQuZ2V0KGtleSk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYyLnNldFZhbHVlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBjb250ZXh0MiA9IG5ldyBCYXNlQ29udGV4dDIoc2VsZjIuX2N1cnJlbnRDb250ZXh0KTtcbiAgICAgICAgICBjb250ZXh0Mi5fY3VycmVudENvbnRleHQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZjIuZGVsZXRlVmFsdWUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICB2YXIgY29udGV4dDIgPSBuZXcgQmFzZUNvbnRleHQyKHNlbGYyLl9jdXJyZW50Q29udGV4dCk7XG4gICAgICAgICAgY29udGV4dDIuX2N1cnJlbnRDb250ZXh0LmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCYXNlQ29udGV4dDI7XG4gICAgfSgpO1xuICAgIFJPT1RfQ09OVEVYVCA9IG5ldyBCYXNlQ29udGV4dCgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vZGlhZy9jb25zb2xlTG9nZ2VyLmpzXG52YXIgY29uc29sZU1hcCwgRGlhZ0NvbnNvbGVMb2dnZXI7XG52YXIgaW5pdF9jb25zb2xlTG9nZ2VyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWcvY29uc29sZUxvZ2dlci5qc1wiKCkge1xuICAgIGNvbnNvbGVNYXAgPSBbXG4gICAgICB7IG46IFwiZXJyb3JcIiwgYzogXCJlcnJvclwiIH0sXG4gICAgICB7IG46IFwid2FyblwiLCBjOiBcIndhcm5cIiB9LFxuICAgICAgeyBuOiBcImluZm9cIiwgYzogXCJpbmZvXCIgfSxcbiAgICAgIHsgbjogXCJkZWJ1Z1wiLCBjOiBcImRlYnVnXCIgfSxcbiAgICAgIHsgbjogXCJ2ZXJib3NlXCIsIGM6IFwidHJhY2VcIiB9XG4gICAgXTtcbiAgICBEaWFnQ29uc29sZUxvZ2dlciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIERpYWdDb25zb2xlTG9nZ2VyMigpIHtcbiAgICAgICAgZnVuY3Rpb24gX2NvbnNvbGVGdW5jKGZ1bmNOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zb2xlKSB7XG4gICAgICAgICAgICAgIHZhciB0aGVGdW5jID0gY29uc29sZVtmdW5jTmFtZV07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlRnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhlRnVuYyA9IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlRnVuYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZUZ1bmMuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc29sZU1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXNbY29uc29sZU1hcFtpXS5uXSA9IF9jb25zb2xlRnVuYyhjb25zb2xlTWFwW2ldLmMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gRGlhZ0NvbnNvbGVMb2dnZXIyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL21ldHJpY3MvTm9vcE1ldGVyLmpzXG5mdW5jdGlvbiBjcmVhdGVOb29wTWV0ZXIoKSB7XG4gIHJldHVybiBOT09QX01FVEVSO1xufVxudmFyIF9fZXh0ZW5kcywgTm9vcE1ldGVyLCBOb29wTWV0cmljLCBOb29wQ291bnRlck1ldHJpYywgTm9vcFVwRG93bkNvdW50ZXJNZXRyaWMsIE5vb3BIaXN0b2dyYW1NZXRyaWMsIE5vb3BPYnNlcnZhYmxlTWV0cmljLCBOb29wT2JzZXJ2YWJsZUNvdW50ZXJNZXRyaWMsIE5vb3BPYnNlcnZhYmxlR2F1Z2VNZXRyaWMsIE5vb3BPYnNlcnZhYmxlVXBEb3duQ291bnRlck1ldHJpYywgTk9PUF9NRVRFUiwgTk9PUF9DT1VOVEVSX01FVFJJQywgTk9PUF9ISVNUT0dSQU1fTUVUUklDLCBOT09QX1VQX0RPV05fQ09VTlRFUl9NRVRSSUMsIE5PT1BfT0JTRVJWQUJMRV9DT1VOVEVSX01FVFJJQywgTk9PUF9PQlNFUlZBQkxFX0dBVUdFX01FVFJJQywgTk9PUF9PQlNFUlZBQkxFX1VQX0RPV05fQ09VTlRFUl9NRVRSSUM7XG52YXIgaW5pdF9Ob29wTWV0ZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vbWV0cmljcy9Ob29wTWV0ZXIuanNcIigpIHtcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgICAgZDIuX19wcm90b19fID0gYjI7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBiMilcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHApKVxuICAgICAgICAgICAgICBkMltwXSA9IGIyW3BdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgTm9vcE1ldGVyID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gTm9vcE1ldGVyMigpIHtcbiAgICAgIH1cbiAgICAgIE5vb3BNZXRlcjIucHJvdG90eXBlLmNyZWF0ZUhpc3RvZ3JhbSA9IGZ1bmN0aW9uKF9uYW1lLCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gTk9PUF9ISVNUT0dSQU1fTUVUUklDO1xuICAgICAgfTtcbiAgICAgIE5vb3BNZXRlcjIucHJvdG90eXBlLmNyZWF0ZUNvdW50ZXIgPSBmdW5jdGlvbihfbmFtZSwgX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIE5PT1BfQ09VTlRFUl9NRVRSSUM7XG4gICAgICB9O1xuICAgICAgTm9vcE1ldGVyMi5wcm90b3R5cGUuY3JlYXRlVXBEb3duQ291bnRlciA9IGZ1bmN0aW9uKF9uYW1lLCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gTk9PUF9VUF9ET1dOX0NPVU5URVJfTUVUUklDO1xuICAgICAgfTtcbiAgICAgIE5vb3BNZXRlcjIucHJvdG90eXBlLmNyZWF0ZU9ic2VydmFibGVHYXVnZSA9IGZ1bmN0aW9uKF9uYW1lLCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gTk9PUF9PQlNFUlZBQkxFX0dBVUdFX01FVFJJQztcbiAgICAgIH07XG4gICAgICBOb29wTWV0ZXIyLnByb3RvdHlwZS5jcmVhdGVPYnNlcnZhYmxlQ291bnRlciA9IGZ1bmN0aW9uKF9uYW1lLCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gTk9PUF9PQlNFUlZBQkxFX0NPVU5URVJfTUVUUklDO1xuICAgICAgfTtcbiAgICAgIE5vb3BNZXRlcjIucHJvdG90eXBlLmNyZWF0ZU9ic2VydmFibGVVcERvd25Db3VudGVyID0gZnVuY3Rpb24oX25hbWUsIF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBOT09QX09CU0VSVkFCTEVfVVBfRE9XTl9DT1VOVEVSX01FVFJJQztcbiAgICAgIH07XG4gICAgICBOb29wTWV0ZXIyLnByb3RvdHlwZS5hZGRCYXRjaE9ic2VydmFibGVDYWxsYmFjayA9IGZ1bmN0aW9uKF9jYWxsYmFjaywgX29ic2VydmFibGVzKSB7XG4gICAgICB9O1xuICAgICAgTm9vcE1ldGVyMi5wcm90b3R5cGUucmVtb3ZlQmF0Y2hPYnNlcnZhYmxlQ2FsbGJhY2sgPSBmdW5jdGlvbihfY2FsbGJhY2spIHtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTm9vcE1ldGVyMjtcbiAgICB9KCk7XG4gICAgTm9vcE1ldHJpYyA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIE5vb3BNZXRyaWMyKCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5vb3BNZXRyaWMyO1xuICAgIH0oKTtcbiAgICBOb29wQ291bnRlck1ldHJpYyA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhOb29wQ291bnRlck1ldHJpYzIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBOb29wQ291bnRlck1ldHJpYzIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIE5vb3BDb3VudGVyTWV0cmljMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oX3ZhbHVlLCBfYXR0cmlidXRlcykge1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOb29wQ291bnRlck1ldHJpYzI7XG4gICAgfShOb29wTWV0cmljKTtcbiAgICBOb29wVXBEb3duQ291bnRlck1ldHJpYyA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhOb29wVXBEb3duQ291bnRlck1ldHJpYzIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBOb29wVXBEb3duQ291bnRlck1ldHJpYzIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIE5vb3BVcERvd25Db3VudGVyTWV0cmljMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oX3ZhbHVlLCBfYXR0cmlidXRlcykge1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOb29wVXBEb3duQ291bnRlck1ldHJpYzI7XG4gICAgfShOb29wTWV0cmljKTtcbiAgICBOb29wSGlzdG9ncmFtTWV0cmljID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzKE5vb3BIaXN0b2dyYW1NZXRyaWMyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTm9vcEhpc3RvZ3JhbU1ldHJpYzIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIE5vb3BIaXN0b2dyYW1NZXRyaWMyLnByb3RvdHlwZS5yZWNvcmQgPSBmdW5jdGlvbihfdmFsdWUsIF9hdHRyaWJ1dGVzKSB7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIE5vb3BIaXN0b2dyYW1NZXRyaWMyO1xuICAgIH0oTm9vcE1ldHJpYyk7XG4gICAgTm9vcE9ic2VydmFibGVNZXRyaWMgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBOb29wT2JzZXJ2YWJsZU1ldHJpYzIoKSB7XG4gICAgICB9XG4gICAgICBOb29wT2JzZXJ2YWJsZU1ldHJpYzIucHJvdG90eXBlLmFkZENhbGxiYWNrID0gZnVuY3Rpb24oX2NhbGxiYWNrKSB7XG4gICAgICB9O1xuICAgICAgTm9vcE9ic2VydmFibGVNZXRyaWMyLnByb3RvdHlwZS5yZW1vdmVDYWxsYmFjayA9IGZ1bmN0aW9uKF9jYWxsYmFjaykge1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOb29wT2JzZXJ2YWJsZU1ldHJpYzI7XG4gICAgfSgpO1xuICAgIE5vb3BPYnNlcnZhYmxlQ291bnRlck1ldHJpYyA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhOb29wT2JzZXJ2YWJsZUNvdW50ZXJNZXRyaWMyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTm9vcE9ic2VydmFibGVDb3VudGVyTWV0cmljMigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5vb3BPYnNlcnZhYmxlQ291bnRlck1ldHJpYzI7XG4gICAgfShOb29wT2JzZXJ2YWJsZU1ldHJpYyk7XG4gICAgTm9vcE9ic2VydmFibGVHYXVnZU1ldHJpYyA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhOb29wT2JzZXJ2YWJsZUdhdWdlTWV0cmljMiwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIE5vb3BPYnNlcnZhYmxlR2F1Z2VNZXRyaWMyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gTm9vcE9ic2VydmFibGVHYXVnZU1ldHJpYzI7XG4gICAgfShOb29wT2JzZXJ2YWJsZU1ldHJpYyk7XG4gICAgTm9vcE9ic2VydmFibGVVcERvd25Db3VudGVyTWV0cmljID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzKE5vb3BPYnNlcnZhYmxlVXBEb3duQ291bnRlck1ldHJpYzIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBOb29wT2JzZXJ2YWJsZVVwRG93bkNvdW50ZXJNZXRyaWMyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gTm9vcE9ic2VydmFibGVVcERvd25Db3VudGVyTWV0cmljMjtcbiAgICB9KE5vb3BPYnNlcnZhYmxlTWV0cmljKTtcbiAgICBOT09QX01FVEVSID0gbmV3IE5vb3BNZXRlcigpO1xuICAgIE5PT1BfQ09VTlRFUl9NRVRSSUMgPSBuZXcgTm9vcENvdW50ZXJNZXRyaWMoKTtcbiAgICBOT09QX0hJU1RPR1JBTV9NRVRSSUMgPSBuZXcgTm9vcEhpc3RvZ3JhbU1ldHJpYygpO1xuICAgIE5PT1BfVVBfRE9XTl9DT1VOVEVSX01FVFJJQyA9IG5ldyBOb29wVXBEb3duQ291bnRlck1ldHJpYygpO1xuICAgIE5PT1BfT0JTRVJWQUJMRV9DT1VOVEVSX01FVFJJQyA9IG5ldyBOb29wT2JzZXJ2YWJsZUNvdW50ZXJNZXRyaWMoKTtcbiAgICBOT09QX09CU0VSVkFCTEVfR0FVR0VfTUVUUklDID0gbmV3IE5vb3BPYnNlcnZhYmxlR2F1Z2VNZXRyaWMoKTtcbiAgICBOT09QX09CU0VSVkFCTEVfVVBfRE9XTl9DT1VOVEVSX01FVFJJQyA9IG5ldyBOb29wT2JzZXJ2YWJsZVVwRG93bkNvdW50ZXJNZXRyaWMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL21ldHJpY3MvTWV0cmljLmpzXG52YXIgVmFsdWVUeXBlO1xudmFyIGluaXRfTWV0cmljID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL21ldHJpY3MvTWV0cmljLmpzXCIoKSB7XG4gICAgKGZ1bmN0aW9uKFZhbHVlVHlwZTIpIHtcbiAgICAgIFZhbHVlVHlwZTJbVmFsdWVUeXBlMltcIklOVFwiXSA9IDBdID0gXCJJTlRcIjtcbiAgICAgIFZhbHVlVHlwZTJbVmFsdWVUeXBlMltcIkRPVUJMRVwiXSA9IDFdID0gXCJET1VCTEVcIjtcbiAgICB9KShWYWx1ZVR5cGUgfHwgKFZhbHVlVHlwZSA9IHt9KSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9wcm9wYWdhdGlvbi9UZXh0TWFwUHJvcGFnYXRvci5qc1xudmFyIGRlZmF1bHRUZXh0TWFwR2V0dGVyLCBkZWZhdWx0VGV4dE1hcFNldHRlcjtcbnZhciBpbml0X1RleHRNYXBQcm9wYWdhdG9yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3Byb3BhZ2F0aW9uL1RleHRNYXBQcm9wYWdhdG9yLmpzXCIoKSB7XG4gICAgZGVmYXVsdFRleHRNYXBHZXR0ZXIgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKGNhcnJpZXIsIGtleSkge1xuICAgICAgICBpZiAoY2FycmllciA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FycmllcltrZXldO1xuICAgICAgfSxcbiAgICAgIGtleXM6IGZ1bmN0aW9uKGNhcnJpZXIpIHtcbiAgICAgICAgaWYgKGNhcnJpZXIgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY2Fycmllcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBkZWZhdWx0VGV4dE1hcFNldHRlciA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24oY2Fycmllciwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoY2FycmllciA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJpZXJba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9jb250ZXh0L05vb3BDb250ZXh0TWFuYWdlci5qc1xudmFyIF9fcmVhZDQsIF9fc3ByZWFkQXJyYXkzLCBOb29wQ29udGV4dE1hbmFnZXI7XG52YXIgaW5pdF9Ob29wQ29udGV4dE1hbmFnZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vY29udGV4dC9Ob29wQ29udGV4dE1hbmFnZXIuanNcIigpIHtcbiAgICBpbml0X2NvbnRleHQoKTtcbiAgICBfX3JlYWQ0ID0gZnVuY3Rpb24obywgbikge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9O1xuICAgIF9fc3ByZWFkQXJyYXkzID0gZnVuY3Rpb24odG8sIGZyb20sIHBhY2spIHtcbiAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICAgICAgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuICAgIH07XG4gICAgTm9vcENvbnRleHRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gTm9vcENvbnRleHRNYW5hZ2VyMigpIHtcbiAgICAgIH1cbiAgICAgIE5vb3BDb250ZXh0TWFuYWdlcjIucHJvdG90eXBlLmFjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUk9PVF9DT05URVhUO1xuICAgICAgfTtcbiAgICAgIE5vb3BDb250ZXh0TWFuYWdlcjIucHJvdG90eXBlLndpdGggPSBmdW5jdGlvbihfY29udGV4dCwgZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5jYWxsLmFwcGx5KGZuLCBfX3NwcmVhZEFycmF5MyhbdGhpc0FyZ10sIF9fcmVhZDQoYXJncyksIGZhbHNlKSk7XG4gICAgICB9O1xuICAgICAgTm9vcENvbnRleHRNYW5hZ2VyMi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKF9jb250ZXh0LCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH07XG4gICAgICBOb29wQ29udGV4dE1hbmFnZXIyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgTm9vcENvbnRleHRNYW5hZ2VyMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gTm9vcENvbnRleHRNYW5hZ2VyMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9hcGkvY29udGV4dC5qc1xudmFyIF9fcmVhZDUsIF9fc3ByZWFkQXJyYXk0LCBBUElfTkFNRTIsIE5PT1BfQ09OVEVYVF9NQU5BR0VSLCBDb250ZXh0QVBJO1xudmFyIGluaXRfY29udGV4dDIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYXBpL2NvbnRleHQuanNcIigpIHtcbiAgICBpbml0X05vb3BDb250ZXh0TWFuYWdlcigpO1xuICAgIGluaXRfZ2xvYmFsX3V0aWxzKCk7XG4gICAgaW5pdF9kaWFnKCk7XG4gICAgX19yZWFkNSA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghbSlcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0geyBlcnJvciB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgICAgICBtLmNhbGwoaSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXI7XG4gICAgfTtcbiAgICBfX3NwcmVhZEFycmF5NCA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpXG4gICAgICAgICAgICAgIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbiAgICB9O1xuICAgIEFQSV9OQU1FMiA9IFwiY29udGV4dFwiO1xuICAgIE5PT1BfQ09OVEVYVF9NQU5BR0VSID0gbmV3IE5vb3BDb250ZXh0TWFuYWdlcigpO1xuICAgIENvbnRleHRBUEkgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBDb250ZXh0QVBJMigpIHtcbiAgICAgIH1cbiAgICAgIENvbnRleHRBUEkyLmdldEluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBDb250ZXh0QVBJMigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgICAgIH07XG4gICAgICBDb250ZXh0QVBJMi5wcm90b3R5cGUuc2V0R2xvYmFsQ29udGV4dE1hbmFnZXIgPSBmdW5jdGlvbihjb250ZXh0TWFuYWdlcikge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJHbG9iYWwoQVBJX05BTUUyLCBjb250ZXh0TWFuYWdlciwgRGlhZ0FQSS5pbnN0YW5jZSgpKTtcbiAgICAgIH07XG4gICAgICBDb250ZXh0QVBJMi5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZXh0TWFuYWdlcigpLmFjdGl2ZSgpO1xuICAgICAgfTtcbiAgICAgIENvbnRleHRBUEkyLnByb3RvdHlwZS53aXRoID0gZnVuY3Rpb24oY29udGV4dDIsIGZuLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgYXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9hMiA9IHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkpLndpdGguYXBwbHkoX2EyLCBfX3NwcmVhZEFycmF5NChbY29udGV4dDIsIGZuLCB0aGlzQXJnXSwgX19yZWFkNShhcmdzKSwgZmFsc2UpKTtcbiAgICAgIH07XG4gICAgICBDb250ZXh0QVBJMi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGNvbnRleHQyLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRleHRNYW5hZ2VyKCkuYmluZChjb250ZXh0MiwgdGFyZ2V0KTtcbiAgICAgIH07XG4gICAgICBDb250ZXh0QVBJMi5wcm90b3R5cGUuX2dldENvbnRleHRNYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRHbG9iYWwoQVBJX05BTUUyKSB8fCBOT09QX0NPTlRFWFRfTUFOQUdFUjtcbiAgICAgIH07XG4gICAgICBDb250ZXh0QVBJMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9nZXRDb250ZXh0TWFuYWdlcigpLmRpc2FibGUoKTtcbiAgICAgICAgdW5yZWdpc3Rlckdsb2JhbChBUElfTkFNRTIsIERpYWdBUEkuaW5zdGFuY2UoKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbnRleHRBUEkyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL3RyYWNlX2ZsYWdzLmpzXG52YXIgVHJhY2VGbGFncztcbnZhciBpbml0X3RyYWNlX2ZsYWdzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL3RyYWNlX2ZsYWdzLmpzXCIoKSB7XG4gICAgKGZ1bmN0aW9uKFRyYWNlRmxhZ3MyKSB7XG4gICAgICBUcmFjZUZsYWdzMltUcmFjZUZsYWdzMltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgICAgVHJhY2VGbGFnczJbVHJhY2VGbGFnczJbXCJTQU1QTEVEXCJdID0gMV0gPSBcIlNBTVBMRURcIjtcbiAgICB9KShUcmFjZUZsYWdzIHx8IChUcmFjZUZsYWdzID0ge30pKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL2ludmFsaWQtc3Bhbi1jb25zdGFudHMuanNcbnZhciBJTlZBTElEX1NQQU5JRCwgSU5WQUxJRF9UUkFDRUlELCBJTlZBTElEX1NQQU5fQ09OVEVYVDtcbnZhciBpbml0X2ludmFsaWRfc3Bhbl9jb25zdGFudHMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvaW52YWxpZC1zcGFuLWNvbnN0YW50cy5qc1wiKCkge1xuICAgIGluaXRfdHJhY2VfZmxhZ3MoKTtcbiAgICBJTlZBTElEX1NQQU5JRCA9IFwiMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIElOVkFMSURfVFJBQ0VJRCA9IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICBJTlZBTElEX1NQQU5fQ09OVEVYVCA9IHtcbiAgICAgIHRyYWNlSWQ6IElOVkFMSURfVFJBQ0VJRCxcbiAgICAgIHNwYW5JZDogSU5WQUxJRF9TUEFOSUQsXG4gICAgICB0cmFjZUZsYWdzOiBUcmFjZUZsYWdzLk5PTkVcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvTm9uUmVjb3JkaW5nU3Bhbi5qc1xudmFyIE5vblJlY29yZGluZ1NwYW47XG52YXIgaW5pdF9Ob25SZWNvcmRpbmdTcGFuID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL05vblJlY29yZGluZ1NwYW4uanNcIigpIHtcbiAgICBpbml0X2ludmFsaWRfc3Bhbl9jb25zdGFudHMoKTtcbiAgICBOb25SZWNvcmRpbmdTcGFuID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gTm9uUmVjb3JkaW5nU3BhbjIoX3NwYW5Db250ZXh0KSB7XG4gICAgICAgIGlmIChfc3BhbkNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgIF9zcGFuQ29udGV4dCA9IElOVkFMSURfU1BBTl9DT05URVhUO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NwYW5Db250ZXh0ID0gX3NwYW5Db250ZXh0O1xuICAgICAgfVxuICAgICAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLnNwYW5Db250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcGFuQ29udGV4dDtcbiAgICAgIH07XG4gICAgICBOb25SZWNvcmRpbmdTcGFuMi5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oX2tleSwgX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIE5vblJlY29yZGluZ1NwYW4yLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oX2F0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24oX25hbWUsIF9hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIE5vblJlY29yZGluZ1NwYW4yLnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbihfc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIE5vblJlY29yZGluZ1NwYW4yLnByb3RvdHlwZS51cGRhdGVOYW1lID0gZnVuY3Rpb24oX25hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKF9lbmRUaW1lKSB7XG4gICAgICB9O1xuICAgICAgTm9uUmVjb3JkaW5nU3BhbjIucHJvdG90eXBlLmlzUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBOb25SZWNvcmRpbmdTcGFuMi5wcm90b3R5cGUucmVjb3JkRXhjZXB0aW9uID0gZnVuY3Rpb24oX2V4Y2VwdGlvbiwgX3RpbWUpIHtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTm9uUmVjb3JkaW5nU3BhbjI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvY29udGV4dC11dGlscy5qc1xuZnVuY3Rpb24gZ2V0U3Bhbihjb250ZXh0Mikge1xuICByZXR1cm4gY29udGV4dDIuZ2V0VmFsdWUoU1BBTl9LRVkpIHx8IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZVNwYW4oKSB7XG4gIHJldHVybiBnZXRTcGFuKENvbnRleHRBUEkuZ2V0SW5zdGFuY2UoKS5hY3RpdmUoKSk7XG59XG5mdW5jdGlvbiBzZXRTcGFuKGNvbnRleHQyLCBzcGFuKSB7XG4gIHJldHVybiBjb250ZXh0Mi5zZXRWYWx1ZShTUEFOX0tFWSwgc3Bhbik7XG59XG5mdW5jdGlvbiBkZWxldGVTcGFuKGNvbnRleHQyKSB7XG4gIHJldHVybiBjb250ZXh0Mi5kZWxldGVWYWx1ZShTUEFOX0tFWSk7XG59XG5mdW5jdGlvbiBzZXRTcGFuQ29udGV4dChjb250ZXh0Miwgc3BhbkNvbnRleHQpIHtcbiAgcmV0dXJuIHNldFNwYW4oY29udGV4dDIsIG5ldyBOb25SZWNvcmRpbmdTcGFuKHNwYW5Db250ZXh0KSk7XG59XG5mdW5jdGlvbiBnZXRTcGFuQ29udGV4dChjb250ZXh0Mikge1xuICB2YXIgX2EyO1xuICByZXR1cm4gKF9hMiA9IGdldFNwYW4oY29udGV4dDIpKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5zcGFuQ29udGV4dCgpO1xufVxudmFyIFNQQU5fS0VZO1xudmFyIGluaXRfY29udGV4dF91dGlscyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9jb250ZXh0LXV0aWxzLmpzXCIoKSB7XG4gICAgaW5pdF9jb250ZXh0KCk7XG4gICAgaW5pdF9Ob25SZWNvcmRpbmdTcGFuKCk7XG4gICAgaW5pdF9jb250ZXh0MigpO1xuICAgIFNQQU5fS0VZID0gY3JlYXRlQ29udGV4dEtleShcIk9wZW5UZWxlbWV0cnkgQ29udGV4dCBLZXkgU1BBTlwiKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL3NwYW5jb250ZXh0LXV0aWxzLmpzXG5mdW5jdGlvbiBpc1ZhbGlkVHJhY2VJZCh0cmFjZUlkKSB7XG4gIHJldHVybiBWQUxJRF9UUkFDRUlEX1JFR0VYLnRlc3QodHJhY2VJZCkgJiYgdHJhY2VJZCAhPT0gSU5WQUxJRF9UUkFDRUlEO1xufVxuZnVuY3Rpb24gaXNWYWxpZFNwYW5JZChzcGFuSWQpIHtcbiAgcmV0dXJuIFZBTElEX1NQQU5JRF9SRUdFWC50ZXN0KHNwYW5JZCkgJiYgc3BhbklkICE9PSBJTlZBTElEX1NQQU5JRDtcbn1cbmZ1bmN0aW9uIGlzU3BhbkNvbnRleHRWYWxpZChzcGFuQ29udGV4dCkge1xuICByZXR1cm4gaXNWYWxpZFRyYWNlSWQoc3BhbkNvbnRleHQudHJhY2VJZCkgJiYgaXNWYWxpZFNwYW5JZChzcGFuQ29udGV4dC5zcGFuSWQpO1xufVxuZnVuY3Rpb24gd3JhcFNwYW5Db250ZXh0KHNwYW5Db250ZXh0KSB7XG4gIHJldHVybiBuZXcgTm9uUmVjb3JkaW5nU3BhbihzcGFuQ29udGV4dCk7XG59XG52YXIgVkFMSURfVFJBQ0VJRF9SRUdFWCwgVkFMSURfU1BBTklEX1JFR0VYO1xudmFyIGluaXRfc3BhbmNvbnRleHRfdXRpbHMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2Uvc3BhbmNvbnRleHQtdXRpbHMuanNcIigpIHtcbiAgICBpbml0X2ludmFsaWRfc3Bhbl9jb25zdGFudHMoKTtcbiAgICBpbml0X05vblJlY29yZGluZ1NwYW4oKTtcbiAgICBWQUxJRF9UUkFDRUlEX1JFR0VYID0gL14oWzAtOWEtZl17MzJ9KSQvaTtcbiAgICBWQUxJRF9TUEFOSURfUkVHRVggPSAvXlswLTlhLWZdezE2fSQvaTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL05vb3BUcmFjZXIuanNcbmZ1bmN0aW9uIGlzU3BhbkNvbnRleHQoc3BhbkNvbnRleHQpIHtcbiAgcmV0dXJuIHR5cGVvZiBzcGFuQ29udGV4dCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc3BhbkNvbnRleHRbXCJzcGFuSWRcIl0gPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNwYW5Db250ZXh0W1widHJhY2VJZFwiXSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc3BhbkNvbnRleHRbXCJ0cmFjZUZsYWdzXCJdID09PSBcIm51bWJlclwiO1xufVxudmFyIGNvbnRleHRBcGksIE5vb3BUcmFjZXI7XG52YXIgaW5pdF9Ob29wVHJhY2VyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL05vb3BUcmFjZXIuanNcIigpIHtcbiAgICBpbml0X2NvbnRleHQyKCk7XG4gICAgaW5pdF9jb250ZXh0X3V0aWxzKCk7XG4gICAgaW5pdF9Ob25SZWNvcmRpbmdTcGFuKCk7XG4gICAgaW5pdF9zcGFuY29udGV4dF91dGlscygpO1xuICAgIGNvbnRleHRBcGkgPSBDb250ZXh0QVBJLmdldEluc3RhbmNlKCk7XG4gICAgTm9vcFRyYWNlciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIE5vb3BUcmFjZXIyKCkge1xuICAgICAgfVxuICAgICAgTm9vcFRyYWNlcjIucHJvdG90eXBlLnN0YXJ0U3BhbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMsIGNvbnRleHQyKSB7XG4gICAgICAgIGlmIChjb250ZXh0MiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGV4dDIgPSBjb250ZXh0QXBpLmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290ID0gQm9vbGVhbihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucm9vdCk7XG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb25SZWNvcmRpbmdTcGFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudEZyb21Db250ZXh0ID0gY29udGV4dDIgJiYgZ2V0U3BhbkNvbnRleHQoY29udGV4dDIpO1xuICAgICAgICBpZiAoaXNTcGFuQ29udGV4dChwYXJlbnRGcm9tQ29udGV4dCkgJiYgaXNTcGFuQ29udGV4dFZhbGlkKHBhcmVudEZyb21Db250ZXh0KSkge1xuICAgICAgICAgIHJldHVybiBuZXcgTm9uUmVjb3JkaW5nU3BhbihwYXJlbnRGcm9tQ29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb25SZWNvcmRpbmdTcGFuKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBOb29wVHJhY2VyMi5wcm90b3R5cGUuc3RhcnRBY3RpdmVTcGFuID0gZnVuY3Rpb24obmFtZSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgICB2YXIgb3B0cztcbiAgICAgICAgdmFyIGN0eDtcbiAgICAgICAgdmFyIGZuO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGZuID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgb3B0cyA9IGFyZzI7XG4gICAgICAgICAgZm4gPSBhcmczO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdHMgPSBhcmcyO1xuICAgICAgICAgIGN0eCA9IGFyZzM7XG4gICAgICAgICAgZm4gPSBhcmc0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRDb250ZXh0ID0gY3R4ICE9PSBudWxsICYmIGN0eCAhPT0gdm9pZCAwID8gY3R4IDogY29udGV4dEFwaS5hY3RpdmUoKTtcbiAgICAgICAgdmFyIHNwYW4gPSB0aGlzLnN0YXJ0U3BhbihuYW1lLCBvcHRzLCBwYXJlbnRDb250ZXh0KTtcbiAgICAgICAgdmFyIGNvbnRleHRXaXRoU3BhblNldCA9IHNldFNwYW4ocGFyZW50Q29udGV4dCwgc3Bhbik7XG4gICAgICAgIHJldHVybiBjb250ZXh0QXBpLndpdGgoY29udGV4dFdpdGhTcGFuU2V0LCBmbiwgdm9pZCAwLCBzcGFuKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTm9vcFRyYWNlcjI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvUHJveHlUcmFjZXIuanNcbnZhciBOT09QX1RSQUNFUiwgUHJveHlUcmFjZXI7XG52YXIgaW5pdF9Qcm94eVRyYWNlciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9Qcm94eVRyYWNlci5qc1wiKCkge1xuICAgIGluaXRfTm9vcFRyYWNlcigpO1xuICAgIE5PT1BfVFJBQ0VSID0gbmV3IE5vb3BUcmFjZXIoKTtcbiAgICBQcm94eVRyYWNlciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIFByb3h5VHJhY2VyMihfcHJvdmlkZXIsIG5hbWUsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBfcHJvdmlkZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBQcm94eVRyYWNlcjIucHJvdG90eXBlLnN0YXJ0U3BhbiA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMsIGNvbnRleHQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFjZXIoKS5zdGFydFNwYW4obmFtZSwgb3B0aW9ucywgY29udGV4dDIpO1xuICAgICAgfTtcbiAgICAgIFByb3h5VHJhY2VyMi5wcm90b3R5cGUuc3RhcnRBY3RpdmVTcGFuID0gZnVuY3Rpb24oX25hbWUsIF9vcHRpb25zLCBfY29udGV4dCwgX2ZuKSB7XG4gICAgICAgIHZhciB0cmFjZXIgPSB0aGlzLl9nZXRUcmFjZXIoKTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodHJhY2VyLnN0YXJ0QWN0aXZlU3BhbiwgdHJhY2VyLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIFByb3h5VHJhY2VyMi5wcm90b3R5cGUuX2dldFRyYWNlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGVsZWdhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYWNlciA9IHRoaXMuX3Byb3ZpZGVyLmdldERlbGVnYXRlVHJhY2VyKHRoaXMubmFtZSwgdGhpcy52ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRyYWNlcikge1xuICAgICAgICAgIHJldHVybiBOT09QX1RSQUNFUjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IHRyYWNlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQcm94eVRyYWNlcjI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvTm9vcFRyYWNlclByb3ZpZGVyLmpzXG52YXIgTm9vcFRyYWNlclByb3ZpZGVyO1xudmFyIGluaXRfTm9vcFRyYWNlclByb3ZpZGVyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL05vb3BUcmFjZXJQcm92aWRlci5qc1wiKCkge1xuICAgIGluaXRfTm9vcFRyYWNlcigpO1xuICAgIE5vb3BUcmFjZXJQcm92aWRlciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIE5vb3BUcmFjZXJQcm92aWRlcjIoKSB7XG4gICAgICB9XG4gICAgICBOb29wVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5nZXRUcmFjZXIgPSBmdW5jdGlvbihfbmFtZSwgX3ZlcnNpb24sIF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9vcFRyYWNlcigpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOb29wVHJhY2VyUHJvdmlkZXIyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL1Byb3h5VHJhY2VyUHJvdmlkZXIuanNcbnZhciBOT09QX1RSQUNFUl9QUk9WSURFUiwgUHJveHlUcmFjZXJQcm92aWRlcjtcbnZhciBpbml0X1Byb3h5VHJhY2VyUHJvdmlkZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvUHJveHlUcmFjZXJQcm92aWRlci5qc1wiKCkge1xuICAgIGluaXRfUHJveHlUcmFjZXIoKTtcbiAgICBpbml0X05vb3BUcmFjZXJQcm92aWRlcigpO1xuICAgIE5PT1BfVFJBQ0VSX1BST1ZJREVSID0gbmV3IE5vb3BUcmFjZXJQcm92aWRlcigpO1xuICAgIFByb3h5VHJhY2VyUHJvdmlkZXIgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBQcm94eVRyYWNlclByb3ZpZGVyMigpIHtcbiAgICAgIH1cbiAgICAgIFByb3h5VHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5nZXRUcmFjZXIgPSBmdW5jdGlvbihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gdGhpcy5nZXREZWxlZ2F0ZVRyYWNlcihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKSkgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiBuZXcgUHJveHlUcmFjZXIodGhpcywgbmFtZSwgdmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgUHJveHlUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmdldERlbGVnYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gdGhpcy5fZGVsZWdhdGUpICE9PSBudWxsICYmIF9hMiAhPT0gdm9pZCAwID8gX2EyIDogTk9PUF9UUkFDRVJfUFJPVklERVI7XG4gICAgICB9O1xuICAgICAgUHJveHlUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLnNldERlbGVnYXRlID0gZnVuY3Rpb24oZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgIH07XG4gICAgICBQcm94eVRyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUuZ2V0RGVsZWdhdGVUcmFjZXIgPSBmdW5jdGlvbihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gdGhpcy5fZGVsZWdhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmdldFRyYWNlcihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJveHlUcmFjZXJQcm92aWRlcjI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvU2FtcGxpbmdSZXN1bHQuanNcbnZhciBTYW1wbGluZ0RlY2lzaW9uO1xudmFyIGluaXRfU2FtcGxpbmdSZXN1bHQgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvU2FtcGxpbmdSZXN1bHQuanNcIigpIHtcbiAgICAoZnVuY3Rpb24oU2FtcGxpbmdEZWNpc2lvbjMpIHtcbiAgICAgIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiTk9UX1JFQ09SRFwiXSA9IDBdID0gXCJOT1RfUkVDT1JEXCI7XG4gICAgICBTYW1wbGluZ0RlY2lzaW9uM1tTYW1wbGluZ0RlY2lzaW9uM1tcIlJFQ09SRFwiXSA9IDFdID0gXCJSRUNPUkRcIjtcbiAgICAgIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiUkVDT1JEX0FORF9TQU1QTEVEXCJdID0gMl0gPSBcIlJFQ09SRF9BTkRfU0FNUExFRFwiO1xuICAgIH0pKFNhbXBsaW5nRGVjaXNpb24gfHwgKFNhbXBsaW5nRGVjaXNpb24gPSB7fSkpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2Uvc3Bhbl9raW5kLmpzXG52YXIgU3BhbktpbmQ7XG52YXIgaW5pdF9zcGFuX2tpbmQgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2Uvc3Bhbl9raW5kLmpzXCIoKSB7XG4gICAgKGZ1bmN0aW9uKFNwYW5LaW5kMikge1xuICAgICAgU3BhbktpbmQyW1NwYW5LaW5kMltcIklOVEVSTkFMXCJdID0gMF0gPSBcIklOVEVSTkFMXCI7XG4gICAgICBTcGFuS2luZDJbU3BhbktpbmQyW1wiU0VSVkVSXCJdID0gMV0gPSBcIlNFUlZFUlwiO1xuICAgICAgU3BhbktpbmQyW1NwYW5LaW5kMltcIkNMSUVOVFwiXSA9IDJdID0gXCJDTElFTlRcIjtcbiAgICAgIFNwYW5LaW5kMltTcGFuS2luZDJbXCJQUk9EVUNFUlwiXSA9IDNdID0gXCJQUk9EVUNFUlwiO1xuICAgICAgU3BhbktpbmQyW1NwYW5LaW5kMltcIkNPTlNVTUVSXCJdID0gNF0gPSBcIkNPTlNVTUVSXCI7XG4gICAgfSkoU3BhbktpbmQgfHwgKFNwYW5LaW5kID0ge30pKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL3N0YXR1cy5qc1xudmFyIFNwYW5TdGF0dXNDb2RlO1xudmFyIGluaXRfc3RhdHVzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL3N0YXR1cy5qc1wiKCkge1xuICAgIChmdW5jdGlvbihTcGFuU3RhdHVzQ29kZTIpIHtcbiAgICAgIFNwYW5TdGF0dXNDb2RlMltTcGFuU3RhdHVzQ29kZTJbXCJVTlNFVFwiXSA9IDBdID0gXCJVTlNFVFwiO1xuICAgICAgU3BhblN0YXR1c0NvZGUyW1NwYW5TdGF0dXNDb2RlMltcIk9LXCJdID0gMV0gPSBcIk9LXCI7XG4gICAgICBTcGFuU3RhdHVzQ29kZTJbU3BhblN0YXR1c0NvZGUyW1wiRVJST1JcIl0gPSAyXSA9IFwiRVJST1JcIjtcbiAgICB9KShTcGFuU3RhdHVzQ29kZSB8fCAoU3BhblN0YXR1c0NvZGUgPSB7fSkpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvaW50ZXJuYWwvdHJhY2VzdGF0ZS12YWxpZGF0b3JzLmpzXG5mdW5jdGlvbiB2YWxpZGF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIFZBTElEX0tFWV9SRUdFWC50ZXN0KGtleSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiBWQUxJRF9WQUxVRV9CQVNFX1JFR0VYLnRlc3QodmFsdWUpICYmICFJTlZBTElEX1ZBTFVFX0NPTU1BX0VRVUFMX1JFR0VYLnRlc3QodmFsdWUpO1xufVxudmFyIFZBTElEX0tFWV9DSEFSX1JBTkdFLCBWQUxJRF9LRVksIFZBTElEX1ZFTkRPUl9LRVksIFZBTElEX0tFWV9SRUdFWCwgVkFMSURfVkFMVUVfQkFTRV9SRUdFWCwgSU5WQUxJRF9WQUxVRV9DT01NQV9FUVVBTF9SRUdFWDtcbnZhciBpbml0X3RyYWNlc3RhdGVfdmFsaWRhdG9ycyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9pbnRlcm5hbC90cmFjZXN0YXRlLXZhbGlkYXRvcnMuanNcIigpIHtcbiAgICBWQUxJRF9LRVlfQ0hBUl9SQU5HRSA9IFwiW18wLTlhLXotKi9dXCI7XG4gICAgVkFMSURfS0VZID0gXCJbYS16XVwiICsgVkFMSURfS0VZX0NIQVJfUkFOR0UgKyBcInswLDI1NX1cIjtcbiAgICBWQUxJRF9WRU5ET1JfS0VZID0gXCJbYS16MC05XVwiICsgVkFMSURfS0VZX0NIQVJfUkFOR0UgKyBcInswLDI0MH1AW2Etel1cIiArIFZBTElEX0tFWV9DSEFSX1JBTkdFICsgXCJ7MCwxM31cIjtcbiAgICBWQUxJRF9LRVlfUkVHRVggPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgVkFMSURfS0VZICsgXCJ8XCIgKyBWQUxJRF9WRU5ET1JfS0VZICsgXCIpJFwiKTtcbiAgICBWQUxJRF9WQUxVRV9CQVNFX1JFR0VYID0gL15bIC1+XXswLDI1NX1bIS1+XSQvO1xuICAgIElOVkFMSURfVkFMVUVfQ09NTUFfRVFVQUxfUkVHRVggPSAvLHw9LztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlL2ludGVybmFsL3RyYWNlc3RhdGUtaW1wbC5qc1xudmFyIE1BWF9UUkFDRV9TVEFURV9JVEVNUywgTUFYX1RSQUNFX1NUQVRFX0xFTiwgTElTVF9NRU1CRVJTX1NFUEFSQVRPUiwgTElTVF9NRU1CRVJfS0VZX1ZBTFVFX1NQTElUVEVSLCBUcmFjZVN0YXRlSW1wbDtcbnZhciBpbml0X3RyYWNlc3RhdGVfaW1wbCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9pbnRlcm5hbC90cmFjZXN0YXRlLWltcGwuanNcIigpIHtcbiAgICBpbml0X3RyYWNlc3RhdGVfdmFsaWRhdG9ycygpO1xuICAgIE1BWF9UUkFDRV9TVEFURV9JVEVNUyA9IDMyO1xuICAgIE1BWF9UUkFDRV9TVEFURV9MRU4gPSA1MTI7XG4gICAgTElTVF9NRU1CRVJTX1NFUEFSQVRPUiA9IFwiLFwiO1xuICAgIExJU1RfTUVNQkVSX0tFWV9WQUxVRV9TUExJVFRFUiA9IFwiPVwiO1xuICAgIFRyYWNlU3RhdGVJbXBsID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gVHJhY2VTdGF0ZUltcGwyKHJhd1RyYWNlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChyYXdUcmFjZVN0YXRlKVxuICAgICAgICAgIHRoaXMuX3BhcnNlKHJhd1RyYWNlU3RhdGUpO1xuICAgICAgfVxuICAgICAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0cmFjZVN0YXRlID0gdGhpcy5fY2xvbmUoKTtcbiAgICAgICAgaWYgKHRyYWNlU3RhdGUuX2ludGVybmFsU3RhdGUuaGFzKGtleSkpIHtcbiAgICAgICAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlU3RhdGUuX2ludGVybmFsU3RhdGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJhY2VTdGF0ZTtcbiAgICAgIH07XG4gICAgICBUcmFjZVN0YXRlSW1wbDIucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciB0cmFjZVN0YXRlID0gdGhpcy5fY2xvbmUoKTtcbiAgICAgICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGUuZ2V0KGtleSk7XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleXMoKS5yZWR1Y2UoZnVuY3Rpb24oYWdnLCBrZXkpIHtcbiAgICAgICAgICBhZ2cucHVzaChrZXkgKyBMSVNUX01FTUJFUl9LRVlfVkFMVUVfU1BMSVRURVIgKyBfdGhpcy5nZXQoa2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGFnZztcbiAgICAgICAgfSwgW10pLmpvaW4oTElTVF9NRU1CRVJTX1NFUEFSQVRPUik7XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbihyYXdUcmFjZVN0YXRlKSB7XG4gICAgICAgIGlmIChyYXdUcmFjZVN0YXRlLmxlbmd0aCA+IE1BWF9UUkFDRV9TVEFURV9MRU4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbFN0YXRlID0gcmF3VHJhY2VTdGF0ZS5zcGxpdChMSVNUX01FTUJFUlNfU0VQQVJBVE9SKS5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uKGFnZywgcGFydCkge1xuICAgICAgICAgIHZhciBsaXN0TWVtYmVyID0gcGFydC50cmltKCk7XG4gICAgICAgICAgdmFyIGkgPSBsaXN0TWVtYmVyLmluZGV4T2YoTElTVF9NRU1CRVJfS0VZX1ZBTFVFX1NQTElUVEVSKTtcbiAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBsaXN0TWVtYmVyLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbGlzdE1lbWJlci5zbGljZShpICsgMSwgcGFydC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlS2V5KGtleSkgJiYgdmFsaWRhdGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgYWdnLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhZ2c7XG4gICAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxTdGF0ZS5zaXplID4gTUFYX1RSQUNFX1NUQVRFX0lURU1TKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJuYWxTdGF0ZSA9IG5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLl9pbnRlcm5hbFN0YXRlLmVudHJpZXMoKSkucmV2ZXJzZSgpLnNsaWNlKDAsIE1BWF9UUkFDRV9TVEFURV9JVEVNUykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZUltcGwyLnByb3RvdHlwZS5fa2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9pbnRlcm5hbFN0YXRlLmtleXMoKSkucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICAgIFRyYWNlU3RhdGVJbXBsMi5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0cmFjZVN0YXRlID0gbmV3IFRyYWNlU3RhdGVJbXBsMigpO1xuICAgICAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlID0gbmV3IE1hcCh0aGlzLl9pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRyYWNlU3RhdGVJbXBsMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS90cmFjZS9pbnRlcm5hbC91dGlscy5qc1xuZnVuY3Rpb24gY3JlYXRlVHJhY2VTdGF0ZShyYXdUcmFjZVN0YXRlKSB7XG4gIHJldHVybiBuZXcgVHJhY2VTdGF0ZUltcGwocmF3VHJhY2VTdGF0ZSk7XG59XG52YXIgaW5pdF91dGlsczIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vdHJhY2UvaW50ZXJuYWwvdXRpbHMuanNcIigpIHtcbiAgICBpbml0X3RyYWNlc3RhdGVfaW1wbCgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vY29udGV4dC1hcGkuanNcbnZhciBjb250ZXh0O1xudmFyIGluaXRfY29udGV4dF9hcGkgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vY29udGV4dC1hcGkuanNcIigpIHtcbiAgICBpbml0X2NvbnRleHQyKCk7XG4gICAgY29udGV4dCA9IENvbnRleHRBUEkuZ2V0SW5zdGFuY2UoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2RpYWctYXBpLmpzXG52YXIgZGlhZzI7XG52YXIgaW5pdF9kaWFnX2FwaSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9kaWFnLWFwaS5qc1wiKCkge1xuICAgIGluaXRfZGlhZygpO1xuICAgIGRpYWcyID0gRGlhZ0FQSS5pbnN0YW5jZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vbWV0cmljcy9Ob29wTWV0ZXJQcm92aWRlci5qc1xudmFyIE5vb3BNZXRlclByb3ZpZGVyLCBOT09QX01FVEVSX1BST1ZJREVSO1xudmFyIGluaXRfTm9vcE1ldGVyUHJvdmlkZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vbWV0cmljcy9Ob29wTWV0ZXJQcm92aWRlci5qc1wiKCkge1xuICAgIGluaXRfTm9vcE1ldGVyKCk7XG4gICAgTm9vcE1ldGVyUHJvdmlkZXIgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBOb29wTWV0ZXJQcm92aWRlcjIoKSB7XG4gICAgICB9XG4gICAgICBOb29wTWV0ZXJQcm92aWRlcjIucHJvdG90eXBlLmdldE1ldGVyID0gZnVuY3Rpb24oX25hbWUsIF92ZXJzaW9uLCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gTk9PUF9NRVRFUjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTm9vcE1ldGVyUHJvdmlkZXIyO1xuICAgIH0oKTtcbiAgICBOT09QX01FVEVSX1BST1ZJREVSID0gbmV3IE5vb3BNZXRlclByb3ZpZGVyKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9hcGkvbWV0cmljcy5qc1xudmFyIEFQSV9OQU1FMywgTWV0cmljc0FQSTtcbnZhciBpbml0X21ldHJpY3MgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYXBpL21ldHJpY3MuanNcIigpIHtcbiAgICBpbml0X05vb3BNZXRlclByb3ZpZGVyKCk7XG4gICAgaW5pdF9nbG9iYWxfdXRpbHMoKTtcbiAgICBpbml0X2RpYWcoKTtcbiAgICBBUElfTkFNRTMgPSBcIm1ldHJpY3NcIjtcbiAgICBNZXRyaWNzQVBJID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gTWV0cmljc0FQSTIoKSB7XG4gICAgICB9XG4gICAgICBNZXRyaWNzQVBJMi5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBuZXcgTWV0cmljc0FQSTIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gICAgICB9O1xuICAgICAgTWV0cmljc0FQSTIucHJvdG90eXBlLnNldEdsb2JhbE1ldGVyUHJvdmlkZXIgPSBmdW5jdGlvbihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJHbG9iYWwoQVBJX05BTUUzLCBwcm92aWRlciwgRGlhZ0FQSS5pbnN0YW5jZSgpKTtcbiAgICAgIH07XG4gICAgICBNZXRyaWNzQVBJMi5wcm90b3R5cGUuZ2V0TWV0ZXJQcm92aWRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0R2xvYmFsKEFQSV9OQU1FMykgfHwgTk9PUF9NRVRFUl9QUk9WSURFUjtcbiAgICAgIH07XG4gICAgICBNZXRyaWNzQVBJMi5wcm90b3R5cGUuZ2V0TWV0ZXIgPSBmdW5jdGlvbihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGVyUHJvdmlkZXIoKS5nZXRNZXRlcihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICBNZXRyaWNzQVBJMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB1bnJlZ2lzdGVyR2xvYmFsKEFQSV9OQU1FMywgRGlhZ0FQSS5pbnN0YW5jZSgpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTWV0cmljc0FQSTI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vbWV0cmljcy1hcGkuanNcbnZhciBtZXRyaWNzO1xudmFyIGluaXRfbWV0cmljc19hcGkgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vbWV0cmljcy1hcGkuanNcIigpIHtcbiAgICBpbml0X21ldHJpY3MoKTtcbiAgICBtZXRyaWNzID0gTWV0cmljc0FQSS5nZXRJbnN0YW5jZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vcHJvcGFnYXRpb24vTm9vcFRleHRNYXBQcm9wYWdhdG9yLmpzXG52YXIgTm9vcFRleHRNYXBQcm9wYWdhdG9yO1xudmFyIGluaXRfTm9vcFRleHRNYXBQcm9wYWdhdG9yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3Byb3BhZ2F0aW9uL05vb3BUZXh0TWFwUHJvcGFnYXRvci5qc1wiKCkge1xuICAgIE5vb3BUZXh0TWFwUHJvcGFnYXRvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIE5vb3BUZXh0TWFwUHJvcGFnYXRvcjIoKSB7XG4gICAgICB9XG4gICAgICBOb29wVGV4dE1hcFByb3BhZ2F0b3IyLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbihfY29udGV4dCwgX2NhcnJpZXIpIHtcbiAgICAgIH07XG4gICAgICBOb29wVGV4dE1hcFByb3BhZ2F0b3IyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDIsIF9jYXJyaWVyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICAgIH07XG4gICAgICBOb29wVGV4dE1hcFByb3BhZ2F0b3IyLnByb3RvdHlwZS5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOb29wVGV4dE1hcFByb3BhZ2F0b3IyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2JhZ2dhZ2UvY29udGV4dC1oZWxwZXJzLmpzXG5mdW5jdGlvbiBnZXRCYWdnYWdlKGNvbnRleHQyKSB7XG4gIHJldHVybiBjb250ZXh0Mi5nZXRWYWx1ZShCQUdHQUdFX0tFWSkgfHwgdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlQmFnZ2FnZSgpIHtcbiAgcmV0dXJuIGdldEJhZ2dhZ2UoQ29udGV4dEFQSS5nZXRJbnN0YW5jZSgpLmFjdGl2ZSgpKTtcbn1cbmZ1bmN0aW9uIHNldEJhZ2dhZ2UoY29udGV4dDIsIGJhZ2dhZ2UpIHtcbiAgcmV0dXJuIGNvbnRleHQyLnNldFZhbHVlKEJBR0dBR0VfS0VZLCBiYWdnYWdlKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhZ2dhZ2UoY29udGV4dDIpIHtcbiAgcmV0dXJuIGNvbnRleHQyLmRlbGV0ZVZhbHVlKEJBR0dBR0VfS0VZKTtcbn1cbnZhciBCQUdHQUdFX0tFWTtcbnZhciBpbml0X2NvbnRleHRfaGVscGVycyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9iYWdnYWdlL2NvbnRleHQtaGVscGVycy5qc1wiKCkge1xuICAgIGluaXRfY29udGV4dDIoKTtcbiAgICBpbml0X2NvbnRleHQoKTtcbiAgICBCQUdHQUdFX0tFWSA9IGNyZWF0ZUNvbnRleHRLZXkoXCJPcGVuVGVsZW1ldHJ5IEJhZ2dhZ2UgS2V5XCIpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYXBpL3Byb3BhZ2F0aW9uLmpzXG52YXIgQVBJX05BTUU0LCBOT09QX1RFWFRfTUFQX1BST1BBR0FUT1IsIFByb3BhZ2F0aW9uQVBJO1xudmFyIGluaXRfcHJvcGFnYXRpb24gPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYXBpL3Byb3BhZ2F0aW9uLmpzXCIoKSB7XG4gICAgaW5pdF9nbG9iYWxfdXRpbHMoKTtcbiAgICBpbml0X05vb3BUZXh0TWFwUHJvcGFnYXRvcigpO1xuICAgIGluaXRfVGV4dE1hcFByb3BhZ2F0b3IoKTtcbiAgICBpbml0X2NvbnRleHRfaGVscGVycygpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X2RpYWcoKTtcbiAgICBBUElfTkFNRTQgPSBcInByb3BhZ2F0aW9uXCI7XG4gICAgTk9PUF9URVhUX01BUF9QUk9QQUdBVE9SID0gbmV3IE5vb3BUZXh0TWFwUHJvcGFnYXRvcigpO1xuICAgIFByb3BhZ2F0aW9uQVBJID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gUHJvcGFnYXRpb25BUEkyKCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUJhZ2dhZ2UgPSBjcmVhdGVCYWdnYWdlO1xuICAgICAgICB0aGlzLmdldEJhZ2dhZ2UgPSBnZXRCYWdnYWdlO1xuICAgICAgICB0aGlzLmdldEFjdGl2ZUJhZ2dhZ2UgPSBnZXRBY3RpdmVCYWdnYWdlO1xuICAgICAgICB0aGlzLnNldEJhZ2dhZ2UgPSBzZXRCYWdnYWdlO1xuICAgICAgICB0aGlzLmRlbGV0ZUJhZ2dhZ2UgPSBkZWxldGVCYWdnYWdlO1xuICAgICAgfVxuICAgICAgUHJvcGFnYXRpb25BUEkyLmdldEluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBQcm9wYWdhdGlvbkFQSTIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gICAgICB9O1xuICAgICAgUHJvcGFnYXRpb25BUEkyLnByb3RvdHlwZS5zZXRHbG9iYWxQcm9wYWdhdG9yID0gZnVuY3Rpb24ocHJvcGFnYXRvcikge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJHbG9iYWwoQVBJX05BTUU0LCBwcm9wYWdhdG9yLCBEaWFnQVBJLmluc3RhbmNlKCkpO1xuICAgICAgfTtcbiAgICAgIFByb3BhZ2F0aW9uQVBJMi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24oY29udGV4dDIsIGNhcnJpZXIsIHNldHRlcikge1xuICAgICAgICBpZiAoc2V0dGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICBzZXR0ZXIgPSBkZWZhdWx0VGV4dE1hcFNldHRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0R2xvYmFsUHJvcGFnYXRvcigpLmluamVjdChjb250ZXh0MiwgY2Fycmllciwgc2V0dGVyKTtcbiAgICAgIH07XG4gICAgICBQcm9wYWdhdGlvbkFQSTIucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbihjb250ZXh0MiwgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgICAgIGlmIChnZXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGdldHRlciA9IGRlZmF1bHRUZXh0TWFwR2V0dGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRHbG9iYWxQcm9wYWdhdG9yKCkuZXh0cmFjdChjb250ZXh0MiwgY2FycmllciwgZ2V0dGVyKTtcbiAgICAgIH07XG4gICAgICBQcm9wYWdhdGlvbkFQSTIucHJvdG90eXBlLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0R2xvYmFsUHJvcGFnYXRvcigpLmZpZWxkcygpO1xuICAgICAgfTtcbiAgICAgIFByb3BhZ2F0aW9uQVBJMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB1bnJlZ2lzdGVyR2xvYmFsKEFQSV9OQU1FNCwgRGlhZ0FQSS5pbnN0YW5jZSgpKTtcbiAgICAgIH07XG4gICAgICBQcm9wYWdhdGlvbkFQSTIucHJvdG90eXBlLl9nZXRHbG9iYWxQcm9wYWdhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRHbG9iYWwoQVBJX05BTUU0KSB8fCBOT09QX1RFWFRfTUFQX1BST1BBR0FUT1I7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3BhZ2F0aW9uQVBJMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9wcm9wYWdhdGlvbi1hcGkuanNcbnZhciBwcm9wYWdhdGlvbjtcbnZhciBpbml0X3Byb3BhZ2F0aW9uX2FwaSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9wcm9wYWdhdGlvbi1hcGkuanNcIigpIHtcbiAgICBpbml0X3Byb3BhZ2F0aW9uKCk7XG4gICAgcHJvcGFnYXRpb24gPSBQcm9wYWdhdGlvbkFQSS5nZXRJbnN0YW5jZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vYXBpL3RyYWNlLmpzXG52YXIgQVBJX05BTUU1LCBUcmFjZUFQSTtcbnZhciBpbml0X3RyYWNlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL2FwaS90cmFjZS5qc1wiKCkge1xuICAgIGluaXRfZ2xvYmFsX3V0aWxzKCk7XG4gICAgaW5pdF9Qcm94eVRyYWNlclByb3ZpZGVyKCk7XG4gICAgaW5pdF9zcGFuY29udGV4dF91dGlscygpO1xuICAgIGluaXRfY29udGV4dF91dGlscygpO1xuICAgIGluaXRfZGlhZygpO1xuICAgIEFQSV9OQU1FNSA9IFwidHJhY2VcIjtcbiAgICBUcmFjZUFQSSA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIFRyYWNlQVBJMigpIHtcbiAgICAgICAgdGhpcy5fcHJveHlUcmFjZXJQcm92aWRlciA9IG5ldyBQcm94eVRyYWNlclByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMud3JhcFNwYW5Db250ZXh0ID0gd3JhcFNwYW5Db250ZXh0O1xuICAgICAgICB0aGlzLmlzU3BhbkNvbnRleHRWYWxpZCA9IGlzU3BhbkNvbnRleHRWYWxpZDtcbiAgICAgICAgdGhpcy5kZWxldGVTcGFuID0gZGVsZXRlU3BhbjtcbiAgICAgICAgdGhpcy5nZXRTcGFuID0gZ2V0U3BhbjtcbiAgICAgICAgdGhpcy5nZXRBY3RpdmVTcGFuID0gZ2V0QWN0aXZlU3BhbjtcbiAgICAgICAgdGhpcy5nZXRTcGFuQ29udGV4dCA9IGdldFNwYW5Db250ZXh0O1xuICAgICAgICB0aGlzLnNldFNwYW4gPSBzZXRTcGFuO1xuICAgICAgICB0aGlzLnNldFNwYW5Db250ZXh0ID0gc2V0U3BhbkNvbnRleHQ7XG4gICAgICB9XG4gICAgICBUcmFjZUFQSTIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IFRyYWNlQVBJMigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgICAgIH07XG4gICAgICBUcmFjZUFQSTIucHJvdG90eXBlLnNldEdsb2JhbFRyYWNlclByb3ZpZGVyID0gZnVuY3Rpb24ocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSByZWdpc3Rlckdsb2JhbChBUElfTkFNRTUsIHRoaXMuX3Byb3h5VHJhY2VyUHJvdmlkZXIsIERpYWdBUEkuaW5zdGFuY2UoKSk7XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgdGhpcy5fcHJveHlUcmFjZXJQcm92aWRlci5zZXREZWxlZ2F0ZShwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICB9O1xuICAgICAgVHJhY2VBUEkyLnByb3RvdHlwZS5nZXRUcmFjZXJQcm92aWRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0R2xvYmFsKEFQSV9OQU1FNSkgfHwgdGhpcy5fcHJveHlUcmFjZXJQcm92aWRlcjtcbiAgICAgIH07XG4gICAgICBUcmFjZUFQSTIucHJvdG90eXBlLmdldFRyYWNlciA9IGZ1bmN0aW9uKG5hbWUsIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhY2VyUHJvdmlkZXIoKS5nZXRUcmFjZXIobmFtZSwgdmVyc2lvbik7XG4gICAgICB9O1xuICAgICAgVHJhY2VBUEkyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHVucmVnaXN0ZXJHbG9iYWwoQVBJX05BTUU1LCBEaWFnQVBJLmluc3RhbmNlKCkpO1xuICAgICAgICB0aGlzLl9wcm94eVRyYWNlclByb3ZpZGVyID0gbmV3IFByb3h5VHJhY2VyUHJvdmlkZXIoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVHJhY2VBUEkyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlLWFwaS5qc1xudmFyIHRyYWNlO1xudmFyIGluaXRfdHJhY2VfYXBpID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGkvYnVpbGQvZXNtL3RyYWNlLWFwaS5qc1wiKCkge1xuICAgIGluaXRfdHJhY2UoKTtcbiAgICB0cmFjZSA9IFRyYWNlQVBJLmdldEluc3RhbmNlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvYXBpL2J1aWxkL2VzbS9pbmRleC5qc1xudmFyIGVzbV9leHBvcnRzID0ge307XG5fX2V4cG9ydChlc21fZXhwb3J0cywge1xuICBEaWFnQ29uc29sZUxvZ2dlcjogKCkgPT4gRGlhZ0NvbnNvbGVMb2dnZXIsXG4gIERpYWdMb2dMZXZlbDogKCkgPT4gRGlhZ0xvZ0xldmVsLFxuICBJTlZBTElEX1NQQU5JRDogKCkgPT4gSU5WQUxJRF9TUEFOSUQsXG4gIElOVkFMSURfU1BBTl9DT05URVhUOiAoKSA9PiBJTlZBTElEX1NQQU5fQ09OVEVYVCxcbiAgSU5WQUxJRF9UUkFDRUlEOiAoKSA9PiBJTlZBTElEX1RSQUNFSUQsXG4gIFByb3h5VHJhY2VyOiAoKSA9PiBQcm94eVRyYWNlcixcbiAgUHJveHlUcmFjZXJQcm92aWRlcjogKCkgPT4gUHJveHlUcmFjZXJQcm92aWRlcixcbiAgUk9PVF9DT05URVhUOiAoKSA9PiBST09UX0NPTlRFWFQsXG4gIFNhbXBsaW5nRGVjaXNpb246ICgpID0+IFNhbXBsaW5nRGVjaXNpb24sXG4gIFNwYW5LaW5kOiAoKSA9PiBTcGFuS2luZCxcbiAgU3BhblN0YXR1c0NvZGU6ICgpID0+IFNwYW5TdGF0dXNDb2RlLFxuICBUcmFjZUZsYWdzOiAoKSA9PiBUcmFjZUZsYWdzLFxuICBWYWx1ZVR5cGU6ICgpID0+IFZhbHVlVHlwZSxcbiAgYmFnZ2FnZUVudHJ5TWV0YWRhdGFGcm9tU3RyaW5nOiAoKSA9PiBiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmcsXG4gIGNvbnRleHQ6ICgpID0+IGNvbnRleHQsXG4gIGNyZWF0ZUNvbnRleHRLZXk6ICgpID0+IGNyZWF0ZUNvbnRleHRLZXksXG4gIGNyZWF0ZU5vb3BNZXRlcjogKCkgPT4gY3JlYXRlTm9vcE1ldGVyLFxuICBjcmVhdGVUcmFjZVN0YXRlOiAoKSA9PiBjcmVhdGVUcmFjZVN0YXRlLFxuICBkZWZhdWx0OiAoKSA9PiBlc21fZGVmYXVsdCxcbiAgZGVmYXVsdFRleHRNYXBHZXR0ZXI6ICgpID0+IGRlZmF1bHRUZXh0TWFwR2V0dGVyLFxuICBkZWZhdWx0VGV4dE1hcFNldHRlcjogKCkgPT4gZGVmYXVsdFRleHRNYXBTZXR0ZXIsXG4gIGRpYWc6ICgpID0+IGRpYWcyLFxuICBpc1NwYW5Db250ZXh0VmFsaWQ6ICgpID0+IGlzU3BhbkNvbnRleHRWYWxpZCxcbiAgaXNWYWxpZFNwYW5JZDogKCkgPT4gaXNWYWxpZFNwYW5JZCxcbiAgaXNWYWxpZFRyYWNlSWQ6ICgpID0+IGlzVmFsaWRUcmFjZUlkLFxuICBtZXRyaWNzOiAoKSA9PiBtZXRyaWNzLFxuICBwcm9wYWdhdGlvbjogKCkgPT4gcHJvcGFnYXRpb24sXG4gIHRyYWNlOiAoKSA9PiB0cmFjZVxufSk7XG52YXIgZXNtX2RlZmF1bHQ7XG52YXIgaW5pdF9lc20gPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS9idWlsZC9lc20vaW5kZXguanNcIigpIHtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9jb250ZXh0KCk7XG4gICAgaW5pdF9jb25zb2xlTG9nZ2VyKCk7XG4gICAgaW5pdF90eXBlcygpO1xuICAgIGluaXRfTm9vcE1ldGVyKCk7XG4gICAgaW5pdF9NZXRyaWMoKTtcbiAgICBpbml0X1RleHRNYXBQcm9wYWdhdG9yKCk7XG4gICAgaW5pdF9Qcm94eVRyYWNlcigpO1xuICAgIGluaXRfUHJveHlUcmFjZXJQcm92aWRlcigpO1xuICAgIGluaXRfU2FtcGxpbmdSZXN1bHQoKTtcbiAgICBpbml0X3NwYW5fa2luZCgpO1xuICAgIGluaXRfc3RhdHVzKCk7XG4gICAgaW5pdF90cmFjZV9mbGFncygpO1xuICAgIGluaXRfdXRpbHMyKCk7XG4gICAgaW5pdF9zcGFuY29udGV4dF91dGlscygpO1xuICAgIGluaXRfaW52YWxpZF9zcGFuX2NvbnN0YW50cygpO1xuICAgIGluaXRfY29udGV4dF9hcGkoKTtcbiAgICBpbml0X2RpYWdfYXBpKCk7XG4gICAgaW5pdF9tZXRyaWNzX2FwaSgpO1xuICAgIGluaXRfcHJvcGFnYXRpb25fYXBpKCk7XG4gICAgaW5pdF90cmFjZV9hcGkoKTtcbiAgICBlc21fZGVmYXVsdCA9IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBkaWFnOiBkaWFnMixcbiAgICAgIG1ldHJpY3MsXG4gICAgICBwcm9wYWdhdGlvbixcbiAgICAgIHRyYWNlXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb250ZXh0LWFzeW5jLWhvb2tzL2J1aWxkL3NyYy9BYnN0cmFjdEFzeW5jSG9va3NDb250ZXh0TWFuYWdlci5qc1xudmFyIHJlcXVpcmVfQWJzdHJhY3RBc3luY0hvb2tzQ29udGV4dE1hbmFnZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29udGV4dC1hc3luYy1ob29rcy9idWlsZC9zcmMvQWJzdHJhY3RBc3luY0hvb2tzQ29udGV4dE1hbmFnZXIuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuQWJzdHJhY3RBc3luY0hvb2tzQ29udGV4dE1hbmFnZXIgPSB2b2lkIDA7XG4gICAgdmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbiAgICB2YXIgQUREX0xJU1RFTkVSX01FVEhPRFMgPSBbXG4gICAgICBcImFkZExpc3RlbmVyXCIsXG4gICAgICBcIm9uXCIsXG4gICAgICBcIm9uY2VcIixcbiAgICAgIFwicHJlcGVuZExpc3RlbmVyXCIsXG4gICAgICBcInByZXBlbmRPbmNlTGlzdGVuZXJcIlxuICAgIF07XG4gICAgdmFyIEFic3RyYWN0QXN5bmNIb29rc0NvbnRleHRNYW5hZ2VyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2tPdExpc3RlbmVycyA9IFN5bWJvbChcIk90TGlzdGVuZXJzXCIpO1xuICAgICAgICB0aGlzLl93cmFwcGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEJpbmRzIGEgdGhlIGNlcnRhaW4gY29udGV4dCBvciB0aGUgYWN0aXZlIG9uZSB0byB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZCB0aGVuIHJldHVybnMgdGhlIHRhcmdldFxuICAgICAgICogQHBhcmFtIGNvbnRleHQgQSBjb250ZXh0IChzcGFuKSB0byBiZSBiaW5kIHRvIHRhcmdldFxuICAgICAgICogQHBhcmFtIHRhcmdldCBhIGZ1bmN0aW9uIG9yIGV2ZW50IGVtaXR0ZXIuIFdoZW4gdGFyZ2V0IG9yIG9uZSBvZiBpdHMgY2FsbGJhY2tzIGlzIGNhbGxlZCxcbiAgICAgICAqICB0aGUgcHJvdmlkZWQgY29udGV4dCB3aWxsIGJlIHVzZWQgYXMgdGhlIGFjdGl2ZSBjb250ZXh0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGNhbGwuXG4gICAgICAgKi9cbiAgICAgIGJpbmQoY29udGV4dDIsIHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRFdmVudEVtaXR0ZXIoY29udGV4dDIsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9iaW5kRnVuY3Rpb24oY29udGV4dDIsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIF9iaW5kRnVuY3Rpb24oY29udGV4dDIsIHRhcmdldCkge1xuICAgICAgICBjb25zdCBtYW5hZ2VyID0gdGhpcztcbiAgICAgICAgY29uc3QgY29udGV4dFdyYXBwZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIG1hbmFnZXIud2l0aChjb250ZXh0MiwgKCkgPT4gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRleHRXcmFwcGVyLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogdGFyZ2V0Lmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRXcmFwcGVyO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBCeSBkZWZhdWx0LCBFdmVudEVtaXR0ZXIgY2FsbCB0aGVpciBjYWxsYmFjayB3aXRoIHRoZWlyIGNvbnRleHQsIHdoaWNoIHdlIGRvXG4gICAgICAgKiBub3Qgd2FudCwgaW5zdGVhZCB3ZSB3aWxsIGJpbmQgYSBzcGVjaWZpYyBjb250ZXh0IHRvIGFsbCBjYWxsYmFja3MgdGhhdFxuICAgICAgICogZ28gdGhyb3VnaCBpdC5cbiAgICAgICAqIEBwYXJhbSBjb250ZXh0IHRoZSBjb250ZXh0IHdlIHdhbnQgdG8gYmluZFxuICAgICAgICogQHBhcmFtIGVlIEV2ZW50RW1pdHRlciBhbiBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgdG8gcGF0Y2hcbiAgICAgICAqL1xuICAgICAgX2JpbmRFdmVudEVtaXR0ZXIoY29udGV4dDIsIGVlKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuX2dldFBhdGNoTWFwKGVlKTtcbiAgICAgICAgaWYgKG1hcCAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiBlZTtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGF0Y2hNYXAoZWUpO1xuICAgICAgICBBRERfTElTVEVORVJfTUVUSE9EUy5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKGVlW21ldGhvZE5hbWVdID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZWVbbWV0aG9kTmFtZV0gPSB0aGlzLl9wYXRjaEFkZExpc3RlbmVyKGVlLCBlZVttZXRob2ROYW1lXSwgY29udGV4dDIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBlZS5yZW1vdmVMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZWUucmVtb3ZlTGlzdGVuZXIgPSB0aGlzLl9wYXRjaFJlbW92ZUxpc3RlbmVyKGVlLCBlZS5yZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlZS5vZmYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGVlLm9mZiA9IHRoaXMuX3BhdGNoUmVtb3ZlTGlzdGVuZXIoZWUsIGVlLm9mZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGVlLnJlbW92ZUFsbExpc3RlbmVycyA9IHRoaXMuX3BhdGNoUmVtb3ZlQWxsTGlzdGVuZXJzKGVlLCBlZS5yZW1vdmVBbGxMaXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUGF0Y2ggbWV0aG9kcyB0aGF0IHJlbW92ZSBhIGdpdmVuIGxpc3RlbmVyIHNvIHRoYXQgd2UgbWF0Y2ggdGhlIFwicGF0Y2hlZFwiXG4gICAgICAgKiB2ZXJzaW9uIG9mIHRoYXQgbGlzdGVuZXIgKHRoZSBvbmUgdGhhdCBwcm9wYWdhdGUgY29udGV4dCkuXG4gICAgICAgKiBAcGFyYW0gZWUgRXZlbnRFbWl0dGVyIGluc3RhbmNlXG4gICAgICAgKiBAcGFyYW0gb3JpZ2luYWwgcmVmZXJlbmNlIHRvIHRoZSBwYXRjaGVkIG1ldGhvZFxuICAgICAgICovXG4gICAgICBfcGF0Y2hSZW1vdmVMaXN0ZW5lcihlZSwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3QgY29udGV4dE1hbmFnZXIgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICBjb25zdCBldmVudHMgPSAoX2EyID0gY29udGV4dE1hbmFnZXIuX2dldFBhdGNoTWFwKGVlKSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTJbZXZlbnRdO1xuICAgICAgICAgIGlmIChldmVudHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwodGhpcywgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcGF0Y2hlZExpc3RlbmVyID0gZXZlbnRzLmdldChsaXN0ZW5lcik7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwodGhpcywgZXZlbnQsIHBhdGNoZWRMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFBhdGNoIG1ldGhvZHMgdGhhdCByZW1vdmUgYWxsIGxpc3RlbmVycyBzbyB3ZSByZW1vdmUgb3VyXG4gICAgICAgKiBpbnRlcm5hbCByZWZlcmVuY2VzIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAgICogQHBhcmFtIGVlIEV2ZW50RW1pdHRlciBpbnN0YW5jZVxuICAgICAgICogQHBhcmFtIG9yaWdpbmFsIHJlZmVyZW5jZSB0byB0aGUgcGF0Y2hlZCBtZXRob2RcbiAgICAgICAqL1xuICAgICAgX3BhdGNoUmVtb3ZlQWxsTGlzdGVuZXJzKGVlLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBjb250ZXh0TWFuYWdlciA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIGNvbnN0IG1hcCA9IGNvbnRleHRNYW5hZ2VyLl9nZXRQYXRjaE1hcChlZSk7XG4gICAgICAgICAgaWYgKG1hcCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb250ZXh0TWFuYWdlci5fY3JlYXRlUGF0Y2hNYXAoZWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBbZXZlbnRdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG1hcFtldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBQYXRjaCBtZXRob2RzIG9uIGFuIGV2ZW50IGVtaXR0ZXIgaW5zdGFuY2UgdGhhdCBjYW4gYWRkIGxpc3RlbmVycyBzbyB3ZVxuICAgICAgICogY2FuIGZvcmNlIHRoZW0gdG8gcHJvcGFnYXRlIGEgZ2l2ZW4gY29udGV4dC5cbiAgICAgICAqIEBwYXJhbSBlZSBFdmVudEVtaXR0ZXIgaW5zdGFuY2VcbiAgICAgICAqIEBwYXJhbSBvcmlnaW5hbCByZWZlcmVuY2UgdG8gdGhlIHBhdGNoZWQgbWV0aG9kXG4gICAgICAgKiBAcGFyYW0gW2NvbnRleHRdIGNvbnRleHQgdG8gcHJvcGFnYXRlIHdoZW4gY2FsbGluZyBsaXN0ZW5lcnNcbiAgICAgICAqL1xuICAgICAgX3BhdGNoQWRkTGlzdGVuZXIoZWUsIG9yaWdpbmFsLCBjb250ZXh0Mikge1xuICAgICAgICBjb25zdCBjb250ZXh0TWFuYWdlciA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICBpZiAoY29udGV4dE1hbmFnZXIuX3dyYXBwZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5jYWxsKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBtYXAgPSBjb250ZXh0TWFuYWdlci5fZ2V0UGF0Y2hNYXAoZWUpO1xuICAgICAgICAgIGlmIChtYXAgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbWFwID0gY29udGV4dE1hbmFnZXIuX2NyZWF0ZVBhdGNoTWFwKGVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGxpc3RlbmVycyA9IG1hcFtldmVudF07XG4gICAgICAgICAgaWYgKGxpc3RlbmVycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIG1hcFtldmVudF0gPSBsaXN0ZW5lcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBhdGNoZWRMaXN0ZW5lciA9IGNvbnRleHRNYW5hZ2VyLmJpbmQoY29udGV4dDIsIGxpc3RlbmVyKTtcbiAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCBwYXRjaGVkTGlzdGVuZXIpO1xuICAgICAgICAgIGNvbnRleHRNYW5hZ2VyLl93cmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwodGhpcywgZXZlbnQsIHBhdGNoZWRMaXN0ZW5lcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnRleHRNYW5hZ2VyLl93cmFwcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgX2NyZWF0ZVBhdGNoTWFwKGVlKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlZVt0aGlzLl9rT3RMaXN0ZW5lcnNdID0gbWFwO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuICAgICAgX2dldFBhdGNoTWFwKGVlKSB7XG4gICAgICAgIHJldHVybiBlZVt0aGlzLl9rT3RMaXN0ZW5lcnNdO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5BYnN0cmFjdEFzeW5jSG9va3NDb250ZXh0TWFuYWdlciA9IEFic3RyYWN0QXN5bmNIb29rc0NvbnRleHRNYW5hZ2VyO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvbnRleHQtYXN5bmMtaG9va3MvYnVpbGQvc3JjL0FzeW5jSG9va3NDb250ZXh0TWFuYWdlci5qc1xudmFyIHJlcXVpcmVfQXN5bmNIb29rc0NvbnRleHRNYW5hZ2VyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvbnRleHQtYXN5bmMtaG9va3MvYnVpbGQvc3JjL0FzeW5jSG9va3NDb250ZXh0TWFuYWdlci5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgZXhwb3J0cy5Bc3luY0hvb2tzQ29udGV4dE1hbmFnZXIgPSB2b2lkIDA7XG4gICAgdmFyIGFwaV8xID0gKGluaXRfZXNtKCksIF9fdG9Db21tb25KUyhlc21fZXhwb3J0cykpO1xuICAgIHZhciBhc3luY0hvb2tzID0gcmVxdWlyZShcImFzeW5jX2hvb2tzXCIpO1xuICAgIHZhciBBYnN0cmFjdEFzeW5jSG9va3NDb250ZXh0TWFuYWdlcl8xID0gcmVxdWlyZV9BYnN0cmFjdEFzeW5jSG9va3NDb250ZXh0TWFuYWdlcigpO1xuICAgIHZhciBBc3luY0hvb2tzQ29udGV4dE1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0QXN5bmNIb29rc0NvbnRleHRNYW5hZ2VyXzEuQWJzdHJhY3RBc3luY0hvb2tzQ29udGV4dE1hbmFnZXIge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5fYXN5bmNIb29rID0gYXN5bmNIb29rcy5jcmVhdGVIb29rKHtcbiAgICAgICAgICBpbml0OiB0aGlzLl9pbml0LmJpbmQodGhpcyksXG4gICAgICAgICAgYmVmb3JlOiB0aGlzLl9iZWZvcmUuYmluZCh0aGlzKSxcbiAgICAgICAgICBhZnRlcjogdGhpcy5fYWZ0ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgICBkZXN0cm95OiB0aGlzLl9kZXN0cm95LmJpbmQodGhpcyksXG4gICAgICAgICAgcHJvbWlzZVJlc29sdmU6IHRoaXMuX2Rlc3Ryb3kuYmluZCh0aGlzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZSgpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIChfYTIgPSB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGggLSAxXSkgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiBhcGlfMS5ST09UX0NPTlRFWFQ7XG4gICAgICB9XG4gICAgICB3aXRoKGNvbnRleHQyLCBmbiwgdGhpc0FyZywgLi4uYXJncykge1xuICAgICAgICB0aGlzLl9lbnRlckNvbnRleHQoY29udGV4dDIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXNBcmcsIC4uLmFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRoaXMuX2V4aXRDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fYXN5bmNIb29rLmVuYWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX2FzeW5jSG9vay5kaXNhYmxlKCk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3N0YWNrID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJbml0IGhvb2sgd2lsbCBiZSBjYWxsZWQgd2hlbiB1c2VybGFuZCBjcmVhdGUgYSBhc3luYyBjb250ZXh0LCBzZXR0aW5nIHRoZVxuICAgICAgICogY29udGV4dCBhcyB0aGUgY3VycmVudCBvbmUgaWYgaXQgZXhpc3QuXG4gICAgICAgKiBAcGFyYW0gdWlkIGlkIG9mIHRoZSBhc3luYyBjb250ZXh0XG4gICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgcmVzb3VyY2UgdHlwZVxuICAgICAgICovXG4gICAgICBfaW5pdCh1aWQsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiVElNRVJXUkFQXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb250ZXh0MiA9IHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoY29udGV4dDIgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHRzLnNldCh1aWQsIGNvbnRleHQyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBEZXN0cm95IGhvb2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIGdpdmVuIGNvbnRleHQgaXMgbm8gbG9uZ2VyIHVzZWQgc28gd2UgY2FuXG4gICAgICAgKiByZW1vdmUgaXRzIGF0dGFjaGVkIGNvbnRleHQuXG4gICAgICAgKiBAcGFyYW0gdWlkIHVpZCBvZiB0aGUgYXN5bmMgY29udGV4dFxuICAgICAgICovXG4gICAgICBfZGVzdHJveSh1aWQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dHMuZGVsZXRlKHVpZCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEJlZm9yZSBob29rIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSBleGVjdXRpbmcgYSBhc3luYyBjb250ZXh0LlxuICAgICAgICogQHBhcmFtIHVpZCB1aWQgb2YgdGhlIGFzeW5jIGNvbnRleHRcbiAgICAgICAqL1xuICAgICAgX2JlZm9yZSh1aWQpIHtcbiAgICAgICAgY29uc3QgY29udGV4dDIgPSB0aGlzLl9jb250ZXh0cy5nZXQodWlkKTtcbiAgICAgICAgaWYgKGNvbnRleHQyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLl9lbnRlckNvbnRleHQoY29udGV4dDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEFmdGVyIGhvb2sgaXMgY2FsbGVkIGp1c3QgYWZ0ZXIgY29tcGxldGluZyB0aGUgZXhlY3V0aW9uIG9mIGEgYXN5bmMgY29udGV4dC5cbiAgICAgICAqL1xuICAgICAgX2FmdGVyKCkge1xuICAgICAgICB0aGlzLl9leGl0Q29udGV4dCgpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIGdpdmVuIGNvbnRleHQgYXMgYWN0aXZlXG4gICAgICAgKi9cbiAgICAgIF9lbnRlckNvbnRleHQoY29udGV4dDIpIHtcbiAgICAgICAgdGhpcy5fc3RhY2sucHVzaChjb250ZXh0Mik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSB0aGUgY29udGV4dCBhdCB0aGUgcm9vdCBvZiB0aGUgc3RhY2tcbiAgICAgICAqL1xuICAgICAgX2V4aXRDb250ZXh0KCkge1xuICAgICAgICB0aGlzLl9zdGFjay5wb3AoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuQXN5bmNIb29rc0NvbnRleHRNYW5hZ2VyID0gQXN5bmNIb29rc0NvbnRleHRNYW5hZ2VyO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvbnRleHQtYXN5bmMtaG9va3MvYnVpbGQvc3JjL0FzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIuanNcbnZhciByZXF1aXJlX0FzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29udGV4dC1hc3luYy1ob29rcy9idWlsZC9zcmMvQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlci5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgZXhwb3J0cy5Bc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyID0gdm9pZCAwO1xuICAgIHZhciBhcGlfMSA9IChpbml0X2VzbSgpLCBfX3RvQ29tbW9uSlMoZXNtX2V4cG9ydHMpKTtcbiAgICB2YXIgYXN5bmNfaG9va3NfMSA9IHJlcXVpcmUoXCJhc3luY19ob29rc1wiKTtcbiAgICB2YXIgQWJzdHJhY3RBc3luY0hvb2tzQ29udGV4dE1hbmFnZXJfMSA9IHJlcXVpcmVfQWJzdHJhY3RBc3luY0hvb2tzQ29udGV4dE1hbmFnZXIoKTtcbiAgICB2YXIgQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RBc3luY0hvb2tzQ29udGV4dE1hbmFnZXJfMS5BYnN0cmFjdEFzeW5jSG9va3NDb250ZXh0TWFuYWdlciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fYXN5bmNMb2NhbFN0b3JhZ2UgPSBuZXcgYXN5bmNfaG9va3NfMS5Bc3luY0xvY2FsU3RvcmFnZSgpO1xuICAgICAgfVxuICAgICAgYWN0aXZlKCkge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKF9hMiA9IHRoaXMuX2FzeW5jTG9jYWxTdG9yYWdlLmdldFN0b3JlKCkpICE9PSBudWxsICYmIF9hMiAhPT0gdm9pZCAwID8gX2EyIDogYXBpXzEuUk9PVF9DT05URVhUO1xuICAgICAgfVxuICAgICAgd2l0aChjb250ZXh0MiwgZm4sIHRoaXNBcmcsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2IgPSB0aGlzQXJnID09IG51bGwgPyBmbiA6IGZuLmJpbmQodGhpc0FyZyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc3luY0xvY2FsU3RvcmFnZS5ydW4oY29udGV4dDIsIGNiLCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIGVuYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLl9hc3luY0xvY2FsU3RvcmFnZS5kaXNhYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5Bc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyID0gQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlcjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb250ZXh0LWFzeW5jLWhvb2tzL2J1aWxkL3NyYy9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3JjID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvbnRleHQtYXN5bmMtaG9va3MvYnVpbGQvc3JjL2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBleHBvcnRzICYmIGV4cG9ydHMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICAgIGlmIChrMiA9PT0gdm9pZCAwKVxuICAgICAgICBrMiA9IGs7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9IH0pO1xuICAgIH0gOiBmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgICAgaWYgKGsyID09PSB2b2lkIDApXG4gICAgICAgIGsyID0gaztcbiAgICAgIG9bazJdID0gbVtrXTtcbiAgICB9KTtcbiAgICB2YXIgX19leHBvcnRTdGFyID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZXhwb3J0U3RhciB8fCBmdW5jdGlvbihtLCBleHBvcnRzMikge1xuICAgICAgZm9yICh2YXIgcCBpbiBtKVxuICAgICAgICBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzMiwgcCkpXG4gICAgICAgICAgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMyLCBtLCBwKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Bc3luY0hvb2tzQ29udGV4dE1hbmFnZXIoKSwgZXhwb3J0cyk7XG4gICAgX19leHBvcnRTdGFyKHJlcXVpcmVfQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlcigpLCBleHBvcnRzKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9zdXBwcmVzcy10cmFjaW5nLmpzXG5mdW5jdGlvbiBzdXBwcmVzc1RyYWNpbmcoY29udGV4dDIpIHtcbiAgcmV0dXJuIGNvbnRleHQyLnNldFZhbHVlKFNVUFBSRVNTX1RSQUNJTkdfS0VZLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHVuc3VwcHJlc3NUcmFjaW5nKGNvbnRleHQyKSB7XG4gIHJldHVybiBjb250ZXh0Mi5kZWxldGVWYWx1ZShTVVBQUkVTU19UUkFDSU5HX0tFWSk7XG59XG5mdW5jdGlvbiBpc1RyYWNpbmdTdXBwcmVzc2VkKGNvbnRleHQyKSB7XG4gIHJldHVybiBjb250ZXh0Mi5nZXRWYWx1ZShTVVBQUkVTU19UUkFDSU5HX0tFWSkgPT09IHRydWU7XG59XG52YXIgU1VQUFJFU1NfVFJBQ0lOR19LRVk7XG52YXIgaW5pdF9zdXBwcmVzc190cmFjaW5nID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9zdXBwcmVzcy10cmFjaW5nLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBTVVBQUkVTU19UUkFDSU5HX0tFWSA9IGNyZWF0ZUNvbnRleHRLZXkoXCJPcGVuVGVsZW1ldHJ5IFNESyBDb250ZXh0IEtleSBTVVBQUkVTU19UUkFDSU5HXCIpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2JhZ2dhZ2UvY29uc3RhbnRzLmpzXG52YXIgQkFHR0FHRV9LRVlfUEFJUl9TRVBBUkFUT1IsIEJBR0dBR0VfUFJPUEVSVElFU19TRVBBUkFUT1IsIEJBR0dBR0VfSVRFTVNfU0VQQVJBVE9SLCBCQUdHQUdFX0hFQURFUiwgQkFHR0FHRV9NQVhfTkFNRV9WQUxVRV9QQUlSUywgQkFHR0FHRV9NQVhfUEVSX05BTUVfVkFMVUVfUEFJUlMsIEJBR0dBR0VfTUFYX1RPVEFMX0xFTkdUSDtcbnZhciBpbml0X2NvbnN0YW50cyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vYmFnZ2FnZS9jb25zdGFudHMuanNcIigpIHtcbiAgICBCQUdHQUdFX0tFWV9QQUlSX1NFUEFSQVRPUiA9IFwiPVwiO1xuICAgIEJBR0dBR0VfUFJPUEVSVElFU19TRVBBUkFUT1IgPSBcIjtcIjtcbiAgICBCQUdHQUdFX0lURU1TX1NFUEFSQVRPUiA9IFwiLFwiO1xuICAgIEJBR0dBR0VfSEVBREVSID0gXCJiYWdnYWdlXCI7XG4gICAgQkFHR0FHRV9NQVhfTkFNRV9WQUxVRV9QQUlSUyA9IDE4MDtcbiAgICBCQUdHQUdFX01BWF9QRVJfTkFNRV9WQUxVRV9QQUlSUyA9IDQwOTY7XG4gICAgQkFHR0FHRV9NQVhfVE9UQUxfTEVOR1RIID0gODE5MjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9iYWdnYWdlL3V0aWxzLmpzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBnZXRLZXlQYWlyczogKCkgPT4gZ2V0S2V5UGFpcnMsXG4gIHBhcnNlS2V5UGFpcnNJbnRvUmVjb3JkOiAoKSA9PiBwYXJzZUtleVBhaXJzSW50b1JlY29yZCxcbiAgcGFyc2VQYWlyS2V5VmFsdWU6ICgpID0+IHBhcnNlUGFpcktleVZhbHVlLFxuICBzZXJpYWxpemVLZXlQYWlyczogKCkgPT4gc2VyaWFsaXplS2V5UGFpcnNcbn0pO1xuZnVuY3Rpb24gc2VyaWFsaXplS2V5UGFpcnMoa2V5UGFpcnMpIHtcbiAgcmV0dXJuIGtleVBhaXJzLnJlZHVjZShmdW5jdGlvbihoVmFsdWUsIGN1cnJlbnQpIHtcbiAgICB2YXIgdmFsdWUgPSBcIlwiICsgaFZhbHVlICsgKGhWYWx1ZSAhPT0gXCJcIiA/IEJBR0dBR0VfSVRFTVNfU0VQQVJBVE9SIDogXCJcIikgKyBjdXJyZW50O1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiBCQUdHQUdFX01BWF9UT1RBTF9MRU5HVEggPyBoVmFsdWUgOiB2YWx1ZTtcbiAgfSwgXCJcIik7XG59XG5mdW5jdGlvbiBnZXRLZXlQYWlycyhiYWdnYWdlKSB7XG4gIHJldHVybiBiYWdnYWdlLmdldEFsbEVudHJpZXMoKS5tYXAoZnVuY3Rpb24oX2EyKSB7XG4gICAgdmFyIF9iID0gX19yZWFkNihfYTIsIDIpLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICB2YXIgZW50cnkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnZhbHVlKTtcbiAgICBpZiAodmFsdWUubWV0YWRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgZW50cnkgKz0gQkFHR0FHRV9QUk9QRVJUSUVTX1NFUEFSQVRPUiArIHZhbHVlLm1ldGFkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVBhaXJLZXlWYWx1ZShlbnRyeSkge1xuICB2YXIgdmFsdWVQcm9wcyA9IGVudHJ5LnNwbGl0KEJBR0dBR0VfUFJPUEVSVElFU19TRVBBUkFUT1IpO1xuICBpZiAodmFsdWVQcm9wcy5sZW5ndGggPD0gMClcbiAgICByZXR1cm47XG4gIHZhciBrZXlQYWlyUGFydCA9IHZhbHVlUHJvcHMuc2hpZnQoKTtcbiAgaWYgKCFrZXlQYWlyUGFydClcbiAgICByZXR1cm47XG4gIHZhciBzZXBhcmF0b3JJbmRleCA9IGtleVBhaXJQYXJ0LmluZGV4T2YoQkFHR0FHRV9LRVlfUEFJUl9TRVBBUkFUT1IpO1xuICBpZiAoc2VwYXJhdG9ySW5kZXggPD0gMClcbiAgICByZXR1cm47XG4gIHZhciBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5UGFpclBhcnQuc3Vic3RyaW5nKDAsIHNlcGFyYXRvckluZGV4KS50cmltKCkpO1xuICB2YXIgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5UGFpclBhcnQuc3Vic3RyaW5nKHNlcGFyYXRvckluZGV4ICsgMSkudHJpbSgpKTtcbiAgdmFyIG1ldGFkYXRhO1xuICBpZiAodmFsdWVQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgbWV0YWRhdGEgPSBiYWdnYWdlRW50cnlNZXRhZGF0YUZyb21TdHJpbmcodmFsdWVQcm9wcy5qb2luKEJBR0dBR0VfUFJPUEVSVElFU19TRVBBUkFUT1IpKTtcbiAgfVxuICByZXR1cm4geyBrZXksIHZhbHVlLCBtZXRhZGF0YSB9O1xufVxuZnVuY3Rpb24gcGFyc2VLZXlQYWlyc0ludG9SZWNvcmQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIHt9O1xuICByZXR1cm4gdmFsdWUuc3BsaXQoQkFHR0FHRV9JVEVNU19TRVBBUkFUT1IpLm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBwYXJzZVBhaXJLZXlWYWx1ZShlbnRyeSk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbihrZXlQYWlyKSB7XG4gICAgcmV0dXJuIGtleVBhaXIgIT09IHZvaWQgMCAmJiBrZXlQYWlyLnZhbHVlLmxlbmd0aCA+IDA7XG4gIH0pLnJlZHVjZShmdW5jdGlvbihoZWFkZXJzLCBrZXlQYWlyKSB7XG4gICAgaGVhZGVyc1trZXlQYWlyLmtleV0gPSBrZXlQYWlyLnZhbHVlO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LCB7fSk7XG59XG52YXIgX19yZWFkNjtcbnZhciBpbml0X3V0aWxzMyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vYmFnZ2FnZS91dGlscy5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgaW5pdF9jb25zdGFudHMoKTtcbiAgICBfX3JlYWQ2ID0gZnVuY3Rpb24obywgbikge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2JhZ2dhZ2UvcHJvcGFnYXRpb24vVzNDQmFnZ2FnZVByb3BhZ2F0b3IuanNcbnZhciBXM0NCYWdnYWdlUHJvcGFnYXRvcjtcbnZhciBpbml0X1czQ0JhZ2dhZ2VQcm9wYWdhdG9yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9iYWdnYWdlL3Byb3BhZ2F0aW9uL1czQ0JhZ2dhZ2VQcm9wYWdhdG9yLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBpbml0X3N1cHByZXNzX3RyYWNpbmcoKTtcbiAgICBpbml0X2NvbnN0YW50cygpO1xuICAgIGluaXRfdXRpbHMzKCk7XG4gICAgVzNDQmFnZ2FnZVByb3BhZ2F0b3IgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBXM0NCYWdnYWdlUHJvcGFnYXRvcjIoKSB7XG4gICAgICB9XG4gICAgICBXM0NCYWdnYWdlUHJvcGFnYXRvcjIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGNvbnRleHQyLCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGJhZ2dhZ2UgPSBwcm9wYWdhdGlvbi5nZXRCYWdnYWdlKGNvbnRleHQyKTtcbiAgICAgICAgaWYgKCFiYWdnYWdlIHx8IGlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dDIpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGtleVBhaXJzID0gZ2V0S2V5UGFpcnMoYmFnZ2FnZSkuZmlsdGVyKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgICByZXR1cm4gcGFpci5sZW5ndGggPD0gQkFHR0FHRV9NQVhfUEVSX05BTUVfVkFMVUVfUEFJUlM7XG4gICAgICAgIH0pLnNsaWNlKDAsIEJBR0dBR0VfTUFYX05BTUVfVkFMVUVfUEFJUlMpO1xuICAgICAgICB2YXIgaGVhZGVyVmFsdWUgPSBzZXJpYWxpemVLZXlQYWlycyhrZXlQYWlycyk7XG4gICAgICAgIGlmIChoZWFkZXJWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2V0dGVyLnNldChjYXJyaWVyLCBCQUdHQUdFX0hFQURFUiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVzNDQmFnZ2FnZVByb3BhZ2F0b3IyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDIsIGNhcnJpZXIsIGdldHRlcikge1xuICAgICAgICB2YXIgaGVhZGVyVmFsdWUgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIEJBR0dBR0VfSEVBREVSKTtcbiAgICAgICAgdmFyIGJhZ2dhZ2VTdHJpbmcgPSBBcnJheS5pc0FycmF5KGhlYWRlclZhbHVlKSA/IGhlYWRlclZhbHVlLmpvaW4oQkFHR0FHRV9JVEVNU19TRVBBUkFUT1IpIDogaGVhZGVyVmFsdWU7XG4gICAgICAgIGlmICghYmFnZ2FnZVN0cmluZylcbiAgICAgICAgICByZXR1cm4gY29udGV4dDI7XG4gICAgICAgIHZhciBiYWdnYWdlID0ge307XG4gICAgICAgIGlmIChiYWdnYWdlU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpcnMgPSBiYWdnYWdlU3RyaW5nLnNwbGl0KEJBR0dBR0VfSVRFTVNfU0VQQVJBVE9SKTtcbiAgICAgICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgIHZhciBrZXlQYWlyID0gcGFyc2VQYWlyS2V5VmFsdWUoZW50cnkpO1xuICAgICAgICAgIGlmIChrZXlQYWlyKSB7XG4gICAgICAgICAgICB2YXIgYmFnZ2FnZUVudHJ5ID0geyB2YWx1ZToga2V5UGFpci52YWx1ZSB9O1xuICAgICAgICAgICAgaWYgKGtleVBhaXIubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgYmFnZ2FnZUVudHJ5Lm1ldGFkYXRhID0ga2V5UGFpci5tZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhZ2dhZ2Vba2V5UGFpci5rZXldID0gYmFnZ2FnZUVudHJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChPYmplY3QuZW50cmllcyhiYWdnYWdlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BhZ2F0aW9uLnNldEJhZ2dhZ2UoY29udGV4dDIsIHByb3BhZ2F0aW9uLmNyZWF0ZUJhZ2dhZ2UoYmFnZ2FnZSkpO1xuICAgICAgfTtcbiAgICAgIFczQ0JhZ2dhZ2VQcm9wYWdhdG9yMi5wcm90b3R5cGUuZmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbQkFHR0FHRV9IRUFERVJdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXM0NCYWdnYWdlUHJvcGFnYXRvcjI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9hbmNob3JlZC1jbG9jay5qc1xudmFyIEFuY2hvcmVkQ2xvY2s7XG52YXIgaW5pdF9hbmNob3JlZF9jbG9jayA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vY29tbW9uL2FuY2hvcmVkLWNsb2NrLmpzXCIoKSB7XG4gICAgQW5jaG9yZWRDbG9jayA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEFuY2hvcmVkQ2xvY2syKHN5c3RlbUNsb2NrLCBtb25vdG9uaWNDbG9jaykge1xuICAgICAgICB0aGlzLl9tb25vdG9uaWNDbG9jayA9IG1vbm90b25pY0Nsb2NrO1xuICAgICAgICB0aGlzLl9lcG9jaE1pbGxpcyA9IHN5c3RlbUNsb2NrLm5vdygpO1xuICAgICAgICB0aGlzLl9wZXJmb3JtYW5jZU1pbGxpcyA9IG1vbm90b25pY0Nsb2NrLm5vdygpO1xuICAgICAgfVxuICAgICAgQW5jaG9yZWRDbG9jazIucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLl9tb25vdG9uaWNDbG9jay5ub3coKSAtIHRoaXMuX3BlcmZvcm1hbmNlTWlsbGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXBvY2hNaWxsaXMgKyBkZWx0YTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5jaG9yZWRDbG9jazI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9hdHRyaWJ1dGVzLmpzXG5mdW5jdGlvbiBzYW5pdGl6ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICB2YXIgZV8xLCBfYTI7XG4gIHZhciBvdXQgPSB7fTtcbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzMihPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgIHZhciBfZCA9IF9fcmVhZDcoX2MudmFsdWUsIDIpLCBrZXkgPSBfZFswXSwgdmFsID0gX2RbMV07XG4gICAgICBpZiAoIWlzQXR0cmlidXRlS2V5KGtleSkpIHtcbiAgICAgICAgZGlhZzIud2FybihcIkludmFsaWQgYXR0cmlidXRlIGtleTogXCIgKyBrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBdHRyaWJ1dGVWYWx1ZSh2YWwpKSB7XG4gICAgICAgIGRpYWcyLndhcm4oXCJJbnZhbGlkIGF0dHJpYnV0ZSB2YWx1ZSBzZXQgZm9yIGtleTogXCIgKyBrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgb3V0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hMiA9IF9iLnJldHVybikpXG4gICAgICAgIF9hMi5jYWxsKF9iKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSlcbiAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVLZXkoa2V5KSB7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGtleS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVWYWx1ZSh2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBpc0hvbW9nZW5lb3VzQXR0cmlidXRlVmFsdWVBcnJheSh2YWwpO1xuICB9XG4gIHJldHVybiBpc1ZhbGlkUHJpbWl0aXZlQXR0cmlidXRlVmFsdWUodmFsKTtcbn1cbmZ1bmN0aW9uIGlzSG9tb2dlbmVvdXNBdHRyaWJ1dGVWYWx1ZUFycmF5KGFycikge1xuICB2YXIgZV8yLCBfYTI7XG4gIHZhciB0eXBlO1xuICB0cnkge1xuICAgIGZvciAodmFyIGFycl8xID0gX192YWx1ZXMyKGFyciksIGFycl8xXzEgPSBhcnJfMS5uZXh0KCk7ICFhcnJfMV8xLmRvbmU7IGFycl8xXzEgPSBhcnJfMS5uZXh0KCkpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gYXJyXzFfMS52YWx1ZTtcbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkUHJpbWl0aXZlQXR0cmlidXRlVmFsdWUoZWxlbWVudCkpIHtcbiAgICAgICAgICB0eXBlID0gdHlwZW9mIGVsZW1lbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSB0eXBlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXJyXzFfMSAmJiAhYXJyXzFfMS5kb25lICYmIChfYTIgPSBhcnJfMS5yZXR1cm4pKVxuICAgICAgICBfYTIuY2FsbChhcnJfMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzIpXG4gICAgICAgIHRocm93IGVfMi5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc1ZhbGlkUHJpbWl0aXZlQXR0cmlidXRlVmFsdWUodmFsKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBfX3ZhbHVlczIsIF9fcmVhZDc7XG52YXIgaW5pdF9hdHRyaWJ1dGVzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9jb21tb24vYXR0cmlidXRlcy5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgX192YWx1ZXMyID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICAgIGlmIChtKVxuICAgICAgICByZXR1cm4gbS5jYWxsKG8pO1xuICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aClcbiAgICAgICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgfTtcbiAgICBfX3JlYWQ3ID0gZnVuY3Rpb24obywgbikge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9sb2dnaW5nLWVycm9yLWhhbmRsZXIuanNcbmZ1bmN0aW9uIGxvZ2dpbmdFcnJvckhhbmRsZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbihleCkge1xuICAgIGRpYWcyLmVycm9yKHN0cmluZ2lmeUV4Y2VwdGlvbihleCkpO1xuICB9O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5RXhjZXB0aW9uKGV4KSB7XG4gIGlmICh0eXBlb2YgZXggPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGZsYXR0ZW5FeGNlcHRpb24oZXgpKTtcbiAgfVxufVxuZnVuY3Rpb24gZmxhdHRlbkV4Y2VwdGlvbihleCkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBjdXJyZW50ID0gZXg7XG4gIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VycmVudCkuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIGlmIChyZXN1bHRbcHJvcGVydHlOYW1lXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIHZhbHVlID0gY3VycmVudFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eU5hbWVdID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdXJyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaW5pdF9sb2dnaW5nX2Vycm9yX2hhbmRsZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9sb2dnaW5nLWVycm9yLWhhbmRsZXIuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9nbG9iYWwtZXJyb3ItaGFuZGxlci5qc1xuZnVuY3Rpb24gc2V0R2xvYmFsRXJyb3JIYW5kbGVyKGhhbmRsZXIpIHtcbiAgZGVsZWdhdGVIYW5kbGVyID0gaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIGdsb2JhbEVycm9ySGFuZGxlcihleCkge1xuICB0cnkge1xuICAgIGRlbGVnYXRlSGFuZGxlcihleCk7XG4gIH0gY2F0Y2ggKF9hMikge1xuICB9XG59XG52YXIgZGVsZWdhdGVIYW5kbGVyO1xudmFyIGluaXRfZ2xvYmFsX2Vycm9yX2hhbmRsZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9nbG9iYWwtZXJyb3ItaGFuZGxlci5qc1wiKCkge1xuICAgIGluaXRfbG9nZ2luZ19lcnJvcl9oYW5kbGVyKCk7XG4gICAgZGVsZWdhdGVIYW5kbGVyID0gbG9nZ2luZ0Vycm9ySGFuZGxlcigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3NhbXBsaW5nLmpzXG52YXIgVHJhY2VzU2FtcGxlclZhbHVlcztcbnZhciBpbml0X3NhbXBsaW5nID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9zYW1wbGluZy5qc1wiKCkge1xuICAgIChmdW5jdGlvbihUcmFjZXNTYW1wbGVyVmFsdWVzMikge1xuICAgICAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJBbHdheXNPZmZcIl0gPSBcImFsd2F5c19vZmZcIjtcbiAgICAgIFRyYWNlc1NhbXBsZXJWYWx1ZXMyW1wiQWx3YXlzT25cIl0gPSBcImFsd2F5c19vblwiO1xuICAgICAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJQYXJlbnRCYXNlZEFsd2F5c09mZlwiXSA9IFwicGFyZW50YmFzZWRfYWx3YXlzX29mZlwiO1xuICAgICAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJQYXJlbnRCYXNlZEFsd2F5c09uXCJdID0gXCJwYXJlbnRiYXNlZF9hbHdheXNfb25cIjtcbiAgICAgIFRyYWNlc1NhbXBsZXJWYWx1ZXMyW1wiUGFyZW50QmFzZWRUcmFjZUlkUmF0aW9cIl0gPSBcInBhcmVudGJhc2VkX3RyYWNlaWRyYXRpb1wiO1xuICAgICAgVHJhY2VzU2FtcGxlclZhbHVlczJbXCJUcmFjZUlkUmF0aW9cIl0gPSBcInRyYWNlaWRyYXRpb1wiO1xuICAgIH0pKFRyYWNlc1NhbXBsZXJWYWx1ZXMgfHwgKFRyYWNlc1NhbXBsZXJWYWx1ZXMgPSB7fSkpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL2Jyb3dzZXIvZ2xvYmFsVGhpcy5qc1xudmFyIF9nbG9iYWxUaGlzMjtcbnZhciBpbml0X2dsb2JhbFRoaXMyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9icm93c2VyL2dsb2JhbFRoaXMuanNcIigpIHtcbiAgICBfZ2xvYmFsVGhpczIgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHt9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL2Vudmlyb25tZW50LmpzXG5mdW5jdGlvbiBpc0VudlZhckFCb29sZWFuKGtleSkge1xuICByZXR1cm4gRU5WSVJPTk1FTlRfQk9PTEVBTl9LRVlTLmluZGV4T2Yoa2V5KSA+IC0xO1xufVxuZnVuY3Rpb24gaXNFbnZWYXJBTnVtYmVyKGtleSkge1xuICByZXR1cm4gRU5WSVJPTk1FTlRfTlVNQkVSU19LRVlTLmluZGV4T2Yoa2V5KSA+IC0xO1xufVxuZnVuY3Rpb24gaXNFbnZWYXJBTGlzdChrZXkpIHtcbiAgcmV0dXJuIEVOVklST05NRU5UX0xJU1RTX0tFWVMuaW5kZXhPZihrZXkpID4gLTE7XG59XG5mdW5jdGlvbiBwYXJzZUJvb2xlYW4oa2V5LCBlbnZpcm9ubWVudCwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2YgdmFsdWVzW2tleV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gU3RyaW5nKHZhbHVlc1trZXldKTtcbiAgZW52aXJvbm1lbnRba2V5XSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiO1xufVxuZnVuY3Rpb24gcGFyc2VOdW1iZXIobmFtZSwgZW52aXJvbm1lbnQsIHZhbHVlcywgbWluLCBtYXgpIHtcbiAgaWYgKG1pbiA9PT0gdm9pZCAwKSB7XG4gICAgbWluID0gLUluZmluaXR5O1xuICB9XG4gIGlmIChtYXggPT09IHZvaWQgMCkge1xuICAgIG1heCA9IEluZmluaXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWVzW25hbWVdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHZhbHVlID0gTnVtYmVyKHZhbHVlc1tuYW1lXSk7XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICBlbnZpcm9ubWVudFtuYW1lXSA9IG1pbjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgZW52aXJvbm1lbnRbbmFtZV0gPSBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnZpcm9ubWVudFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmdMaXN0KG5hbWUsIG91dHB1dCwgaW5wdXQsIHNlcGFyYXRvcikge1xuICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHtcbiAgICBzZXBhcmF0b3IgPSBERUZBVUxUX0xJU1RfU0VQQVJBVE9SO1xuICB9XG4gIHZhciBnaXZlblZhbHVlID0gaW5wdXRbbmFtZV07XG4gIGlmICh0eXBlb2YgZ2l2ZW5WYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIG91dHB1dFtuYW1lXSA9IGdpdmVuVmFsdWUuc3BsaXQoc2VwYXJhdG9yKS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudHJpbSgpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRMb2dMZXZlbEZyb21FbnYoa2V5LCBlbnZpcm9ubWVudCwgdmFsdWVzKSB7XG4gIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFyIHRoZUxldmVsID0gbG9nTGV2ZWxNYXBbdmFsdWUudG9VcHBlckNhc2UoKV07XG4gICAgaWYgKHRoZUxldmVsICE9IG51bGwpIHtcbiAgICAgIGVudmlyb25tZW50W2tleV0gPSB0aGVMZXZlbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRW52aXJvbm1lbnQodmFsdWVzKSB7XG4gIHZhciBlbnZpcm9ubWVudCA9IHt9O1xuICBmb3IgKHZhciBlbnYzIGluIERFRkFVTFRfRU5WSVJPTk1FTlQpIHtcbiAgICB2YXIga2V5ID0gZW52MztcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIk9URUxfTE9HX0xFVkVMXCI6XG4gICAgICAgIHNldExvZ0xldmVsRnJvbUVudihrZXksIGVudmlyb25tZW50LCB2YWx1ZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChpc0VudlZhckFCb29sZWFuKGtleSkpIHtcbiAgICAgICAgICBwYXJzZUJvb2xlYW4oa2V5LCBlbnZpcm9ubWVudCwgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0VudlZhckFOdW1iZXIoa2V5KSkge1xuICAgICAgICAgIHBhcnNlTnVtYmVyKGtleSwgZW52aXJvbm1lbnQsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFbnZWYXJBTGlzdChrZXkpKSB7XG4gICAgICAgICAgcGFyc2VTdHJpbmdMaXN0KGtleSwgZW52aXJvbm1lbnQsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZW52aXJvbm1lbnRba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlbnZpcm9ubWVudDtcbn1cbmZ1bmN0aW9uIGdldEVudldpdGhvdXREZWZhdWx0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgPyBwYXJzZUVudmlyb25tZW50KHByb2Nlc3MuZW52KSA6IHBhcnNlRW52aXJvbm1lbnQoX2dsb2JhbFRoaXMyKTtcbn1cbnZhciBERUZBVUxUX0xJU1RfU0VQQVJBVE9SLCBFTlZJUk9OTUVOVF9CT09MRUFOX0tFWVMsIEVOVklST05NRU5UX05VTUJFUlNfS0VZUywgRU5WSVJPTk1FTlRfTElTVFNfS0VZUywgREVGQVVMVF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlULCBERUZBVUxUX0FUVFJJQlVURV9DT1VOVF9MSU1JVCwgREVGQVVMVF9TUEFOX0FUVFJJQlVURV9QRVJfRVZFTlRfQ09VTlRfTElNSVQsIERFRkFVTFRfU1BBTl9BVFRSSUJVVEVfUEVSX0xJTktfQ09VTlRfTElNSVQsIERFRkFVTFRfRU5WSVJPTk1FTlQsIGxvZ0xldmVsTWFwO1xudmFyIGluaXRfZW52aXJvbm1lbnQgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL2Vudmlyb25tZW50LmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBpbml0X3NhbXBsaW5nKCk7XG4gICAgaW5pdF9nbG9iYWxUaGlzMigpO1xuICAgIERFRkFVTFRfTElTVF9TRVBBUkFUT1IgPSBcIixcIjtcbiAgICBFTlZJUk9OTUVOVF9CT09MRUFOX0tFWVMgPSBbXCJPVEVMX1NES19ESVNBQkxFRFwiXTtcbiAgICBFTlZJUk9OTUVOVF9OVU1CRVJTX0tFWVMgPSBbXG4gICAgICBcIk9URUxfQlNQX0VYUE9SVF9USU1FT1VUXCIsXG4gICAgICBcIk9URUxfQlNQX01BWF9FWFBPUlRfQkFUQ0hfU0laRVwiLFxuICAgICAgXCJPVEVMX0JTUF9NQVhfUVVFVUVfU0laRVwiLFxuICAgICAgXCJPVEVMX0JTUF9TQ0hFRFVMRV9ERUxBWVwiLFxuICAgICAgXCJPVEVMX0JMUlBfRVhQT1JUX1RJTUVPVVRcIixcbiAgICAgIFwiT1RFTF9CTFJQX01BWF9FWFBPUlRfQkFUQ0hfU0laRVwiLFxuICAgICAgXCJPVEVMX0JMUlBfTUFYX1FVRVVFX1NJWkVcIixcbiAgICAgIFwiT1RFTF9CTFJQX1NDSEVEVUxFX0RFTEFZXCIsXG4gICAgICBcIk9URUxfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVFwiLFxuICAgICAgXCJPVEVMX0FUVFJJQlVURV9DT1VOVF9MSU1JVFwiLFxuICAgICAgXCJPVEVMX1NQQU5fQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVFwiLFxuICAgICAgXCJPVEVMX1NQQU5fQVRUUklCVVRFX0NPVU5UX0xJTUlUXCIsXG4gICAgICBcIk9URUxfTE9HUkVDT1JEX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVRcIixcbiAgICAgIFwiT1RFTF9MT0dSRUNPUkRfQVRUUklCVVRFX0NPVU5UX0xJTUlUXCIsXG4gICAgICBcIk9URUxfU1BBTl9FVkVOVF9DT1VOVF9MSU1JVFwiLFxuICAgICAgXCJPVEVMX1NQQU5fTElOS19DT1VOVF9MSU1JVFwiLFxuICAgICAgXCJPVEVMX1NQQU5fQVRUUklCVVRFX1BFUl9FVkVOVF9DT1VOVF9MSU1JVFwiLFxuICAgICAgXCJPVEVMX1NQQU5fQVRUUklCVVRFX1BFUl9MSU5LX0NPVU5UX0xJTUlUXCIsXG4gICAgICBcIk9URUxfRVhQT1JURVJfT1RMUF9USU1FT1VUXCIsXG4gICAgICBcIk9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfVElNRU9VVFwiLFxuICAgICAgXCJPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19USU1FT1VUXCIsXG4gICAgICBcIk9URUxfRVhQT1JURVJfT1RMUF9MT0dTX1RJTUVPVVRcIixcbiAgICAgIFwiT1RFTF9FWFBPUlRFUl9KQUVHRVJfQUdFTlRfUE9SVFwiXG4gICAgXTtcbiAgICBFTlZJUk9OTUVOVF9MSVNUU19LRVlTID0gW1xuICAgICAgXCJPVEVMX05PX1BBVENIX01PRFVMRVNcIixcbiAgICAgIFwiT1RFTF9QUk9QQUdBVE9SU1wiXG4gICAgXTtcbiAgICBERUZBVUxUX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQgPSBJbmZpbml0eTtcbiAgICBERUZBVUxUX0FUVFJJQlVURV9DT1VOVF9MSU1JVCA9IDEyODtcbiAgICBERUZBVUxUX1NQQU5fQVRUUklCVVRFX1BFUl9FVkVOVF9DT1VOVF9MSU1JVCA9IDEyODtcbiAgICBERUZBVUxUX1NQQU5fQVRUUklCVVRFX1BFUl9MSU5LX0NPVU5UX0xJTUlUID0gMTI4O1xuICAgIERFRkFVTFRfRU5WSVJPTk1FTlQgPSB7XG4gICAgICBPVEVMX1NES19ESVNBQkxFRDogZmFsc2UsXG4gICAgICBDT05UQUlORVJfTkFNRTogXCJcIixcbiAgICAgIEVDU19DT05UQUlORVJfTUVUQURBVEFfVVJJX1Y0OiBcIlwiLFxuICAgICAgRUNTX0NPTlRBSU5FUl9NRVRBREFUQV9VUkk6IFwiXCIsXG4gICAgICBIT1NUTkFNRTogXCJcIixcbiAgICAgIEtVQkVSTkVURVNfU0VSVklDRV9IT1NUOiBcIlwiLFxuICAgICAgTkFNRVNQQUNFOiBcIlwiLFxuICAgICAgT1RFTF9CU1BfRVhQT1JUX1RJTUVPVVQ6IDNlNCxcbiAgICAgIE9URUxfQlNQX01BWF9FWFBPUlRfQkFUQ0hfU0laRTogNTEyLFxuICAgICAgT1RFTF9CU1BfTUFYX1FVRVVFX1NJWkU6IDIwNDgsXG4gICAgICBPVEVMX0JTUF9TQ0hFRFVMRV9ERUxBWTogNWUzLFxuICAgICAgT1RFTF9CTFJQX0VYUE9SVF9USU1FT1VUOiAzZTQsXG4gICAgICBPVEVMX0JMUlBfTUFYX0VYUE9SVF9CQVRDSF9TSVpFOiA1MTIsXG4gICAgICBPVEVMX0JMUlBfTUFYX1FVRVVFX1NJWkU6IDIwNDgsXG4gICAgICBPVEVMX0JMUlBfU0NIRURVTEVfREVMQVk6IDVlMyxcbiAgICAgIE9URUxfRVhQT1JURVJfSkFFR0VSX0FHRU5UX0hPU1Q6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX0pBRUdFUl9BR0VOVF9QT1JUOiA2ODMyLFxuICAgICAgT1RFTF9FWFBPUlRFUl9KQUVHRVJfRU5EUE9JTlQ6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX0pBRUdFUl9QQVNTV09SRDogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfSkFFR0VSX1VTRVI6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfRU5EUE9JTlQ6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0VORFBPSU5UOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfRU5EUE9JTlQ6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfTE9HU19FTkRQT0lOVDogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9IRUFERVJTOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19IRUFERVJTOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfSEVBREVSUzogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9MT0dTX0hFQURFUlM6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfVElNRU9VVDogMWU0LFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19USU1FT1VUOiAxZTQsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19USU1FT1VUOiAxZTQsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfTE9HU19USU1FT1VUOiAxZTQsXG4gICAgICBPVEVMX0VYUE9SVEVSX1pJUEtJTl9FTkRQT0lOVDogXCJodHRwOi8vbG9jYWxob3N0Ojk0MTEvYXBpL3YyL3NwYW5zXCIsXG4gICAgICBPVEVMX0xPR19MRVZFTDogRGlhZ0xvZ0xldmVsLklORk8sXG4gICAgICBPVEVMX05PX1BBVENIX01PRFVMRVM6IFtdLFxuICAgICAgT1RFTF9QUk9QQUdBVE9SUzogW1widHJhY2Vjb250ZXh0XCIsIFwiYmFnZ2FnZVwiXSxcbiAgICAgIE9URUxfUkVTT1VSQ0VfQVRUUklCVVRFUzogXCJcIixcbiAgICAgIE9URUxfU0VSVklDRV9OQU1FOiBcIlwiLFxuICAgICAgT1RFTF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlUOiBERUZBVUxUX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQsXG4gICAgICBPVEVMX0FUVFJJQlVURV9DT1VOVF9MSU1JVDogREVGQVVMVF9BVFRSSUJVVEVfQ09VTlRfTElNSVQsXG4gICAgICBPVEVMX1NQQU5fQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVDogREVGQVVMVF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlULFxuICAgICAgT1RFTF9TUEFOX0FUVFJJQlVURV9DT1VOVF9MSU1JVDogREVGQVVMVF9BVFRSSUJVVEVfQ09VTlRfTElNSVQsXG4gICAgICBPVEVMX0xPR1JFQ09SRF9BVFRSSUJVVEVfVkFMVUVfTEVOR1RIX0xJTUlUOiBERUZBVUxUX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQsXG4gICAgICBPVEVMX0xPR1JFQ09SRF9BVFRSSUJVVEVfQ09VTlRfTElNSVQ6IERFRkFVTFRfQVRUUklCVVRFX0NPVU5UX0xJTUlULFxuICAgICAgT1RFTF9TUEFOX0VWRU5UX0NPVU5UX0xJTUlUOiAxMjgsXG4gICAgICBPVEVMX1NQQU5fTElOS19DT1VOVF9MSU1JVDogMTI4LFxuICAgICAgT1RFTF9TUEFOX0FUVFJJQlVURV9QRVJfRVZFTlRfQ09VTlRfTElNSVQ6IERFRkFVTFRfU1BBTl9BVFRSSUJVVEVfUEVSX0VWRU5UX0NPVU5UX0xJTUlULFxuICAgICAgT1RFTF9TUEFOX0FUVFJJQlVURV9QRVJfTElOS19DT1VOVF9MSU1JVDogREVGQVVMVF9TUEFOX0FUVFJJQlVURV9QRVJfTElOS19DT1VOVF9MSU1JVCxcbiAgICAgIE9URUxfVFJBQ0VTX0VYUE9SVEVSOiBcIlwiLFxuICAgICAgT1RFTF9UUkFDRVNfU0FNUExFUjogVHJhY2VzU2FtcGxlclZhbHVlcy5QYXJlbnRCYXNlZEFsd2F5c09uLFxuICAgICAgT1RFTF9UUkFDRVNfU0FNUExFUl9BUkc6IFwiXCIsXG4gICAgICBPVEVMX0xPR1NfRVhQT1JURVI6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfSU5TRUNVUkU6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0lOU0VDVVJFOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfSU5TRUNVUkU6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfTE9HU19JTlNFQ1VSRTogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9DRVJUSUZJQ0FURTogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfQ0VSVElGSUNBVEU6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfTUVUUklDU19DRVJUSUZJQ0FURTogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9MT0dTX0NFUlRJRklDQVRFOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX0NPTVBSRVNTSU9OOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19DT01QUkVTU0lPTjogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX0NPTVBSRVNTSU9OOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX0xPR1NfQ09NUFJFU1NJT046IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfQ0xJRU5UX0tFWTogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfQ0xJRU5UX0tFWTogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9NRVRSSUNTX0NMSUVOVF9LRVk6IFwiXCIsXG4gICAgICBPVEVMX0VYUE9SVEVSX09UTFBfTE9HU19DTElFTlRfS0VZOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX0NMSUVOVF9DRVJUSUZJQ0FURTogXCJcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfQ0xJRU5UX0NFUlRJRklDQVRFOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfQ0xJRU5UX0NFUlRJRklDQVRFOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX0xPR1NfQ0xJRU5UX0NFUlRJRklDQVRFOiBcIlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX1BST1RPQ09MOiBcImh0dHAvcHJvdG9idWZcIixcbiAgICAgIE9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfUFJPVE9DT0w6IFwiaHR0cC9wcm90b2J1ZlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfUFJPVE9DT0w6IFwiaHR0cC9wcm90b2J1ZlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX0xPR1NfUFJPVE9DT0w6IFwiaHR0cC9wcm90b2J1ZlwiLFxuICAgICAgT1RFTF9FWFBPUlRFUl9PVExQX01FVFJJQ1NfVEVNUE9SQUxJVFlfUFJFRkVSRU5DRTogXCJjdW11bGF0aXZlXCJcbiAgICB9O1xuICAgIGxvZ0xldmVsTWFwID0ge1xuICAgICAgQUxMOiBEaWFnTG9nTGV2ZWwuQUxMLFxuICAgICAgVkVSQk9TRTogRGlhZ0xvZ0xldmVsLlZFUkJPU0UsXG4gICAgICBERUJVRzogRGlhZ0xvZ0xldmVsLkRFQlVHLFxuICAgICAgSU5GTzogRGlhZ0xvZ0xldmVsLklORk8sXG4gICAgICBXQVJOOiBEaWFnTG9nTGV2ZWwuV0FSTixcbiAgICAgIEVSUk9SOiBEaWFnTG9nTGV2ZWwuRVJST1IsXG4gICAgICBOT05FOiBEaWFnTG9nTGV2ZWwuTk9ORVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9lbnZpcm9ubWVudC5qc1xuZnVuY3Rpb24gZ2V0RW52KCkge1xuICB2YXIgcHJvY2Vzc0VudiA9IHBhcnNlRW52aXJvbm1lbnQocHJvY2Vzcy5lbnYpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9FTlZJUk9OTUVOVCwgcHJvY2Vzc0Vudik7XG59XG52YXIgaW5pdF9lbnZpcm9ubWVudDIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvZW52aXJvbm1lbnQuanNcIigpIHtcbiAgICBpbml0X2Vudmlyb25tZW50KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9nbG9iYWxUaGlzLmpzXG52YXIgX2dsb2JhbFRoaXMzO1xudmFyIGluaXRfZ2xvYmFsVGhpczMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvZ2xvYmFsVGhpcy5qc1wiKCkge1xuICAgIF9nbG9iYWxUaGlzMyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiID8gZ2xvYmFsVGhpcyA6IGdsb2JhbDtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9jb21tb24vaGV4LXRvLWJpbmFyeS5qc1xuZnVuY3Rpb24gaW50VmFsdWUoY2hhckNvZGUpIHtcbiAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlIC0gNDg7XG4gIH1cbiAgaWYgKGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMikge1xuICAgIHJldHVybiBjaGFyQ29kZSAtIDg3O1xuICB9XG4gIHJldHVybiBjaGFyQ29kZSAtIDU1O1xufVxuZnVuY3Rpb24gaGV4VG9CaW5hcnkoaGV4U3RyKSB7XG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShoZXhTdHIubGVuZ3RoIC8gMik7XG4gIHZhciBvZmZzZXQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ci5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBoaSA9IGludFZhbHVlKGhleFN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICB2YXIgbG8gPSBpbnRWYWx1ZShoZXhTdHIuY2hhckNvZGVBdChpICsgMSkpO1xuICAgIGJ1ZltvZmZzZXQrK10gPSBoaSA8PCA0IHwgbG87XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbnZhciBpbml0X2hleF90b19iaW5hcnkgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi9oZXgtdG8tYmluYXJ5LmpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9oZXgtdG8tYmFzZTY0LmpzXG5mdW5jdGlvbiBoZXhUb0Jhc2U2NChoZXhTdHIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleFRvQmluYXJ5KGhleFN0cikpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxudmFyIGluaXRfaGV4X3RvX2Jhc2U2NCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9oZXgtdG8tYmFzZTY0LmpzXCIoKSB7XG4gICAgaW5pdF9oZXhfdG9fYmluYXJ5KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9SYW5kb21JZEdlbmVyYXRvci5qc1xuZnVuY3Rpb24gZ2V0SWRHZW5lcmF0b3IoYnl0ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlSWQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcyAvIDQ7IGkrKykge1xuICAgICAgU0hBUkVEX0JVRkZFUi53cml0ZVVJbnQzMkJFKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCAzMikgPj4+IDAsIGkgKiA0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICBpZiAoU0hBUkVEX0JVRkZFUltpXSA+IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IGJ5dGVzIC0gMSkge1xuICAgICAgICBTSEFSRURfQlVGRkVSW2J5dGVzIC0gMV0gPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU0hBUkVEX0JVRkZFUi50b1N0cmluZyhcImhleFwiLCAwLCBieXRlcyk7XG4gIH07XG59XG52YXIgU1BBTl9JRF9CWVRFUywgVFJBQ0VfSURfQllURVMsIFJhbmRvbUlkR2VuZXJhdG9yLCBTSEFSRURfQlVGRkVSO1xudmFyIGluaXRfUmFuZG9tSWRHZW5lcmF0b3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvUmFuZG9tSWRHZW5lcmF0b3IuanNcIigpIHtcbiAgICBTUEFOX0lEX0JZVEVTID0gODtcbiAgICBUUkFDRV9JRF9CWVRFUyA9IDE2O1xuICAgIFJhbmRvbUlkR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gUmFuZG9tSWRHZW5lcmF0b3IzKCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlVHJhY2VJZCA9IGdldElkR2VuZXJhdG9yKFRSQUNFX0lEX0JZVEVTKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVNwYW5JZCA9IGdldElkR2VuZXJhdG9yKFNQQU5fSURfQllURVMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJhbmRvbUlkR2VuZXJhdG9yMztcbiAgICB9KCk7XG4gICAgU0hBUkVEX0JVRkZFUiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShUUkFDRV9JRF9CWVRFUyk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9wZXJmb3JtYW5jZS5qc1xudmFyIGltcG9ydF9wZXJmX2hvb2tzLCBvdHBlcmZvcm1hbmNlO1xudmFyIGluaXRfcGVyZm9ybWFuY2UgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvcGVyZm9ybWFuY2UuanNcIigpIHtcbiAgICBpbXBvcnRfcGVyZl9ob29rcyA9IHJlcXVpcmUoXCJwZXJmX2hvb2tzXCIpO1xuICAgIG90cGVyZm9ybWFuY2UgPSBpbXBvcnRfcGVyZl9ob29rcy5wZXJmb3JtYW5jZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTjI7XG52YXIgaW5pdF92ZXJzaW9uMiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdmVyc2lvbi5qc1wiKCkge1xuICAgIFZFUlNJT04yID0gXCIxLjIzLjBcIjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9ucy9idWlsZC9lc20vaW50ZXJuYWwvdXRpbHMuanNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBjcmVhdGVDb25zdE1hcCh2YWx1ZXMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yICh2YXIgbHAgPSAwOyBscCA8IGxlbjsgbHArKykge1xuICAgIHZhciB2YWwgPSB2YWx1ZXNbbHBdO1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHJlc1tTdHJpbmcodmFsKS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1stLl0vZywgXCJfXCIpXSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnZhciBpbml0X3V0aWxzNCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYnVpbGQvZXNtL2ludGVybmFsL3V0aWxzLmpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYnVpbGQvZXNtL3RyYWNlL1NlbWFudGljQXR0cmlidXRlcy5qc1xudmFyIFRNUF9BV1NfTEFNQkRBX0lOVk9LRURfQVJOLCBUTVBfREJfU1lTVEVNLCBUTVBfREJfQ09OTkVDVElPTl9TVFJJTkcsIFRNUF9EQl9VU0VSLCBUTVBfREJfSkRCQ19EUklWRVJfQ0xBU1NOQU1FLCBUTVBfREJfTkFNRSwgVE1QX0RCX1NUQVRFTUVOVCwgVE1QX0RCX09QRVJBVElPTiwgVE1QX0RCX01TU1FMX0lOU1RBTkNFX05BTUUsIFRNUF9EQl9DQVNTQU5EUkFfS0VZU1BBQ0UsIFRNUF9EQl9DQVNTQU5EUkFfUEFHRV9TSVpFLCBUTVBfREJfQ0FTU0FORFJBX0NPTlNJU1RFTkNZX0xFVkVMLCBUTVBfREJfQ0FTU0FORFJBX1RBQkxFLCBUTVBfREJfQ0FTU0FORFJBX0lERU1QT1RFTkNFLCBUTVBfREJfQ0FTU0FORFJBX1NQRUNVTEFUSVZFX0VYRUNVVElPTl9DT1VOVCwgVE1QX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9JRCwgVE1QX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9EQywgVE1QX0RCX0hCQVNFX05BTUVTUEFDRSwgVE1QX0RCX1JFRElTX0RBVEFCQVNFX0lOREVYLCBUTVBfREJfTU9OR09EQl9DT0xMRUNUSU9OLCBUTVBfREJfU1FMX1RBQkxFLCBUTVBfRVhDRVBUSU9OX1RZUEUsIFRNUF9FWENFUFRJT05fTUVTU0FHRSwgVE1QX0VYQ0VQVElPTl9TVEFDS1RSQUNFLCBUTVBfRVhDRVBUSU9OX0VTQ0FQRUQsIFRNUF9GQUFTX1RSSUdHRVIsIFRNUF9GQUFTX0VYRUNVVElPTiwgVE1QX0ZBQVNfRE9DVU1FTlRfQ09MTEVDVElPTiwgVE1QX0ZBQVNfRE9DVU1FTlRfT1BFUkFUSU9OLCBUTVBfRkFBU19ET0NVTUVOVF9USU1FLCBUTVBfRkFBU19ET0NVTUVOVF9OQU1FLCBUTVBfRkFBU19USU1FLCBUTVBfRkFBU19DUk9OLCBUTVBfRkFBU19DT0xEU1RBUlQsIFRNUF9GQUFTX0lOVk9LRURfTkFNRSwgVE1QX0ZBQVNfSU5WT0tFRF9QUk9WSURFUiwgVE1QX0ZBQVNfSU5WT0tFRF9SRUdJT04sIFRNUF9ORVRfVFJBTlNQT1JULCBUTVBfTkVUX1BFRVJfSVAsIFRNUF9ORVRfUEVFUl9QT1JULCBUTVBfTkVUX1BFRVJfTkFNRSwgVE1QX05FVF9IT1NUX0lQLCBUTVBfTkVUX0hPU1RfUE9SVCwgVE1QX05FVF9IT1NUX05BTUUsIFRNUF9ORVRfSE9TVF9DT05ORUNUSU9OX1RZUEUsIFRNUF9ORVRfSE9TVF9DT05ORUNUSU9OX1NVQlRZUEUsIFRNUF9ORVRfSE9TVF9DQVJSSUVSX05BTUUsIFRNUF9ORVRfSE9TVF9DQVJSSUVSX01DQywgVE1QX05FVF9IT1NUX0NBUlJJRVJfTU5DLCBUTVBfTkVUX0hPU1RfQ0FSUklFUl9JQ0MsIFRNUF9QRUVSX1NFUlZJQ0UsIFRNUF9FTkRVU0VSX0lELCBUTVBfRU5EVVNFUl9ST0xFLCBUTVBfRU5EVVNFUl9TQ09QRSwgVE1QX1RIUkVBRF9JRCwgVE1QX1RIUkVBRF9OQU1FLCBUTVBfQ09ERV9GVU5DVElPTiwgVE1QX0NPREVfTkFNRVNQQUNFLCBUTVBfQ09ERV9GSUxFUEFUSCwgVE1QX0NPREVfTElORU5PLCBUTVBfSFRUUF9NRVRIT0QsIFRNUF9IVFRQX1VSTCwgVE1QX0hUVFBfVEFSR0VULCBUTVBfSFRUUF9IT1NULCBUTVBfSFRUUF9TQ0hFTUUsIFRNUF9IVFRQX1NUQVRVU19DT0RFLCBUTVBfSFRUUF9GTEFWT1IsIFRNUF9IVFRQX1VTRVJfQUdFTlQsIFRNUF9IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEgsIFRNUF9IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VELCBUTVBfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSCwgVE1QX0hUVFBfUkVTUE9OU0VfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VELCBUTVBfSFRUUF9TRVJWRVJfTkFNRSwgVE1QX0hUVFBfUk9VVEUsIFRNUF9IVFRQX0NMSUVOVF9JUCwgVE1QX0FXU19EWU5BTU9EQl9UQUJMRV9OQU1FUywgVE1QX0FXU19EWU5BTU9EQl9DT05TVU1FRF9DQVBBQ0lUWSwgVE1QX0FXU19EWU5BTU9EQl9JVEVNX0NPTExFQ1RJT05fTUVUUklDUywgVE1QX0FXU19EWU5BTU9EQl9QUk9WSVNJT05FRF9SRUFEX0NBUEFDSVRZLCBUTVBfQVdTX0RZTkFNT0RCX1BST1ZJU0lPTkVEX1dSSVRFX0NBUEFDSVRZLCBUTVBfQVdTX0RZTkFNT0RCX0NPTlNJU1RFTlRfUkVBRCwgVE1QX0FXU19EWU5BTU9EQl9QUk9KRUNUSU9OLCBUTVBfQVdTX0RZTkFNT0RCX0xJTUlULCBUTVBfQVdTX0RZTkFNT0RCX0FUVFJJQlVURVNfVE9fR0VULCBUTVBfQVdTX0RZTkFNT0RCX0lOREVYX05BTUUsIFRNUF9BV1NfRFlOQU1PREJfU0VMRUNULCBUTVBfQVdTX0RZTkFNT0RCX0dMT0JBTF9TRUNPTkRBUllfSU5ERVhFUywgVE1QX0FXU19EWU5BTU9EQl9MT0NBTF9TRUNPTkRBUllfSU5ERVhFUywgVE1QX0FXU19EWU5BTU9EQl9FWENMVVNJVkVfU1RBUlRfVEFCTEUsIFRNUF9BV1NfRFlOQU1PREJfVEFCTEVfQ09VTlQsIFRNUF9BV1NfRFlOQU1PREJfU0NBTl9GT1JXQVJELCBUTVBfQVdTX0RZTkFNT0RCX1NFR01FTlQsIFRNUF9BV1NfRFlOQU1PREJfVE9UQUxfU0VHTUVOVFMsIFRNUF9BV1NfRFlOQU1PREJfQ09VTlQsIFRNUF9BV1NfRFlOQU1PREJfU0NBTk5FRF9DT1VOVCwgVE1QX0FXU19EWU5BTU9EQl9BVFRSSUJVVEVfREVGSU5JVElPTlMsIFRNUF9BV1NfRFlOQU1PREJfR0xPQkFMX1NFQ09OREFSWV9JTkRFWF9VUERBVEVTLCBUTVBfTUVTU0FHSU5HX1NZU1RFTSwgVE1QX01FU1NBR0lOR19ERVNUSU5BVElPTiwgVE1QX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5ELCBUTVBfTUVTU0FHSU5HX1RFTVBfREVTVElOQVRJT04sIFRNUF9NRVNTQUdJTkdfUFJPVE9DT0wsIFRNUF9NRVNTQUdJTkdfUFJPVE9DT0xfVkVSU0lPTiwgVE1QX01FU1NBR0lOR19VUkwsIFRNUF9NRVNTQUdJTkdfTUVTU0FHRV9JRCwgVE1QX01FU1NBR0lOR19DT05WRVJTQVRJT05fSUQsIFRNUF9NRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX1NJWkVfQllURVMsIFRNUF9NRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX0NPTVBSRVNTRURfU0laRV9CWVRFUywgVE1QX01FU1NBR0lOR19PUEVSQVRJT04sIFRNUF9NRVNTQUdJTkdfQ09OU1VNRVJfSUQsIFRNUF9NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVksIFRNUF9NRVNTQUdJTkdfS0FGS0FfTUVTU0FHRV9LRVksIFRNUF9NRVNTQUdJTkdfS0FGS0FfQ09OU1VNRVJfR1JPVVAsIFRNUF9NRVNTQUdJTkdfS0FGS0FfQ0xJRU5UX0lELCBUTVBfTUVTU0FHSU5HX0tBRktBX1BBUlRJVElPTiwgVE1QX01FU1NBR0lOR19LQUZLQV9UT01CU1RPTkUsIFRNUF9SUENfU1lTVEVNLCBUTVBfUlBDX1NFUlZJQ0UsIFRNUF9SUENfTUVUSE9ELCBUTVBfUlBDX0dSUENfU1RBVFVTX0NPREUsIFRNUF9SUENfSlNPTlJQQ19WRVJTSU9OLCBUTVBfUlBDX0pTT05SUENfUkVRVUVTVF9JRCwgVE1QX1JQQ19KU09OUlBDX0VSUk9SX0NPREUsIFRNUF9SUENfSlNPTlJQQ19FUlJPUl9NRVNTQUdFLCBUTVBfTUVTU0FHRV9UWVBFLCBUTVBfTUVTU0FHRV9JRCwgVE1QX01FU1NBR0VfQ09NUFJFU1NFRF9TSVpFLCBUTVBfTUVTU0FHRV9VTkNPTVBSRVNTRURfU0laRSwgU0VNQVRUUlNfQVdTX0xBTUJEQV9JTlZPS0VEX0FSTiwgU0VNQVRUUlNfREJfU1lTVEVNLCBTRU1BVFRSU19EQl9DT05ORUNUSU9OX1NUUklORywgU0VNQVRUUlNfREJfVVNFUiwgU0VNQVRUUlNfREJfSkRCQ19EUklWRVJfQ0xBU1NOQU1FLCBTRU1BVFRSU19EQl9OQU1FLCBTRU1BVFRSU19EQl9TVEFURU1FTlQsIFNFTUFUVFJTX0RCX09QRVJBVElPTiwgU0VNQVRUUlNfREJfTVNTUUxfSU5TVEFOQ0VfTkFNRSwgU0VNQVRUUlNfREJfQ0FTU0FORFJBX0tFWVNQQUNFLCBTRU1BVFRSU19EQl9DQVNTQU5EUkFfUEFHRV9TSVpFLCBTRU1BVFRSU19EQl9DQVNTQU5EUkFfQ09OU0lTVEVOQ1lfTEVWRUwsIFNFTUFUVFJTX0RCX0NBU1NBTkRSQV9UQUJMRSwgU0VNQVRUUlNfREJfQ0FTU0FORFJBX0lERU1QT1RFTkNFLCBTRU1BVFRSU19EQl9DQVNTQU5EUkFfU1BFQ1VMQVRJVkVfRVhFQ1VUSU9OX0NPVU5ULCBTRU1BVFRSU19EQl9DQVNTQU5EUkFfQ09PUkRJTkFUT1JfSUQsIFNFTUFUVFJTX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9EQywgU0VNQVRUUlNfREJfSEJBU0VfTkFNRVNQQUNFLCBTRU1BVFRSU19EQl9SRURJU19EQVRBQkFTRV9JTkRFWCwgU0VNQVRUUlNfREJfTU9OR09EQl9DT0xMRUNUSU9OLCBTRU1BVFRSU19EQl9TUUxfVEFCTEUsIFNFTUFUVFJTX0VYQ0VQVElPTl9UWVBFLCBTRU1BVFRSU19FWENFUFRJT05fTUVTU0FHRSwgU0VNQVRUUlNfRVhDRVBUSU9OX1NUQUNLVFJBQ0UsIFNFTUFUVFJTX0VYQ0VQVElPTl9FU0NBUEVELCBTRU1BVFRSU19GQUFTX1RSSUdHRVIsIFNFTUFUVFJTX0ZBQVNfRVhFQ1VUSU9OLCBTRU1BVFRSU19GQUFTX0RPQ1VNRU5UX0NPTExFQ1RJT04sIFNFTUFUVFJTX0ZBQVNfRE9DVU1FTlRfT1BFUkFUSU9OLCBTRU1BVFRSU19GQUFTX0RPQ1VNRU5UX1RJTUUsIFNFTUFUVFJTX0ZBQVNfRE9DVU1FTlRfTkFNRSwgU0VNQVRUUlNfRkFBU19USU1FLCBTRU1BVFRSU19GQUFTX0NST04sIFNFTUFUVFJTX0ZBQVNfQ09MRFNUQVJULCBTRU1BVFRSU19GQUFTX0lOVk9LRURfTkFNRSwgU0VNQVRUUlNfRkFBU19JTlZPS0VEX1BST1ZJREVSLCBTRU1BVFRSU19GQUFTX0lOVk9LRURfUkVHSU9OLCBTRU1BVFRSU19ORVRfVFJBTlNQT1JULCBTRU1BVFRSU19ORVRfUEVFUl9JUCwgU0VNQVRUUlNfTkVUX1BFRVJfUE9SVCwgU0VNQVRUUlNfTkVUX1BFRVJfTkFNRSwgU0VNQVRUUlNfTkVUX0hPU1RfSVAsIFNFTUFUVFJTX05FVF9IT1NUX1BPUlQsIFNFTUFUVFJTX05FVF9IT1NUX05BTUUsIFNFTUFUVFJTX05FVF9IT1NUX0NPTk5FQ1RJT05fVFlQRSwgU0VNQVRUUlNfTkVUX0hPU1RfQ09OTkVDVElPTl9TVUJUWVBFLCBTRU1BVFRSU19ORVRfSE9TVF9DQVJSSUVSX05BTUUsIFNFTUFUVFJTX05FVF9IT1NUX0NBUlJJRVJfTUNDLCBTRU1BVFRSU19ORVRfSE9TVF9DQVJSSUVSX01OQywgU0VNQVRUUlNfTkVUX0hPU1RfQ0FSUklFUl9JQ0MsIFNFTUFUVFJTX1BFRVJfU0VSVklDRSwgU0VNQVRUUlNfRU5EVVNFUl9JRCwgU0VNQVRUUlNfRU5EVVNFUl9ST0xFLCBTRU1BVFRSU19FTkRVU0VSX1NDT1BFLCBTRU1BVFRSU19USFJFQURfSUQsIFNFTUFUVFJTX1RIUkVBRF9OQU1FLCBTRU1BVFRSU19DT0RFX0ZVTkNUSU9OLCBTRU1BVFRSU19DT0RFX05BTUVTUEFDRSwgU0VNQVRUUlNfQ09ERV9GSUxFUEFUSCwgU0VNQVRUUlNfQ09ERV9MSU5FTk8sIFNFTUFUVFJTX0hUVFBfTUVUSE9ELCBTRU1BVFRSU19IVFRQX1VSTCwgU0VNQVRUUlNfSFRUUF9UQVJHRVQsIFNFTUFUVFJTX0hUVFBfSE9TVCwgU0VNQVRUUlNfSFRUUF9TQ0hFTUUsIFNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREUsIFNFTUFUVFJTX0hUVFBfRkxBVk9SLCBTRU1BVFRSU19IVFRQX1VTRVJfQUdFTlQsIFNFTUFUVFJTX0hUVFBfUkVRVUVTVF9DT05URU5UX0xFTkdUSCwgU0VNQVRUUlNfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRCwgU0VNQVRUUlNfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSCwgU0VNQVRUUlNfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSF9VTkNPTVBSRVNTRUQsIFNFTUFUVFJTX0hUVFBfU0VSVkVSX05BTUUsIFNFTUFUVFJTX0hUVFBfUk9VVEUsIFNFTUFUVFJTX0hUVFBfQ0xJRU5UX0lQLCBTRU1BVFRSU19BV1NfRFlOQU1PREJfVEFCTEVfTkFNRVMsIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9DT05TVU1FRF9DQVBBQ0lUWSwgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0lURU1fQ09MTEVDVElPTl9NRVRSSUNTLCBTRU1BVFRSU19BV1NfRFlOQU1PREJfUFJPVklTSU9ORURfUkVBRF9DQVBBQ0lUWSwgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1BST1ZJU0lPTkVEX1dSSVRFX0NBUEFDSVRZLCBTRU1BVFRSU19BV1NfRFlOQU1PREJfQ09OU0lTVEVOVF9SRUFELCBTRU1BVFRSU19BV1NfRFlOQU1PREJfUFJPSkVDVElPTiwgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0xJTUlULCBTRU1BVFRSU19BV1NfRFlOQU1PREJfQVRUUklCVVRFU19UT19HRVQsIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9JTkRFWF9OQU1FLCBTRU1BVFRSU19BV1NfRFlOQU1PREJfU0VMRUNULCBTRU1BVFRSU19BV1NfRFlOQU1PREJfR0xPQkFMX1NFQ09OREFSWV9JTkRFWEVTLCBTRU1BVFRSU19BV1NfRFlOQU1PREJfTE9DQUxfU0VDT05EQVJZX0lOREVYRVMsIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9FWENMVVNJVkVfU1RBUlRfVEFCTEUsIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9UQUJMRV9DT1VOVCwgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1NDQU5fRk9SV0FSRCwgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1NFR01FTlQsIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9UT1RBTF9TRUdNRU5UUywgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0NPVU5ULCBTRU1BVFRSU19BV1NfRFlOQU1PREJfU0NBTk5FRF9DT1VOVCwgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0FUVFJJQlVURV9ERUZJTklUSU9OUywgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0dMT0JBTF9TRUNPTkRBUllfSU5ERVhfVVBEQVRFUywgU0VNQVRUUlNfTUVTU0FHSU5HX1NZU1RFTSwgU0VNQVRUUlNfTUVTU0FHSU5HX0RFU1RJTkFUSU9OLCBTRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05fS0lORCwgU0VNQVRUUlNfTUVTU0FHSU5HX1RFTVBfREVTVElOQVRJT04sIFNFTUFUVFJTX01FU1NBR0lOR19QUk9UT0NPTCwgU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT04sIFNFTUFUVFJTX01FU1NBR0lOR19VUkwsIFNFTUFUVFJTX01FU1NBR0lOR19NRVNTQUdFX0lELCBTRU1BVFRSU19NRVNTQUdJTkdfQ09OVkVSU0FUSU9OX0lELCBTRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX1NJWkVfQllURVMsIFNFTUFUVFJTX01FU1NBR0lOR19NRVNTQUdFX1BBWUxPQURfQ09NUFJFU1NFRF9TSVpFX0JZVEVTLCBTRU1BVFRSU19NRVNTQUdJTkdfT1BFUkFUSU9OLCBTRU1BVFRSU19NRVNTQUdJTkdfQ09OU1VNRVJfSUQsIFNFTUFUVFJTX01FU1NBR0lOR19SQUJCSVRNUV9ST1VUSU5HX0tFWSwgU0VNQVRUUlNfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZLCBTRU1BVFRSU19NRVNTQUdJTkdfS0FGS0FfQ09OU1VNRVJfR1JPVVAsIFNFTUFUVFJTX01FU1NBR0lOR19LQUZLQV9DTElFTlRfSUQsIFNFTUFUVFJTX01FU1NBR0lOR19LQUZLQV9QQVJUSVRJT04sIFNFTUFUVFJTX01FU1NBR0lOR19LQUZLQV9UT01CU1RPTkUsIFNFTUFUVFJTX1JQQ19TWVNURU0sIFNFTUFUVFJTX1JQQ19TRVJWSUNFLCBTRU1BVFRSU19SUENfTUVUSE9ELCBTRU1BVFRSU19SUENfR1JQQ19TVEFUVVNfQ09ERSwgU0VNQVRUUlNfUlBDX0pTT05SUENfVkVSU0lPTiwgU0VNQVRUUlNfUlBDX0pTT05SUENfUkVRVUVTVF9JRCwgU0VNQVRUUlNfUlBDX0pTT05SUENfRVJST1JfQ09ERSwgU0VNQVRUUlNfUlBDX0pTT05SUENfRVJST1JfTUVTU0FHRSwgU0VNQVRUUlNfTUVTU0FHRV9UWVBFLCBTRU1BVFRSU19NRVNTQUdFX0lELCBTRU1BVFRSU19NRVNTQUdFX0NPTVBSRVNTRURfU0laRSwgU0VNQVRUUlNfTUVTU0FHRV9VTkNPTVBSRVNTRURfU0laRSwgU2VtYW50aWNBdHRyaWJ1dGVzLCBUTVBfREJTWVNURU1WQUxVRVNfT1RIRVJfU1FMLCBUTVBfREJTWVNURU1WQUxVRVNfTVNTUUwsIFRNUF9EQlNZU1RFTVZBTFVFU19NWVNRTCwgVE1QX0RCU1lTVEVNVkFMVUVTX09SQUNMRSwgVE1QX0RCU1lTVEVNVkFMVUVTX0RCMiwgVE1QX0RCU1lTVEVNVkFMVUVTX1BPU1RHUkVTUUwsIFRNUF9EQlNZU1RFTVZBTFVFU19SRURTSElGVCwgVE1QX0RCU1lTVEVNVkFMVUVTX0hJVkUsIFRNUF9EQlNZU1RFTVZBTFVFU19DTE9VRFNDQVBFLCBUTVBfREJTWVNURU1WQUxVRVNfSFNRTERCLCBUTVBfREJTWVNURU1WQUxVRVNfUFJPR1JFU1MsIFRNUF9EQlNZU1RFTVZBTFVFU19NQVhEQiwgVE1QX0RCU1lTVEVNVkFMVUVTX0hBTkFEQiwgVE1QX0RCU1lTVEVNVkFMVUVTX0lOR1JFUywgVE1QX0RCU1lTVEVNVkFMVUVTX0ZJUlNUU1FMLCBUTVBfREJTWVNURU1WQUxVRVNfRURCLCBUTVBfREJTWVNURU1WQUxVRVNfQ0FDSEUsIFRNUF9EQlNZU1RFTVZBTFVFU19BREFCQVMsIFRNUF9EQlNZU1RFTVZBTFVFU19GSVJFQklSRCwgVE1QX0RCU1lTVEVNVkFMVUVTX0RFUkJZLCBUTVBfREJTWVNURU1WQUxVRVNfRklMRU1BS0VSLCBUTVBfREJTWVNURU1WQUxVRVNfSU5GT1JNSVgsIFRNUF9EQlNZU1RFTVZBTFVFU19JTlNUQU5UREIsIFRNUF9EQlNZU1RFTVZBTFVFU19JTlRFUkJBU0UsIFRNUF9EQlNZU1RFTVZBTFVFU19NQVJJQURCLCBUTVBfREJTWVNURU1WQUxVRVNfTkVURVpaQSwgVE1QX0RCU1lTVEVNVkFMVUVTX1BFUlZBU0lWRSwgVE1QX0RCU1lTVEVNVkFMVUVTX1BPSU5UQkFTRSwgVE1QX0RCU1lTVEVNVkFMVUVTX1NRTElURSwgVE1QX0RCU1lTVEVNVkFMVUVTX1NZQkFTRSwgVE1QX0RCU1lTVEVNVkFMVUVTX1RFUkFEQVRBLCBUTVBfREJTWVNURU1WQUxVRVNfVkVSVElDQSwgVE1QX0RCU1lTVEVNVkFMVUVTX0gyLCBUTVBfREJTWVNURU1WQUxVRVNfQ09MREZVU0lPTiwgVE1QX0RCU1lTVEVNVkFMVUVTX0NBU1NBTkRSQSwgVE1QX0RCU1lTVEVNVkFMVUVTX0hCQVNFLCBUTVBfREJTWVNURU1WQUxVRVNfTU9OR09EQiwgVE1QX0RCU1lTVEVNVkFMVUVTX1JFRElTLCBUTVBfREJTWVNURU1WQUxVRVNfQ09VQ0hCQVNFLCBUTVBfREJTWVNURU1WQUxVRVNfQ09VQ0hEQiwgVE1QX0RCU1lTVEVNVkFMVUVTX0NPU01PU0RCLCBUTVBfREJTWVNURU1WQUxVRVNfRFlOQU1PREIsIFRNUF9EQlNZU1RFTVZBTFVFU19ORU80SiwgVE1QX0RCU1lTVEVNVkFMVUVTX0dFT0RFLCBUTVBfREJTWVNURU1WQUxVRVNfRUxBU1RJQ1NFQVJDSCwgVE1QX0RCU1lTVEVNVkFMVUVTX01FTUNBQ0hFRCwgVE1QX0RCU1lTVEVNVkFMVUVTX0NPQ0tST0FDSERCLCBEQlNZU1RFTVZBTFVFU19PVEhFUl9TUUwsIERCU1lTVEVNVkFMVUVTX01TU1FMLCBEQlNZU1RFTVZBTFVFU19NWVNRTCwgREJTWVNURU1WQUxVRVNfT1JBQ0xFLCBEQlNZU1RFTVZBTFVFU19EQjIsIERCU1lTVEVNVkFMVUVTX1BPU1RHUkVTUUwsIERCU1lTVEVNVkFMVUVTX1JFRFNISUZULCBEQlNZU1RFTVZBTFVFU19ISVZFLCBEQlNZU1RFTVZBTFVFU19DTE9VRFNDQVBFLCBEQlNZU1RFTVZBTFVFU19IU1FMREIsIERCU1lTVEVNVkFMVUVTX1BST0dSRVNTLCBEQlNZU1RFTVZBTFVFU19NQVhEQiwgREJTWVNURU1WQUxVRVNfSEFOQURCLCBEQlNZU1RFTVZBTFVFU19JTkdSRVMsIERCU1lTVEVNVkFMVUVTX0ZJUlNUU1FMLCBEQlNZU1RFTVZBTFVFU19FREIsIERCU1lTVEVNVkFMVUVTX0NBQ0hFLCBEQlNZU1RFTVZBTFVFU19BREFCQVMsIERCU1lTVEVNVkFMVUVTX0ZJUkVCSVJELCBEQlNZU1RFTVZBTFVFU19ERVJCWSwgREJTWVNURU1WQUxVRVNfRklMRU1BS0VSLCBEQlNZU1RFTVZBTFVFU19JTkZPUk1JWCwgREJTWVNURU1WQUxVRVNfSU5TVEFOVERCLCBEQlNZU1RFTVZBTFVFU19JTlRFUkJBU0UsIERCU1lTVEVNVkFMVUVTX01BUklBREIsIERCU1lTVEVNVkFMVUVTX05FVEVaWkEsIERCU1lTVEVNVkFMVUVTX1BFUlZBU0lWRSwgREJTWVNURU1WQUxVRVNfUE9JTlRCQVNFLCBEQlNZU1RFTVZBTFVFU19TUUxJVEUsIERCU1lTVEVNVkFMVUVTX1NZQkFTRSwgREJTWVNURU1WQUxVRVNfVEVSQURBVEEsIERCU1lTVEVNVkFMVUVTX1ZFUlRJQ0EsIERCU1lTVEVNVkFMVUVTX0gyLCBEQlNZU1RFTVZBTFVFU19DT0xERlVTSU9OLCBEQlNZU1RFTVZBTFVFU19DQVNTQU5EUkEsIERCU1lTVEVNVkFMVUVTX0hCQVNFLCBEQlNZU1RFTVZBTFVFU19NT05HT0RCLCBEQlNZU1RFTVZBTFVFU19SRURJUywgREJTWVNURU1WQUxVRVNfQ09VQ0hCQVNFLCBEQlNZU1RFTVZBTFVFU19DT1VDSERCLCBEQlNZU1RFTVZBTFVFU19DT1NNT1NEQiwgREJTWVNURU1WQUxVRVNfRFlOQU1PREIsIERCU1lTVEVNVkFMVUVTX05FTzRKLCBEQlNZU1RFTVZBTFVFU19HRU9ERSwgREJTWVNURU1WQUxVRVNfRUxBU1RJQ1NFQVJDSCwgREJTWVNURU1WQUxVRVNfTUVNQ0FDSEVELCBEQlNZU1RFTVZBTFVFU19DT0NLUk9BQ0hEQiwgRGJTeXN0ZW1WYWx1ZXMsIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfQUxMLCBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0VBQ0hfUVVPUlVNLCBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1FVT1JVTSwgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9RVU9SVU0sIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfT05FLCBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1RXTywgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19USFJFRSwgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9PTkUsIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfQU5ZLCBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1NFUklBTCwgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9TRVJJQUwsIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19BTEwsIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19FQUNIX1FVT1JVTSwgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1FVT1JVTSwgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0xPQ0FMX1FVT1JVTSwgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX09ORSwgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1RXTywgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1RIUkVFLCBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfT05FLCBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfQU5ZLCBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfU0VSSUFMLCBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfU0VSSUFMLCBEYkNhc3NhbmRyYUNvbnNpc3RlbmN5TGV2ZWxWYWx1ZXMsIFRNUF9GQUFTVFJJR0dFUlZBTFVFU19EQVRBU09VUkNFLCBUTVBfRkFBU1RSSUdHRVJWQUxVRVNfSFRUUCwgVE1QX0ZBQVNUUklHR0VSVkFMVUVTX1BVQlNVQiwgVE1QX0ZBQVNUUklHR0VSVkFMVUVTX1RJTUVSLCBUTVBfRkFBU1RSSUdHRVJWQUxVRVNfT1RIRVIsIEZBQVNUUklHR0VSVkFMVUVTX0RBVEFTT1VSQ0UsIEZBQVNUUklHR0VSVkFMVUVTX0hUVFAsIEZBQVNUUklHR0VSVkFMVUVTX1BVQlNVQiwgRkFBU1RSSUdHRVJWQUxVRVNfVElNRVIsIEZBQVNUUklHR0VSVkFMVUVTX09USEVSLCBGYWFzVHJpZ2dlclZhbHVlcywgVE1QX0ZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19JTlNFUlQsIFRNUF9GQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfRURJVCwgVE1QX0ZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19ERUxFVEUsIEZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19JTlNFUlQsIEZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19FRElULCBGQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfREVMRVRFLCBGYWFzRG9jdW1lbnRPcGVyYXRpb25WYWx1ZXMsIFRNUF9GQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0FMSUJBQkFfQ0xPVUQsIFRNUF9GQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0FXUywgVE1QX0ZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfQVpVUkUsIFRNUF9GQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0dDUCwgRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BTElCQUJBX0NMT1VELCBGQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0FXUywgRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BWlVSRSwgRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19HQ1AsIEZhYXNJbnZva2VkUHJvdmlkZXJWYWx1ZXMsIFRNUF9ORVRUUkFOU1BPUlRWQUxVRVNfSVBfVENQLCBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX0lQX1VEUCwgVE1QX05FVFRSQU5TUE9SVFZBTFVFU19JUCwgVE1QX05FVFRSQU5TUE9SVFZBTFVFU19VTklYLCBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX1BJUEUsIFRNUF9ORVRUUkFOU1BPUlRWQUxVRVNfSU5QUk9DLCBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX09USEVSLCBORVRUUkFOU1BPUlRWQUxVRVNfSVBfVENQLCBORVRUUkFOU1BPUlRWQUxVRVNfSVBfVURQLCBORVRUUkFOU1BPUlRWQUxVRVNfSVAsIE5FVFRSQU5TUE9SVFZBTFVFU19VTklYLCBORVRUUkFOU1BPUlRWQUxVRVNfUElQRSwgTkVUVFJBTlNQT1JUVkFMVUVTX0lOUFJPQywgTkVUVFJBTlNQT1JUVkFMVUVTX09USEVSLCBOZXRUcmFuc3BvcnRWYWx1ZXMsIFRNUF9ORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfV0lGSSwgVE1QX05FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSVJFRCwgVE1QX05FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19DRUxMLCBUTVBfTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX1VOQVZBSUxBQkxFLCBUTVBfTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX1VOS05PV04sIE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSUZJLCBORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfV0lSRUQsIE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19DRUxMLCBORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfVU5BVkFJTEFCTEUsIE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19VTktOT1dOLCBOZXRIb3N0Q29ubmVjdGlvblR5cGVWYWx1ZXMsIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfR1BSUywgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FREdFLCBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX1VNVFMsIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQSwgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPXzAsIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRVZET19BLCBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0NETUEyMDAwXzFYUlRULCBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTRFBBLCBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTVVBBLCBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTUEEsIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSURFTiwgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPX0IsIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTFRFLCBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VIUlBELCBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTUEFQLCBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0dTTSwgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19URF9TQ0RNQSwgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19JV0xBTiwgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19OUiwgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19OUk5TQSwgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19MVEVfQ0EsIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19HUFJTLCBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRURHRSwgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX1VNVFMsIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19DRE1BLCBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRVZET18wLCBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRVZET19BLCBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQTIwMDBfMVhSVFQsIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU0RQQSwgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTVVBBLCBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSFNQQSwgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0lERU4sIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPX0IsIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19MVEUsIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FSFJQRCwgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTUEFQLCBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfR1NNLCBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfVERfU0NETUEsIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19JV0xBTiwgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX05SLCBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTlJOU0EsIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19MVEVfQ0EsIE5ldEhvc3RDb25uZWN0aW9uU3VidHlwZVZhbHVlcywgVE1QX0hUVFBGTEFWT1JWQUxVRVNfSFRUUF8xXzAsIFRNUF9IVFRQRkxBVk9SVkFMVUVTX0hUVFBfMV8xLCBUTVBfSFRUUEZMQVZPUlZBTFVFU19IVFRQXzJfMCwgVE1QX0hUVFBGTEFWT1JWQUxVRVNfU1BEWSwgVE1QX0hUVFBGTEFWT1JWQUxVRVNfUVVJQywgSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMCwgSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMSwgSFRUUEZMQVZPUlZBTFVFU19IVFRQXzJfMCwgSFRUUEZMQVZPUlZBTFVFU19TUERZLCBIVFRQRkxBVk9SVkFMVUVTX1FVSUMsIEh0dHBGbGF2b3JWYWx1ZXMsIFRNUF9NRVNTQUdJTkdERVNUSU5BVElPTktJTkRWQUxVRVNfUVVFVUUsIFRNUF9NRVNTQUdJTkdERVNUSU5BVElPTktJTkRWQUxVRVNfVE9QSUMsIE1FU1NBR0lOR0RFU1RJTkFUSU9OS0lORFZBTFVFU19RVUVVRSwgTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1RPUElDLCBNZXNzYWdpbmdEZXN0aW5hdGlvbktpbmRWYWx1ZXMsIFRNUF9NRVNTQUdJTkdPUEVSQVRJT05WQUxVRVNfUkVDRUlWRSwgVE1QX01FU1NBR0lOR09QRVJBVElPTlZBTFVFU19QUk9DRVNTLCBNRVNTQUdJTkdPUEVSQVRJT05WQUxVRVNfUkVDRUlWRSwgTUVTU0FHSU5HT1BFUkFUSU9OVkFMVUVTX1BST0NFU1MsIE1lc3NhZ2luZ09wZXJhdGlvblZhbHVlcywgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX09LLCBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfQ0FOQ0VMTEVELCBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5LTk9XTiwgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0lOVkFMSURfQVJHVU1FTlQsIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19ERUFETElORV9FWENFRURFRCwgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX05PVF9GT1VORCwgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0FMUkVBRFlfRVhJU1RTLCBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfUEVSTUlTU0lPTl9ERU5JRUQsIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19SRVNPVVJDRV9FWEhBVVNURUQsIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19GQUlMRURfUFJFQ09ORElUSU9OLCBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfQUJPUlRFRCwgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX09VVF9PRl9SQU5HRSwgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOSU1QTEVNRU5URUQsIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19JTlRFUk5BTCwgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOQVZBSUxBQkxFLCBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfREFUQV9MT1NTLCBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5BVVRIRU5USUNBVEVELCBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19PSywgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfQ0FOQ0VMTEVELCBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTktOT1dOLCBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19JTlZBTElEX0FSR1VNRU5ULCBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19ERUFETElORV9FWENFRURFRCwgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfTk9UX0ZPVU5ELCBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BTFJFQURZX0VYSVNUUywgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfUEVSTUlTU0lPTl9ERU5JRUQsIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1JFU09VUkNFX0VYSEFVU1RFRCwgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfRkFJTEVEX1BSRUNPTkRJVElPTiwgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfQUJPUlRFRCwgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfT1VUX09GX1JBTkdFLCBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTklNUExFTUVOVEVELCBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19JTlRFUk5BTCwgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5BVkFJTEFCTEUsIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0RBVEFfTE9TUywgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5BVVRIRU5USUNBVEVELCBScGNHcnBjU3RhdHVzQ29kZVZhbHVlcywgVE1QX01FU1NBR0VUWVBFVkFMVUVTX1NFTlQsIFRNUF9NRVNTQUdFVFlQRVZBTFVFU19SRUNFSVZFRCwgTUVTU0FHRVRZUEVWQUxVRVNfU0VOVCwgTUVTU0FHRVRZUEVWQUxVRVNfUkVDRUlWRUQsIE1lc3NhZ2VUeXBlVmFsdWVzO1xudmFyIGluaXRfU2VtYW50aWNBdHRyaWJ1dGVzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9ucy9idWlsZC9lc20vdHJhY2UvU2VtYW50aWNBdHRyaWJ1dGVzLmpzXCIoKSB7XG4gICAgaW5pdF91dGlsczQoKTtcbiAgICBUTVBfQVdTX0xBTUJEQV9JTlZPS0VEX0FSTiA9IFwiYXdzLmxhbWJkYS5pbnZva2VkX2FyblwiO1xuICAgIFRNUF9EQl9TWVNURU0gPSBcImRiLnN5c3RlbVwiO1xuICAgIFRNUF9EQl9DT05ORUNUSU9OX1NUUklORyA9IFwiZGIuY29ubmVjdGlvbl9zdHJpbmdcIjtcbiAgICBUTVBfREJfVVNFUiA9IFwiZGIudXNlclwiO1xuICAgIFRNUF9EQl9KREJDX0RSSVZFUl9DTEFTU05BTUUgPSBcImRiLmpkYmMuZHJpdmVyX2NsYXNzbmFtZVwiO1xuICAgIFRNUF9EQl9OQU1FID0gXCJkYi5uYW1lXCI7XG4gICAgVE1QX0RCX1NUQVRFTUVOVCA9IFwiZGIuc3RhdGVtZW50XCI7XG4gICAgVE1QX0RCX09QRVJBVElPTiA9IFwiZGIub3BlcmF0aW9uXCI7XG4gICAgVE1QX0RCX01TU1FMX0lOU1RBTkNFX05BTUUgPSBcImRiLm1zc3FsLmluc3RhbmNlX25hbWVcIjtcbiAgICBUTVBfREJfQ0FTU0FORFJBX0tFWVNQQUNFID0gXCJkYi5jYXNzYW5kcmEua2V5c3BhY2VcIjtcbiAgICBUTVBfREJfQ0FTU0FORFJBX1BBR0VfU0laRSA9IFwiZGIuY2Fzc2FuZHJhLnBhZ2Vfc2l6ZVwiO1xuICAgIFRNUF9EQl9DQVNTQU5EUkFfQ09OU0lTVEVOQ1lfTEVWRUwgPSBcImRiLmNhc3NhbmRyYS5jb25zaXN0ZW5jeV9sZXZlbFwiO1xuICAgIFRNUF9EQl9DQVNTQU5EUkFfVEFCTEUgPSBcImRiLmNhc3NhbmRyYS50YWJsZVwiO1xuICAgIFRNUF9EQl9DQVNTQU5EUkFfSURFTVBPVEVOQ0UgPSBcImRiLmNhc3NhbmRyYS5pZGVtcG90ZW5jZVwiO1xuICAgIFRNUF9EQl9DQVNTQU5EUkFfU1BFQ1VMQVRJVkVfRVhFQ1VUSU9OX0NPVU5UID0gXCJkYi5jYXNzYW5kcmEuc3BlY3VsYXRpdmVfZXhlY3V0aW9uX2NvdW50XCI7XG4gICAgVE1QX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9JRCA9IFwiZGIuY2Fzc2FuZHJhLmNvb3JkaW5hdG9yLmlkXCI7XG4gICAgVE1QX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9EQyA9IFwiZGIuY2Fzc2FuZHJhLmNvb3JkaW5hdG9yLmRjXCI7XG4gICAgVE1QX0RCX0hCQVNFX05BTUVTUEFDRSA9IFwiZGIuaGJhc2UubmFtZXNwYWNlXCI7XG4gICAgVE1QX0RCX1JFRElTX0RBVEFCQVNFX0lOREVYID0gXCJkYi5yZWRpcy5kYXRhYmFzZV9pbmRleFwiO1xuICAgIFRNUF9EQl9NT05HT0RCX0NPTExFQ1RJT04gPSBcImRiLm1vbmdvZGIuY29sbGVjdGlvblwiO1xuICAgIFRNUF9EQl9TUUxfVEFCTEUgPSBcImRiLnNxbC50YWJsZVwiO1xuICAgIFRNUF9FWENFUFRJT05fVFlQRSA9IFwiZXhjZXB0aW9uLnR5cGVcIjtcbiAgICBUTVBfRVhDRVBUSU9OX01FU1NBR0UgPSBcImV4Y2VwdGlvbi5tZXNzYWdlXCI7XG4gICAgVE1QX0VYQ0VQVElPTl9TVEFDS1RSQUNFID0gXCJleGNlcHRpb24uc3RhY2t0cmFjZVwiO1xuICAgIFRNUF9FWENFUFRJT05fRVNDQVBFRCA9IFwiZXhjZXB0aW9uLmVzY2FwZWRcIjtcbiAgICBUTVBfRkFBU19UUklHR0VSID0gXCJmYWFzLnRyaWdnZXJcIjtcbiAgICBUTVBfRkFBU19FWEVDVVRJT04gPSBcImZhYXMuZXhlY3V0aW9uXCI7XG4gICAgVE1QX0ZBQVNfRE9DVU1FTlRfQ09MTEVDVElPTiA9IFwiZmFhcy5kb2N1bWVudC5jb2xsZWN0aW9uXCI7XG4gICAgVE1QX0ZBQVNfRE9DVU1FTlRfT1BFUkFUSU9OID0gXCJmYWFzLmRvY3VtZW50Lm9wZXJhdGlvblwiO1xuICAgIFRNUF9GQUFTX0RPQ1VNRU5UX1RJTUUgPSBcImZhYXMuZG9jdW1lbnQudGltZVwiO1xuICAgIFRNUF9GQUFTX0RPQ1VNRU5UX05BTUUgPSBcImZhYXMuZG9jdW1lbnQubmFtZVwiO1xuICAgIFRNUF9GQUFTX1RJTUUgPSBcImZhYXMudGltZVwiO1xuICAgIFRNUF9GQUFTX0NST04gPSBcImZhYXMuY3JvblwiO1xuICAgIFRNUF9GQUFTX0NPTERTVEFSVCA9IFwiZmFhcy5jb2xkc3RhcnRcIjtcbiAgICBUTVBfRkFBU19JTlZPS0VEX05BTUUgPSBcImZhYXMuaW52b2tlZF9uYW1lXCI7XG4gICAgVE1QX0ZBQVNfSU5WT0tFRF9QUk9WSURFUiA9IFwiZmFhcy5pbnZva2VkX3Byb3ZpZGVyXCI7XG4gICAgVE1QX0ZBQVNfSU5WT0tFRF9SRUdJT04gPSBcImZhYXMuaW52b2tlZF9yZWdpb25cIjtcbiAgICBUTVBfTkVUX1RSQU5TUE9SVCA9IFwibmV0LnRyYW5zcG9ydFwiO1xuICAgIFRNUF9ORVRfUEVFUl9JUCA9IFwibmV0LnBlZXIuaXBcIjtcbiAgICBUTVBfTkVUX1BFRVJfUE9SVCA9IFwibmV0LnBlZXIucG9ydFwiO1xuICAgIFRNUF9ORVRfUEVFUl9OQU1FID0gXCJuZXQucGVlci5uYW1lXCI7XG4gICAgVE1QX05FVF9IT1NUX0lQID0gXCJuZXQuaG9zdC5pcFwiO1xuICAgIFRNUF9ORVRfSE9TVF9QT1JUID0gXCJuZXQuaG9zdC5wb3J0XCI7XG4gICAgVE1QX05FVF9IT1NUX05BTUUgPSBcIm5ldC5ob3N0Lm5hbWVcIjtcbiAgICBUTVBfTkVUX0hPU1RfQ09OTkVDVElPTl9UWVBFID0gXCJuZXQuaG9zdC5jb25uZWN0aW9uLnR5cGVcIjtcbiAgICBUTVBfTkVUX0hPU1RfQ09OTkVDVElPTl9TVUJUWVBFID0gXCJuZXQuaG9zdC5jb25uZWN0aW9uLnN1YnR5cGVcIjtcbiAgICBUTVBfTkVUX0hPU1RfQ0FSUklFUl9OQU1FID0gXCJuZXQuaG9zdC5jYXJyaWVyLm5hbWVcIjtcbiAgICBUTVBfTkVUX0hPU1RfQ0FSUklFUl9NQ0MgPSBcIm5ldC5ob3N0LmNhcnJpZXIubWNjXCI7XG4gICAgVE1QX05FVF9IT1NUX0NBUlJJRVJfTU5DID0gXCJuZXQuaG9zdC5jYXJyaWVyLm1uY1wiO1xuICAgIFRNUF9ORVRfSE9TVF9DQVJSSUVSX0lDQyA9IFwibmV0Lmhvc3QuY2Fycmllci5pY2NcIjtcbiAgICBUTVBfUEVFUl9TRVJWSUNFID0gXCJwZWVyLnNlcnZpY2VcIjtcbiAgICBUTVBfRU5EVVNFUl9JRCA9IFwiZW5kdXNlci5pZFwiO1xuICAgIFRNUF9FTkRVU0VSX1JPTEUgPSBcImVuZHVzZXIucm9sZVwiO1xuICAgIFRNUF9FTkRVU0VSX1NDT1BFID0gXCJlbmR1c2VyLnNjb3BlXCI7XG4gICAgVE1QX1RIUkVBRF9JRCA9IFwidGhyZWFkLmlkXCI7XG4gICAgVE1QX1RIUkVBRF9OQU1FID0gXCJ0aHJlYWQubmFtZVwiO1xuICAgIFRNUF9DT0RFX0ZVTkNUSU9OID0gXCJjb2RlLmZ1bmN0aW9uXCI7XG4gICAgVE1QX0NPREVfTkFNRVNQQUNFID0gXCJjb2RlLm5hbWVzcGFjZVwiO1xuICAgIFRNUF9DT0RFX0ZJTEVQQVRIID0gXCJjb2RlLmZpbGVwYXRoXCI7XG4gICAgVE1QX0NPREVfTElORU5PID0gXCJjb2RlLmxpbmVub1wiO1xuICAgIFRNUF9IVFRQX01FVEhPRCA9IFwiaHR0cC5tZXRob2RcIjtcbiAgICBUTVBfSFRUUF9VUkwgPSBcImh0dHAudXJsXCI7XG4gICAgVE1QX0hUVFBfVEFSR0VUID0gXCJodHRwLnRhcmdldFwiO1xuICAgIFRNUF9IVFRQX0hPU1QgPSBcImh0dHAuaG9zdFwiO1xuICAgIFRNUF9IVFRQX1NDSEVNRSA9IFwiaHR0cC5zY2hlbWVcIjtcbiAgICBUTVBfSFRUUF9TVEFUVVNfQ09ERSA9IFwiaHR0cC5zdGF0dXNfY29kZVwiO1xuICAgIFRNUF9IVFRQX0ZMQVZPUiA9IFwiaHR0cC5mbGF2b3JcIjtcbiAgICBUTVBfSFRUUF9VU0VSX0FHRU5UID0gXCJodHRwLnVzZXJfYWdlbnRcIjtcbiAgICBUTVBfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIID0gXCJodHRwLnJlcXVlc3RfY29udGVudF9sZW5ndGhcIjtcbiAgICBUTVBfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRCA9IFwiaHR0cC5yZXF1ZXN0X2NvbnRlbnRfbGVuZ3RoX3VuY29tcHJlc3NlZFwiO1xuICAgIFRNUF9IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIID0gXCJodHRwLnJlc3BvbnNlX2NvbnRlbnRfbGVuZ3RoXCI7XG4gICAgVE1QX0hUVFBfUkVTUE9OU0VfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VEID0gXCJodHRwLnJlc3BvbnNlX2NvbnRlbnRfbGVuZ3RoX3VuY29tcHJlc3NlZFwiO1xuICAgIFRNUF9IVFRQX1NFUlZFUl9OQU1FID0gXCJodHRwLnNlcnZlcl9uYW1lXCI7XG4gICAgVE1QX0hUVFBfUk9VVEUgPSBcImh0dHAucm91dGVcIjtcbiAgICBUTVBfSFRUUF9DTElFTlRfSVAgPSBcImh0dHAuY2xpZW50X2lwXCI7XG4gICAgVE1QX0FXU19EWU5BTU9EQl9UQUJMRV9OQU1FUyA9IFwiYXdzLmR5bmFtb2RiLnRhYmxlX25hbWVzXCI7XG4gICAgVE1QX0FXU19EWU5BTU9EQl9DT05TVU1FRF9DQVBBQ0lUWSA9IFwiYXdzLmR5bmFtb2RiLmNvbnN1bWVkX2NhcGFjaXR5XCI7XG4gICAgVE1QX0FXU19EWU5BTU9EQl9JVEVNX0NPTExFQ1RJT05fTUVUUklDUyA9IFwiYXdzLmR5bmFtb2RiLml0ZW1fY29sbGVjdGlvbl9tZXRyaWNzXCI7XG4gICAgVE1QX0FXU19EWU5BTU9EQl9QUk9WSVNJT05FRF9SRUFEX0NBUEFDSVRZID0gXCJhd3MuZHluYW1vZGIucHJvdmlzaW9uZWRfcmVhZF9jYXBhY2l0eVwiO1xuICAgIFRNUF9BV1NfRFlOQU1PREJfUFJPVklTSU9ORURfV1JJVEVfQ0FQQUNJVFkgPSBcImF3cy5keW5hbW9kYi5wcm92aXNpb25lZF93cml0ZV9jYXBhY2l0eVwiO1xuICAgIFRNUF9BV1NfRFlOQU1PREJfQ09OU0lTVEVOVF9SRUFEID0gXCJhd3MuZHluYW1vZGIuY29uc2lzdGVudF9yZWFkXCI7XG4gICAgVE1QX0FXU19EWU5BTU9EQl9QUk9KRUNUSU9OID0gXCJhd3MuZHluYW1vZGIucHJvamVjdGlvblwiO1xuICAgIFRNUF9BV1NfRFlOQU1PREJfTElNSVQgPSBcImF3cy5keW5hbW9kYi5saW1pdFwiO1xuICAgIFRNUF9BV1NfRFlOQU1PREJfQVRUUklCVVRFU19UT19HRVQgPSBcImF3cy5keW5hbW9kYi5hdHRyaWJ1dGVzX3RvX2dldFwiO1xuICAgIFRNUF9BV1NfRFlOQU1PREJfSU5ERVhfTkFNRSA9IFwiYXdzLmR5bmFtb2RiLmluZGV4X25hbWVcIjtcbiAgICBUTVBfQVdTX0RZTkFNT0RCX1NFTEVDVCA9IFwiYXdzLmR5bmFtb2RiLnNlbGVjdFwiO1xuICAgIFRNUF9BV1NfRFlOQU1PREJfR0xPQkFMX1NFQ09OREFSWV9JTkRFWEVTID0gXCJhd3MuZHluYW1vZGIuZ2xvYmFsX3NlY29uZGFyeV9pbmRleGVzXCI7XG4gICAgVE1QX0FXU19EWU5BTU9EQl9MT0NBTF9TRUNPTkRBUllfSU5ERVhFUyA9IFwiYXdzLmR5bmFtb2RiLmxvY2FsX3NlY29uZGFyeV9pbmRleGVzXCI7XG4gICAgVE1QX0FXU19EWU5BTU9EQl9FWENMVVNJVkVfU1RBUlRfVEFCTEUgPSBcImF3cy5keW5hbW9kYi5leGNsdXNpdmVfc3RhcnRfdGFibGVcIjtcbiAgICBUTVBfQVdTX0RZTkFNT0RCX1RBQkxFX0NPVU5UID0gXCJhd3MuZHluYW1vZGIudGFibGVfY291bnRcIjtcbiAgICBUTVBfQVdTX0RZTkFNT0RCX1NDQU5fRk9SV0FSRCA9IFwiYXdzLmR5bmFtb2RiLnNjYW5fZm9yd2FyZFwiO1xuICAgIFRNUF9BV1NfRFlOQU1PREJfU0VHTUVOVCA9IFwiYXdzLmR5bmFtb2RiLnNlZ21lbnRcIjtcbiAgICBUTVBfQVdTX0RZTkFNT0RCX1RPVEFMX1NFR01FTlRTID0gXCJhd3MuZHluYW1vZGIudG90YWxfc2VnbWVudHNcIjtcbiAgICBUTVBfQVdTX0RZTkFNT0RCX0NPVU5UID0gXCJhd3MuZHluYW1vZGIuY291bnRcIjtcbiAgICBUTVBfQVdTX0RZTkFNT0RCX1NDQU5ORURfQ09VTlQgPSBcImF3cy5keW5hbW9kYi5zY2FubmVkX2NvdW50XCI7XG4gICAgVE1QX0FXU19EWU5BTU9EQl9BVFRSSUJVVEVfREVGSU5JVElPTlMgPSBcImF3cy5keW5hbW9kYi5hdHRyaWJ1dGVfZGVmaW5pdGlvbnNcIjtcbiAgICBUTVBfQVdTX0RZTkFNT0RCX0dMT0JBTF9TRUNPTkRBUllfSU5ERVhfVVBEQVRFUyA9IFwiYXdzLmR5bmFtb2RiLmdsb2JhbF9zZWNvbmRhcnlfaW5kZXhfdXBkYXRlc1wiO1xuICAgIFRNUF9NRVNTQUdJTkdfU1lTVEVNID0gXCJtZXNzYWdpbmcuc3lzdGVtXCI7XG4gICAgVE1QX01FU1NBR0lOR19ERVNUSU5BVElPTiA9IFwibWVzc2FnaW5nLmRlc3RpbmF0aW9uXCI7XG4gICAgVE1QX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EID0gXCJtZXNzYWdpbmcuZGVzdGluYXRpb25fa2luZFwiO1xuICAgIFRNUF9NRVNTQUdJTkdfVEVNUF9ERVNUSU5BVElPTiA9IFwibWVzc2FnaW5nLnRlbXBfZGVzdGluYXRpb25cIjtcbiAgICBUTVBfTUVTU0FHSU5HX1BST1RPQ09MID0gXCJtZXNzYWdpbmcucHJvdG9jb2xcIjtcbiAgICBUTVBfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT04gPSBcIm1lc3NhZ2luZy5wcm90b2NvbF92ZXJzaW9uXCI7XG4gICAgVE1QX01FU1NBR0lOR19VUkwgPSBcIm1lc3NhZ2luZy51cmxcIjtcbiAgICBUTVBfTUVTU0FHSU5HX01FU1NBR0VfSUQgPSBcIm1lc3NhZ2luZy5tZXNzYWdlX2lkXCI7XG4gICAgVE1QX01FU1NBR0lOR19DT05WRVJTQVRJT05fSUQgPSBcIm1lc3NhZ2luZy5jb252ZXJzYXRpb25faWRcIjtcbiAgICBUTVBfTUVTU0FHSU5HX01FU1NBR0VfUEFZTE9BRF9TSVpFX0JZVEVTID0gXCJtZXNzYWdpbmcubWVzc2FnZV9wYXlsb2FkX3NpemVfYnl0ZXNcIjtcbiAgICBUTVBfTUVTU0FHSU5HX01FU1NBR0VfUEFZTE9BRF9DT01QUkVTU0VEX1NJWkVfQllURVMgPSBcIm1lc3NhZ2luZy5tZXNzYWdlX3BheWxvYWRfY29tcHJlc3NlZF9zaXplX2J5dGVzXCI7XG4gICAgVE1QX01FU1NBR0lOR19PUEVSQVRJT04gPSBcIm1lc3NhZ2luZy5vcGVyYXRpb25cIjtcbiAgICBUTVBfTUVTU0FHSU5HX0NPTlNVTUVSX0lEID0gXCJtZXNzYWdpbmcuY29uc3VtZXJfaWRcIjtcbiAgICBUTVBfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZID0gXCJtZXNzYWdpbmcucmFiYml0bXEucm91dGluZ19rZXlcIjtcbiAgICBUTVBfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZID0gXCJtZXNzYWdpbmcua2Fma2EubWVzc2FnZV9rZXlcIjtcbiAgICBUTVBfTUVTU0FHSU5HX0tBRktBX0NPTlNVTUVSX0dST1VQID0gXCJtZXNzYWdpbmcua2Fma2EuY29uc3VtZXJfZ3JvdXBcIjtcbiAgICBUTVBfTUVTU0FHSU5HX0tBRktBX0NMSUVOVF9JRCA9IFwibWVzc2FnaW5nLmthZmthLmNsaWVudF9pZFwiO1xuICAgIFRNUF9NRVNTQUdJTkdfS0FGS0FfUEFSVElUSU9OID0gXCJtZXNzYWdpbmcua2Fma2EucGFydGl0aW9uXCI7XG4gICAgVE1QX01FU1NBR0lOR19LQUZLQV9UT01CU1RPTkUgPSBcIm1lc3NhZ2luZy5rYWZrYS50b21ic3RvbmVcIjtcbiAgICBUTVBfUlBDX1NZU1RFTSA9IFwicnBjLnN5c3RlbVwiO1xuICAgIFRNUF9SUENfU0VSVklDRSA9IFwicnBjLnNlcnZpY2VcIjtcbiAgICBUTVBfUlBDX01FVEhPRCA9IFwicnBjLm1ldGhvZFwiO1xuICAgIFRNUF9SUENfR1JQQ19TVEFUVVNfQ09ERSA9IFwicnBjLmdycGMuc3RhdHVzX2NvZGVcIjtcbiAgICBUTVBfUlBDX0pTT05SUENfVkVSU0lPTiA9IFwicnBjLmpzb25ycGMudmVyc2lvblwiO1xuICAgIFRNUF9SUENfSlNPTlJQQ19SRVFVRVNUX0lEID0gXCJycGMuanNvbnJwYy5yZXF1ZXN0X2lkXCI7XG4gICAgVE1QX1JQQ19KU09OUlBDX0VSUk9SX0NPREUgPSBcInJwYy5qc29ucnBjLmVycm9yX2NvZGVcIjtcbiAgICBUTVBfUlBDX0pTT05SUENfRVJST1JfTUVTU0FHRSA9IFwicnBjLmpzb25ycGMuZXJyb3JfbWVzc2FnZVwiO1xuICAgIFRNUF9NRVNTQUdFX1RZUEUgPSBcIm1lc3NhZ2UudHlwZVwiO1xuICAgIFRNUF9NRVNTQUdFX0lEID0gXCJtZXNzYWdlLmlkXCI7XG4gICAgVE1QX01FU1NBR0VfQ09NUFJFU1NFRF9TSVpFID0gXCJtZXNzYWdlLmNvbXByZXNzZWRfc2l6ZVwiO1xuICAgIFRNUF9NRVNTQUdFX1VOQ09NUFJFU1NFRF9TSVpFID0gXCJtZXNzYWdlLnVuY29tcHJlc3NlZF9zaXplXCI7XG4gICAgU0VNQVRUUlNfQVdTX0xBTUJEQV9JTlZPS0VEX0FSTiA9IFRNUF9BV1NfTEFNQkRBX0lOVk9LRURfQVJOO1xuICAgIFNFTUFUVFJTX0RCX1NZU1RFTSA9IFRNUF9EQl9TWVNURU07XG4gICAgU0VNQVRUUlNfREJfQ09OTkVDVElPTl9TVFJJTkcgPSBUTVBfREJfQ09OTkVDVElPTl9TVFJJTkc7XG4gICAgU0VNQVRUUlNfREJfVVNFUiA9IFRNUF9EQl9VU0VSO1xuICAgIFNFTUFUVFJTX0RCX0pEQkNfRFJJVkVSX0NMQVNTTkFNRSA9IFRNUF9EQl9KREJDX0RSSVZFUl9DTEFTU05BTUU7XG4gICAgU0VNQVRUUlNfREJfTkFNRSA9IFRNUF9EQl9OQU1FO1xuICAgIFNFTUFUVFJTX0RCX1NUQVRFTUVOVCA9IFRNUF9EQl9TVEFURU1FTlQ7XG4gICAgU0VNQVRUUlNfREJfT1BFUkFUSU9OID0gVE1QX0RCX09QRVJBVElPTjtcbiAgICBTRU1BVFRSU19EQl9NU1NRTF9JTlNUQU5DRV9OQU1FID0gVE1QX0RCX01TU1FMX0lOU1RBTkNFX05BTUU7XG4gICAgU0VNQVRUUlNfREJfQ0FTU0FORFJBX0tFWVNQQUNFID0gVE1QX0RCX0NBU1NBTkRSQV9LRVlTUEFDRTtcbiAgICBTRU1BVFRSU19EQl9DQVNTQU5EUkFfUEFHRV9TSVpFID0gVE1QX0RCX0NBU1NBTkRSQV9QQUdFX1NJWkU7XG4gICAgU0VNQVRUUlNfREJfQ0FTU0FORFJBX0NPTlNJU1RFTkNZX0xFVkVMID0gVE1QX0RCX0NBU1NBTkRSQV9DT05TSVNURU5DWV9MRVZFTDtcbiAgICBTRU1BVFRSU19EQl9DQVNTQU5EUkFfVEFCTEUgPSBUTVBfREJfQ0FTU0FORFJBX1RBQkxFO1xuICAgIFNFTUFUVFJTX0RCX0NBU1NBTkRSQV9JREVNUE9URU5DRSA9IFRNUF9EQl9DQVNTQU5EUkFfSURFTVBPVEVOQ0U7XG4gICAgU0VNQVRUUlNfREJfQ0FTU0FORFJBX1NQRUNVTEFUSVZFX0VYRUNVVElPTl9DT1VOVCA9IFRNUF9EQl9DQVNTQU5EUkFfU1BFQ1VMQVRJVkVfRVhFQ1VUSU9OX0NPVU5UO1xuICAgIFNFTUFUVFJTX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9JRCA9IFRNUF9EQl9DQVNTQU5EUkFfQ09PUkRJTkFUT1JfSUQ7XG4gICAgU0VNQVRUUlNfREJfQ0FTU0FORFJBX0NPT1JESU5BVE9SX0RDID0gVE1QX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9EQztcbiAgICBTRU1BVFRSU19EQl9IQkFTRV9OQU1FU1BBQ0UgPSBUTVBfREJfSEJBU0VfTkFNRVNQQUNFO1xuICAgIFNFTUFUVFJTX0RCX1JFRElTX0RBVEFCQVNFX0lOREVYID0gVE1QX0RCX1JFRElTX0RBVEFCQVNFX0lOREVYO1xuICAgIFNFTUFUVFJTX0RCX01PTkdPREJfQ09MTEVDVElPTiA9IFRNUF9EQl9NT05HT0RCX0NPTExFQ1RJT047XG4gICAgU0VNQVRUUlNfREJfU1FMX1RBQkxFID0gVE1QX0RCX1NRTF9UQUJMRTtcbiAgICBTRU1BVFRSU19FWENFUFRJT05fVFlQRSA9IFRNUF9FWENFUFRJT05fVFlQRTtcbiAgICBTRU1BVFRSU19FWENFUFRJT05fTUVTU0FHRSA9IFRNUF9FWENFUFRJT05fTUVTU0FHRTtcbiAgICBTRU1BVFRSU19FWENFUFRJT05fU1RBQ0tUUkFDRSA9IFRNUF9FWENFUFRJT05fU1RBQ0tUUkFDRTtcbiAgICBTRU1BVFRSU19FWENFUFRJT05fRVNDQVBFRCA9IFRNUF9FWENFUFRJT05fRVNDQVBFRDtcbiAgICBTRU1BVFRSU19GQUFTX1RSSUdHRVIgPSBUTVBfRkFBU19UUklHR0VSO1xuICAgIFNFTUFUVFJTX0ZBQVNfRVhFQ1VUSU9OID0gVE1QX0ZBQVNfRVhFQ1VUSU9OO1xuICAgIFNFTUFUVFJTX0ZBQVNfRE9DVU1FTlRfQ09MTEVDVElPTiA9IFRNUF9GQUFTX0RPQ1VNRU5UX0NPTExFQ1RJT047XG4gICAgU0VNQVRUUlNfRkFBU19ET0NVTUVOVF9PUEVSQVRJT04gPSBUTVBfRkFBU19ET0NVTUVOVF9PUEVSQVRJT047XG4gICAgU0VNQVRUUlNfRkFBU19ET0NVTUVOVF9USU1FID0gVE1QX0ZBQVNfRE9DVU1FTlRfVElNRTtcbiAgICBTRU1BVFRSU19GQUFTX0RPQ1VNRU5UX05BTUUgPSBUTVBfRkFBU19ET0NVTUVOVF9OQU1FO1xuICAgIFNFTUFUVFJTX0ZBQVNfVElNRSA9IFRNUF9GQUFTX1RJTUU7XG4gICAgU0VNQVRUUlNfRkFBU19DUk9OID0gVE1QX0ZBQVNfQ1JPTjtcbiAgICBTRU1BVFRSU19GQUFTX0NPTERTVEFSVCA9IFRNUF9GQUFTX0NPTERTVEFSVDtcbiAgICBTRU1BVFRSU19GQUFTX0lOVk9LRURfTkFNRSA9IFRNUF9GQUFTX0lOVk9LRURfTkFNRTtcbiAgICBTRU1BVFRSU19GQUFTX0lOVk9LRURfUFJPVklERVIgPSBUTVBfRkFBU19JTlZPS0VEX1BST1ZJREVSO1xuICAgIFNFTUFUVFJTX0ZBQVNfSU5WT0tFRF9SRUdJT04gPSBUTVBfRkFBU19JTlZPS0VEX1JFR0lPTjtcbiAgICBTRU1BVFRSU19ORVRfVFJBTlNQT1JUID0gVE1QX05FVF9UUkFOU1BPUlQ7XG4gICAgU0VNQVRUUlNfTkVUX1BFRVJfSVAgPSBUTVBfTkVUX1BFRVJfSVA7XG4gICAgU0VNQVRUUlNfTkVUX1BFRVJfUE9SVCA9IFRNUF9ORVRfUEVFUl9QT1JUO1xuICAgIFNFTUFUVFJTX05FVF9QRUVSX05BTUUgPSBUTVBfTkVUX1BFRVJfTkFNRTtcbiAgICBTRU1BVFRSU19ORVRfSE9TVF9JUCA9IFRNUF9ORVRfSE9TVF9JUDtcbiAgICBTRU1BVFRSU19ORVRfSE9TVF9QT1JUID0gVE1QX05FVF9IT1NUX1BPUlQ7XG4gICAgU0VNQVRUUlNfTkVUX0hPU1RfTkFNRSA9IFRNUF9ORVRfSE9TVF9OQU1FO1xuICAgIFNFTUFUVFJTX05FVF9IT1NUX0NPTk5FQ1RJT05fVFlQRSA9IFRNUF9ORVRfSE9TVF9DT05ORUNUSU9OX1RZUEU7XG4gICAgU0VNQVRUUlNfTkVUX0hPU1RfQ09OTkVDVElPTl9TVUJUWVBFID0gVE1QX05FVF9IT1NUX0NPTk5FQ1RJT05fU1VCVFlQRTtcbiAgICBTRU1BVFRSU19ORVRfSE9TVF9DQVJSSUVSX05BTUUgPSBUTVBfTkVUX0hPU1RfQ0FSUklFUl9OQU1FO1xuICAgIFNFTUFUVFJTX05FVF9IT1NUX0NBUlJJRVJfTUNDID0gVE1QX05FVF9IT1NUX0NBUlJJRVJfTUNDO1xuICAgIFNFTUFUVFJTX05FVF9IT1NUX0NBUlJJRVJfTU5DID0gVE1QX05FVF9IT1NUX0NBUlJJRVJfTU5DO1xuICAgIFNFTUFUVFJTX05FVF9IT1NUX0NBUlJJRVJfSUNDID0gVE1QX05FVF9IT1NUX0NBUlJJRVJfSUNDO1xuICAgIFNFTUFUVFJTX1BFRVJfU0VSVklDRSA9IFRNUF9QRUVSX1NFUlZJQ0U7XG4gICAgU0VNQVRUUlNfRU5EVVNFUl9JRCA9IFRNUF9FTkRVU0VSX0lEO1xuICAgIFNFTUFUVFJTX0VORFVTRVJfUk9MRSA9IFRNUF9FTkRVU0VSX1JPTEU7XG4gICAgU0VNQVRUUlNfRU5EVVNFUl9TQ09QRSA9IFRNUF9FTkRVU0VSX1NDT1BFO1xuICAgIFNFTUFUVFJTX1RIUkVBRF9JRCA9IFRNUF9USFJFQURfSUQ7XG4gICAgU0VNQVRUUlNfVEhSRUFEX05BTUUgPSBUTVBfVEhSRUFEX05BTUU7XG4gICAgU0VNQVRUUlNfQ09ERV9GVU5DVElPTiA9IFRNUF9DT0RFX0ZVTkNUSU9OO1xuICAgIFNFTUFUVFJTX0NPREVfTkFNRVNQQUNFID0gVE1QX0NPREVfTkFNRVNQQUNFO1xuICAgIFNFTUFUVFJTX0NPREVfRklMRVBBVEggPSBUTVBfQ09ERV9GSUxFUEFUSDtcbiAgICBTRU1BVFRSU19DT0RFX0xJTkVOTyA9IFRNUF9DT0RFX0xJTkVOTztcbiAgICBTRU1BVFRSU19IVFRQX01FVEhPRCA9IFRNUF9IVFRQX01FVEhPRDtcbiAgICBTRU1BVFRSU19IVFRQX1VSTCA9IFRNUF9IVFRQX1VSTDtcbiAgICBTRU1BVFRSU19IVFRQX1RBUkdFVCA9IFRNUF9IVFRQX1RBUkdFVDtcbiAgICBTRU1BVFRSU19IVFRQX0hPU1QgPSBUTVBfSFRUUF9IT1NUO1xuICAgIFNFTUFUVFJTX0hUVFBfU0NIRU1FID0gVE1QX0hUVFBfU0NIRU1FO1xuICAgIFNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREUgPSBUTVBfSFRUUF9TVEFUVVNfQ09ERTtcbiAgICBTRU1BVFRSU19IVFRQX0ZMQVZPUiA9IFRNUF9IVFRQX0ZMQVZPUjtcbiAgICBTRU1BVFRSU19IVFRQX1VTRVJfQUdFTlQgPSBUTVBfSFRUUF9VU0VSX0FHRU5UO1xuICAgIFNFTUFUVFJTX0hUVFBfUkVRVUVTVF9DT05URU5UX0xFTkdUSCA9IFRNUF9IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEg7XG4gICAgU0VNQVRUUlNfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRCA9IFRNUF9IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VEO1xuICAgIFNFTUFUVFJTX0hUVFBfUkVTUE9OU0VfQ09OVEVOVF9MRU5HVEggPSBUTVBfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSDtcbiAgICBTRU1BVFRSU19IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRCA9IFRNUF9IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRDtcbiAgICBTRU1BVFRSU19IVFRQX1NFUlZFUl9OQU1FID0gVE1QX0hUVFBfU0VSVkVSX05BTUU7XG4gICAgU0VNQVRUUlNfSFRUUF9ST1VURSA9IFRNUF9IVFRQX1JPVVRFO1xuICAgIFNFTUFUVFJTX0hUVFBfQ0xJRU5UX0lQID0gVE1QX0hUVFBfQ0xJRU5UX0lQO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9UQUJMRV9OQU1FUyA9IFRNUF9BV1NfRFlOQU1PREJfVEFCTEVfTkFNRVM7XG4gICAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0NPTlNVTUVEX0NBUEFDSVRZID0gVE1QX0FXU19EWU5BTU9EQl9DT05TVU1FRF9DQVBBQ0lUWTtcbiAgICBTRU1BVFRSU19BV1NfRFlOQU1PREJfSVRFTV9DT0xMRUNUSU9OX01FVFJJQ1MgPSBUTVBfQVdTX0RZTkFNT0RCX0lURU1fQ09MTEVDVElPTl9NRVRSSUNTO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9QUk9WSVNJT05FRF9SRUFEX0NBUEFDSVRZID0gVE1QX0FXU19EWU5BTU9EQl9QUk9WSVNJT05FRF9SRUFEX0NBUEFDSVRZO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9QUk9WSVNJT05FRF9XUklURV9DQVBBQ0lUWSA9IFRNUF9BV1NfRFlOQU1PREJfUFJPVklTSU9ORURfV1JJVEVfQ0FQQUNJVFk7XG4gICAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0NPTlNJU1RFTlRfUkVBRCA9IFRNUF9BV1NfRFlOQU1PREJfQ09OU0lTVEVOVF9SRUFEO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9QUk9KRUNUSU9OID0gVE1QX0FXU19EWU5BTU9EQl9QUk9KRUNUSU9OO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9MSU1JVCA9IFRNUF9BV1NfRFlOQU1PREJfTElNSVQ7XG4gICAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0FUVFJJQlVURVNfVE9fR0VUID0gVE1QX0FXU19EWU5BTU9EQl9BVFRSSUJVVEVTX1RPX0dFVDtcbiAgICBTRU1BVFRSU19BV1NfRFlOQU1PREJfSU5ERVhfTkFNRSA9IFRNUF9BV1NfRFlOQU1PREJfSU5ERVhfTkFNRTtcbiAgICBTRU1BVFRSU19BV1NfRFlOQU1PREJfU0VMRUNUID0gVE1QX0FXU19EWU5BTU9EQl9TRUxFQ1Q7XG4gICAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0dMT0JBTF9TRUNPTkRBUllfSU5ERVhFUyA9IFRNUF9BV1NfRFlOQU1PREJfR0xPQkFMX1NFQ09OREFSWV9JTkRFWEVTO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9MT0NBTF9TRUNPTkRBUllfSU5ERVhFUyA9IFRNUF9BV1NfRFlOQU1PREJfTE9DQUxfU0VDT05EQVJZX0lOREVYRVM7XG4gICAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0VYQ0xVU0lWRV9TVEFSVF9UQUJMRSA9IFRNUF9BV1NfRFlOQU1PREJfRVhDTFVTSVZFX1NUQVJUX1RBQkxFO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9UQUJMRV9DT1VOVCA9IFRNUF9BV1NfRFlOQU1PREJfVEFCTEVfQ09VTlQ7XG4gICAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1NDQU5fRk9SV0FSRCA9IFRNUF9BV1NfRFlOQU1PREJfU0NBTl9GT1JXQVJEO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9TRUdNRU5UID0gVE1QX0FXU19EWU5BTU9EQl9TRUdNRU5UO1xuICAgIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9UT1RBTF9TRUdNRU5UUyA9IFRNUF9BV1NfRFlOQU1PREJfVE9UQUxfU0VHTUVOVFM7XG4gICAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0NPVU5UID0gVE1QX0FXU19EWU5BTU9EQl9DT1VOVDtcbiAgICBTRU1BVFRSU19BV1NfRFlOQU1PREJfU0NBTk5FRF9DT1VOVCA9IFRNUF9BV1NfRFlOQU1PREJfU0NBTk5FRF9DT1VOVDtcbiAgICBTRU1BVFRSU19BV1NfRFlOQU1PREJfQVRUUklCVVRFX0RFRklOSVRJT05TID0gVE1QX0FXU19EWU5BTU9EQl9BVFRSSUJVVEVfREVGSU5JVElPTlM7XG4gICAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0dMT0JBTF9TRUNPTkRBUllfSU5ERVhfVVBEQVRFUyA9IFRNUF9BV1NfRFlOQU1PREJfR0xPQkFMX1NFQ09OREFSWV9JTkRFWF9VUERBVEVTO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19TWVNURU0gPSBUTVBfTUVTU0FHSU5HX1NZU1RFTTtcbiAgICBTRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT04gPSBUTVBfTUVTU0FHSU5HX0RFU1RJTkFUSU9OO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EID0gVE1QX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19URU1QX0RFU1RJTkFUSU9OID0gVE1QX01FU1NBR0lOR19URU1QX0RFU1RJTkFUSU9OO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19QUk9UT0NPTCA9IFRNUF9NRVNTQUdJTkdfUFJPVE9DT0w7XG4gICAgU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT04gPSBUTVBfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT047XG4gICAgU0VNQVRUUlNfTUVTU0FHSU5HX1VSTCA9IFRNUF9NRVNTQUdJTkdfVVJMO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19NRVNTQUdFX0lEID0gVE1QX01FU1NBR0lOR19NRVNTQUdFX0lEO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19DT05WRVJTQVRJT05fSUQgPSBUTVBfTUVTU0FHSU5HX0NPTlZFUlNBVElPTl9JRDtcbiAgICBTRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX1NJWkVfQllURVMgPSBUTVBfTUVTU0FHSU5HX01FU1NBR0VfUEFZTE9BRF9TSVpFX0JZVEVTO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19NRVNTQUdFX1BBWUxPQURfQ09NUFJFU1NFRF9TSVpFX0JZVEVTID0gVE1QX01FU1NBR0lOR19NRVNTQUdFX1BBWUxPQURfQ09NUFJFU1NFRF9TSVpFX0JZVEVTO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19PUEVSQVRJT04gPSBUTVBfTUVTU0FHSU5HX09QRVJBVElPTjtcbiAgICBTRU1BVFRSU19NRVNTQUdJTkdfQ09OU1VNRVJfSUQgPSBUTVBfTUVTU0FHSU5HX0NPTlNVTUVSX0lEO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19SQUJCSVRNUV9ST1VUSU5HX0tFWSA9IFRNUF9NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVk7XG4gICAgU0VNQVRUUlNfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZID0gVE1QX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWTtcbiAgICBTRU1BVFRSU19NRVNTQUdJTkdfS0FGS0FfQ09OU1VNRVJfR1JPVVAgPSBUTVBfTUVTU0FHSU5HX0tBRktBX0NPTlNVTUVSX0dST1VQO1xuICAgIFNFTUFUVFJTX01FU1NBR0lOR19LQUZLQV9DTElFTlRfSUQgPSBUTVBfTUVTU0FHSU5HX0tBRktBX0NMSUVOVF9JRDtcbiAgICBTRU1BVFRSU19NRVNTQUdJTkdfS0FGS0FfUEFSVElUSU9OID0gVE1QX01FU1NBR0lOR19LQUZLQV9QQVJUSVRJT047XG4gICAgU0VNQVRUUlNfTUVTU0FHSU5HX0tBRktBX1RPTUJTVE9ORSA9IFRNUF9NRVNTQUdJTkdfS0FGS0FfVE9NQlNUT05FO1xuICAgIFNFTUFUVFJTX1JQQ19TWVNURU0gPSBUTVBfUlBDX1NZU1RFTTtcbiAgICBTRU1BVFRSU19SUENfU0VSVklDRSA9IFRNUF9SUENfU0VSVklDRTtcbiAgICBTRU1BVFRSU19SUENfTUVUSE9EID0gVE1QX1JQQ19NRVRIT0Q7XG4gICAgU0VNQVRUUlNfUlBDX0dSUENfU1RBVFVTX0NPREUgPSBUTVBfUlBDX0dSUENfU1RBVFVTX0NPREU7XG4gICAgU0VNQVRUUlNfUlBDX0pTT05SUENfVkVSU0lPTiA9IFRNUF9SUENfSlNPTlJQQ19WRVJTSU9OO1xuICAgIFNFTUFUVFJTX1JQQ19KU09OUlBDX1JFUVVFU1RfSUQgPSBUTVBfUlBDX0pTT05SUENfUkVRVUVTVF9JRDtcbiAgICBTRU1BVFRSU19SUENfSlNPTlJQQ19FUlJPUl9DT0RFID0gVE1QX1JQQ19KU09OUlBDX0VSUk9SX0NPREU7XG4gICAgU0VNQVRUUlNfUlBDX0pTT05SUENfRVJST1JfTUVTU0FHRSA9IFRNUF9SUENfSlNPTlJQQ19FUlJPUl9NRVNTQUdFO1xuICAgIFNFTUFUVFJTX01FU1NBR0VfVFlQRSA9IFRNUF9NRVNTQUdFX1RZUEU7XG4gICAgU0VNQVRUUlNfTUVTU0FHRV9JRCA9IFRNUF9NRVNTQUdFX0lEO1xuICAgIFNFTUFUVFJTX01FU1NBR0VfQ09NUFJFU1NFRF9TSVpFID0gVE1QX01FU1NBR0VfQ09NUFJFU1NFRF9TSVpFO1xuICAgIFNFTUFUVFJTX01FU1NBR0VfVU5DT01QUkVTU0VEX1NJWkUgPSBUTVBfTUVTU0FHRV9VTkNPTVBSRVNTRURfU0laRTtcbiAgICBTZW1hbnRpY0F0dHJpYnV0ZXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RNYXAoW1xuICAgICAgVE1QX0FXU19MQU1CREFfSU5WT0tFRF9BUk4sXG4gICAgICBUTVBfREJfU1lTVEVNLFxuICAgICAgVE1QX0RCX0NPTk5FQ1RJT05fU1RSSU5HLFxuICAgICAgVE1QX0RCX1VTRVIsXG4gICAgICBUTVBfREJfSkRCQ19EUklWRVJfQ0xBU1NOQU1FLFxuICAgICAgVE1QX0RCX05BTUUsXG4gICAgICBUTVBfREJfU1RBVEVNRU5ULFxuICAgICAgVE1QX0RCX09QRVJBVElPTixcbiAgICAgIFRNUF9EQl9NU1NRTF9JTlNUQU5DRV9OQU1FLFxuICAgICAgVE1QX0RCX0NBU1NBTkRSQV9LRVlTUEFDRSxcbiAgICAgIFRNUF9EQl9DQVNTQU5EUkFfUEFHRV9TSVpFLFxuICAgICAgVE1QX0RCX0NBU1NBTkRSQV9DT05TSVNURU5DWV9MRVZFTCxcbiAgICAgIFRNUF9EQl9DQVNTQU5EUkFfVEFCTEUsXG4gICAgICBUTVBfREJfQ0FTU0FORFJBX0lERU1QT1RFTkNFLFxuICAgICAgVE1QX0RCX0NBU1NBTkRSQV9TUEVDVUxBVElWRV9FWEVDVVRJT05fQ09VTlQsXG4gICAgICBUTVBfREJfQ0FTU0FORFJBX0NPT1JESU5BVE9SX0lELFxuICAgICAgVE1QX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9EQyxcbiAgICAgIFRNUF9EQl9IQkFTRV9OQU1FU1BBQ0UsXG4gICAgICBUTVBfREJfUkVESVNfREFUQUJBU0VfSU5ERVgsXG4gICAgICBUTVBfREJfTU9OR09EQl9DT0xMRUNUSU9OLFxuICAgICAgVE1QX0RCX1NRTF9UQUJMRSxcbiAgICAgIFRNUF9FWENFUFRJT05fVFlQRSxcbiAgICAgIFRNUF9FWENFUFRJT05fTUVTU0FHRSxcbiAgICAgIFRNUF9FWENFUFRJT05fU1RBQ0tUUkFDRSxcbiAgICAgIFRNUF9FWENFUFRJT05fRVNDQVBFRCxcbiAgICAgIFRNUF9GQUFTX1RSSUdHRVIsXG4gICAgICBUTVBfRkFBU19FWEVDVVRJT04sXG4gICAgICBUTVBfRkFBU19ET0NVTUVOVF9DT0xMRUNUSU9OLFxuICAgICAgVE1QX0ZBQVNfRE9DVU1FTlRfT1BFUkFUSU9OLFxuICAgICAgVE1QX0ZBQVNfRE9DVU1FTlRfVElNRSxcbiAgICAgIFRNUF9GQUFTX0RPQ1VNRU5UX05BTUUsXG4gICAgICBUTVBfRkFBU19USU1FLFxuICAgICAgVE1QX0ZBQVNfQ1JPTixcbiAgICAgIFRNUF9GQUFTX0NPTERTVEFSVCxcbiAgICAgIFRNUF9GQUFTX0lOVk9LRURfTkFNRSxcbiAgICAgIFRNUF9GQUFTX0lOVk9LRURfUFJPVklERVIsXG4gICAgICBUTVBfRkFBU19JTlZPS0VEX1JFR0lPTixcbiAgICAgIFRNUF9ORVRfVFJBTlNQT1JULFxuICAgICAgVE1QX05FVF9QRUVSX0lQLFxuICAgICAgVE1QX05FVF9QRUVSX1BPUlQsXG4gICAgICBUTVBfTkVUX1BFRVJfTkFNRSxcbiAgICAgIFRNUF9ORVRfSE9TVF9JUCxcbiAgICAgIFRNUF9ORVRfSE9TVF9QT1JULFxuICAgICAgVE1QX05FVF9IT1NUX05BTUUsXG4gICAgICBUTVBfTkVUX0hPU1RfQ09OTkVDVElPTl9UWVBFLFxuICAgICAgVE1QX05FVF9IT1NUX0NPTk5FQ1RJT05fU1VCVFlQRSxcbiAgICAgIFRNUF9ORVRfSE9TVF9DQVJSSUVSX05BTUUsXG4gICAgICBUTVBfTkVUX0hPU1RfQ0FSUklFUl9NQ0MsXG4gICAgICBUTVBfTkVUX0hPU1RfQ0FSUklFUl9NTkMsXG4gICAgICBUTVBfTkVUX0hPU1RfQ0FSUklFUl9JQ0MsXG4gICAgICBUTVBfUEVFUl9TRVJWSUNFLFxuICAgICAgVE1QX0VORFVTRVJfSUQsXG4gICAgICBUTVBfRU5EVVNFUl9ST0xFLFxuICAgICAgVE1QX0VORFVTRVJfU0NPUEUsXG4gICAgICBUTVBfVEhSRUFEX0lELFxuICAgICAgVE1QX1RIUkVBRF9OQU1FLFxuICAgICAgVE1QX0NPREVfRlVOQ1RJT04sXG4gICAgICBUTVBfQ09ERV9OQU1FU1BBQ0UsXG4gICAgICBUTVBfQ09ERV9GSUxFUEFUSCxcbiAgICAgIFRNUF9DT0RFX0xJTkVOTyxcbiAgICAgIFRNUF9IVFRQX01FVEhPRCxcbiAgICAgIFRNUF9IVFRQX1VSTCxcbiAgICAgIFRNUF9IVFRQX1RBUkdFVCxcbiAgICAgIFRNUF9IVFRQX0hPU1QsXG4gICAgICBUTVBfSFRUUF9TQ0hFTUUsXG4gICAgICBUTVBfSFRUUF9TVEFUVVNfQ09ERSxcbiAgICAgIFRNUF9IVFRQX0ZMQVZPUixcbiAgICAgIFRNUF9IVFRQX1VTRVJfQUdFTlQsXG4gICAgICBUTVBfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RILFxuICAgICAgVE1QX0hUVFBfUkVRVUVTVF9DT05URU5UX0xFTkdUSF9VTkNPTVBSRVNTRUQsXG4gICAgICBUTVBfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSCxcbiAgICAgIFRNUF9IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRCxcbiAgICAgIFRNUF9IVFRQX1NFUlZFUl9OQU1FLFxuICAgICAgVE1QX0hUVFBfUk9VVEUsXG4gICAgICBUTVBfSFRUUF9DTElFTlRfSVAsXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX1RBQkxFX05BTUVTLFxuICAgICAgVE1QX0FXU19EWU5BTU9EQl9DT05TVU1FRF9DQVBBQ0lUWSxcbiAgICAgIFRNUF9BV1NfRFlOQU1PREJfSVRFTV9DT0xMRUNUSU9OX01FVFJJQ1MsXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX1BST1ZJU0lPTkVEX1JFQURfQ0FQQUNJVFksXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX1BST1ZJU0lPTkVEX1dSSVRFX0NBUEFDSVRZLFxuICAgICAgVE1QX0FXU19EWU5BTU9EQl9DT05TSVNURU5UX1JFQUQsXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX1BST0pFQ1RJT04sXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX0xJTUlULFxuICAgICAgVE1QX0FXU19EWU5BTU9EQl9BVFRSSUJVVEVTX1RPX0dFVCxcbiAgICAgIFRNUF9BV1NfRFlOQU1PREJfSU5ERVhfTkFNRSxcbiAgICAgIFRNUF9BV1NfRFlOQU1PREJfU0VMRUNULFxuICAgICAgVE1QX0FXU19EWU5BTU9EQl9HTE9CQUxfU0VDT05EQVJZX0lOREVYRVMsXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX0xPQ0FMX1NFQ09OREFSWV9JTkRFWEVTLFxuICAgICAgVE1QX0FXU19EWU5BTU9EQl9FWENMVVNJVkVfU1RBUlRfVEFCTEUsXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX1RBQkxFX0NPVU5ULFxuICAgICAgVE1QX0FXU19EWU5BTU9EQl9TQ0FOX0ZPUldBUkQsXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX1NFR01FTlQsXG4gICAgICBUTVBfQVdTX0RZTkFNT0RCX1RPVEFMX1NFR01FTlRTLFxuICAgICAgVE1QX0FXU19EWU5BTU9EQl9DT1VOVCxcbiAgICAgIFRNUF9BV1NfRFlOQU1PREJfU0NBTk5FRF9DT1VOVCxcbiAgICAgIFRNUF9BV1NfRFlOQU1PREJfQVRUUklCVVRFX0RFRklOSVRJT05TLFxuICAgICAgVE1QX0FXU19EWU5BTU9EQl9HTE9CQUxfU0VDT05EQVJZX0lOREVYX1VQREFURVMsXG4gICAgICBUTVBfTUVTU0FHSU5HX1NZU1RFTSxcbiAgICAgIFRNUF9NRVNTQUdJTkdfREVTVElOQVRJT04sXG4gICAgICBUTVBfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkQsXG4gICAgICBUTVBfTUVTU0FHSU5HX1RFTVBfREVTVElOQVRJT04sXG4gICAgICBUTVBfTUVTU0FHSU5HX1BST1RPQ09MLFxuICAgICAgVE1QX01FU1NBR0lOR19QUk9UT0NPTF9WRVJTSU9OLFxuICAgICAgVE1QX01FU1NBR0lOR19VUkwsXG4gICAgICBUTVBfTUVTU0FHSU5HX01FU1NBR0VfSUQsXG4gICAgICBUTVBfTUVTU0FHSU5HX0NPTlZFUlNBVElPTl9JRCxcbiAgICAgIFRNUF9NRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX1NJWkVfQllURVMsXG4gICAgICBUTVBfTUVTU0FHSU5HX01FU1NBR0VfUEFZTE9BRF9DT01QUkVTU0VEX1NJWkVfQllURVMsXG4gICAgICBUTVBfTUVTU0FHSU5HX09QRVJBVElPTixcbiAgICAgIFRNUF9NRVNTQUdJTkdfQ09OU1VNRVJfSUQsXG4gICAgICBUTVBfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZLFxuICAgICAgVE1QX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWSxcbiAgICAgIFRNUF9NRVNTQUdJTkdfS0FGS0FfQ09OU1VNRVJfR1JPVVAsXG4gICAgICBUTVBfTUVTU0FHSU5HX0tBRktBX0NMSUVOVF9JRCxcbiAgICAgIFRNUF9NRVNTQUdJTkdfS0FGS0FfUEFSVElUSU9OLFxuICAgICAgVE1QX01FU1NBR0lOR19LQUZLQV9UT01CU1RPTkUsXG4gICAgICBUTVBfUlBDX1NZU1RFTSxcbiAgICAgIFRNUF9SUENfU0VSVklDRSxcbiAgICAgIFRNUF9SUENfTUVUSE9ELFxuICAgICAgVE1QX1JQQ19HUlBDX1NUQVRVU19DT0RFLFxuICAgICAgVE1QX1JQQ19KU09OUlBDX1ZFUlNJT04sXG4gICAgICBUTVBfUlBDX0pTT05SUENfUkVRVUVTVF9JRCxcbiAgICAgIFRNUF9SUENfSlNPTlJQQ19FUlJPUl9DT0RFLFxuICAgICAgVE1QX1JQQ19KU09OUlBDX0VSUk9SX01FU1NBR0UsXG4gICAgICBUTVBfTUVTU0FHRV9UWVBFLFxuICAgICAgVE1QX01FU1NBR0VfSUQsXG4gICAgICBUTVBfTUVTU0FHRV9DT01QUkVTU0VEX1NJWkUsXG4gICAgICBUTVBfTUVTU0FHRV9VTkNPTVBSRVNTRURfU0laRVxuICAgIF0pO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19PVEhFUl9TUUwgPSBcIm90aGVyX3NxbFwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19NU1NRTCA9IFwibXNzcWxcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfTVlTUUwgPSBcIm15c3FsXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX09SQUNMRSA9IFwib3JhY2xlXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0RCMiA9IFwiZGIyXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX1BPU1RHUkVTUUwgPSBcInBvc3RncmVzcWxcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfUkVEU0hJRlQgPSBcInJlZHNoaWZ0XCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0hJVkUgPSBcImhpdmVcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfQ0xPVURTQ0FQRSA9IFwiY2xvdWRzY2FwZVwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19IU1FMREIgPSBcImhzcWxkYlwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19QUk9HUkVTUyA9IFwicHJvZ3Jlc3NcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfTUFYREIgPSBcIm1heGRiXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0hBTkFEQiA9IFwiaGFuYWRiXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0lOR1JFUyA9IFwiaW5ncmVzXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0ZJUlNUU1FMID0gXCJmaXJzdHNxbFwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19FREIgPSBcImVkYlwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19DQUNIRSA9IFwiY2FjaGVcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfQURBQkFTID0gXCJhZGFiYXNcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfRklSRUJJUkQgPSBcImZpcmViaXJkXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0RFUkJZID0gXCJkZXJieVwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19GSUxFTUFLRVIgPSBcImZpbGVtYWtlclwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19JTkZPUk1JWCA9IFwiaW5mb3JtaXhcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfSU5TVEFOVERCID0gXCJpbnN0YW50ZGJcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfSU5URVJCQVNFID0gXCJpbnRlcmJhc2VcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfTUFSSUFEQiA9IFwibWFyaWFkYlwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19ORVRFWlpBID0gXCJuZXRlenphXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX1BFUlZBU0lWRSA9IFwicGVydmFzaXZlXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX1BPSU5UQkFTRSA9IFwicG9pbnRiYXNlXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX1NRTElURSA9IFwic3FsaXRlXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX1NZQkFTRSA9IFwic3liYXNlXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX1RFUkFEQVRBID0gXCJ0ZXJhZGF0YVwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19WRVJUSUNBID0gXCJ2ZXJ0aWNhXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0gyID0gXCJoMlwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19DT0xERlVTSU9OID0gXCJjb2xkZnVzaW9uXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0NBU1NBTkRSQSA9IFwiY2Fzc2FuZHJhXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0hCQVNFID0gXCJoYmFzZVwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19NT05HT0RCID0gXCJtb25nb2RiXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX1JFRElTID0gXCJyZWRpc1wiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19DT1VDSEJBU0UgPSBcImNvdWNoYmFzZVwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19DT1VDSERCID0gXCJjb3VjaGRiXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0NPU01PU0RCID0gXCJjb3Ntb3NkYlwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19EWU5BTU9EQiA9IFwiZHluYW1vZGJcIjtcbiAgICBUTVBfREJTWVNURU1WQUxVRVNfTkVPNEogPSBcIm5lbzRqXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0dFT0RFID0gXCJnZW9kZVwiO1xuICAgIFRNUF9EQlNZU1RFTVZBTFVFU19FTEFTVElDU0VBUkNIID0gXCJlbGFzdGljc2VhcmNoXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX01FTUNBQ0hFRCA9IFwibWVtY2FjaGVkXCI7XG4gICAgVE1QX0RCU1lTVEVNVkFMVUVTX0NPQ0tST0FDSERCID0gXCJjb2Nrcm9hY2hkYlwiO1xuICAgIERCU1lTVEVNVkFMVUVTX09USEVSX1NRTCA9IFRNUF9EQlNZU1RFTVZBTFVFU19PVEhFUl9TUUw7XG4gICAgREJTWVNURU1WQUxVRVNfTVNTUUwgPSBUTVBfREJTWVNURU1WQUxVRVNfTVNTUUw7XG4gICAgREJTWVNURU1WQUxVRVNfTVlTUUwgPSBUTVBfREJTWVNURU1WQUxVRVNfTVlTUUw7XG4gICAgREJTWVNURU1WQUxVRVNfT1JBQ0xFID0gVE1QX0RCU1lTVEVNVkFMVUVTX09SQUNMRTtcbiAgICBEQlNZU1RFTVZBTFVFU19EQjIgPSBUTVBfREJTWVNURU1WQUxVRVNfREIyO1xuICAgIERCU1lTVEVNVkFMVUVTX1BPU1RHUkVTUUwgPSBUTVBfREJTWVNURU1WQUxVRVNfUE9TVEdSRVNRTDtcbiAgICBEQlNZU1RFTVZBTFVFU19SRURTSElGVCA9IFRNUF9EQlNZU1RFTVZBTFVFU19SRURTSElGVDtcbiAgICBEQlNZU1RFTVZBTFVFU19ISVZFID0gVE1QX0RCU1lTVEVNVkFMVUVTX0hJVkU7XG4gICAgREJTWVNURU1WQUxVRVNfQ0xPVURTQ0FQRSA9IFRNUF9EQlNZU1RFTVZBTFVFU19DTE9VRFNDQVBFO1xuICAgIERCU1lTVEVNVkFMVUVTX0hTUUxEQiA9IFRNUF9EQlNZU1RFTVZBTFVFU19IU1FMREI7XG4gICAgREJTWVNURU1WQUxVRVNfUFJPR1JFU1MgPSBUTVBfREJTWVNURU1WQUxVRVNfUFJPR1JFU1M7XG4gICAgREJTWVNURU1WQUxVRVNfTUFYREIgPSBUTVBfREJTWVNURU1WQUxVRVNfTUFYREI7XG4gICAgREJTWVNURU1WQUxVRVNfSEFOQURCID0gVE1QX0RCU1lTVEVNVkFMVUVTX0hBTkFEQjtcbiAgICBEQlNZU1RFTVZBTFVFU19JTkdSRVMgPSBUTVBfREJTWVNURU1WQUxVRVNfSU5HUkVTO1xuICAgIERCU1lTVEVNVkFMVUVTX0ZJUlNUU1FMID0gVE1QX0RCU1lTVEVNVkFMVUVTX0ZJUlNUU1FMO1xuICAgIERCU1lTVEVNVkFMVUVTX0VEQiA9IFRNUF9EQlNZU1RFTVZBTFVFU19FREI7XG4gICAgREJTWVNURU1WQUxVRVNfQ0FDSEUgPSBUTVBfREJTWVNURU1WQUxVRVNfQ0FDSEU7XG4gICAgREJTWVNURU1WQUxVRVNfQURBQkFTID0gVE1QX0RCU1lTVEVNVkFMVUVTX0FEQUJBUztcbiAgICBEQlNZU1RFTVZBTFVFU19GSVJFQklSRCA9IFRNUF9EQlNZU1RFTVZBTFVFU19GSVJFQklSRDtcbiAgICBEQlNZU1RFTVZBTFVFU19ERVJCWSA9IFRNUF9EQlNZU1RFTVZBTFVFU19ERVJCWTtcbiAgICBEQlNZU1RFTVZBTFVFU19GSUxFTUFLRVIgPSBUTVBfREJTWVNURU1WQUxVRVNfRklMRU1BS0VSO1xuICAgIERCU1lTVEVNVkFMVUVTX0lORk9STUlYID0gVE1QX0RCU1lTVEVNVkFMVUVTX0lORk9STUlYO1xuICAgIERCU1lTVEVNVkFMVUVTX0lOU1RBTlREQiA9IFRNUF9EQlNZU1RFTVZBTFVFU19JTlNUQU5UREI7XG4gICAgREJTWVNURU1WQUxVRVNfSU5URVJCQVNFID0gVE1QX0RCU1lTVEVNVkFMVUVTX0lOVEVSQkFTRTtcbiAgICBEQlNZU1RFTVZBTFVFU19NQVJJQURCID0gVE1QX0RCU1lTVEVNVkFMVUVTX01BUklBREI7XG4gICAgREJTWVNURU1WQUxVRVNfTkVURVpaQSA9IFRNUF9EQlNZU1RFTVZBTFVFU19ORVRFWlpBO1xuICAgIERCU1lTVEVNVkFMVUVTX1BFUlZBU0lWRSA9IFRNUF9EQlNZU1RFTVZBTFVFU19QRVJWQVNJVkU7XG4gICAgREJTWVNURU1WQUxVRVNfUE9JTlRCQVNFID0gVE1QX0RCU1lTVEVNVkFMVUVTX1BPSU5UQkFTRTtcbiAgICBEQlNZU1RFTVZBTFVFU19TUUxJVEUgPSBUTVBfREJTWVNURU1WQUxVRVNfU1FMSVRFO1xuICAgIERCU1lTVEVNVkFMVUVTX1NZQkFTRSA9IFRNUF9EQlNZU1RFTVZBTFVFU19TWUJBU0U7XG4gICAgREJTWVNURU1WQUxVRVNfVEVSQURBVEEgPSBUTVBfREJTWVNURU1WQUxVRVNfVEVSQURBVEE7XG4gICAgREJTWVNURU1WQUxVRVNfVkVSVElDQSA9IFRNUF9EQlNZU1RFTVZBTFVFU19WRVJUSUNBO1xuICAgIERCU1lTVEVNVkFMVUVTX0gyID0gVE1QX0RCU1lTVEVNVkFMVUVTX0gyO1xuICAgIERCU1lTVEVNVkFMVUVTX0NPTERGVVNJT04gPSBUTVBfREJTWVNURU1WQUxVRVNfQ09MREZVU0lPTjtcbiAgICBEQlNZU1RFTVZBTFVFU19DQVNTQU5EUkEgPSBUTVBfREJTWVNURU1WQUxVRVNfQ0FTU0FORFJBO1xuICAgIERCU1lTVEVNVkFMVUVTX0hCQVNFID0gVE1QX0RCU1lTVEVNVkFMVUVTX0hCQVNFO1xuICAgIERCU1lTVEVNVkFMVUVTX01PTkdPREIgPSBUTVBfREJTWVNURU1WQUxVRVNfTU9OR09EQjtcbiAgICBEQlNZU1RFTVZBTFVFU19SRURJUyA9IFRNUF9EQlNZU1RFTVZBTFVFU19SRURJUztcbiAgICBEQlNZU1RFTVZBTFVFU19DT1VDSEJBU0UgPSBUTVBfREJTWVNURU1WQUxVRVNfQ09VQ0hCQVNFO1xuICAgIERCU1lTVEVNVkFMVUVTX0NPVUNIREIgPSBUTVBfREJTWVNURU1WQUxVRVNfQ09VQ0hEQjtcbiAgICBEQlNZU1RFTVZBTFVFU19DT1NNT1NEQiA9IFRNUF9EQlNZU1RFTVZBTFVFU19DT1NNT1NEQjtcbiAgICBEQlNZU1RFTVZBTFVFU19EWU5BTU9EQiA9IFRNUF9EQlNZU1RFTVZBTFVFU19EWU5BTU9EQjtcbiAgICBEQlNZU1RFTVZBTFVFU19ORU80SiA9IFRNUF9EQlNZU1RFTVZBTFVFU19ORU80SjtcbiAgICBEQlNZU1RFTVZBTFVFU19HRU9ERSA9IFRNUF9EQlNZU1RFTVZBTFVFU19HRU9ERTtcbiAgICBEQlNZU1RFTVZBTFVFU19FTEFTVElDU0VBUkNIID0gVE1QX0RCU1lTVEVNVkFMVUVTX0VMQVNUSUNTRUFSQ0g7XG4gICAgREJTWVNURU1WQUxVRVNfTUVNQ0FDSEVEID0gVE1QX0RCU1lTVEVNVkFMVUVTX01FTUNBQ0hFRDtcbiAgICBEQlNZU1RFTVZBTFVFU19DT0NLUk9BQ0hEQiA9IFRNUF9EQlNZU1RFTVZBTFVFU19DT0NLUk9BQ0hEQjtcbiAgICBEYlN5c3RlbVZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb25zdE1hcChbXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfT1RIRVJfU1FMLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX01TU1FMLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX01ZU1FMLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX09SQUNMRSxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19EQjIsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfUE9TVEdSRVNRTCxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19SRURTSElGVCxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19ISVZFLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX0NMT1VEU0NBUEUsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfSFNRTERCLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX1BST0dSRVNTLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX01BWERCLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX0hBTkFEQixcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19JTkdSRVMsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfRklSU1RTUUwsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfRURCLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX0NBQ0hFLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX0FEQUJBUyxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19GSVJFQklSRCxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19ERVJCWSxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19GSUxFTUFLRVIsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfSU5GT1JNSVgsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfSU5TVEFOVERCLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX0lOVEVSQkFTRSxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19NQVJJQURCLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX05FVEVaWkEsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfUEVSVkFTSVZFLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX1BPSU5UQkFTRSxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19TUUxJVEUsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfU1lCQVNFLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX1RFUkFEQVRBLFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX1ZFUlRJQ0EsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfSDIsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfQ09MREZVU0lPTixcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19DQVNTQU5EUkEsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfSEJBU0UsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfTU9OR09EQixcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19SRURJUyxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19DT1VDSEJBU0UsXG4gICAgICBUTVBfREJTWVNURU1WQUxVRVNfQ09VQ0hEQixcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19DT1NNT1NEQixcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19EWU5BTU9EQixcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19ORU80SixcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19HRU9ERSxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19FTEFTVElDU0VBUkNILFxuICAgICAgVE1QX0RCU1lTVEVNVkFMVUVTX01FTUNBQ0hFRCxcbiAgICAgIFRNUF9EQlNZU1RFTVZBTFVFU19DT0NLUk9BQ0hEQlxuICAgIF0pO1xuICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfQUxMID0gXCJhbGxcIjtcbiAgICBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0VBQ0hfUVVPUlVNID0gXCJlYWNoX3F1b3J1bVwiO1xuICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfUVVPUlVNID0gXCJxdW9ydW1cIjtcbiAgICBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0xPQ0FMX1FVT1JVTSA9IFwibG9jYWxfcXVvcnVtXCI7XG4gICAgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19PTkUgPSBcIm9uZVwiO1xuICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfVFdPID0gXCJ0d29cIjtcbiAgICBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1RIUkVFID0gXCJ0aHJlZVwiO1xuICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfT05FID0gXCJsb2NhbF9vbmVcIjtcbiAgICBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0FOWSA9IFwiYW55XCI7XG4gICAgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19TRVJJQUwgPSBcInNlcmlhbFwiO1xuICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfU0VSSUFMID0gXCJsb2NhbF9zZXJpYWxcIjtcbiAgICBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfQUxMID0gVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19BTEw7XG4gICAgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0VBQ0hfUVVPUlVNID0gVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19FQUNIX1FVT1JVTTtcbiAgICBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfUVVPUlVNID0gVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19RVU9SVU07XG4gICAgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0xPQ0FMX1FVT1JVTSA9IFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfUVVPUlVNO1xuICAgIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19PTkUgPSBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX09ORTtcbiAgICBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfVFdPID0gVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19UV087XG4gICAgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1RIUkVFID0gVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19USFJFRTtcbiAgICBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfT05FID0gVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9PTkU7XG4gICAgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0FOWSA9IFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfQU5ZO1xuICAgIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19TRVJJQUwgPSBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1NFUklBTDtcbiAgICBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfU0VSSUFMID0gVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9TRVJJQUw7XG4gICAgRGJDYXNzYW5kcmFDb25zaXN0ZW5jeUxldmVsVmFsdWVzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0TWFwKFtcbiAgICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfQUxMLFxuICAgICAgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19FQUNIX1FVT1JVTSxcbiAgICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfUVVPUlVNLFxuICAgICAgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9RVU9SVU0sXG4gICAgICBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX09ORSxcbiAgICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfVFdPLFxuICAgICAgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19USFJFRSxcbiAgICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfT05FLFxuICAgICAgVE1QX0RCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19BTlksXG4gICAgICBUTVBfREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1NFUklBTCxcbiAgICAgIFRNUF9EQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfTE9DQUxfU0VSSUFMXG4gICAgXSk7XG4gICAgVE1QX0ZBQVNUUklHR0VSVkFMVUVTX0RBVEFTT1VSQ0UgPSBcImRhdGFzb3VyY2VcIjtcbiAgICBUTVBfRkFBU1RSSUdHRVJWQUxVRVNfSFRUUCA9IFwiaHR0cFwiO1xuICAgIFRNUF9GQUFTVFJJR0dFUlZBTFVFU19QVUJTVUIgPSBcInB1YnN1YlwiO1xuICAgIFRNUF9GQUFTVFJJR0dFUlZBTFVFU19USU1FUiA9IFwidGltZXJcIjtcbiAgICBUTVBfRkFBU1RSSUdHRVJWQUxVRVNfT1RIRVIgPSBcIm90aGVyXCI7XG4gICAgRkFBU1RSSUdHRVJWQUxVRVNfREFUQVNPVVJDRSA9IFRNUF9GQUFTVFJJR0dFUlZBTFVFU19EQVRBU09VUkNFO1xuICAgIEZBQVNUUklHR0VSVkFMVUVTX0hUVFAgPSBUTVBfRkFBU1RSSUdHRVJWQUxVRVNfSFRUUDtcbiAgICBGQUFTVFJJR0dFUlZBTFVFU19QVUJTVUIgPSBUTVBfRkFBU1RSSUdHRVJWQUxVRVNfUFVCU1VCO1xuICAgIEZBQVNUUklHR0VSVkFMVUVTX1RJTUVSID0gVE1QX0ZBQVNUUklHR0VSVkFMVUVTX1RJTUVSO1xuICAgIEZBQVNUUklHR0VSVkFMVUVTX09USEVSID0gVE1QX0ZBQVNUUklHR0VSVkFMVUVTX09USEVSO1xuICAgIEZhYXNUcmlnZ2VyVmFsdWVzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0TWFwKFtcbiAgICAgIFRNUF9GQUFTVFJJR0dFUlZBTFVFU19EQVRBU09VUkNFLFxuICAgICAgVE1QX0ZBQVNUUklHR0VSVkFMVUVTX0hUVFAsXG4gICAgICBUTVBfRkFBU1RSSUdHRVJWQUxVRVNfUFVCU1VCLFxuICAgICAgVE1QX0ZBQVNUUklHR0VSVkFMVUVTX1RJTUVSLFxuICAgICAgVE1QX0ZBQVNUUklHR0VSVkFMVUVTX09USEVSXG4gICAgXSk7XG4gICAgVE1QX0ZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19JTlNFUlQgPSBcImluc2VydFwiO1xuICAgIFRNUF9GQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfRURJVCA9IFwiZWRpdFwiO1xuICAgIFRNUF9GQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfREVMRVRFID0gXCJkZWxldGVcIjtcbiAgICBGQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfSU5TRVJUID0gVE1QX0ZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19JTlNFUlQ7XG4gICAgRkFBU0RPQ1VNRU5UT1BFUkFUSU9OVkFMVUVTX0VESVQgPSBUTVBfRkFBU0RPQ1VNRU5UT1BFUkFUSU9OVkFMVUVTX0VESVQ7XG4gICAgRkFBU0RPQ1VNRU5UT1BFUkFUSU9OVkFMVUVTX0RFTEVURSA9IFRNUF9GQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfREVMRVRFO1xuICAgIEZhYXNEb2N1bWVudE9wZXJhdGlvblZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb25zdE1hcChbXG4gICAgICBUTVBfRkFBU0RPQ1VNRU5UT1BFUkFUSU9OVkFMVUVTX0lOU0VSVCxcbiAgICAgIFRNUF9GQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfRURJVCxcbiAgICAgIFRNUF9GQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfREVMRVRFXG4gICAgXSk7XG4gICAgVE1QX0ZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfQUxJQkFCQV9DTE9VRCA9IFwiYWxpYmFiYV9jbG91ZFwiO1xuICAgIFRNUF9GQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0FXUyA9IFwiYXdzXCI7XG4gICAgVE1QX0ZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfQVpVUkUgPSBcImF6dXJlXCI7XG4gICAgVE1QX0ZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfR0NQID0gXCJnY3BcIjtcbiAgICBGQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0FMSUJBQkFfQ0xPVUQgPSBUTVBfRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BTElCQUJBX0NMT1VEO1xuICAgIEZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfQVdTID0gVE1QX0ZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfQVdTO1xuICAgIEZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfQVpVUkUgPSBUTVBfRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BWlVSRTtcbiAgICBGQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0dDUCA9IFRNUF9GQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0dDUDtcbiAgICBGYWFzSW52b2tlZFByb3ZpZGVyVmFsdWVzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0TWFwKFtcbiAgICAgIFRNUF9GQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0FMSUJBQkFfQ0xPVUQsXG4gICAgICBUTVBfRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BV1MsXG4gICAgICBUTVBfRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BWlVSRSxcbiAgICAgIFRNUF9GQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0dDUFxuICAgIF0pO1xuICAgIFRNUF9ORVRUUkFOU1BPUlRWQUxVRVNfSVBfVENQID0gXCJpcF90Y3BcIjtcbiAgICBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX0lQX1VEUCA9IFwiaXBfdWRwXCI7XG4gICAgVE1QX05FVFRSQU5TUE9SVFZBTFVFU19JUCA9IFwiaXBcIjtcbiAgICBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX1VOSVggPSBcInVuaXhcIjtcbiAgICBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX1BJUEUgPSBcInBpcGVcIjtcbiAgICBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX0lOUFJPQyA9IFwiaW5wcm9jXCI7XG4gICAgVE1QX05FVFRSQU5TUE9SVFZBTFVFU19PVEhFUiA9IFwib3RoZXJcIjtcbiAgICBORVRUUkFOU1BPUlRWQUxVRVNfSVBfVENQID0gVE1QX05FVFRSQU5TUE9SVFZBTFVFU19JUF9UQ1A7XG4gICAgTkVUVFJBTlNQT1JUVkFMVUVTX0lQX1VEUCA9IFRNUF9ORVRUUkFOU1BPUlRWQUxVRVNfSVBfVURQO1xuICAgIE5FVFRSQU5TUE9SVFZBTFVFU19JUCA9IFRNUF9ORVRUUkFOU1BPUlRWQUxVRVNfSVA7XG4gICAgTkVUVFJBTlNQT1JUVkFMVUVTX1VOSVggPSBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX1VOSVg7XG4gICAgTkVUVFJBTlNQT1JUVkFMVUVTX1BJUEUgPSBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX1BJUEU7XG4gICAgTkVUVFJBTlNQT1JUVkFMVUVTX0lOUFJPQyA9IFRNUF9ORVRUUkFOU1BPUlRWQUxVRVNfSU5QUk9DO1xuICAgIE5FVFRSQU5TUE9SVFZBTFVFU19PVEhFUiA9IFRNUF9ORVRUUkFOU1BPUlRWQUxVRVNfT1RIRVI7XG4gICAgTmV0VHJhbnNwb3J0VmFsdWVzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0TWFwKFtcbiAgICAgIFRNUF9ORVRUUkFOU1BPUlRWQUxVRVNfSVBfVENQLFxuICAgICAgVE1QX05FVFRSQU5TUE9SVFZBTFVFU19JUF9VRFAsXG4gICAgICBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX0lQLFxuICAgICAgVE1QX05FVFRSQU5TUE9SVFZBTFVFU19VTklYLFxuICAgICAgVE1QX05FVFRSQU5TUE9SVFZBTFVFU19QSVBFLFxuICAgICAgVE1QX05FVFRSQU5TUE9SVFZBTFVFU19JTlBST0MsXG4gICAgICBUTVBfTkVUVFJBTlNQT1JUVkFMVUVTX09USEVSXG4gICAgXSk7XG4gICAgVE1QX05FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSUZJID0gXCJ3aWZpXCI7XG4gICAgVE1QX05FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSVJFRCA9IFwid2lyZWRcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX0NFTEwgPSBcImNlbGxcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX1VOQVZBSUxBQkxFID0gXCJ1bmF2YWlsYWJsZVwiO1xuICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfVU5LTk9XTiA9IFwidW5rbm93blwiO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSUZJID0gVE1QX05FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSUZJO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSVJFRCA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfV0lSRUQ7XG4gICAgTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX0NFTEwgPSBUTVBfTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX0NFTEw7XG4gICAgTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX1VOQVZBSUxBQkxFID0gVE1QX05FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19VTkFWQUlMQUJMRTtcbiAgICBORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfVU5LTk9XTiA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfVU5LTk9XTjtcbiAgICBOZXRIb3N0Q29ubmVjdGlvblR5cGVWYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RNYXAoW1xuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSUZJLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSVJFRCxcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfQ0VMTCxcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfVU5BVkFJTEFCTEUsXG4gICAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX1VOS05PV05cbiAgICBdKTtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0dQUlMgPSBcImdwcnNcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VER0UgPSBcImVkZ2VcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX1VNVFMgPSBcInVtdHNcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0NETUEgPSBcImNkbWFcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VWRE9fMCA9IFwiZXZkb18wXCI7XG4gICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPX0EgPSBcImV2ZG9fYVwiO1xuICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQTIwMDBfMVhSVFQgPSBcImNkbWEyMDAwXzF4cnR0XCI7XG4gICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU0RQQSA9IFwiaHNkcGFcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTVVBBID0gXCJoc3VwYVwiO1xuICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSFNQQSA9IFwiaHNwYVwiO1xuICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSURFTiA9IFwiaWRlblwiO1xuICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRVZET19CID0gXCJldmRvX2JcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0xURSA9IFwibHRlXCI7XG4gICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FSFJQRCA9IFwiZWhycGRcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTUEFQID0gXCJoc3BhcFwiO1xuICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfR1NNID0gXCJnc21cIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX1REX1NDRE1BID0gXCJ0ZF9zY2RtYVwiO1xuICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSVdMQU4gPSBcIml3bGFuXCI7XG4gICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19OUiA9IFwibnJcIjtcbiAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX05STlNBID0gXCJucm5zYVwiO1xuICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTFRFX0NBID0gXCJsdGVfY2FcIjtcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfR1BSUyA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfR1BSUztcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRURHRSA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRURHRTtcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfVU1UUyA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfVU1UUztcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQSA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQTtcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRVZET18wID0gVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPXzA7XG4gICAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VWRE9fQSA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRVZET19BO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19DRE1BMjAwMF8xWFJUVCA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQTIwMDBfMVhSVFQ7XG4gICAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTRFBBID0gVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU0RQQTtcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSFNVUEEgPSBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTVVBBO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU1BBID0gVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU1BBO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19JREVOID0gVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19JREVOO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPX0IgPSBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VWRE9fQjtcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTFRFID0gVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19MVEU7XG4gICAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VIUlBEID0gVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FSFJQRDtcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSFNQQVAgPSBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTUEFQO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19HU00gPSBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0dTTTtcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfVERfU0NETUEgPSBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX1REX1NDRE1BO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19JV0xBTiA9IFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSVdMQU47XG4gICAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX05SID0gVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19OUjtcbiAgICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTlJOU0EgPSBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX05STlNBO1xuICAgIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19MVEVfQ0EgPSBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0xURV9DQTtcbiAgICBOZXRIb3N0Q29ubmVjdGlvblN1YnR5cGVWYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RNYXAoW1xuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19HUFJTLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FREdFLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19VTVRTLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19DRE1BLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPXzAsXG4gICAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VWRE9fQSxcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQTIwMDBfMVhSVFQsXG4gICAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTRFBBLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU1VQQSxcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSFNQQSxcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSURFTixcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRVZET19CLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19MVEUsXG4gICAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VIUlBELFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU1BBUCxcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfR1NNLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19URF9TQ0RNQSxcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSVdMQU4sXG4gICAgICBUTVBfTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX05SLFxuICAgICAgVE1QX05FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19OUk5TQSxcbiAgICAgIFRNUF9ORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTFRFX0NBXG4gICAgXSk7XG4gICAgVE1QX0hUVFBGTEFWT1JWQUxVRVNfSFRUUF8xXzAgPSBcIjEuMFwiO1xuICAgIFRNUF9IVFRQRkxBVk9SVkFMVUVTX0hUVFBfMV8xID0gXCIxLjFcIjtcbiAgICBUTVBfSFRUUEZMQVZPUlZBTFVFU19IVFRQXzJfMCA9IFwiMi4wXCI7XG4gICAgVE1QX0hUVFBGTEFWT1JWQUxVRVNfU1BEWSA9IFwiU1BEWVwiO1xuICAgIFRNUF9IVFRQRkxBVk9SVkFMVUVTX1FVSUMgPSBcIlFVSUNcIjtcbiAgICBIVFRQRkxBVk9SVkFMVUVTX0hUVFBfMV8wID0gVE1QX0hUVFBGTEFWT1JWQUxVRVNfSFRUUF8xXzA7XG4gICAgSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMSA9IFRNUF9IVFRQRkxBVk9SVkFMVUVTX0hUVFBfMV8xO1xuICAgIEhUVFBGTEFWT1JWQUxVRVNfSFRUUF8yXzAgPSBUTVBfSFRUUEZMQVZPUlZBTFVFU19IVFRQXzJfMDtcbiAgICBIVFRQRkxBVk9SVkFMVUVTX1NQRFkgPSBUTVBfSFRUUEZMQVZPUlZBTFVFU19TUERZO1xuICAgIEhUVFBGTEFWT1JWQUxVRVNfUVVJQyA9IFRNUF9IVFRQRkxBVk9SVkFMVUVTX1FVSUM7XG4gICAgSHR0cEZsYXZvclZhbHVlcyA9IHtcbiAgICAgIEhUVFBfMV8wOiBUTVBfSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMCxcbiAgICAgIEhUVFBfMV8xOiBUTVBfSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMSxcbiAgICAgIEhUVFBfMl8wOiBUTVBfSFRUUEZMQVZPUlZBTFVFU19IVFRQXzJfMCxcbiAgICAgIFNQRFk6IFRNUF9IVFRQRkxBVk9SVkFMVUVTX1NQRFksXG4gICAgICBRVUlDOiBUTVBfSFRUUEZMQVZPUlZBTFVFU19RVUlDXG4gICAgfTtcbiAgICBUTVBfTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1FVRVVFID0gXCJxdWV1ZVwiO1xuICAgIFRNUF9NRVNTQUdJTkdERVNUSU5BVElPTktJTkRWQUxVRVNfVE9QSUMgPSBcInRvcGljXCI7XG4gICAgTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1FVRVVFID0gVE1QX01FU1NBR0lOR0RFU1RJTkFUSU9OS0lORFZBTFVFU19RVUVVRTtcbiAgICBNRVNTQUdJTkdERVNUSU5BVElPTktJTkRWQUxVRVNfVE9QSUMgPSBUTVBfTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1RPUElDO1xuICAgIE1lc3NhZ2luZ0Rlc3RpbmF0aW9uS2luZFZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb25zdE1hcChbXG4gICAgICBUTVBfTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1FVRVVFLFxuICAgICAgVE1QX01FU1NBR0lOR0RFU1RJTkFUSU9OS0lORFZBTFVFU19UT1BJQ1xuICAgIF0pO1xuICAgIFRNUF9NRVNTQUdJTkdPUEVSQVRJT05WQUxVRVNfUkVDRUlWRSA9IFwicmVjZWl2ZVwiO1xuICAgIFRNUF9NRVNTQUdJTkdPUEVSQVRJT05WQUxVRVNfUFJPQ0VTUyA9IFwicHJvY2Vzc1wiO1xuICAgIE1FU1NBR0lOR09QRVJBVElPTlZBTFVFU19SRUNFSVZFID0gVE1QX01FU1NBR0lOR09QRVJBVElPTlZBTFVFU19SRUNFSVZFO1xuICAgIE1FU1NBR0lOR09QRVJBVElPTlZBTFVFU19QUk9DRVNTID0gVE1QX01FU1NBR0lOR09QRVJBVElPTlZBTFVFU19QUk9DRVNTO1xuICAgIE1lc3NhZ2luZ09wZXJhdGlvblZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb25zdE1hcChbXG4gICAgICBUTVBfTUVTU0FHSU5HT1BFUkFUSU9OVkFMVUVTX1JFQ0VJVkUsXG4gICAgICBUTVBfTUVTU0FHSU5HT1BFUkFUSU9OVkFMVUVTX1BST0NFU1NcbiAgICBdKTtcbiAgICBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfT0sgPSAwO1xuICAgIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19DQU5DRUxMRUQgPSAxO1xuICAgIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTktOT1dOID0gMjtcbiAgICBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfSU5WQUxJRF9BUkdVTUVOVCA9IDM7XG4gICAgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0RFQURMSU5FX0VYQ0VFREVEID0gNDtcbiAgICBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfTk9UX0ZPVU5EID0gNTtcbiAgICBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfQUxSRUFEWV9FWElTVFMgPSA2O1xuICAgIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19QRVJNSVNTSU9OX0RFTklFRCA9IDc7XG4gICAgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1JFU09VUkNFX0VYSEFVU1RFRCA9IDg7XG4gICAgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0ZBSUxFRF9QUkVDT05ESVRJT04gPSA5O1xuICAgIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BQk9SVEVEID0gMTA7XG4gICAgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX09VVF9PRl9SQU5HRSA9IDExO1xuICAgIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTklNUExFTUVOVEVEID0gMTI7XG4gICAgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0lOVEVSTkFMID0gMTM7XG4gICAgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOQVZBSUxBQkxFID0gMTQ7XG4gICAgVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0RBVEFfTE9TUyA9IDE1O1xuICAgIFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTkFVVEhFTlRJQ0FURUQgPSAxNjtcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19PSyA9IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19PSztcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19DQU5DRUxMRUQgPSBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfQ0FOQ0VMTEVEO1xuICAgIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOS05PV04gPSBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5LTk9XTjtcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19JTlZBTElEX0FSR1VNRU5UID0gVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0lOVkFMSURfQVJHVU1FTlQ7XG4gICAgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfREVBRExJTkVfRVhDRUVERUQgPSBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfREVBRExJTkVfRVhDRUVERUQ7XG4gICAgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfTk9UX0ZPVU5EID0gVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX05PVF9GT1VORDtcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BTFJFQURZX0VYSVNUUyA9IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BTFJFQURZX0VYSVNUUztcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19QRVJNSVNTSU9OX0RFTklFRCA9IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19QRVJNSVNTSU9OX0RFTklFRDtcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19SRVNPVVJDRV9FWEhBVVNURUQgPSBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfUkVTT1VSQ0VfRVhIQVVTVEVEO1xuICAgIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0ZBSUxFRF9QUkVDT05ESVRJT04gPSBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfRkFJTEVEX1BSRUNPTkRJVElPTjtcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BQk9SVEVEID0gVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0FCT1JURUQ7XG4gICAgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfT1VUX09GX1JBTkdFID0gVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX09VVF9PRl9SQU5HRTtcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTklNUExFTUVOVEVEID0gVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOSU1QTEVNRU5URUQ7XG4gICAgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfSU5URVJOQUwgPSBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfSU5URVJOQUw7XG4gICAgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5BVkFJTEFCTEUgPSBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5BVkFJTEFCTEU7XG4gICAgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfREFUQV9MT1NTID0gVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0RBVEFfTE9TUztcbiAgICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTkFVVEhFTlRJQ0FURUQgPSBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5BVVRIRU5USUNBVEVEO1xuICAgIFJwY0dycGNTdGF0dXNDb2RlVmFsdWVzID0ge1xuICAgICAgT0s6IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19PSyxcbiAgICAgIENBTkNFTExFRDogVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0NBTkNFTExFRCxcbiAgICAgIFVOS05PV046IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTktOT1dOLFxuICAgICAgSU5WQUxJRF9BUkdVTUVOVDogVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0lOVkFMSURfQVJHVU1FTlQsXG4gICAgICBERUFETElORV9FWENFRURFRDogVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0RFQURMSU5FX0VYQ0VFREVELFxuICAgICAgTk9UX0ZPVU5EOiBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfTk9UX0ZPVU5ELFxuICAgICAgQUxSRUFEWV9FWElTVFM6IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BTFJFQURZX0VYSVNUUyxcbiAgICAgIFBFUk1JU1NJT05fREVOSUVEOiBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfUEVSTUlTU0lPTl9ERU5JRUQsXG4gICAgICBSRVNPVVJDRV9FWEhBVVNURUQ6IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICBGQUlMRURfUFJFQ09ORElUSU9OOiBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfRkFJTEVEX1BSRUNPTkRJVElPTixcbiAgICAgIEFCT1JURUQ6IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BQk9SVEVELFxuICAgICAgT1VUX09GX1JBTkdFOiBUTVBfUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfT1VUX09GX1JBTkdFLFxuICAgICAgVU5JTVBMRU1FTlRFRDogVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOSU1QTEVNRU5URUQsXG4gICAgICBJTlRFUk5BTDogVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0lOVEVSTkFMLFxuICAgICAgVU5BVkFJTEFCTEU6IFRNUF9SUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTkFWQUlMQUJMRSxcbiAgICAgIERBVEFfTE9TUzogVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0RBVEFfTE9TUyxcbiAgICAgIFVOQVVUSEVOVElDQVRFRDogVE1QX1JQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOQVVUSEVOVElDQVRFRFxuICAgIH07XG4gICAgVE1QX01FU1NBR0VUWVBFVkFMVUVTX1NFTlQgPSBcIlNFTlRcIjtcbiAgICBUTVBfTUVTU0FHRVRZUEVWQUxVRVNfUkVDRUlWRUQgPSBcIlJFQ0VJVkVEXCI7XG4gICAgTUVTU0FHRVRZUEVWQUxVRVNfU0VOVCA9IFRNUF9NRVNTQUdFVFlQRVZBTFVFU19TRU5UO1xuICAgIE1FU1NBR0VUWVBFVkFMVUVTX1JFQ0VJVkVEID0gVE1QX01FU1NBR0VUWVBFVkFMVUVTX1JFQ0VJVkVEO1xuICAgIE1lc3NhZ2VUeXBlVmFsdWVzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0TWFwKFtcbiAgICAgIFRNUF9NRVNTQUdFVFlQRVZBTFVFU19TRU5ULFxuICAgICAgVE1QX01FU1NBR0VUWVBFVkFMVUVTX1JFQ0VJVkVEXG4gICAgXSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYnVpbGQvZXNtL3RyYWNlL2luZGV4LmpzXG52YXIgaW5pdF90cmFjZTIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zL2J1aWxkL2VzbS90cmFjZS9pbmRleC5qc1wiKCkge1xuICAgIGluaXRfU2VtYW50aWNBdHRyaWJ1dGVzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYnVpbGQvZXNtL3Jlc291cmNlL1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLmpzXG52YXIgVE1QX0NMT1VEX1BST1ZJREVSLCBUTVBfQ0xPVURfQUNDT1VOVF9JRCwgVE1QX0NMT1VEX1JFR0lPTiwgVE1QX0NMT1VEX0FWQUlMQUJJTElUWV9aT05FLCBUTVBfQ0xPVURfUExBVEZPUk0sIFRNUF9BV1NfRUNTX0NPTlRBSU5FUl9BUk4sIFRNUF9BV1NfRUNTX0NMVVNURVJfQVJOLCBUTVBfQVdTX0VDU19MQVVOQ0hUWVBFLCBUTVBfQVdTX0VDU19UQVNLX0FSTiwgVE1QX0FXU19FQ1NfVEFTS19GQU1JTFksIFRNUF9BV1NfRUNTX1RBU0tfUkVWSVNJT04sIFRNUF9BV1NfRUtTX0NMVVNURVJfQVJOLCBUTVBfQVdTX0xPR19HUk9VUF9OQU1FUywgVE1QX0FXU19MT0dfR1JPVVBfQVJOUywgVE1QX0FXU19MT0dfU1RSRUFNX05BTUVTLCBUTVBfQVdTX0xPR19TVFJFQU1fQVJOUywgVE1QX0NPTlRBSU5FUl9OQU1FLCBUTVBfQ09OVEFJTkVSX0lELCBUTVBfQ09OVEFJTkVSX1JVTlRJTUUsIFRNUF9DT05UQUlORVJfSU1BR0VfTkFNRSwgVE1QX0NPTlRBSU5FUl9JTUFHRV9UQUcsIFRNUF9ERVBMT1lNRU5UX0VOVklST05NRU5ULCBUTVBfREVWSUNFX0lELCBUTVBfREVWSUNFX01PREVMX0lERU5USUZJRVIsIFRNUF9ERVZJQ0VfTU9ERUxfTkFNRSwgVE1QX0ZBQVNfTkFNRSwgVE1QX0ZBQVNfSUQsIFRNUF9GQUFTX1ZFUlNJT04sIFRNUF9GQUFTX0lOU1RBTkNFLCBUTVBfRkFBU19NQVhfTUVNT1JZLCBUTVBfSE9TVF9JRCwgVE1QX0hPU1RfTkFNRSwgVE1QX0hPU1RfVFlQRSwgVE1QX0hPU1RfQVJDSCwgVE1QX0hPU1RfSU1BR0VfTkFNRSwgVE1QX0hPU1RfSU1BR0VfSUQsIFRNUF9IT1NUX0lNQUdFX1ZFUlNJT04sIFRNUF9LOFNfQ0xVU1RFUl9OQU1FLCBUTVBfSzhTX05PREVfTkFNRSwgVE1QX0s4U19OT0RFX1VJRCwgVE1QX0s4U19OQU1FU1BBQ0VfTkFNRSwgVE1QX0s4U19QT0RfVUlELCBUTVBfSzhTX1BPRF9OQU1FLCBUTVBfSzhTX0NPTlRBSU5FUl9OQU1FLCBUTVBfSzhTX1JFUExJQ0FTRVRfVUlELCBUTVBfSzhTX1JFUExJQ0FTRVRfTkFNRSwgVE1QX0s4U19ERVBMT1lNRU5UX1VJRCwgVE1QX0s4U19ERVBMT1lNRU5UX05BTUUsIFRNUF9LOFNfU1RBVEVGVUxTRVRfVUlELCBUTVBfSzhTX1NUQVRFRlVMU0VUX05BTUUsIFRNUF9LOFNfREFFTU9OU0VUX1VJRCwgVE1QX0s4U19EQUVNT05TRVRfTkFNRSwgVE1QX0s4U19KT0JfVUlELCBUTVBfSzhTX0pPQl9OQU1FLCBUTVBfSzhTX0NST05KT0JfVUlELCBUTVBfSzhTX0NST05KT0JfTkFNRSwgVE1QX09TX1RZUEUsIFRNUF9PU19ERVNDUklQVElPTiwgVE1QX09TX05BTUUsIFRNUF9PU19WRVJTSU9OLCBUTVBfUFJPQ0VTU19QSUQsIFRNUF9QUk9DRVNTX0VYRUNVVEFCTEVfTkFNRSwgVE1QX1BST0NFU1NfRVhFQ1VUQUJMRV9QQVRILCBUTVBfUFJPQ0VTU19DT01NQU5ELCBUTVBfUFJPQ0VTU19DT01NQU5EX0xJTkUsIFRNUF9QUk9DRVNTX0NPTU1BTkRfQVJHUywgVE1QX1BST0NFU1NfT1dORVIsIFRNUF9QUk9DRVNTX1JVTlRJTUVfTkFNRSwgVE1QX1BST0NFU1NfUlVOVElNRV9WRVJTSU9OLCBUTVBfUFJPQ0VTU19SVU5USU1FX0RFU0NSSVBUSU9OLCBUTVBfU0VSVklDRV9OQU1FLCBUTVBfU0VSVklDRV9OQU1FU1BBQ0UsIFRNUF9TRVJWSUNFX0lOU1RBTkNFX0lELCBUTVBfU0VSVklDRV9WRVJTSU9OLCBUTVBfVEVMRU1FVFJZX1NES19OQU1FLCBUTVBfVEVMRU1FVFJZX1NES19MQU5HVUFHRSwgVE1QX1RFTEVNRVRSWV9TREtfVkVSU0lPTiwgVE1QX1RFTEVNRVRSWV9BVVRPX1ZFUlNJT04sIFRNUF9XRUJFTkdJTkVfTkFNRSwgVE1QX1dFQkVOR0lORV9WRVJTSU9OLCBUTVBfV0VCRU5HSU5FX0RFU0NSSVBUSU9OLCBTRU1SRVNBVFRSU19DTE9VRF9QUk9WSURFUiwgU0VNUkVTQVRUUlNfQ0xPVURfQUNDT1VOVF9JRCwgU0VNUkVTQVRUUlNfQ0xPVURfUkVHSU9OLCBTRU1SRVNBVFRSU19DTE9VRF9BVkFJTEFCSUxJVFlfWk9ORSwgU0VNUkVTQVRUUlNfQ0xPVURfUExBVEZPUk0sIFNFTVJFU0FUVFJTX0FXU19FQ1NfQ09OVEFJTkVSX0FSTiwgU0VNUkVTQVRUUlNfQVdTX0VDU19DTFVTVEVSX0FSTiwgU0VNUkVTQVRUUlNfQVdTX0VDU19MQVVOQ0hUWVBFLCBTRU1SRVNBVFRSU19BV1NfRUNTX1RBU0tfQVJOLCBTRU1SRVNBVFRSU19BV1NfRUNTX1RBU0tfRkFNSUxZLCBTRU1SRVNBVFRSU19BV1NfRUNTX1RBU0tfUkVWSVNJT04sIFNFTVJFU0FUVFJTX0FXU19FS1NfQ0xVU1RFUl9BUk4sIFNFTVJFU0FUVFJTX0FXU19MT0dfR1JPVVBfTkFNRVMsIFNFTVJFU0FUVFJTX0FXU19MT0dfR1JPVVBfQVJOUywgU0VNUkVTQVRUUlNfQVdTX0xPR19TVFJFQU1fTkFNRVMsIFNFTVJFU0FUVFJTX0FXU19MT0dfU1RSRUFNX0FSTlMsIFNFTVJFU0FUVFJTX0NPTlRBSU5FUl9OQU1FLCBTRU1SRVNBVFRSU19DT05UQUlORVJfSUQsIFNFTVJFU0FUVFJTX0NPTlRBSU5FUl9SVU5USU1FLCBTRU1SRVNBVFRSU19DT05UQUlORVJfSU1BR0VfTkFNRSwgU0VNUkVTQVRUUlNfQ09OVEFJTkVSX0lNQUdFX1RBRywgU0VNUkVTQVRUUlNfREVQTE9ZTUVOVF9FTlZJUk9OTUVOVCwgU0VNUkVTQVRUUlNfREVWSUNFX0lELCBTRU1SRVNBVFRSU19ERVZJQ0VfTU9ERUxfSURFTlRJRklFUiwgU0VNUkVTQVRUUlNfREVWSUNFX01PREVMX05BTUUsIFNFTVJFU0FUVFJTX0ZBQVNfTkFNRSwgU0VNUkVTQVRUUlNfRkFBU19JRCwgU0VNUkVTQVRUUlNfRkFBU19WRVJTSU9OLCBTRU1SRVNBVFRSU19GQUFTX0lOU1RBTkNFLCBTRU1SRVNBVFRSU19GQUFTX01BWF9NRU1PUlksIFNFTVJFU0FUVFJTX0hPU1RfSUQsIFNFTVJFU0FUVFJTX0hPU1RfTkFNRSwgU0VNUkVTQVRUUlNfSE9TVF9UWVBFLCBTRU1SRVNBVFRSU19IT1NUX0FSQ0gsIFNFTVJFU0FUVFJTX0hPU1RfSU1BR0VfTkFNRSwgU0VNUkVTQVRUUlNfSE9TVF9JTUFHRV9JRCwgU0VNUkVTQVRUUlNfSE9TVF9JTUFHRV9WRVJTSU9OLCBTRU1SRVNBVFRSU19LOFNfQ0xVU1RFUl9OQU1FLCBTRU1SRVNBVFRSU19LOFNfTk9ERV9OQU1FLCBTRU1SRVNBVFRSU19LOFNfTk9ERV9VSUQsIFNFTVJFU0FUVFJTX0s4U19OQU1FU1BBQ0VfTkFNRSwgU0VNUkVTQVRUUlNfSzhTX1BPRF9VSUQsIFNFTVJFU0FUVFJTX0s4U19QT0RfTkFNRSwgU0VNUkVTQVRUUlNfSzhTX0NPTlRBSU5FUl9OQU1FLCBTRU1SRVNBVFRSU19LOFNfUkVQTElDQVNFVF9VSUQsIFNFTVJFU0FUVFJTX0s4U19SRVBMSUNBU0VUX05BTUUsIFNFTVJFU0FUVFJTX0s4U19ERVBMT1lNRU5UX1VJRCwgU0VNUkVTQVRUUlNfSzhTX0RFUExPWU1FTlRfTkFNRSwgU0VNUkVTQVRUUlNfSzhTX1NUQVRFRlVMU0VUX1VJRCwgU0VNUkVTQVRUUlNfSzhTX1NUQVRFRlVMU0VUX05BTUUsIFNFTVJFU0FUVFJTX0s4U19EQUVNT05TRVRfVUlELCBTRU1SRVNBVFRSU19LOFNfREFFTU9OU0VUX05BTUUsIFNFTVJFU0FUVFJTX0s4U19KT0JfVUlELCBTRU1SRVNBVFRSU19LOFNfSk9CX05BTUUsIFNFTVJFU0FUVFJTX0s4U19DUk9OSk9CX1VJRCwgU0VNUkVTQVRUUlNfSzhTX0NST05KT0JfTkFNRSwgU0VNUkVTQVRUUlNfT1NfVFlQRSwgU0VNUkVTQVRUUlNfT1NfREVTQ1JJUFRJT04sIFNFTVJFU0FUVFJTX09TX05BTUUsIFNFTVJFU0FUVFJTX09TX1ZFUlNJT04sIFNFTVJFU0FUVFJTX1BST0NFU1NfUElELCBTRU1SRVNBVFRSU19QUk9DRVNTX0VYRUNVVEFCTEVfTkFNRSwgU0VNUkVTQVRUUlNfUFJPQ0VTU19FWEVDVVRBQkxFX1BBVEgsIFNFTVJFU0FUVFJTX1BST0NFU1NfQ09NTUFORCwgU0VNUkVTQVRUUlNfUFJPQ0VTU19DT01NQU5EX0xJTkUsIFNFTVJFU0FUVFJTX1BST0NFU1NfQ09NTUFORF9BUkdTLCBTRU1SRVNBVFRSU19QUk9DRVNTX09XTkVSLCBTRU1SRVNBVFRSU19QUk9DRVNTX1JVTlRJTUVfTkFNRSwgU0VNUkVTQVRUUlNfUFJPQ0VTU19SVU5USU1FX1ZFUlNJT04sIFNFTVJFU0FUVFJTX1BST0NFU1NfUlVOVElNRV9ERVNDUklQVElPTiwgU0VNUkVTQVRUUlNfU0VSVklDRV9OQU1FLCBTRU1SRVNBVFRSU19TRVJWSUNFX05BTUVTUEFDRSwgU0VNUkVTQVRUUlNfU0VSVklDRV9JTlNUQU5DRV9JRCwgU0VNUkVTQVRUUlNfU0VSVklDRV9WRVJTSU9OLCBTRU1SRVNBVFRSU19URUxFTUVUUllfU0RLX05BTUUsIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfTEFOR1VBR0UsIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfVkVSU0lPTiwgU0VNUkVTQVRUUlNfVEVMRU1FVFJZX0FVVE9fVkVSU0lPTiwgU0VNUkVTQVRUUlNfV0VCRU5HSU5FX05BTUUsIFNFTVJFU0FUVFJTX1dFQkVOR0lORV9WRVJTSU9OLCBTRU1SRVNBVFRSU19XRUJFTkdJTkVfREVTQ1JJUFRJT04sIFNlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLCBUTVBfQ0xPVURQUk9WSURFUlZBTFVFU19BTElCQUJBX0NMT1VELCBUTVBfQ0xPVURQUk9WSURFUlZBTFVFU19BV1MsIFRNUF9DTE9VRFBST1ZJREVSVkFMVUVTX0FaVVJFLCBUTVBfQ0xPVURQUk9WSURFUlZBTFVFU19HQ1AsIENMT1VEUFJPVklERVJWQUxVRVNfQUxJQkFCQV9DTE9VRCwgQ0xPVURQUk9WSURFUlZBTFVFU19BV1MsIENMT1VEUFJPVklERVJWQUxVRVNfQVpVUkUsIENMT1VEUFJPVklERVJWQUxVRVNfR0NQLCBDbG91ZFByb3ZpZGVyVmFsdWVzLCBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BTElCQUJBX0NMT1VEX0VDUywgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9GQywgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VDMiwgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VDUywgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VLUywgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0xBTUJEQSwgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VMQVNUSUNfQkVBTlNUQUxLLCBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9WTSwgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQ09OVEFJTkVSX0lOU1RBTkNFUywgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQUtTLCBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9GVU5DVElPTlMsIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0FQUF9TRVJWSUNFLCBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ09NUFVURV9FTkdJTkUsIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9DTE9VRF9SVU4sIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9LVUJFUk5FVEVTX0VOR0lORSwgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0NMT1VEX0ZVTkNUSU9OUywgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0FQUF9FTkdJTkUsIENMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9FQ1MsIENMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9GQywgQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUMyLCBDTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FQ1MsIENMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VLUywgQ0xPVURQTEFURk9STVZBTFVFU19BV1NfTEFNQkRBLCBDTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FTEFTVElDX0JFQU5TVEFMSywgQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9WTSwgQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9DT05UQUlORVJfSU5TVEFOQ0VTLCBDTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0FLUywgQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9GVU5DVElPTlMsIENMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQVBQX1NFUlZJQ0UsIENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0NPTVBVVEVfRU5HSU5FLCBDTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9DTE9VRF9SVU4sIENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0tVQkVSTkVURVNfRU5HSU5FLCBDTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9DTE9VRF9GVU5DVElPTlMsIENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0FQUF9FTkdJTkUsIENsb3VkUGxhdGZvcm1WYWx1ZXMsIFRNUF9BV1NFQ1NMQVVOQ0hUWVBFVkFMVUVTX0VDMiwgVE1QX0FXU0VDU0xBVU5DSFRZUEVWQUxVRVNfRkFSR0FURSwgQVdTRUNTTEFVTkNIVFlQRVZBTFVFU19FQzIsIEFXU0VDU0xBVU5DSFRZUEVWQUxVRVNfRkFSR0FURSwgQXdzRWNzTGF1bmNodHlwZVZhbHVlcywgVE1QX0hPU1RBUkNIVkFMVUVTX0FNRDY0LCBUTVBfSE9TVEFSQ0hWQUxVRVNfQVJNMzIsIFRNUF9IT1NUQVJDSFZBTFVFU19BUk02NCwgVE1QX0hPU1RBUkNIVkFMVUVTX0lBNjQsIFRNUF9IT1NUQVJDSFZBTFVFU19QUEMzMiwgVE1QX0hPU1RBUkNIVkFMVUVTX1BQQzY0LCBUTVBfSE9TVEFSQ0hWQUxVRVNfWDg2LCBIT1NUQVJDSFZBTFVFU19BTUQ2NCwgSE9TVEFSQ0hWQUxVRVNfQVJNMzIsIEhPU1RBUkNIVkFMVUVTX0FSTTY0LCBIT1NUQVJDSFZBTFVFU19JQTY0LCBIT1NUQVJDSFZBTFVFU19QUEMzMiwgSE9TVEFSQ0hWQUxVRVNfUFBDNjQsIEhPU1RBUkNIVkFMVUVTX1g4NiwgSG9zdEFyY2hWYWx1ZXMsIFRNUF9PU1RZUEVWQUxVRVNfV0lORE9XUywgVE1QX09TVFlQRVZBTFVFU19MSU5VWCwgVE1QX09TVFlQRVZBTFVFU19EQVJXSU4sIFRNUF9PU1RZUEVWQUxVRVNfRlJFRUJTRCwgVE1QX09TVFlQRVZBTFVFU19ORVRCU0QsIFRNUF9PU1RZUEVWQUxVRVNfT1BFTkJTRCwgVE1QX09TVFlQRVZBTFVFU19EUkFHT05GTFlCU0QsIFRNUF9PU1RZUEVWQUxVRVNfSFBVWCwgVE1QX09TVFlQRVZBTFVFU19BSVgsIFRNUF9PU1RZUEVWQUxVRVNfU09MQVJJUywgVE1QX09TVFlQRVZBTFVFU19aX09TLCBPU1RZUEVWQUxVRVNfV0lORE9XUywgT1NUWVBFVkFMVUVTX0xJTlVYLCBPU1RZUEVWQUxVRVNfREFSV0lOLCBPU1RZUEVWQUxVRVNfRlJFRUJTRCwgT1NUWVBFVkFMVUVTX05FVEJTRCwgT1NUWVBFVkFMVUVTX09QRU5CU0QsIE9TVFlQRVZBTFVFU19EUkFHT05GTFlCU0QsIE9TVFlQRVZBTFVFU19IUFVYLCBPU1RZUEVWQUxVRVNfQUlYLCBPU1RZUEVWQUxVRVNfU09MQVJJUywgT1NUWVBFVkFMVUVTX1pfT1MsIE9zVHlwZVZhbHVlcywgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0NQUCwgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0RPVE5FVCwgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0VSTEFORywgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0dPLCBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfSkFWQSwgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX05PREVKUywgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1BIUCwgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1BZVEhPTiwgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1JVQlksIFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19XRUJKUywgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfQ1BQLCBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19ET1RORVQsIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0VSTEFORywgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfR08sIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0pBVkEsIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX05PREVKUywgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfUEhQLCBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19QWVRIT04sIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1JVQlksIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1dFQkpTLCBUZWxlbWV0cnlTZGtMYW5ndWFnZVZhbHVlcztcbnZhciBpbml0X1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9ucy9idWlsZC9lc20vcmVzb3VyY2UvU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuanNcIigpIHtcbiAgICBpbml0X3V0aWxzNCgpO1xuICAgIFRNUF9DTE9VRF9QUk9WSURFUiA9IFwiY2xvdWQucHJvdmlkZXJcIjtcbiAgICBUTVBfQ0xPVURfQUNDT1VOVF9JRCA9IFwiY2xvdWQuYWNjb3VudC5pZFwiO1xuICAgIFRNUF9DTE9VRF9SRUdJT04gPSBcImNsb3VkLnJlZ2lvblwiO1xuICAgIFRNUF9DTE9VRF9BVkFJTEFCSUxJVFlfWk9ORSA9IFwiY2xvdWQuYXZhaWxhYmlsaXR5X3pvbmVcIjtcbiAgICBUTVBfQ0xPVURfUExBVEZPUk0gPSBcImNsb3VkLnBsYXRmb3JtXCI7XG4gICAgVE1QX0FXU19FQ1NfQ09OVEFJTkVSX0FSTiA9IFwiYXdzLmVjcy5jb250YWluZXIuYXJuXCI7XG4gICAgVE1QX0FXU19FQ1NfQ0xVU1RFUl9BUk4gPSBcImF3cy5lY3MuY2x1c3Rlci5hcm5cIjtcbiAgICBUTVBfQVdTX0VDU19MQVVOQ0hUWVBFID0gXCJhd3MuZWNzLmxhdW5jaHR5cGVcIjtcbiAgICBUTVBfQVdTX0VDU19UQVNLX0FSTiA9IFwiYXdzLmVjcy50YXNrLmFyblwiO1xuICAgIFRNUF9BV1NfRUNTX1RBU0tfRkFNSUxZID0gXCJhd3MuZWNzLnRhc2suZmFtaWx5XCI7XG4gICAgVE1QX0FXU19FQ1NfVEFTS19SRVZJU0lPTiA9IFwiYXdzLmVjcy50YXNrLnJldmlzaW9uXCI7XG4gICAgVE1QX0FXU19FS1NfQ0xVU1RFUl9BUk4gPSBcImF3cy5la3MuY2x1c3Rlci5hcm5cIjtcbiAgICBUTVBfQVdTX0xPR19HUk9VUF9OQU1FUyA9IFwiYXdzLmxvZy5ncm91cC5uYW1lc1wiO1xuICAgIFRNUF9BV1NfTE9HX0dST1VQX0FSTlMgPSBcImF3cy5sb2cuZ3JvdXAuYXJuc1wiO1xuICAgIFRNUF9BV1NfTE9HX1NUUkVBTV9OQU1FUyA9IFwiYXdzLmxvZy5zdHJlYW0ubmFtZXNcIjtcbiAgICBUTVBfQVdTX0xPR19TVFJFQU1fQVJOUyA9IFwiYXdzLmxvZy5zdHJlYW0uYXJuc1wiO1xuICAgIFRNUF9DT05UQUlORVJfTkFNRSA9IFwiY29udGFpbmVyLm5hbWVcIjtcbiAgICBUTVBfQ09OVEFJTkVSX0lEID0gXCJjb250YWluZXIuaWRcIjtcbiAgICBUTVBfQ09OVEFJTkVSX1JVTlRJTUUgPSBcImNvbnRhaW5lci5ydW50aW1lXCI7XG4gICAgVE1QX0NPTlRBSU5FUl9JTUFHRV9OQU1FID0gXCJjb250YWluZXIuaW1hZ2UubmFtZVwiO1xuICAgIFRNUF9DT05UQUlORVJfSU1BR0VfVEFHID0gXCJjb250YWluZXIuaW1hZ2UudGFnXCI7XG4gICAgVE1QX0RFUExPWU1FTlRfRU5WSVJPTk1FTlQgPSBcImRlcGxveW1lbnQuZW52aXJvbm1lbnRcIjtcbiAgICBUTVBfREVWSUNFX0lEID0gXCJkZXZpY2UuaWRcIjtcbiAgICBUTVBfREVWSUNFX01PREVMX0lERU5USUZJRVIgPSBcImRldmljZS5tb2RlbC5pZGVudGlmaWVyXCI7XG4gICAgVE1QX0RFVklDRV9NT0RFTF9OQU1FID0gXCJkZXZpY2UubW9kZWwubmFtZVwiO1xuICAgIFRNUF9GQUFTX05BTUUgPSBcImZhYXMubmFtZVwiO1xuICAgIFRNUF9GQUFTX0lEID0gXCJmYWFzLmlkXCI7XG4gICAgVE1QX0ZBQVNfVkVSU0lPTiA9IFwiZmFhcy52ZXJzaW9uXCI7XG4gICAgVE1QX0ZBQVNfSU5TVEFOQ0UgPSBcImZhYXMuaW5zdGFuY2VcIjtcbiAgICBUTVBfRkFBU19NQVhfTUVNT1JZID0gXCJmYWFzLm1heF9tZW1vcnlcIjtcbiAgICBUTVBfSE9TVF9JRCA9IFwiaG9zdC5pZFwiO1xuICAgIFRNUF9IT1NUX05BTUUgPSBcImhvc3QubmFtZVwiO1xuICAgIFRNUF9IT1NUX1RZUEUgPSBcImhvc3QudHlwZVwiO1xuICAgIFRNUF9IT1NUX0FSQ0ggPSBcImhvc3QuYXJjaFwiO1xuICAgIFRNUF9IT1NUX0lNQUdFX05BTUUgPSBcImhvc3QuaW1hZ2UubmFtZVwiO1xuICAgIFRNUF9IT1NUX0lNQUdFX0lEID0gXCJob3N0LmltYWdlLmlkXCI7XG4gICAgVE1QX0hPU1RfSU1BR0VfVkVSU0lPTiA9IFwiaG9zdC5pbWFnZS52ZXJzaW9uXCI7XG4gICAgVE1QX0s4U19DTFVTVEVSX05BTUUgPSBcIms4cy5jbHVzdGVyLm5hbWVcIjtcbiAgICBUTVBfSzhTX05PREVfTkFNRSA9IFwiazhzLm5vZGUubmFtZVwiO1xuICAgIFRNUF9LOFNfTk9ERV9VSUQgPSBcIms4cy5ub2RlLnVpZFwiO1xuICAgIFRNUF9LOFNfTkFNRVNQQUNFX05BTUUgPSBcIms4cy5uYW1lc3BhY2UubmFtZVwiO1xuICAgIFRNUF9LOFNfUE9EX1VJRCA9IFwiazhzLnBvZC51aWRcIjtcbiAgICBUTVBfSzhTX1BPRF9OQU1FID0gXCJrOHMucG9kLm5hbWVcIjtcbiAgICBUTVBfSzhTX0NPTlRBSU5FUl9OQU1FID0gXCJrOHMuY29udGFpbmVyLm5hbWVcIjtcbiAgICBUTVBfSzhTX1JFUExJQ0FTRVRfVUlEID0gXCJrOHMucmVwbGljYXNldC51aWRcIjtcbiAgICBUTVBfSzhTX1JFUExJQ0FTRVRfTkFNRSA9IFwiazhzLnJlcGxpY2FzZXQubmFtZVwiO1xuICAgIFRNUF9LOFNfREVQTE9ZTUVOVF9VSUQgPSBcIms4cy5kZXBsb3ltZW50LnVpZFwiO1xuICAgIFRNUF9LOFNfREVQTE9ZTUVOVF9OQU1FID0gXCJrOHMuZGVwbG95bWVudC5uYW1lXCI7XG4gICAgVE1QX0s4U19TVEFURUZVTFNFVF9VSUQgPSBcIms4cy5zdGF0ZWZ1bHNldC51aWRcIjtcbiAgICBUTVBfSzhTX1NUQVRFRlVMU0VUX05BTUUgPSBcIms4cy5zdGF0ZWZ1bHNldC5uYW1lXCI7XG4gICAgVE1QX0s4U19EQUVNT05TRVRfVUlEID0gXCJrOHMuZGFlbW9uc2V0LnVpZFwiO1xuICAgIFRNUF9LOFNfREFFTU9OU0VUX05BTUUgPSBcIms4cy5kYWVtb25zZXQubmFtZVwiO1xuICAgIFRNUF9LOFNfSk9CX1VJRCA9IFwiazhzLmpvYi51aWRcIjtcbiAgICBUTVBfSzhTX0pPQl9OQU1FID0gXCJrOHMuam9iLm5hbWVcIjtcbiAgICBUTVBfSzhTX0NST05KT0JfVUlEID0gXCJrOHMuY3JvbmpvYi51aWRcIjtcbiAgICBUTVBfSzhTX0NST05KT0JfTkFNRSA9IFwiazhzLmNyb25qb2IubmFtZVwiO1xuICAgIFRNUF9PU19UWVBFID0gXCJvcy50eXBlXCI7XG4gICAgVE1QX09TX0RFU0NSSVBUSU9OID0gXCJvcy5kZXNjcmlwdGlvblwiO1xuICAgIFRNUF9PU19OQU1FID0gXCJvcy5uYW1lXCI7XG4gICAgVE1QX09TX1ZFUlNJT04gPSBcIm9zLnZlcnNpb25cIjtcbiAgICBUTVBfUFJPQ0VTU19QSUQgPSBcInByb2Nlc3MucGlkXCI7XG4gICAgVE1QX1BST0NFU1NfRVhFQ1VUQUJMRV9OQU1FID0gXCJwcm9jZXNzLmV4ZWN1dGFibGUubmFtZVwiO1xuICAgIFRNUF9QUk9DRVNTX0VYRUNVVEFCTEVfUEFUSCA9IFwicHJvY2Vzcy5leGVjdXRhYmxlLnBhdGhcIjtcbiAgICBUTVBfUFJPQ0VTU19DT01NQU5EID0gXCJwcm9jZXNzLmNvbW1hbmRcIjtcbiAgICBUTVBfUFJPQ0VTU19DT01NQU5EX0xJTkUgPSBcInByb2Nlc3MuY29tbWFuZF9saW5lXCI7XG4gICAgVE1QX1BST0NFU1NfQ09NTUFORF9BUkdTID0gXCJwcm9jZXNzLmNvbW1hbmRfYXJnc1wiO1xuICAgIFRNUF9QUk9DRVNTX09XTkVSID0gXCJwcm9jZXNzLm93bmVyXCI7XG4gICAgVE1QX1BST0NFU1NfUlVOVElNRV9OQU1FID0gXCJwcm9jZXNzLnJ1bnRpbWUubmFtZVwiO1xuICAgIFRNUF9QUk9DRVNTX1JVTlRJTUVfVkVSU0lPTiA9IFwicHJvY2Vzcy5ydW50aW1lLnZlcnNpb25cIjtcbiAgICBUTVBfUFJPQ0VTU19SVU5USU1FX0RFU0NSSVBUSU9OID0gXCJwcm9jZXNzLnJ1bnRpbWUuZGVzY3JpcHRpb25cIjtcbiAgICBUTVBfU0VSVklDRV9OQU1FID0gXCJzZXJ2aWNlLm5hbWVcIjtcbiAgICBUTVBfU0VSVklDRV9OQU1FU1BBQ0UgPSBcInNlcnZpY2UubmFtZXNwYWNlXCI7XG4gICAgVE1QX1NFUlZJQ0VfSU5TVEFOQ0VfSUQgPSBcInNlcnZpY2UuaW5zdGFuY2UuaWRcIjtcbiAgICBUTVBfU0VSVklDRV9WRVJTSU9OID0gXCJzZXJ2aWNlLnZlcnNpb25cIjtcbiAgICBUTVBfVEVMRU1FVFJZX1NES19OQU1FID0gXCJ0ZWxlbWV0cnkuc2RrLm5hbWVcIjtcbiAgICBUTVBfVEVMRU1FVFJZX1NES19MQU5HVUFHRSA9IFwidGVsZW1ldHJ5LnNkay5sYW5ndWFnZVwiO1xuICAgIFRNUF9URUxFTUVUUllfU0RLX1ZFUlNJT04gPSBcInRlbGVtZXRyeS5zZGsudmVyc2lvblwiO1xuICAgIFRNUF9URUxFTUVUUllfQVVUT19WRVJTSU9OID0gXCJ0ZWxlbWV0cnkuYXV0by52ZXJzaW9uXCI7XG4gICAgVE1QX1dFQkVOR0lORV9OQU1FID0gXCJ3ZWJlbmdpbmUubmFtZVwiO1xuICAgIFRNUF9XRUJFTkdJTkVfVkVSU0lPTiA9IFwid2ViZW5naW5lLnZlcnNpb25cIjtcbiAgICBUTVBfV0VCRU5HSU5FX0RFU0NSSVBUSU9OID0gXCJ3ZWJlbmdpbmUuZGVzY3JpcHRpb25cIjtcbiAgICBTRU1SRVNBVFRSU19DTE9VRF9QUk9WSURFUiA9IFRNUF9DTE9VRF9QUk9WSURFUjtcbiAgICBTRU1SRVNBVFRSU19DTE9VRF9BQ0NPVU5UX0lEID0gVE1QX0NMT1VEX0FDQ09VTlRfSUQ7XG4gICAgU0VNUkVTQVRUUlNfQ0xPVURfUkVHSU9OID0gVE1QX0NMT1VEX1JFR0lPTjtcbiAgICBTRU1SRVNBVFRSU19DTE9VRF9BVkFJTEFCSUxJVFlfWk9ORSA9IFRNUF9DTE9VRF9BVkFJTEFCSUxJVFlfWk9ORTtcbiAgICBTRU1SRVNBVFRSU19DTE9VRF9QTEFURk9STSA9IFRNUF9DTE9VRF9QTEFURk9STTtcbiAgICBTRU1SRVNBVFRSU19BV1NfRUNTX0NPTlRBSU5FUl9BUk4gPSBUTVBfQVdTX0VDU19DT05UQUlORVJfQVJOO1xuICAgIFNFTVJFU0FUVFJTX0FXU19FQ1NfQ0xVU1RFUl9BUk4gPSBUTVBfQVdTX0VDU19DTFVTVEVSX0FSTjtcbiAgICBTRU1SRVNBVFRSU19BV1NfRUNTX0xBVU5DSFRZUEUgPSBUTVBfQVdTX0VDU19MQVVOQ0hUWVBFO1xuICAgIFNFTVJFU0FUVFJTX0FXU19FQ1NfVEFTS19BUk4gPSBUTVBfQVdTX0VDU19UQVNLX0FSTjtcbiAgICBTRU1SRVNBVFRSU19BV1NfRUNTX1RBU0tfRkFNSUxZID0gVE1QX0FXU19FQ1NfVEFTS19GQU1JTFk7XG4gICAgU0VNUkVTQVRUUlNfQVdTX0VDU19UQVNLX1JFVklTSU9OID0gVE1QX0FXU19FQ1NfVEFTS19SRVZJU0lPTjtcbiAgICBTRU1SRVNBVFRSU19BV1NfRUtTX0NMVVNURVJfQVJOID0gVE1QX0FXU19FS1NfQ0xVU1RFUl9BUk47XG4gICAgU0VNUkVTQVRUUlNfQVdTX0xPR19HUk9VUF9OQU1FUyA9IFRNUF9BV1NfTE9HX0dST1VQX05BTUVTO1xuICAgIFNFTVJFU0FUVFJTX0FXU19MT0dfR1JPVVBfQVJOUyA9IFRNUF9BV1NfTE9HX0dST1VQX0FSTlM7XG4gICAgU0VNUkVTQVRUUlNfQVdTX0xPR19TVFJFQU1fTkFNRVMgPSBUTVBfQVdTX0xPR19TVFJFQU1fTkFNRVM7XG4gICAgU0VNUkVTQVRUUlNfQVdTX0xPR19TVFJFQU1fQVJOUyA9IFRNUF9BV1NfTE9HX1NUUkVBTV9BUk5TO1xuICAgIFNFTVJFU0FUVFJTX0NPTlRBSU5FUl9OQU1FID0gVE1QX0NPTlRBSU5FUl9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX0NPTlRBSU5FUl9JRCA9IFRNUF9DT05UQUlORVJfSUQ7XG4gICAgU0VNUkVTQVRUUlNfQ09OVEFJTkVSX1JVTlRJTUUgPSBUTVBfQ09OVEFJTkVSX1JVTlRJTUU7XG4gICAgU0VNUkVTQVRUUlNfQ09OVEFJTkVSX0lNQUdFX05BTUUgPSBUTVBfQ09OVEFJTkVSX0lNQUdFX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfQ09OVEFJTkVSX0lNQUdFX1RBRyA9IFRNUF9DT05UQUlORVJfSU1BR0VfVEFHO1xuICAgIFNFTVJFU0FUVFJTX0RFUExPWU1FTlRfRU5WSVJPTk1FTlQgPSBUTVBfREVQTE9ZTUVOVF9FTlZJUk9OTUVOVDtcbiAgICBTRU1SRVNBVFRSU19ERVZJQ0VfSUQgPSBUTVBfREVWSUNFX0lEO1xuICAgIFNFTVJFU0FUVFJTX0RFVklDRV9NT0RFTF9JREVOVElGSUVSID0gVE1QX0RFVklDRV9NT0RFTF9JREVOVElGSUVSO1xuICAgIFNFTVJFU0FUVFJTX0RFVklDRV9NT0RFTF9OQU1FID0gVE1QX0RFVklDRV9NT0RFTF9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX0ZBQVNfTkFNRSA9IFRNUF9GQUFTX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfRkFBU19JRCA9IFRNUF9GQUFTX0lEO1xuICAgIFNFTVJFU0FUVFJTX0ZBQVNfVkVSU0lPTiA9IFRNUF9GQUFTX1ZFUlNJT047XG4gICAgU0VNUkVTQVRUUlNfRkFBU19JTlNUQU5DRSA9IFRNUF9GQUFTX0lOU1RBTkNFO1xuICAgIFNFTVJFU0FUVFJTX0ZBQVNfTUFYX01FTU9SWSA9IFRNUF9GQUFTX01BWF9NRU1PUlk7XG4gICAgU0VNUkVTQVRUUlNfSE9TVF9JRCA9IFRNUF9IT1NUX0lEO1xuICAgIFNFTVJFU0FUVFJTX0hPU1RfTkFNRSA9IFRNUF9IT1NUX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfSE9TVF9UWVBFID0gVE1QX0hPU1RfVFlQRTtcbiAgICBTRU1SRVNBVFRSU19IT1NUX0FSQ0ggPSBUTVBfSE9TVF9BUkNIO1xuICAgIFNFTVJFU0FUVFJTX0hPU1RfSU1BR0VfTkFNRSA9IFRNUF9IT1NUX0lNQUdFX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfSE9TVF9JTUFHRV9JRCA9IFRNUF9IT1NUX0lNQUdFX0lEO1xuICAgIFNFTVJFU0FUVFJTX0hPU1RfSU1BR0VfVkVSU0lPTiA9IFRNUF9IT1NUX0lNQUdFX1ZFUlNJT047XG4gICAgU0VNUkVTQVRUUlNfSzhTX0NMVVNURVJfTkFNRSA9IFRNUF9LOFNfQ0xVU1RFUl9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX0s4U19OT0RFX05BTUUgPSBUTVBfSzhTX05PREVfTkFNRTtcbiAgICBTRU1SRVNBVFRSU19LOFNfTk9ERV9VSUQgPSBUTVBfSzhTX05PREVfVUlEO1xuICAgIFNFTVJFU0FUVFJTX0s4U19OQU1FU1BBQ0VfTkFNRSA9IFRNUF9LOFNfTkFNRVNQQUNFX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfSzhTX1BPRF9VSUQgPSBUTVBfSzhTX1BPRF9VSUQ7XG4gICAgU0VNUkVTQVRUUlNfSzhTX1BPRF9OQU1FID0gVE1QX0s4U19QT0RfTkFNRTtcbiAgICBTRU1SRVNBVFRSU19LOFNfQ09OVEFJTkVSX05BTUUgPSBUTVBfSzhTX0NPTlRBSU5FUl9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX0s4U19SRVBMSUNBU0VUX1VJRCA9IFRNUF9LOFNfUkVQTElDQVNFVF9VSUQ7XG4gICAgU0VNUkVTQVRUUlNfSzhTX1JFUExJQ0FTRVRfTkFNRSA9IFRNUF9LOFNfUkVQTElDQVNFVF9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX0s4U19ERVBMT1lNRU5UX1VJRCA9IFRNUF9LOFNfREVQTE9ZTUVOVF9VSUQ7XG4gICAgU0VNUkVTQVRUUlNfSzhTX0RFUExPWU1FTlRfTkFNRSA9IFRNUF9LOFNfREVQTE9ZTUVOVF9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX0s4U19TVEFURUZVTFNFVF9VSUQgPSBUTVBfSzhTX1NUQVRFRlVMU0VUX1VJRDtcbiAgICBTRU1SRVNBVFRSU19LOFNfU1RBVEVGVUxTRVRfTkFNRSA9IFRNUF9LOFNfU1RBVEVGVUxTRVRfTkFNRTtcbiAgICBTRU1SRVNBVFRSU19LOFNfREFFTU9OU0VUX1VJRCA9IFRNUF9LOFNfREFFTU9OU0VUX1VJRDtcbiAgICBTRU1SRVNBVFRSU19LOFNfREFFTU9OU0VUX05BTUUgPSBUTVBfSzhTX0RBRU1PTlNFVF9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX0s4U19KT0JfVUlEID0gVE1QX0s4U19KT0JfVUlEO1xuICAgIFNFTVJFU0FUVFJTX0s4U19KT0JfTkFNRSA9IFRNUF9LOFNfSk9CX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfSzhTX0NST05KT0JfVUlEID0gVE1QX0s4U19DUk9OSk9CX1VJRDtcbiAgICBTRU1SRVNBVFRSU19LOFNfQ1JPTkpPQl9OQU1FID0gVE1QX0s4U19DUk9OSk9CX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfT1NfVFlQRSA9IFRNUF9PU19UWVBFO1xuICAgIFNFTVJFU0FUVFJTX09TX0RFU0NSSVBUSU9OID0gVE1QX09TX0RFU0NSSVBUSU9OO1xuICAgIFNFTVJFU0FUVFJTX09TX05BTUUgPSBUTVBfT1NfTkFNRTtcbiAgICBTRU1SRVNBVFRSU19PU19WRVJTSU9OID0gVE1QX09TX1ZFUlNJT047XG4gICAgU0VNUkVTQVRUUlNfUFJPQ0VTU19QSUQgPSBUTVBfUFJPQ0VTU19QSUQ7XG4gICAgU0VNUkVTQVRUUlNfUFJPQ0VTU19FWEVDVVRBQkxFX05BTUUgPSBUTVBfUFJPQ0VTU19FWEVDVVRBQkxFX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfUFJPQ0VTU19FWEVDVVRBQkxFX1BBVEggPSBUTVBfUFJPQ0VTU19FWEVDVVRBQkxFX1BBVEg7XG4gICAgU0VNUkVTQVRUUlNfUFJPQ0VTU19DT01NQU5EID0gVE1QX1BST0NFU1NfQ09NTUFORDtcbiAgICBTRU1SRVNBVFRSU19QUk9DRVNTX0NPTU1BTkRfTElORSA9IFRNUF9QUk9DRVNTX0NPTU1BTkRfTElORTtcbiAgICBTRU1SRVNBVFRSU19QUk9DRVNTX0NPTU1BTkRfQVJHUyA9IFRNUF9QUk9DRVNTX0NPTU1BTkRfQVJHUztcbiAgICBTRU1SRVNBVFRSU19QUk9DRVNTX09XTkVSID0gVE1QX1BST0NFU1NfT1dORVI7XG4gICAgU0VNUkVTQVRUUlNfUFJPQ0VTU19SVU5USU1FX05BTUUgPSBUTVBfUFJPQ0VTU19SVU5USU1FX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfUFJPQ0VTU19SVU5USU1FX1ZFUlNJT04gPSBUTVBfUFJPQ0VTU19SVU5USU1FX1ZFUlNJT047XG4gICAgU0VNUkVTQVRUUlNfUFJPQ0VTU19SVU5USU1FX0RFU0NSSVBUSU9OID0gVE1QX1BST0NFU1NfUlVOVElNRV9ERVNDUklQVElPTjtcbiAgICBTRU1SRVNBVFRSU19TRVJWSUNFX05BTUUgPSBUTVBfU0VSVklDRV9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX1NFUlZJQ0VfTkFNRVNQQUNFID0gVE1QX1NFUlZJQ0VfTkFNRVNQQUNFO1xuICAgIFNFTVJFU0FUVFJTX1NFUlZJQ0VfSU5TVEFOQ0VfSUQgPSBUTVBfU0VSVklDRV9JTlNUQU5DRV9JRDtcbiAgICBTRU1SRVNBVFRSU19TRVJWSUNFX1ZFUlNJT04gPSBUTVBfU0VSVklDRV9WRVJTSU9OO1xuICAgIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfTkFNRSA9IFRNUF9URUxFTUVUUllfU0RLX05BTUU7XG4gICAgU0VNUkVTQVRUUlNfVEVMRU1FVFJZX1NES19MQU5HVUFHRSA9IFRNUF9URUxFTUVUUllfU0RLX0xBTkdVQUdFO1xuICAgIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfVkVSU0lPTiA9IFRNUF9URUxFTUVUUllfU0RLX1ZFUlNJT047XG4gICAgU0VNUkVTQVRUUlNfVEVMRU1FVFJZX0FVVE9fVkVSU0lPTiA9IFRNUF9URUxFTUVUUllfQVVUT19WRVJTSU9OO1xuICAgIFNFTVJFU0FUVFJTX1dFQkVOR0lORV9OQU1FID0gVE1QX1dFQkVOR0lORV9OQU1FO1xuICAgIFNFTVJFU0FUVFJTX1dFQkVOR0lORV9WRVJTSU9OID0gVE1QX1dFQkVOR0lORV9WRVJTSU9OO1xuICAgIFNFTVJFU0FUVFJTX1dFQkVOR0lORV9ERVNDUklQVElPTiA9IFRNUF9XRUJFTkdJTkVfREVTQ1JJUFRJT047XG4gICAgU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RNYXAoW1xuICAgICAgVE1QX0NMT1VEX1BST1ZJREVSLFxuICAgICAgVE1QX0NMT1VEX0FDQ09VTlRfSUQsXG4gICAgICBUTVBfQ0xPVURfUkVHSU9OLFxuICAgICAgVE1QX0NMT1VEX0FWQUlMQUJJTElUWV9aT05FLFxuICAgICAgVE1QX0NMT1VEX1BMQVRGT1JNLFxuICAgICAgVE1QX0FXU19FQ1NfQ09OVEFJTkVSX0FSTixcbiAgICAgIFRNUF9BV1NfRUNTX0NMVVNURVJfQVJOLFxuICAgICAgVE1QX0FXU19FQ1NfTEFVTkNIVFlQRSxcbiAgICAgIFRNUF9BV1NfRUNTX1RBU0tfQVJOLFxuICAgICAgVE1QX0FXU19FQ1NfVEFTS19GQU1JTFksXG4gICAgICBUTVBfQVdTX0VDU19UQVNLX1JFVklTSU9OLFxuICAgICAgVE1QX0FXU19FS1NfQ0xVU1RFUl9BUk4sXG4gICAgICBUTVBfQVdTX0xPR19HUk9VUF9OQU1FUyxcbiAgICAgIFRNUF9BV1NfTE9HX0dST1VQX0FSTlMsXG4gICAgICBUTVBfQVdTX0xPR19TVFJFQU1fTkFNRVMsXG4gICAgICBUTVBfQVdTX0xPR19TVFJFQU1fQVJOUyxcbiAgICAgIFRNUF9DT05UQUlORVJfTkFNRSxcbiAgICAgIFRNUF9DT05UQUlORVJfSUQsXG4gICAgICBUTVBfQ09OVEFJTkVSX1JVTlRJTUUsXG4gICAgICBUTVBfQ09OVEFJTkVSX0lNQUdFX05BTUUsXG4gICAgICBUTVBfQ09OVEFJTkVSX0lNQUdFX1RBRyxcbiAgICAgIFRNUF9ERVBMT1lNRU5UX0VOVklST05NRU5ULFxuICAgICAgVE1QX0RFVklDRV9JRCxcbiAgICAgIFRNUF9ERVZJQ0VfTU9ERUxfSURFTlRJRklFUixcbiAgICAgIFRNUF9ERVZJQ0VfTU9ERUxfTkFNRSxcbiAgICAgIFRNUF9GQUFTX05BTUUsXG4gICAgICBUTVBfRkFBU19JRCxcbiAgICAgIFRNUF9GQUFTX1ZFUlNJT04sXG4gICAgICBUTVBfRkFBU19JTlNUQU5DRSxcbiAgICAgIFRNUF9GQUFTX01BWF9NRU1PUlksXG4gICAgICBUTVBfSE9TVF9JRCxcbiAgICAgIFRNUF9IT1NUX05BTUUsXG4gICAgICBUTVBfSE9TVF9UWVBFLFxuICAgICAgVE1QX0hPU1RfQVJDSCxcbiAgICAgIFRNUF9IT1NUX0lNQUdFX05BTUUsXG4gICAgICBUTVBfSE9TVF9JTUFHRV9JRCxcbiAgICAgIFRNUF9IT1NUX0lNQUdFX1ZFUlNJT04sXG4gICAgICBUTVBfSzhTX0NMVVNURVJfTkFNRSxcbiAgICAgIFRNUF9LOFNfTk9ERV9OQU1FLFxuICAgICAgVE1QX0s4U19OT0RFX1VJRCxcbiAgICAgIFRNUF9LOFNfTkFNRVNQQUNFX05BTUUsXG4gICAgICBUTVBfSzhTX1BPRF9VSUQsXG4gICAgICBUTVBfSzhTX1BPRF9OQU1FLFxuICAgICAgVE1QX0s4U19DT05UQUlORVJfTkFNRSxcbiAgICAgIFRNUF9LOFNfUkVQTElDQVNFVF9VSUQsXG4gICAgICBUTVBfSzhTX1JFUExJQ0FTRVRfTkFNRSxcbiAgICAgIFRNUF9LOFNfREVQTE9ZTUVOVF9VSUQsXG4gICAgICBUTVBfSzhTX0RFUExPWU1FTlRfTkFNRSxcbiAgICAgIFRNUF9LOFNfU1RBVEVGVUxTRVRfVUlELFxuICAgICAgVE1QX0s4U19TVEFURUZVTFNFVF9OQU1FLFxuICAgICAgVE1QX0s4U19EQUVNT05TRVRfVUlELFxuICAgICAgVE1QX0s4U19EQUVNT05TRVRfTkFNRSxcbiAgICAgIFRNUF9LOFNfSk9CX1VJRCxcbiAgICAgIFRNUF9LOFNfSk9CX05BTUUsXG4gICAgICBUTVBfSzhTX0NST05KT0JfVUlELFxuICAgICAgVE1QX0s4U19DUk9OSk9CX05BTUUsXG4gICAgICBUTVBfT1NfVFlQRSxcbiAgICAgIFRNUF9PU19ERVNDUklQVElPTixcbiAgICAgIFRNUF9PU19OQU1FLFxuICAgICAgVE1QX09TX1ZFUlNJT04sXG4gICAgICBUTVBfUFJPQ0VTU19QSUQsXG4gICAgICBUTVBfUFJPQ0VTU19FWEVDVVRBQkxFX05BTUUsXG4gICAgICBUTVBfUFJPQ0VTU19FWEVDVVRBQkxFX1BBVEgsXG4gICAgICBUTVBfUFJPQ0VTU19DT01NQU5ELFxuICAgICAgVE1QX1BST0NFU1NfQ09NTUFORF9MSU5FLFxuICAgICAgVE1QX1BST0NFU1NfQ09NTUFORF9BUkdTLFxuICAgICAgVE1QX1BST0NFU1NfT1dORVIsXG4gICAgICBUTVBfUFJPQ0VTU19SVU5USU1FX05BTUUsXG4gICAgICBUTVBfUFJPQ0VTU19SVU5USU1FX1ZFUlNJT04sXG4gICAgICBUTVBfUFJPQ0VTU19SVU5USU1FX0RFU0NSSVBUSU9OLFxuICAgICAgVE1QX1NFUlZJQ0VfTkFNRSxcbiAgICAgIFRNUF9TRVJWSUNFX05BTUVTUEFDRSxcbiAgICAgIFRNUF9TRVJWSUNFX0lOU1RBTkNFX0lELFxuICAgICAgVE1QX1NFUlZJQ0VfVkVSU0lPTixcbiAgICAgIFRNUF9URUxFTUVUUllfU0RLX05BTUUsXG4gICAgICBUTVBfVEVMRU1FVFJZX1NES19MQU5HVUFHRSxcbiAgICAgIFRNUF9URUxFTUVUUllfU0RLX1ZFUlNJT04sXG4gICAgICBUTVBfVEVMRU1FVFJZX0FVVE9fVkVSU0lPTixcbiAgICAgIFRNUF9XRUJFTkdJTkVfTkFNRSxcbiAgICAgIFRNUF9XRUJFTkdJTkVfVkVSU0lPTixcbiAgICAgIFRNUF9XRUJFTkdJTkVfREVTQ1JJUFRJT05cbiAgICBdKTtcbiAgICBUTVBfQ0xPVURQUk9WSURFUlZBTFVFU19BTElCQUJBX0NMT1VEID0gXCJhbGliYWJhX2Nsb3VkXCI7XG4gICAgVE1QX0NMT1VEUFJPVklERVJWQUxVRVNfQVdTID0gXCJhd3NcIjtcbiAgICBUTVBfQ0xPVURQUk9WSURFUlZBTFVFU19BWlVSRSA9IFwiYXp1cmVcIjtcbiAgICBUTVBfQ0xPVURQUk9WSURFUlZBTFVFU19HQ1AgPSBcImdjcFwiO1xuICAgIENMT1VEUFJPVklERVJWQUxVRVNfQUxJQkFCQV9DTE9VRCA9IFRNUF9DTE9VRFBST1ZJREVSVkFMVUVTX0FMSUJBQkFfQ0xPVUQ7XG4gICAgQ0xPVURQUk9WSURFUlZBTFVFU19BV1MgPSBUTVBfQ0xPVURQUk9WSURFUlZBTFVFU19BV1M7XG4gICAgQ0xPVURQUk9WSURFUlZBTFVFU19BWlVSRSA9IFRNUF9DTE9VRFBST1ZJREVSVkFMVUVTX0FaVVJFO1xuICAgIENMT1VEUFJPVklERVJWQUxVRVNfR0NQID0gVE1QX0NMT1VEUFJPVklERVJWQUxVRVNfR0NQO1xuICAgIENsb3VkUHJvdmlkZXJWYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RNYXAoW1xuICAgICAgVE1QX0NMT1VEUFJPVklERVJWQUxVRVNfQUxJQkFCQV9DTE9VRCxcbiAgICAgIFRNUF9DTE9VRFBST1ZJREVSVkFMVUVTX0FXUyxcbiAgICAgIFRNUF9DTE9VRFBST1ZJREVSVkFMVUVTX0FaVVJFLFxuICAgICAgVE1QX0NMT1VEUFJPVklERVJWQUxVRVNfR0NQXG4gICAgXSk7XG4gICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9FQ1MgPSBcImFsaWJhYmFfY2xvdWRfZWNzXCI7XG4gICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9GQyA9IFwiYWxpYmFiYV9jbG91ZF9mY1wiO1xuICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FQzIgPSBcImF3c19lYzJcIjtcbiAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUNTID0gXCJhd3NfZWNzXCI7XG4gICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VLUyA9IFwiYXdzX2Vrc1wiO1xuICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19MQU1CREEgPSBcImF3c19sYW1iZGFcIjtcbiAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUxBU1RJQ19CRUFOU1RBTEsgPSBcImF3c19lbGFzdGljX2JlYW5zdGFsa1wiO1xuICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX1ZNID0gXCJhenVyZV92bVwiO1xuICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0NPTlRBSU5FUl9JTlNUQU5DRVMgPSBcImF6dXJlX2NvbnRhaW5lcl9pbnN0YW5jZXNcIjtcbiAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9BS1MgPSBcImF6dXJlX2Frc1wiO1xuICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0ZVTkNUSU9OUyA9IFwiYXp1cmVfZnVuY3Rpb25zXCI7XG4gICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQVBQX1NFUlZJQ0UgPSBcImF6dXJlX2FwcF9zZXJ2aWNlXCI7XG4gICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0NPTVBVVEVfRU5HSU5FID0gXCJnY3BfY29tcHV0ZV9lbmdpbmVcIjtcbiAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ0xPVURfUlVOID0gXCJnY3BfY2xvdWRfcnVuXCI7XG4gICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0tVQkVSTkVURVNfRU5HSU5FID0gXCJnY3Bfa3ViZXJuZXRlc19lbmdpbmVcIjtcbiAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ0xPVURfRlVOQ1RJT05TID0gXCJnY3BfY2xvdWRfZnVuY3Rpb25zXCI7XG4gICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0FQUF9FTkdJTkUgPSBcImdjcF9hcHBfZW5naW5lXCI7XG4gICAgQ0xPVURQTEFURk9STVZBTFVFU19BTElCQUJBX0NMT1VEX0VDUyA9IFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FMSUJBQkFfQ0xPVURfRUNTO1xuICAgIENMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9GQyA9IFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FMSUJBQkFfQ0xPVURfRkM7XG4gICAgQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUMyID0gVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VDMjtcbiAgICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FQ1MgPSBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUNTO1xuICAgIENMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VLUyA9IFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FS1M7XG4gICAgQ0xPVURQTEFURk9STVZBTFVFU19BV1NfTEFNQkRBID0gVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0xBTUJEQTtcbiAgICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FTEFTVElDX0JFQU5TVEFMSyA9IFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FTEFTVElDX0JFQU5TVEFMSztcbiAgICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX1ZNID0gVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfVk07XG4gICAgQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9DT05UQUlORVJfSU5TVEFOQ0VTID0gVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQ09OVEFJTkVSX0lOU1RBTkNFUztcbiAgICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0FLUyA9IFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0FLUztcbiAgICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0ZVTkNUSU9OUyA9IFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0ZVTkNUSU9OUztcbiAgICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0FQUF9TRVJWSUNFID0gVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQVBQX1NFUlZJQ0U7XG4gICAgQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ09NUFVURV9FTkdJTkUgPSBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ09NUFVURV9FTkdJTkU7XG4gICAgQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ0xPVURfUlVOID0gVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0NMT1VEX1JVTjtcbiAgICBDTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9LVUJFUk5FVEVTX0VOR0lORSA9IFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9LVUJFUk5FVEVTX0VOR0lORTtcbiAgICBDTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9DTE9VRF9GVU5DVElPTlMgPSBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ0xPVURfRlVOQ1RJT05TO1xuICAgIENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0FQUF9FTkdJTkUgPSBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQVBQX0VOR0lORTtcbiAgICBDbG91ZFBsYXRmb3JtVmFsdWVzID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0TWFwKFtcbiAgICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FMSUJBQkFfQ0xPVURfRUNTLFxuICAgICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9GQyxcbiAgICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FQzIsXG4gICAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUNTLFxuICAgICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VLUyxcbiAgICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19MQU1CREEsXG4gICAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUxBU1RJQ19CRUFOU1RBTEssXG4gICAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9WTSxcbiAgICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0NPTlRBSU5FUl9JTlNUQU5DRVMsXG4gICAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9BS1MsXG4gICAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9GVU5DVElPTlMsXG4gICAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9BUFBfU0VSVklDRSxcbiAgICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9DT01QVVRFX0VOR0lORSxcbiAgICAgIFRNUF9DTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9DTE9VRF9SVU4sXG4gICAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfS1VCRVJORVRFU19FTkdJTkUsXG4gICAgICBUTVBfQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ0xPVURfRlVOQ1RJT05TLFxuICAgICAgVE1QX0NMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0FQUF9FTkdJTkVcbiAgICBdKTtcbiAgICBUTVBfQVdTRUNTTEFVTkNIVFlQRVZBTFVFU19FQzIgPSBcImVjMlwiO1xuICAgIFRNUF9BV1NFQ1NMQVVOQ0hUWVBFVkFMVUVTX0ZBUkdBVEUgPSBcImZhcmdhdGVcIjtcbiAgICBBV1NFQ1NMQVVOQ0hUWVBFVkFMVUVTX0VDMiA9IFRNUF9BV1NFQ1NMQVVOQ0hUWVBFVkFMVUVTX0VDMjtcbiAgICBBV1NFQ1NMQVVOQ0hUWVBFVkFMVUVTX0ZBUkdBVEUgPSBUTVBfQVdTRUNTTEFVTkNIVFlQRVZBTFVFU19GQVJHQVRFO1xuICAgIEF3c0Vjc0xhdW5jaHR5cGVWYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RNYXAoW1xuICAgICAgVE1QX0FXU0VDU0xBVU5DSFRZUEVWQUxVRVNfRUMyLFxuICAgICAgVE1QX0FXU0VDU0xBVU5DSFRZUEVWQUxVRVNfRkFSR0FURVxuICAgIF0pO1xuICAgIFRNUF9IT1NUQVJDSFZBTFVFU19BTUQ2NCA9IFwiYW1kNjRcIjtcbiAgICBUTVBfSE9TVEFSQ0hWQUxVRVNfQVJNMzIgPSBcImFybTMyXCI7XG4gICAgVE1QX0hPU1RBUkNIVkFMVUVTX0FSTTY0ID0gXCJhcm02NFwiO1xuICAgIFRNUF9IT1NUQVJDSFZBTFVFU19JQTY0ID0gXCJpYTY0XCI7XG4gICAgVE1QX0hPU1RBUkNIVkFMVUVTX1BQQzMyID0gXCJwcGMzMlwiO1xuICAgIFRNUF9IT1NUQVJDSFZBTFVFU19QUEM2NCA9IFwicHBjNjRcIjtcbiAgICBUTVBfSE9TVEFSQ0hWQUxVRVNfWDg2ID0gXCJ4ODZcIjtcbiAgICBIT1NUQVJDSFZBTFVFU19BTUQ2NCA9IFRNUF9IT1NUQVJDSFZBTFVFU19BTUQ2NDtcbiAgICBIT1NUQVJDSFZBTFVFU19BUk0zMiA9IFRNUF9IT1NUQVJDSFZBTFVFU19BUk0zMjtcbiAgICBIT1NUQVJDSFZBTFVFU19BUk02NCA9IFRNUF9IT1NUQVJDSFZBTFVFU19BUk02NDtcbiAgICBIT1NUQVJDSFZBTFVFU19JQTY0ID0gVE1QX0hPU1RBUkNIVkFMVUVTX0lBNjQ7XG4gICAgSE9TVEFSQ0hWQUxVRVNfUFBDMzIgPSBUTVBfSE9TVEFSQ0hWQUxVRVNfUFBDMzI7XG4gICAgSE9TVEFSQ0hWQUxVRVNfUFBDNjQgPSBUTVBfSE9TVEFSQ0hWQUxVRVNfUFBDNjQ7XG4gICAgSE9TVEFSQ0hWQUxVRVNfWDg2ID0gVE1QX0hPU1RBUkNIVkFMVUVTX1g4NjtcbiAgICBIb3N0QXJjaFZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb25zdE1hcChbXG4gICAgICBUTVBfSE9TVEFSQ0hWQUxVRVNfQU1ENjQsXG4gICAgICBUTVBfSE9TVEFSQ0hWQUxVRVNfQVJNMzIsXG4gICAgICBUTVBfSE9TVEFSQ0hWQUxVRVNfQVJNNjQsXG4gICAgICBUTVBfSE9TVEFSQ0hWQUxVRVNfSUE2NCxcbiAgICAgIFRNUF9IT1NUQVJDSFZBTFVFU19QUEMzMixcbiAgICAgIFRNUF9IT1NUQVJDSFZBTFVFU19QUEM2NCxcbiAgICAgIFRNUF9IT1NUQVJDSFZBTFVFU19YODZcbiAgICBdKTtcbiAgICBUTVBfT1NUWVBFVkFMVUVTX1dJTkRPV1MgPSBcIndpbmRvd3NcIjtcbiAgICBUTVBfT1NUWVBFVkFMVUVTX0xJTlVYID0gXCJsaW51eFwiO1xuICAgIFRNUF9PU1RZUEVWQUxVRVNfREFSV0lOID0gXCJkYXJ3aW5cIjtcbiAgICBUTVBfT1NUWVBFVkFMVUVTX0ZSRUVCU0QgPSBcImZyZWVic2RcIjtcbiAgICBUTVBfT1NUWVBFVkFMVUVTX05FVEJTRCA9IFwibmV0YnNkXCI7XG4gICAgVE1QX09TVFlQRVZBTFVFU19PUEVOQlNEID0gXCJvcGVuYnNkXCI7XG4gICAgVE1QX09TVFlQRVZBTFVFU19EUkFHT05GTFlCU0QgPSBcImRyYWdvbmZseWJzZFwiO1xuICAgIFRNUF9PU1RZUEVWQUxVRVNfSFBVWCA9IFwiaHB1eFwiO1xuICAgIFRNUF9PU1RZUEVWQUxVRVNfQUlYID0gXCJhaXhcIjtcbiAgICBUTVBfT1NUWVBFVkFMVUVTX1NPTEFSSVMgPSBcInNvbGFyaXNcIjtcbiAgICBUTVBfT1NUWVBFVkFMVUVTX1pfT1MgPSBcInpfb3NcIjtcbiAgICBPU1RZUEVWQUxVRVNfV0lORE9XUyA9IFRNUF9PU1RZUEVWQUxVRVNfV0lORE9XUztcbiAgICBPU1RZUEVWQUxVRVNfTElOVVggPSBUTVBfT1NUWVBFVkFMVUVTX0xJTlVYO1xuICAgIE9TVFlQRVZBTFVFU19EQVJXSU4gPSBUTVBfT1NUWVBFVkFMVUVTX0RBUldJTjtcbiAgICBPU1RZUEVWQUxVRVNfRlJFRUJTRCA9IFRNUF9PU1RZUEVWQUxVRVNfRlJFRUJTRDtcbiAgICBPU1RZUEVWQUxVRVNfTkVUQlNEID0gVE1QX09TVFlQRVZBTFVFU19ORVRCU0Q7XG4gICAgT1NUWVBFVkFMVUVTX09QRU5CU0QgPSBUTVBfT1NUWVBFVkFMVUVTX09QRU5CU0Q7XG4gICAgT1NUWVBFVkFMVUVTX0RSQUdPTkZMWUJTRCA9IFRNUF9PU1RZUEVWQUxVRVNfRFJBR09ORkxZQlNEO1xuICAgIE9TVFlQRVZBTFVFU19IUFVYID0gVE1QX09TVFlQRVZBTFVFU19IUFVYO1xuICAgIE9TVFlQRVZBTFVFU19BSVggPSBUTVBfT1NUWVBFVkFMVUVTX0FJWDtcbiAgICBPU1RZUEVWQUxVRVNfU09MQVJJUyA9IFRNUF9PU1RZUEVWQUxVRVNfU09MQVJJUztcbiAgICBPU1RZUEVWQUxVRVNfWl9PUyA9IFRNUF9PU1RZUEVWQUxVRVNfWl9PUztcbiAgICBPc1R5cGVWYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RNYXAoW1xuICAgICAgVE1QX09TVFlQRVZBTFVFU19XSU5ET1dTLFxuICAgICAgVE1QX09TVFlQRVZBTFVFU19MSU5VWCxcbiAgICAgIFRNUF9PU1RZUEVWQUxVRVNfREFSV0lOLFxuICAgICAgVE1QX09TVFlQRVZBTFVFU19GUkVFQlNELFxuICAgICAgVE1QX09TVFlQRVZBTFVFU19ORVRCU0QsXG4gICAgICBUTVBfT1NUWVBFVkFMVUVTX09QRU5CU0QsXG4gICAgICBUTVBfT1NUWVBFVkFMVUVTX0RSQUdPTkZMWUJTRCxcbiAgICAgIFRNUF9PU1RZUEVWQUxVRVNfSFBVWCxcbiAgICAgIFRNUF9PU1RZUEVWQUxVRVNfQUlYLFxuICAgICAgVE1QX09TVFlQRVZBTFVFU19TT0xBUklTLFxuICAgICAgVE1QX09TVFlQRVZBTFVFU19aX09TXG4gICAgXSk7XG4gICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0NQUCA9IFwiY3BwXCI7XG4gICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0RPVE5FVCA9IFwiZG90bmV0XCI7XG4gICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0VSTEFORyA9IFwiZXJsYW5nXCI7XG4gICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0dPID0gXCJnb1wiO1xuICAgIFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19KQVZBID0gXCJqYXZhXCI7XG4gICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX05PREVKUyA9IFwibm9kZWpzXCI7XG4gICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1BIUCA9IFwicGhwXCI7XG4gICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1BZVEhPTiA9IFwicHl0aG9uXCI7XG4gICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1JVQlkgPSBcInJ1YnlcIjtcbiAgICBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfV0VCSlMgPSBcIndlYmpzXCI7XG4gICAgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfQ1BQID0gVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0NQUDtcbiAgICBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19ET1RORVQgPSBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfRE9UTkVUO1xuICAgIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0VSTEFORyA9IFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19FUkxBTkc7XG4gICAgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfR08gPSBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfR087XG4gICAgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfSkFWQSA9IFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19KQVZBO1xuICAgIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX05PREVKUyA9IFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19OT0RFSlM7XG4gICAgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfUEhQID0gVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1BIUDtcbiAgICBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19QWVRIT04gPSBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfUFlUSE9OO1xuICAgIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1JVQlkgPSBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfUlVCWTtcbiAgICBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19XRUJKUyA9IFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19XRUJKUztcbiAgICBUZWxlbWV0cnlTZGtMYW5ndWFnZVZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb25zdE1hcChbXG4gICAgICBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfQ1BQLFxuICAgICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0RPVE5FVCxcbiAgICAgIFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19FUkxBTkcsXG4gICAgICBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfR08sXG4gICAgICBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfSkFWQSxcbiAgICAgIFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19OT0RFSlMsXG4gICAgICBUTVBfVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfUEhQLFxuICAgICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1BZVEhPTixcbiAgICAgIFRNUF9URUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19SVUJZLFxuICAgICAgVE1QX1RFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1dFQkpTXG4gICAgXSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYnVpbGQvZXNtL3Jlc291cmNlL2luZGV4LmpzXG52YXIgaW5pdF9yZXNvdXJjZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYnVpbGQvZXNtL3Jlc291cmNlL2luZGV4LmpzXCIoKSB7XG4gICAgaW5pdF9TZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zL2J1aWxkL2VzbS9pbmRleC5qc1xudmFyIGVzbV9leHBvcnRzMiA9IHt9O1xuX19leHBvcnQoZXNtX2V4cG9ydHMyLCB7XG4gIEFXU0VDU0xBVU5DSFRZUEVWQUxVRVNfRUMyOiAoKSA9PiBBV1NFQ1NMQVVOQ0hUWVBFVkFMVUVTX0VDMixcbiAgQVdTRUNTTEFVTkNIVFlQRVZBTFVFU19GQVJHQVRFOiAoKSA9PiBBV1NFQ1NMQVVOQ0hUWVBFVkFMVUVTX0ZBUkdBVEUsXG4gIEF3c0Vjc0xhdW5jaHR5cGVWYWx1ZXM6ICgpID0+IEF3c0Vjc0xhdW5jaHR5cGVWYWx1ZXMsXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9FQ1M6ICgpID0+IENMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9FQ1MsXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfQUxJQkFCQV9DTE9VRF9GQzogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19BTElCQUJBX0NMT1VEX0ZDLFxuICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FQzI6ICgpID0+IENMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VDMixcbiAgQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUNTOiAoKSA9PiBDTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FQ1MsXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VLUzogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUtTLFxuICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FTEFTVElDX0JFQU5TVEFMSzogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUxBU1RJQ19CRUFOU1RBTEssXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0xBTUJEQTogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19BV1NfTEFNQkRBLFxuICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0FLUzogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9BS1MsXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQVBQX1NFUlZJQ0U6ICgpID0+IENMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQVBQX1NFUlZJQ0UsXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfQ09OVEFJTkVSX0lOU1RBTkNFUzogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9DT05UQUlORVJfSU5TVEFOQ0VTLFxuICBDTE9VRFBMQVRGT1JNVkFMVUVTX0FaVVJFX0ZVTkNUSU9OUzogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19BWlVSRV9GVU5DVElPTlMsXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfVk06ICgpID0+IENMT1VEUExBVEZPUk1WQUxVRVNfQVpVUkVfVk0sXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0FQUF9FTkdJTkU6ICgpID0+IENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0FQUF9FTkdJTkUsXG4gIENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0NMT1VEX0ZVTkNUSU9OUzogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ0xPVURfRlVOQ1RJT05TLFxuICBDTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9DTE9VRF9SVU46ICgpID0+IENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0NMT1VEX1JVTixcbiAgQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfQ09NUFVURV9FTkdJTkU6ICgpID0+IENMT1VEUExBVEZPUk1WQUxVRVNfR0NQX0NPTVBVVEVfRU5HSU5FLFxuICBDTE9VRFBMQVRGT1JNVkFMVUVTX0dDUF9LVUJFUk5FVEVTX0VOR0lORTogKCkgPT4gQ0xPVURQTEFURk9STVZBTFVFU19HQ1BfS1VCRVJORVRFU19FTkdJTkUsXG4gIENMT1VEUFJPVklERVJWQUxVRVNfQUxJQkFCQV9DTE9VRDogKCkgPT4gQ0xPVURQUk9WSURFUlZBTFVFU19BTElCQUJBX0NMT1VELFxuICBDTE9VRFBST1ZJREVSVkFMVUVTX0FXUzogKCkgPT4gQ0xPVURQUk9WSURFUlZBTFVFU19BV1MsXG4gIENMT1VEUFJPVklERVJWQUxVRVNfQVpVUkU6ICgpID0+IENMT1VEUFJPVklERVJWQUxVRVNfQVpVUkUsXG4gIENMT1VEUFJPVklERVJWQUxVRVNfR0NQOiAoKSA9PiBDTE9VRFBST1ZJREVSVkFMVUVTX0dDUCxcbiAgQ2xvdWRQbGF0Zm9ybVZhbHVlczogKCkgPT4gQ2xvdWRQbGF0Zm9ybVZhbHVlcyxcbiAgQ2xvdWRQcm92aWRlclZhbHVlczogKCkgPT4gQ2xvdWRQcm92aWRlclZhbHVlcyxcbiAgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0FMTDogKCkgPT4gREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0FMTCxcbiAgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0FOWTogKCkgPT4gREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0FOWSxcbiAgREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX0VBQ0hfUVVPUlVNOiAoKSA9PiBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfRUFDSF9RVU9SVU0sXG4gIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9PTkU6ICgpID0+IERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9PTkUsXG4gIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9RVU9SVU06ICgpID0+IERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9RVU9SVU0sXG4gIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9TRVJJQUw6ICgpID0+IERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19MT0NBTF9TRVJJQUwsXG4gIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19PTkU6ICgpID0+IERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19PTkUsXG4gIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19RVU9SVU06ICgpID0+IERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19RVU9SVU0sXG4gIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19TRVJJQUw6ICgpID0+IERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19TRVJJQUwsXG4gIERCQ0FTU0FORFJBQ09OU0lTVEVOQ1lMRVZFTFZBTFVFU19USFJFRTogKCkgPT4gREJDQVNTQU5EUkFDT05TSVNURU5DWUxFVkVMVkFMVUVTX1RIUkVFLFxuICBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfVFdPOiAoKSA9PiBEQkNBU1NBTkRSQUNPTlNJU1RFTkNZTEVWRUxWQUxVRVNfVFdPLFxuICBEQlNZU1RFTVZBTFVFU19BREFCQVM6ICgpID0+IERCU1lTVEVNVkFMVUVTX0FEQUJBUyxcbiAgREJTWVNURU1WQUxVRVNfQ0FDSEU6ICgpID0+IERCU1lTVEVNVkFMVUVTX0NBQ0hFLFxuICBEQlNZU1RFTVZBTFVFU19DQVNTQU5EUkE6ICgpID0+IERCU1lTVEVNVkFMVUVTX0NBU1NBTkRSQSxcbiAgREJTWVNURU1WQUxVRVNfQ0xPVURTQ0FQRTogKCkgPT4gREJTWVNURU1WQUxVRVNfQ0xPVURTQ0FQRSxcbiAgREJTWVNURU1WQUxVRVNfQ09DS1JPQUNIREI6ICgpID0+IERCU1lTVEVNVkFMVUVTX0NPQ0tST0FDSERCLFxuICBEQlNZU1RFTVZBTFVFU19DT0xERlVTSU9OOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19DT0xERlVTSU9OLFxuICBEQlNZU1RFTVZBTFVFU19DT1NNT1NEQjogKCkgPT4gREJTWVNURU1WQUxVRVNfQ09TTU9TREIsXG4gIERCU1lTVEVNVkFMVUVTX0NPVUNIQkFTRTogKCkgPT4gREJTWVNURU1WQUxVRVNfQ09VQ0hCQVNFLFxuICBEQlNZU1RFTVZBTFVFU19DT1VDSERCOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19DT1VDSERCLFxuICBEQlNZU1RFTVZBTFVFU19EQjI6ICgpID0+IERCU1lTVEVNVkFMVUVTX0RCMixcbiAgREJTWVNURU1WQUxVRVNfREVSQlk6ICgpID0+IERCU1lTVEVNVkFMVUVTX0RFUkJZLFxuICBEQlNZU1RFTVZBTFVFU19EWU5BTU9EQjogKCkgPT4gREJTWVNURU1WQUxVRVNfRFlOQU1PREIsXG4gIERCU1lTVEVNVkFMVUVTX0VEQjogKCkgPT4gREJTWVNURU1WQUxVRVNfRURCLFxuICBEQlNZU1RFTVZBTFVFU19FTEFTVElDU0VBUkNIOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19FTEFTVElDU0VBUkNILFxuICBEQlNZU1RFTVZBTFVFU19GSUxFTUFLRVI6ICgpID0+IERCU1lTVEVNVkFMVUVTX0ZJTEVNQUtFUixcbiAgREJTWVNURU1WQUxVRVNfRklSRUJJUkQ6ICgpID0+IERCU1lTVEVNVkFMVUVTX0ZJUkVCSVJELFxuICBEQlNZU1RFTVZBTFVFU19GSVJTVFNRTDogKCkgPT4gREJTWVNURU1WQUxVRVNfRklSU1RTUUwsXG4gIERCU1lTVEVNVkFMVUVTX0dFT0RFOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19HRU9ERSxcbiAgREJTWVNURU1WQUxVRVNfSDI6ICgpID0+IERCU1lTVEVNVkFMVUVTX0gyLFxuICBEQlNZU1RFTVZBTFVFU19IQU5BREI6ICgpID0+IERCU1lTVEVNVkFMVUVTX0hBTkFEQixcbiAgREJTWVNURU1WQUxVRVNfSEJBU0U6ICgpID0+IERCU1lTVEVNVkFMVUVTX0hCQVNFLFxuICBEQlNZU1RFTVZBTFVFU19ISVZFOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19ISVZFLFxuICBEQlNZU1RFTVZBTFVFU19IU1FMREI6ICgpID0+IERCU1lTVEVNVkFMVUVTX0hTUUxEQixcbiAgREJTWVNURU1WQUxVRVNfSU5GT1JNSVg6ICgpID0+IERCU1lTVEVNVkFMVUVTX0lORk9STUlYLFxuICBEQlNZU1RFTVZBTFVFU19JTkdSRVM6ICgpID0+IERCU1lTVEVNVkFMVUVTX0lOR1JFUyxcbiAgREJTWVNURU1WQUxVRVNfSU5TVEFOVERCOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19JTlNUQU5UREIsXG4gIERCU1lTVEVNVkFMVUVTX0lOVEVSQkFTRTogKCkgPT4gREJTWVNURU1WQUxVRVNfSU5URVJCQVNFLFxuICBEQlNZU1RFTVZBTFVFU19NQVJJQURCOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19NQVJJQURCLFxuICBEQlNZU1RFTVZBTFVFU19NQVhEQjogKCkgPT4gREJTWVNURU1WQUxVRVNfTUFYREIsXG4gIERCU1lTVEVNVkFMVUVTX01FTUNBQ0hFRDogKCkgPT4gREJTWVNURU1WQUxVRVNfTUVNQ0FDSEVELFxuICBEQlNZU1RFTVZBTFVFU19NT05HT0RCOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19NT05HT0RCLFxuICBEQlNZU1RFTVZBTFVFU19NU1NRTDogKCkgPT4gREJTWVNURU1WQUxVRVNfTVNTUUwsXG4gIERCU1lTVEVNVkFMVUVTX01ZU1FMOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19NWVNRTCxcbiAgREJTWVNURU1WQUxVRVNfTkVPNEo6ICgpID0+IERCU1lTVEVNVkFMVUVTX05FTzRKLFxuICBEQlNZU1RFTVZBTFVFU19ORVRFWlpBOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19ORVRFWlpBLFxuICBEQlNZU1RFTVZBTFVFU19PUkFDTEU6ICgpID0+IERCU1lTVEVNVkFMVUVTX09SQUNMRSxcbiAgREJTWVNURU1WQUxVRVNfT1RIRVJfU1FMOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19PVEhFUl9TUUwsXG4gIERCU1lTVEVNVkFMVUVTX1BFUlZBU0lWRTogKCkgPT4gREJTWVNURU1WQUxVRVNfUEVSVkFTSVZFLFxuICBEQlNZU1RFTVZBTFVFU19QT0lOVEJBU0U6ICgpID0+IERCU1lTVEVNVkFMVUVTX1BPSU5UQkFTRSxcbiAgREJTWVNURU1WQUxVRVNfUE9TVEdSRVNRTDogKCkgPT4gREJTWVNURU1WQUxVRVNfUE9TVEdSRVNRTCxcbiAgREJTWVNURU1WQUxVRVNfUFJPR1JFU1M6ICgpID0+IERCU1lTVEVNVkFMVUVTX1BST0dSRVNTLFxuICBEQlNZU1RFTVZBTFVFU19SRURJUzogKCkgPT4gREJTWVNURU1WQUxVRVNfUkVESVMsXG4gIERCU1lTVEVNVkFMVUVTX1JFRFNISUZUOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19SRURTSElGVCxcbiAgREJTWVNURU1WQUxVRVNfU1FMSVRFOiAoKSA9PiBEQlNZU1RFTVZBTFVFU19TUUxJVEUsXG4gIERCU1lTVEVNVkFMVUVTX1NZQkFTRTogKCkgPT4gREJTWVNURU1WQUxVRVNfU1lCQVNFLFxuICBEQlNZU1RFTVZBTFVFU19URVJBREFUQTogKCkgPT4gREJTWVNURU1WQUxVRVNfVEVSQURBVEEsXG4gIERCU1lTVEVNVkFMVUVTX1ZFUlRJQ0E6ICgpID0+IERCU1lTVEVNVkFMVUVTX1ZFUlRJQ0EsXG4gIERiQ2Fzc2FuZHJhQ29uc2lzdGVuY3lMZXZlbFZhbHVlczogKCkgPT4gRGJDYXNzYW5kcmFDb25zaXN0ZW5jeUxldmVsVmFsdWVzLFxuICBEYlN5c3RlbVZhbHVlczogKCkgPT4gRGJTeXN0ZW1WYWx1ZXMsXG4gIEZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19ERUxFVEU6ICgpID0+IEZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19ERUxFVEUsXG4gIEZBQVNET0NVTUVOVE9QRVJBVElPTlZBTFVFU19FRElUOiAoKSA9PiBGQUFTRE9DVU1FTlRPUEVSQVRJT05WQUxVRVNfRURJVCxcbiAgRkFBU0RPQ1VNRU5UT1BFUkFUSU9OVkFMVUVTX0lOU0VSVDogKCkgPT4gRkFBU0RPQ1VNRU5UT1BFUkFUSU9OVkFMVUVTX0lOU0VSVCxcbiAgRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BTElCQUJBX0NMT1VEOiAoKSA9PiBGQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0FMSUJBQkFfQ0xPVUQsXG4gIEZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfQVdTOiAoKSA9PiBGQUFTSU5WT0tFRFBST1ZJREVSVkFMVUVTX0FXUyxcbiAgRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BWlVSRTogKCkgPT4gRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19BWlVSRSxcbiAgRkFBU0lOVk9LRURQUk9WSURFUlZBTFVFU19HQ1A6ICgpID0+IEZBQVNJTlZPS0VEUFJPVklERVJWQUxVRVNfR0NQLFxuICBGQUFTVFJJR0dFUlZBTFVFU19EQVRBU09VUkNFOiAoKSA9PiBGQUFTVFJJR0dFUlZBTFVFU19EQVRBU09VUkNFLFxuICBGQUFTVFJJR0dFUlZBTFVFU19IVFRQOiAoKSA9PiBGQUFTVFJJR0dFUlZBTFVFU19IVFRQLFxuICBGQUFTVFJJR0dFUlZBTFVFU19PVEhFUjogKCkgPT4gRkFBU1RSSUdHRVJWQUxVRVNfT1RIRVIsXG4gIEZBQVNUUklHR0VSVkFMVUVTX1BVQlNVQjogKCkgPT4gRkFBU1RSSUdHRVJWQUxVRVNfUFVCU1VCLFxuICBGQUFTVFJJR0dFUlZBTFVFU19USU1FUjogKCkgPT4gRkFBU1RSSUdHRVJWQUxVRVNfVElNRVIsXG4gIEZhYXNEb2N1bWVudE9wZXJhdGlvblZhbHVlczogKCkgPT4gRmFhc0RvY3VtZW50T3BlcmF0aW9uVmFsdWVzLFxuICBGYWFzSW52b2tlZFByb3ZpZGVyVmFsdWVzOiAoKSA9PiBGYWFzSW52b2tlZFByb3ZpZGVyVmFsdWVzLFxuICBGYWFzVHJpZ2dlclZhbHVlczogKCkgPT4gRmFhc1RyaWdnZXJWYWx1ZXMsXG4gIEhPU1RBUkNIVkFMVUVTX0FNRDY0OiAoKSA9PiBIT1NUQVJDSFZBTFVFU19BTUQ2NCxcbiAgSE9TVEFSQ0hWQUxVRVNfQVJNMzI6ICgpID0+IEhPU1RBUkNIVkFMVUVTX0FSTTMyLFxuICBIT1NUQVJDSFZBTFVFU19BUk02NDogKCkgPT4gSE9TVEFSQ0hWQUxVRVNfQVJNNjQsXG4gIEhPU1RBUkNIVkFMVUVTX0lBNjQ6ICgpID0+IEhPU1RBUkNIVkFMVUVTX0lBNjQsXG4gIEhPU1RBUkNIVkFMVUVTX1BQQzMyOiAoKSA9PiBIT1NUQVJDSFZBTFVFU19QUEMzMixcbiAgSE9TVEFSQ0hWQUxVRVNfUFBDNjQ6ICgpID0+IEhPU1RBUkNIVkFMVUVTX1BQQzY0LFxuICBIT1NUQVJDSFZBTFVFU19YODY6ICgpID0+IEhPU1RBUkNIVkFMVUVTX1g4NixcbiAgSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMDogKCkgPT4gSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMCxcbiAgSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMTogKCkgPT4gSFRUUEZMQVZPUlZBTFVFU19IVFRQXzFfMSxcbiAgSFRUUEZMQVZPUlZBTFVFU19IVFRQXzJfMDogKCkgPT4gSFRUUEZMQVZPUlZBTFVFU19IVFRQXzJfMCxcbiAgSFRUUEZMQVZPUlZBTFVFU19RVUlDOiAoKSA9PiBIVFRQRkxBVk9SVkFMVUVTX1FVSUMsXG4gIEhUVFBGTEFWT1JWQUxVRVNfU1BEWTogKCkgPT4gSFRUUEZMQVZPUlZBTFVFU19TUERZLFxuICBIb3N0QXJjaFZhbHVlczogKCkgPT4gSG9zdEFyY2hWYWx1ZXMsXG4gIEh0dHBGbGF2b3JWYWx1ZXM6ICgpID0+IEh0dHBGbGF2b3JWYWx1ZXMsXG4gIE1FU1NBR0VUWVBFVkFMVUVTX1JFQ0VJVkVEOiAoKSA9PiBNRVNTQUdFVFlQRVZBTFVFU19SRUNFSVZFRCxcbiAgTUVTU0FHRVRZUEVWQUxVRVNfU0VOVDogKCkgPT4gTUVTU0FHRVRZUEVWQUxVRVNfU0VOVCxcbiAgTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1FVRVVFOiAoKSA9PiBNRVNTQUdJTkdERVNUSU5BVElPTktJTkRWQUxVRVNfUVVFVUUsXG4gIE1FU1NBR0lOR0RFU1RJTkFUSU9OS0lORFZBTFVFU19UT1BJQzogKCkgPT4gTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1RPUElDLFxuICBNRVNTQUdJTkdPUEVSQVRJT05WQUxVRVNfUFJPQ0VTUzogKCkgPT4gTUVTU0FHSU5HT1BFUkFUSU9OVkFMVUVTX1BST0NFU1MsXG4gIE1FU1NBR0lOR09QRVJBVElPTlZBTFVFU19SRUNFSVZFOiAoKSA9PiBNRVNTQUdJTkdPUEVSQVRJT05WQUxVRVNfUkVDRUlWRSxcbiAgTWVzc2FnZVR5cGVWYWx1ZXM6ICgpID0+IE1lc3NhZ2VUeXBlVmFsdWVzLFxuICBNZXNzYWdpbmdEZXN0aW5hdGlvbktpbmRWYWx1ZXM6ICgpID0+IE1lc3NhZ2luZ0Rlc3RpbmF0aW9uS2luZFZhbHVlcyxcbiAgTWVzc2FnaW5nT3BlcmF0aW9uVmFsdWVzOiAoKSA9PiBNZXNzYWdpbmdPcGVyYXRpb25WYWx1ZXMsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19DRE1BOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQSxcbiAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0NETUEyMDAwXzFYUlRUOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfQ0RNQTIwMDBfMVhSVFQsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FREdFOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRURHRSxcbiAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0VIUlBEOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfRUhSUEQsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPXzA6ICgpID0+IE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPXzAsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPX0E6ICgpID0+IE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPX0EsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPX0I6ICgpID0+IE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19FVkRPX0IsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19HUFJTOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfR1BSUyxcbiAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0dTTTogKCkgPT4gTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0dTTSxcbiAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTRFBBOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSFNEUEEsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU1BBOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSFNQQSxcbiAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTUEFQOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSFNQQVAsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19IU1VQQTogKCkgPT4gTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0hTVVBBLFxuICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfSURFTjogKCkgPT4gTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0lERU4sXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19JV0xBTjogKCkgPT4gTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX0lXTEFOLFxuICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTFRFOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTFRFLFxuICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTFRFX0NBOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTFRFX0NBLFxuICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTlI6ICgpID0+IE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19OUixcbiAgTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX05STlNBOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfTlJOU0EsXG4gIE5FVEhPU1RDT05ORUNUSU9OU1VCVFlQRVZBTFVFU19URF9TQ0RNQTogKCkgPT4gTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX1REX1NDRE1BLFxuICBORVRIT1NUQ09OTkVDVElPTlNVQlRZUEVWQUxVRVNfVU1UUzogKCkgPT4gTkVUSE9TVENPTk5FQ1RJT05TVUJUWVBFVkFMVUVTX1VNVFMsXG4gIE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19DRUxMOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfQ0VMTCxcbiAgTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX1VOQVZBSUxBQkxFOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfVU5BVkFJTEFCTEUsXG4gIE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19VTktOT1dOOiAoKSA9PiBORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfVU5LTk9XTixcbiAgTkVUSE9TVENPTk5FQ1RJT05UWVBFVkFMVUVTX1dJRkk6ICgpID0+IE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSUZJLFxuICBORVRIT1NUQ09OTkVDVElPTlRZUEVWQUxVRVNfV0lSRUQ6ICgpID0+IE5FVEhPU1RDT05ORUNUSU9OVFlQRVZBTFVFU19XSVJFRCxcbiAgTkVUVFJBTlNQT1JUVkFMVUVTX0lOUFJPQzogKCkgPT4gTkVUVFJBTlNQT1JUVkFMVUVTX0lOUFJPQyxcbiAgTkVUVFJBTlNQT1JUVkFMVUVTX0lQOiAoKSA9PiBORVRUUkFOU1BPUlRWQUxVRVNfSVAsXG4gIE5FVFRSQU5TUE9SVFZBTFVFU19JUF9UQ1A6ICgpID0+IE5FVFRSQU5TUE9SVFZBTFVFU19JUF9UQ1AsXG4gIE5FVFRSQU5TUE9SVFZBTFVFU19JUF9VRFA6ICgpID0+IE5FVFRSQU5TUE9SVFZBTFVFU19JUF9VRFAsXG4gIE5FVFRSQU5TUE9SVFZBTFVFU19PVEhFUjogKCkgPT4gTkVUVFJBTlNQT1JUVkFMVUVTX09USEVSLFxuICBORVRUUkFOU1BPUlRWQUxVRVNfUElQRTogKCkgPT4gTkVUVFJBTlNQT1JUVkFMVUVTX1BJUEUsXG4gIE5FVFRSQU5TUE9SVFZBTFVFU19VTklYOiAoKSA9PiBORVRUUkFOU1BPUlRWQUxVRVNfVU5JWCxcbiAgTmV0SG9zdENvbm5lY3Rpb25TdWJ0eXBlVmFsdWVzOiAoKSA9PiBOZXRIb3N0Q29ubmVjdGlvblN1YnR5cGVWYWx1ZXMsXG4gIE5ldEhvc3RDb25uZWN0aW9uVHlwZVZhbHVlczogKCkgPT4gTmV0SG9zdENvbm5lY3Rpb25UeXBlVmFsdWVzLFxuICBOZXRUcmFuc3BvcnRWYWx1ZXM6ICgpID0+IE5ldFRyYW5zcG9ydFZhbHVlcyxcbiAgT1NUWVBFVkFMVUVTX0FJWDogKCkgPT4gT1NUWVBFVkFMVUVTX0FJWCxcbiAgT1NUWVBFVkFMVUVTX0RBUldJTjogKCkgPT4gT1NUWVBFVkFMVUVTX0RBUldJTixcbiAgT1NUWVBFVkFMVUVTX0RSQUdPTkZMWUJTRDogKCkgPT4gT1NUWVBFVkFMVUVTX0RSQUdPTkZMWUJTRCxcbiAgT1NUWVBFVkFMVUVTX0ZSRUVCU0Q6ICgpID0+IE9TVFlQRVZBTFVFU19GUkVFQlNELFxuICBPU1RZUEVWQUxVRVNfSFBVWDogKCkgPT4gT1NUWVBFVkFMVUVTX0hQVVgsXG4gIE9TVFlQRVZBTFVFU19MSU5VWDogKCkgPT4gT1NUWVBFVkFMVUVTX0xJTlVYLFxuICBPU1RZUEVWQUxVRVNfTkVUQlNEOiAoKSA9PiBPU1RZUEVWQUxVRVNfTkVUQlNELFxuICBPU1RZUEVWQUxVRVNfT1BFTkJTRDogKCkgPT4gT1NUWVBFVkFMVUVTX09QRU5CU0QsXG4gIE9TVFlQRVZBTFVFU19TT0xBUklTOiAoKSA9PiBPU1RZUEVWQUxVRVNfU09MQVJJUyxcbiAgT1NUWVBFVkFMVUVTX1dJTkRPV1M6ICgpID0+IE9TVFlQRVZBTFVFU19XSU5ET1dTLFxuICBPU1RZUEVWQUxVRVNfWl9PUzogKCkgPT4gT1NUWVBFVkFMVUVTX1pfT1MsXG4gIE9zVHlwZVZhbHVlczogKCkgPT4gT3NUeXBlVmFsdWVzLFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BQk9SVEVEOiAoKSA9PiBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BQk9SVEVELFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19BTFJFQURZX0VYSVNUUzogKCkgPT4gUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfQUxSRUFEWV9FWElTVFMsXG4gIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0NBTkNFTExFRDogKCkgPT4gUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfQ0FOQ0VMTEVELFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19EQVRBX0xPU1M6ICgpID0+IFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0RBVEFfTE9TUyxcbiAgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfREVBRExJTkVfRVhDRUVERUQ6ICgpID0+IFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0RFQURMSU5FX0VYQ0VFREVELFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19GQUlMRURfUFJFQ09ORElUSU9OOiAoKSA9PiBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19GQUlMRURfUFJFQ09ORElUSU9OLFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19JTlRFUk5BTDogKCkgPT4gUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfSU5URVJOQUwsXG4gIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0lOVkFMSURfQVJHVU1FTlQ6ICgpID0+IFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX0lOVkFMSURfQVJHVU1FTlQsXG4gIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX05PVF9GT1VORDogKCkgPT4gUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfTk9UX0ZPVU5ELFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19PSzogKCkgPT4gUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfT0ssXG4gIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX09VVF9PRl9SQU5HRTogKCkgPT4gUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfT1VUX09GX1JBTkdFLFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19QRVJNSVNTSU9OX0RFTklFRDogKCkgPT4gUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfUEVSTUlTU0lPTl9ERU5JRUQsXG4gIFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1JFU09VUkNFX0VYSEFVU1RFRDogKCkgPT4gUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfUkVTT1VSQ0VfRVhIQVVTVEVELFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTkFVVEhFTlRJQ0FURUQ6ICgpID0+IFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOQVVUSEVOVElDQVRFRCxcbiAgUlBDR1JQQ1NUQVRVU0NPREVWQUxVRVNfVU5BVkFJTEFCTEU6ICgpID0+IFJQQ0dSUENTVEFUVVNDT0RFVkFMVUVTX1VOQVZBSUxBQkxFLFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTklNUExFTUVOVEVEOiAoKSA9PiBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTklNUExFTUVOVEVELFxuICBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTktOT1dOOiAoKSA9PiBSUENHUlBDU1RBVFVTQ09ERVZBTFVFU19VTktOT1dOLFxuICBScGNHcnBjU3RhdHVzQ29kZVZhbHVlczogKCkgPT4gUnBjR3JwY1N0YXR1c0NvZGVWYWx1ZXMsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9BVFRSSUJVVEVTX1RPX0dFVDogKCkgPT4gU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0FUVFJJQlVURVNfVE9fR0VULFxuICBTRU1BVFRSU19BV1NfRFlOQU1PREJfQVRUUklCVVRFX0RFRklOSVRJT05TOiAoKSA9PiBTRU1BVFRSU19BV1NfRFlOQU1PREJfQVRUUklCVVRFX0RFRklOSVRJT05TLFxuICBTRU1BVFRSU19BV1NfRFlOQU1PREJfQ09OU0lTVEVOVF9SRUFEOiAoKSA9PiBTRU1BVFRSU19BV1NfRFlOQU1PREJfQ09OU0lTVEVOVF9SRUFELFxuICBTRU1BVFRSU19BV1NfRFlOQU1PREJfQ09OU1VNRURfQ0FQQUNJVFk6ICgpID0+IFNFTUFUVFJTX0FXU19EWU5BTU9EQl9DT05TVU1FRF9DQVBBQ0lUWSxcbiAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0NPVU5UOiAoKSA9PiBTRU1BVFRSU19BV1NfRFlOQU1PREJfQ09VTlQsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9FWENMVVNJVkVfU1RBUlRfVEFCTEU6ICgpID0+IFNFTUFUVFJTX0FXU19EWU5BTU9EQl9FWENMVVNJVkVfU1RBUlRfVEFCTEUsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9HTE9CQUxfU0VDT05EQVJZX0lOREVYRVM6ICgpID0+IFNFTUFUVFJTX0FXU19EWU5BTU9EQl9HTE9CQUxfU0VDT05EQVJZX0lOREVYRVMsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9HTE9CQUxfU0VDT05EQVJZX0lOREVYX1VQREFURVM6ICgpID0+IFNFTUFUVFJTX0FXU19EWU5BTU9EQl9HTE9CQUxfU0VDT05EQVJZX0lOREVYX1VQREFURVMsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9JTkRFWF9OQU1FOiAoKSA9PiBTRU1BVFRSU19BV1NfRFlOQU1PREJfSU5ERVhfTkFNRSxcbiAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0lURU1fQ09MTEVDVElPTl9NRVRSSUNTOiAoKSA9PiBTRU1BVFRSU19BV1NfRFlOQU1PREJfSVRFTV9DT0xMRUNUSU9OX01FVFJJQ1MsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9MSU1JVDogKCkgPT4gU0VNQVRUUlNfQVdTX0RZTkFNT0RCX0xJTUlULFxuICBTRU1BVFRSU19BV1NfRFlOQU1PREJfTE9DQUxfU0VDT05EQVJZX0lOREVYRVM6ICgpID0+IFNFTUFUVFJTX0FXU19EWU5BTU9EQl9MT0NBTF9TRUNPTkRBUllfSU5ERVhFUyxcbiAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1BST0pFQ1RJT046ICgpID0+IFNFTUFUVFJTX0FXU19EWU5BTU9EQl9QUk9KRUNUSU9OLFxuICBTRU1BVFRSU19BV1NfRFlOQU1PREJfUFJPVklTSU9ORURfUkVBRF9DQVBBQ0lUWTogKCkgPT4gU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1BST1ZJU0lPTkVEX1JFQURfQ0FQQUNJVFksXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9QUk9WSVNJT05FRF9XUklURV9DQVBBQ0lUWTogKCkgPT4gU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1BST1ZJU0lPTkVEX1dSSVRFX0NBUEFDSVRZLFxuICBTRU1BVFRSU19BV1NfRFlOQU1PREJfU0NBTk5FRF9DT1VOVDogKCkgPT4gU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1NDQU5ORURfQ09VTlQsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9TQ0FOX0ZPUldBUkQ6ICgpID0+IFNFTUFUVFJTX0FXU19EWU5BTU9EQl9TQ0FOX0ZPUldBUkQsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9TRUdNRU5UOiAoKSA9PiBTRU1BVFRSU19BV1NfRFlOQU1PREJfU0VHTUVOVCxcbiAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1NFTEVDVDogKCkgPT4gU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1NFTEVDVCxcbiAgU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1RBQkxFX0NPVU5UOiAoKSA9PiBTRU1BVFRSU19BV1NfRFlOQU1PREJfVEFCTEVfQ09VTlQsXG4gIFNFTUFUVFJTX0FXU19EWU5BTU9EQl9UQUJMRV9OQU1FUzogKCkgPT4gU0VNQVRUUlNfQVdTX0RZTkFNT0RCX1RBQkxFX05BTUVTLFxuICBTRU1BVFRSU19BV1NfRFlOQU1PREJfVE9UQUxfU0VHTUVOVFM6ICgpID0+IFNFTUFUVFJTX0FXU19EWU5BTU9EQl9UT1RBTF9TRUdNRU5UUyxcbiAgU0VNQVRUUlNfQVdTX0xBTUJEQV9JTlZPS0VEX0FSTjogKCkgPT4gU0VNQVRUUlNfQVdTX0xBTUJEQV9JTlZPS0VEX0FSTixcbiAgU0VNQVRUUlNfQ09ERV9GSUxFUEFUSDogKCkgPT4gU0VNQVRUUlNfQ09ERV9GSUxFUEFUSCxcbiAgU0VNQVRUUlNfQ09ERV9GVU5DVElPTjogKCkgPT4gU0VNQVRUUlNfQ09ERV9GVU5DVElPTixcbiAgU0VNQVRUUlNfQ09ERV9MSU5FTk86ICgpID0+IFNFTUFUVFJTX0NPREVfTElORU5PLFxuICBTRU1BVFRSU19DT0RFX05BTUVTUEFDRTogKCkgPT4gU0VNQVRUUlNfQ09ERV9OQU1FU1BBQ0UsXG4gIFNFTUFUVFJTX0RCX0NBU1NBTkRSQV9DT05TSVNURU5DWV9MRVZFTDogKCkgPT4gU0VNQVRUUlNfREJfQ0FTU0FORFJBX0NPTlNJU1RFTkNZX0xFVkVMLFxuICBTRU1BVFRSU19EQl9DQVNTQU5EUkFfQ09PUkRJTkFUT1JfREM6ICgpID0+IFNFTUFUVFJTX0RCX0NBU1NBTkRSQV9DT09SRElOQVRPUl9EQyxcbiAgU0VNQVRUUlNfREJfQ0FTU0FORFJBX0NPT1JESU5BVE9SX0lEOiAoKSA9PiBTRU1BVFRSU19EQl9DQVNTQU5EUkFfQ09PUkRJTkFUT1JfSUQsXG4gIFNFTUFUVFJTX0RCX0NBU1NBTkRSQV9JREVNUE9URU5DRTogKCkgPT4gU0VNQVRUUlNfREJfQ0FTU0FORFJBX0lERU1QT1RFTkNFLFxuICBTRU1BVFRSU19EQl9DQVNTQU5EUkFfS0VZU1BBQ0U6ICgpID0+IFNFTUFUVFJTX0RCX0NBU1NBTkRSQV9LRVlTUEFDRSxcbiAgU0VNQVRUUlNfREJfQ0FTU0FORFJBX1BBR0VfU0laRTogKCkgPT4gU0VNQVRUUlNfREJfQ0FTU0FORFJBX1BBR0VfU0laRSxcbiAgU0VNQVRUUlNfREJfQ0FTU0FORFJBX1NQRUNVTEFUSVZFX0VYRUNVVElPTl9DT1VOVDogKCkgPT4gU0VNQVRUUlNfREJfQ0FTU0FORFJBX1NQRUNVTEFUSVZFX0VYRUNVVElPTl9DT1VOVCxcbiAgU0VNQVRUUlNfREJfQ0FTU0FORFJBX1RBQkxFOiAoKSA9PiBTRU1BVFRSU19EQl9DQVNTQU5EUkFfVEFCTEUsXG4gIFNFTUFUVFJTX0RCX0NPTk5FQ1RJT05fU1RSSU5HOiAoKSA9PiBTRU1BVFRSU19EQl9DT05ORUNUSU9OX1NUUklORyxcbiAgU0VNQVRUUlNfREJfSEJBU0VfTkFNRVNQQUNFOiAoKSA9PiBTRU1BVFRSU19EQl9IQkFTRV9OQU1FU1BBQ0UsXG4gIFNFTUFUVFJTX0RCX0pEQkNfRFJJVkVSX0NMQVNTTkFNRTogKCkgPT4gU0VNQVRUUlNfREJfSkRCQ19EUklWRVJfQ0xBU1NOQU1FLFxuICBTRU1BVFRSU19EQl9NT05HT0RCX0NPTExFQ1RJT046ICgpID0+IFNFTUFUVFJTX0RCX01PTkdPREJfQ09MTEVDVElPTixcbiAgU0VNQVRUUlNfREJfTVNTUUxfSU5TVEFOQ0VfTkFNRTogKCkgPT4gU0VNQVRUUlNfREJfTVNTUUxfSU5TVEFOQ0VfTkFNRSxcbiAgU0VNQVRUUlNfREJfTkFNRTogKCkgPT4gU0VNQVRUUlNfREJfTkFNRSxcbiAgU0VNQVRUUlNfREJfT1BFUkFUSU9OOiAoKSA9PiBTRU1BVFRSU19EQl9PUEVSQVRJT04sXG4gIFNFTUFUVFJTX0RCX1JFRElTX0RBVEFCQVNFX0lOREVYOiAoKSA9PiBTRU1BVFRSU19EQl9SRURJU19EQVRBQkFTRV9JTkRFWCxcbiAgU0VNQVRUUlNfREJfU1FMX1RBQkxFOiAoKSA9PiBTRU1BVFRSU19EQl9TUUxfVEFCTEUsXG4gIFNFTUFUVFJTX0RCX1NUQVRFTUVOVDogKCkgPT4gU0VNQVRUUlNfREJfU1RBVEVNRU5ULFxuICBTRU1BVFRSU19EQl9TWVNURU06ICgpID0+IFNFTUFUVFJTX0RCX1NZU1RFTSxcbiAgU0VNQVRUUlNfREJfVVNFUjogKCkgPT4gU0VNQVRUUlNfREJfVVNFUixcbiAgU0VNQVRUUlNfRU5EVVNFUl9JRDogKCkgPT4gU0VNQVRUUlNfRU5EVVNFUl9JRCxcbiAgU0VNQVRUUlNfRU5EVVNFUl9ST0xFOiAoKSA9PiBTRU1BVFRSU19FTkRVU0VSX1JPTEUsXG4gIFNFTUFUVFJTX0VORFVTRVJfU0NPUEU6ICgpID0+IFNFTUFUVFJTX0VORFVTRVJfU0NPUEUsXG4gIFNFTUFUVFJTX0VYQ0VQVElPTl9FU0NBUEVEOiAoKSA9PiBTRU1BVFRSU19FWENFUFRJT05fRVNDQVBFRCxcbiAgU0VNQVRUUlNfRVhDRVBUSU9OX01FU1NBR0U6ICgpID0+IFNFTUFUVFJTX0VYQ0VQVElPTl9NRVNTQUdFLFxuICBTRU1BVFRSU19FWENFUFRJT05fU1RBQ0tUUkFDRTogKCkgPT4gU0VNQVRUUlNfRVhDRVBUSU9OX1NUQUNLVFJBQ0UsXG4gIFNFTUFUVFJTX0VYQ0VQVElPTl9UWVBFOiAoKSA9PiBTRU1BVFRSU19FWENFUFRJT05fVFlQRSxcbiAgU0VNQVRUUlNfRkFBU19DT0xEU1RBUlQ6ICgpID0+IFNFTUFUVFJTX0ZBQVNfQ09MRFNUQVJULFxuICBTRU1BVFRSU19GQUFTX0NST046ICgpID0+IFNFTUFUVFJTX0ZBQVNfQ1JPTixcbiAgU0VNQVRUUlNfRkFBU19ET0NVTUVOVF9DT0xMRUNUSU9OOiAoKSA9PiBTRU1BVFRSU19GQUFTX0RPQ1VNRU5UX0NPTExFQ1RJT04sXG4gIFNFTUFUVFJTX0ZBQVNfRE9DVU1FTlRfTkFNRTogKCkgPT4gU0VNQVRUUlNfRkFBU19ET0NVTUVOVF9OQU1FLFxuICBTRU1BVFRSU19GQUFTX0RPQ1VNRU5UX09QRVJBVElPTjogKCkgPT4gU0VNQVRUUlNfRkFBU19ET0NVTUVOVF9PUEVSQVRJT04sXG4gIFNFTUFUVFJTX0ZBQVNfRE9DVU1FTlRfVElNRTogKCkgPT4gU0VNQVRUUlNfRkFBU19ET0NVTUVOVF9USU1FLFxuICBTRU1BVFRSU19GQUFTX0VYRUNVVElPTjogKCkgPT4gU0VNQVRUUlNfRkFBU19FWEVDVVRJT04sXG4gIFNFTUFUVFJTX0ZBQVNfSU5WT0tFRF9OQU1FOiAoKSA9PiBTRU1BVFRSU19GQUFTX0lOVk9LRURfTkFNRSxcbiAgU0VNQVRUUlNfRkFBU19JTlZPS0VEX1BST1ZJREVSOiAoKSA9PiBTRU1BVFRSU19GQUFTX0lOVk9LRURfUFJPVklERVIsXG4gIFNFTUFUVFJTX0ZBQVNfSU5WT0tFRF9SRUdJT046ICgpID0+IFNFTUFUVFJTX0ZBQVNfSU5WT0tFRF9SRUdJT04sXG4gIFNFTUFUVFJTX0ZBQVNfVElNRTogKCkgPT4gU0VNQVRUUlNfRkFBU19USU1FLFxuICBTRU1BVFRSU19GQUFTX1RSSUdHRVI6ICgpID0+IFNFTUFUVFJTX0ZBQVNfVFJJR0dFUixcbiAgU0VNQVRUUlNfSFRUUF9DTElFTlRfSVA6ICgpID0+IFNFTUFUVFJTX0hUVFBfQ0xJRU5UX0lQLFxuICBTRU1BVFRSU19IVFRQX0ZMQVZPUjogKCkgPT4gU0VNQVRUUlNfSFRUUF9GTEFWT1IsXG4gIFNFTUFUVFJTX0hUVFBfSE9TVDogKCkgPT4gU0VNQVRUUlNfSFRUUF9IT1NULFxuICBTRU1BVFRSU19IVFRQX01FVEhPRDogKCkgPT4gU0VNQVRUUlNfSFRUUF9NRVRIT0QsXG4gIFNFTUFUVFJTX0hUVFBfUkVRVUVTVF9DT05URU5UX0xFTkdUSDogKCkgPT4gU0VNQVRUUlNfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RILFxuICBTRU1BVFRSU19IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VEOiAoKSA9PiBTRU1BVFRSU19IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VELFxuICBTRU1BVFRSU19IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIOiAoKSA9PiBTRU1BVFRSU19IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RILFxuICBTRU1BVFRSU19IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRDogKCkgPT4gU0VNQVRUUlNfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSF9VTkNPTVBSRVNTRUQsXG4gIFNFTUFUVFJTX0hUVFBfUk9VVEU6ICgpID0+IFNFTUFUVFJTX0hUVFBfUk9VVEUsXG4gIFNFTUFUVFJTX0hUVFBfU0NIRU1FOiAoKSA9PiBTRU1BVFRSU19IVFRQX1NDSEVNRSxcbiAgU0VNQVRUUlNfSFRUUF9TRVJWRVJfTkFNRTogKCkgPT4gU0VNQVRUUlNfSFRUUF9TRVJWRVJfTkFNRSxcbiAgU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERTogKCkgPT4gU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERSxcbiAgU0VNQVRUUlNfSFRUUF9UQVJHRVQ6ICgpID0+IFNFTUFUVFJTX0hUVFBfVEFSR0VULFxuICBTRU1BVFRSU19IVFRQX1VSTDogKCkgPT4gU0VNQVRUUlNfSFRUUF9VUkwsXG4gIFNFTUFUVFJTX0hUVFBfVVNFUl9BR0VOVDogKCkgPT4gU0VNQVRUUlNfSFRUUF9VU0VSX0FHRU5ULFxuICBTRU1BVFRSU19NRVNTQUdFX0NPTVBSRVNTRURfU0laRTogKCkgPT4gU0VNQVRUUlNfTUVTU0FHRV9DT01QUkVTU0VEX1NJWkUsXG4gIFNFTUFUVFJTX01FU1NBR0VfSUQ6ICgpID0+IFNFTUFUVFJTX01FU1NBR0VfSUQsXG4gIFNFTUFUVFJTX01FU1NBR0VfVFlQRTogKCkgPT4gU0VNQVRUUlNfTUVTU0FHRV9UWVBFLFxuICBTRU1BVFRSU19NRVNTQUdFX1VOQ09NUFJFU1NFRF9TSVpFOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdFX1VOQ09NUFJFU1NFRF9TSVpFLFxuICBTRU1BVFRSU19NRVNTQUdJTkdfQ09OU1VNRVJfSUQ6ICgpID0+IFNFTUFUVFJTX01FU1NBR0lOR19DT05TVU1FUl9JRCxcbiAgU0VNQVRUUlNfTUVTU0FHSU5HX0NPTlZFUlNBVElPTl9JRDogKCkgPT4gU0VNQVRUUlNfTUVTU0FHSU5HX0NPTlZFUlNBVElPTl9JRCxcbiAgU0VNQVRUUlNfTUVTU0FHSU5HX0RFU1RJTkFUSU9OOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT04sXG4gIFNFTUFUVFJTX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05fS0lORCxcbiAgU0VNQVRUUlNfTUVTU0FHSU5HX0tBRktBX0NMSUVOVF9JRDogKCkgPT4gU0VNQVRUUlNfTUVTU0FHSU5HX0tBRktBX0NMSUVOVF9JRCxcbiAgU0VNQVRUUlNfTUVTU0FHSU5HX0tBRktBX0NPTlNVTUVSX0dST1VQOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdJTkdfS0FGS0FfQ09OU1VNRVJfR1JPVVAsXG4gIFNFTUFUVFJTX01FU1NBR0lOR19LQUZLQV9NRVNTQUdFX0tFWTogKCkgPT4gU0VNQVRUUlNfTUVTU0FHSU5HX0tBRktBX01FU1NBR0VfS0VZLFxuICBTRU1BVFRSU19NRVNTQUdJTkdfS0FGS0FfUEFSVElUSU9OOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdJTkdfS0FGS0FfUEFSVElUSU9OLFxuICBTRU1BVFRSU19NRVNTQUdJTkdfS0FGS0FfVE9NQlNUT05FOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdJTkdfS0FGS0FfVE9NQlNUT05FLFxuICBTRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9JRDogKCkgPT4gU0VNQVRUUlNfTUVTU0FHSU5HX01FU1NBR0VfSUQsXG4gIFNFTUFUVFJTX01FU1NBR0lOR19NRVNTQUdFX1BBWUxPQURfQ09NUFJFU1NFRF9TSVpFX0JZVEVTOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX0NPTVBSRVNTRURfU0laRV9CWVRFUyxcbiAgU0VNQVRUUlNfTUVTU0FHSU5HX01FU1NBR0VfUEFZTE9BRF9TSVpFX0JZVEVTOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9QQVlMT0FEX1NJWkVfQllURVMsXG4gIFNFTUFUVFJTX01FU1NBR0lOR19PUEVSQVRJT046ICgpID0+IFNFTUFUVFJTX01FU1NBR0lOR19PUEVSQVRJT04sXG4gIFNFTUFUVFJTX01FU1NBR0lOR19QUk9UT0NPTDogKCkgPT4gU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MLFxuICBTRU1BVFRSU19NRVNTQUdJTkdfUFJPVE9DT0xfVkVSU0lPTjogKCkgPT4gU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT04sXG4gIFNFTUFUVFJTX01FU1NBR0lOR19SQUJCSVRNUV9ST1VUSU5HX0tFWTogKCkgPT4gU0VNQVRUUlNfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZLFxuICBTRU1BVFRSU19NRVNTQUdJTkdfU1lTVEVNOiAoKSA9PiBTRU1BVFRSU19NRVNTQUdJTkdfU1lTVEVNLFxuICBTRU1BVFRSU19NRVNTQUdJTkdfVEVNUF9ERVNUSU5BVElPTjogKCkgPT4gU0VNQVRUUlNfTUVTU0FHSU5HX1RFTVBfREVTVElOQVRJT04sXG4gIFNFTUFUVFJTX01FU1NBR0lOR19VUkw6ICgpID0+IFNFTUFUVFJTX01FU1NBR0lOR19VUkwsXG4gIFNFTUFUVFJTX05FVF9IT1NUX0NBUlJJRVJfSUNDOiAoKSA9PiBTRU1BVFRSU19ORVRfSE9TVF9DQVJSSUVSX0lDQyxcbiAgU0VNQVRUUlNfTkVUX0hPU1RfQ0FSUklFUl9NQ0M6ICgpID0+IFNFTUFUVFJTX05FVF9IT1NUX0NBUlJJRVJfTUNDLFxuICBTRU1BVFRSU19ORVRfSE9TVF9DQVJSSUVSX01OQzogKCkgPT4gU0VNQVRUUlNfTkVUX0hPU1RfQ0FSUklFUl9NTkMsXG4gIFNFTUFUVFJTX05FVF9IT1NUX0NBUlJJRVJfTkFNRTogKCkgPT4gU0VNQVRUUlNfTkVUX0hPU1RfQ0FSUklFUl9OQU1FLFxuICBTRU1BVFRSU19ORVRfSE9TVF9DT05ORUNUSU9OX1NVQlRZUEU6ICgpID0+IFNFTUFUVFJTX05FVF9IT1NUX0NPTk5FQ1RJT05fU1VCVFlQRSxcbiAgU0VNQVRUUlNfTkVUX0hPU1RfQ09OTkVDVElPTl9UWVBFOiAoKSA9PiBTRU1BVFRSU19ORVRfSE9TVF9DT05ORUNUSU9OX1RZUEUsXG4gIFNFTUFUVFJTX05FVF9IT1NUX0lQOiAoKSA9PiBTRU1BVFRSU19ORVRfSE9TVF9JUCxcbiAgU0VNQVRUUlNfTkVUX0hPU1RfTkFNRTogKCkgPT4gU0VNQVRUUlNfTkVUX0hPU1RfTkFNRSxcbiAgU0VNQVRUUlNfTkVUX0hPU1RfUE9SVDogKCkgPT4gU0VNQVRUUlNfTkVUX0hPU1RfUE9SVCxcbiAgU0VNQVRUUlNfTkVUX1BFRVJfSVA6ICgpID0+IFNFTUFUVFJTX05FVF9QRUVSX0lQLFxuICBTRU1BVFRSU19ORVRfUEVFUl9OQU1FOiAoKSA9PiBTRU1BVFRSU19ORVRfUEVFUl9OQU1FLFxuICBTRU1BVFRSU19ORVRfUEVFUl9QT1JUOiAoKSA9PiBTRU1BVFRSU19ORVRfUEVFUl9QT1JULFxuICBTRU1BVFRSU19ORVRfVFJBTlNQT1JUOiAoKSA9PiBTRU1BVFRSU19ORVRfVFJBTlNQT1JULFxuICBTRU1BVFRSU19QRUVSX1NFUlZJQ0U6ICgpID0+IFNFTUFUVFJTX1BFRVJfU0VSVklDRSxcbiAgU0VNQVRUUlNfUlBDX0dSUENfU1RBVFVTX0NPREU6ICgpID0+IFNFTUFUVFJTX1JQQ19HUlBDX1NUQVRVU19DT0RFLFxuICBTRU1BVFRSU19SUENfSlNPTlJQQ19FUlJPUl9DT0RFOiAoKSA9PiBTRU1BVFRSU19SUENfSlNPTlJQQ19FUlJPUl9DT0RFLFxuICBTRU1BVFRSU19SUENfSlNPTlJQQ19FUlJPUl9NRVNTQUdFOiAoKSA9PiBTRU1BVFRSU19SUENfSlNPTlJQQ19FUlJPUl9NRVNTQUdFLFxuICBTRU1BVFRSU19SUENfSlNPTlJQQ19SRVFVRVNUX0lEOiAoKSA9PiBTRU1BVFRSU19SUENfSlNPTlJQQ19SRVFVRVNUX0lELFxuICBTRU1BVFRSU19SUENfSlNPTlJQQ19WRVJTSU9OOiAoKSA9PiBTRU1BVFRSU19SUENfSlNPTlJQQ19WRVJTSU9OLFxuICBTRU1BVFRSU19SUENfTUVUSE9EOiAoKSA9PiBTRU1BVFRSU19SUENfTUVUSE9ELFxuICBTRU1BVFRSU19SUENfU0VSVklDRTogKCkgPT4gU0VNQVRUUlNfUlBDX1NFUlZJQ0UsXG4gIFNFTUFUVFJTX1JQQ19TWVNURU06ICgpID0+IFNFTUFUVFJTX1JQQ19TWVNURU0sXG4gIFNFTUFUVFJTX1RIUkVBRF9JRDogKCkgPT4gU0VNQVRUUlNfVEhSRUFEX0lELFxuICBTRU1BVFRSU19USFJFQURfTkFNRTogKCkgPT4gU0VNQVRUUlNfVEhSRUFEX05BTUUsXG4gIFNFTVJFU0FUVFJTX0FXU19FQ1NfQ0xVU1RFUl9BUk46ICgpID0+IFNFTVJFU0FUVFJTX0FXU19FQ1NfQ0xVU1RFUl9BUk4sXG4gIFNFTVJFU0FUVFJTX0FXU19FQ1NfQ09OVEFJTkVSX0FSTjogKCkgPT4gU0VNUkVTQVRUUlNfQVdTX0VDU19DT05UQUlORVJfQVJOLFxuICBTRU1SRVNBVFRSU19BV1NfRUNTX0xBVU5DSFRZUEU6ICgpID0+IFNFTVJFU0FUVFJTX0FXU19FQ1NfTEFVTkNIVFlQRSxcbiAgU0VNUkVTQVRUUlNfQVdTX0VDU19UQVNLX0FSTjogKCkgPT4gU0VNUkVTQVRUUlNfQVdTX0VDU19UQVNLX0FSTixcbiAgU0VNUkVTQVRUUlNfQVdTX0VDU19UQVNLX0ZBTUlMWTogKCkgPT4gU0VNUkVTQVRUUlNfQVdTX0VDU19UQVNLX0ZBTUlMWSxcbiAgU0VNUkVTQVRUUlNfQVdTX0VDU19UQVNLX1JFVklTSU9OOiAoKSA9PiBTRU1SRVNBVFRSU19BV1NfRUNTX1RBU0tfUkVWSVNJT04sXG4gIFNFTVJFU0FUVFJTX0FXU19FS1NfQ0xVU1RFUl9BUk46ICgpID0+IFNFTVJFU0FUVFJTX0FXU19FS1NfQ0xVU1RFUl9BUk4sXG4gIFNFTVJFU0FUVFJTX0FXU19MT0dfR1JPVVBfQVJOUzogKCkgPT4gU0VNUkVTQVRUUlNfQVdTX0xPR19HUk9VUF9BUk5TLFxuICBTRU1SRVNBVFRSU19BV1NfTE9HX0dST1VQX05BTUVTOiAoKSA9PiBTRU1SRVNBVFRSU19BV1NfTE9HX0dST1VQX05BTUVTLFxuICBTRU1SRVNBVFRSU19BV1NfTE9HX1NUUkVBTV9BUk5TOiAoKSA9PiBTRU1SRVNBVFRSU19BV1NfTE9HX1NUUkVBTV9BUk5TLFxuICBTRU1SRVNBVFRSU19BV1NfTE9HX1NUUkVBTV9OQU1FUzogKCkgPT4gU0VNUkVTQVRUUlNfQVdTX0xPR19TVFJFQU1fTkFNRVMsXG4gIFNFTVJFU0FUVFJTX0NMT1VEX0FDQ09VTlRfSUQ6ICgpID0+IFNFTVJFU0FUVFJTX0NMT1VEX0FDQ09VTlRfSUQsXG4gIFNFTVJFU0FUVFJTX0NMT1VEX0FWQUlMQUJJTElUWV9aT05FOiAoKSA9PiBTRU1SRVNBVFRSU19DTE9VRF9BVkFJTEFCSUxJVFlfWk9ORSxcbiAgU0VNUkVTQVRUUlNfQ0xPVURfUExBVEZPUk06ICgpID0+IFNFTVJFU0FUVFJTX0NMT1VEX1BMQVRGT1JNLFxuICBTRU1SRVNBVFRSU19DTE9VRF9QUk9WSURFUjogKCkgPT4gU0VNUkVTQVRUUlNfQ0xPVURfUFJPVklERVIsXG4gIFNFTVJFU0FUVFJTX0NMT1VEX1JFR0lPTjogKCkgPT4gU0VNUkVTQVRUUlNfQ0xPVURfUkVHSU9OLFxuICBTRU1SRVNBVFRSU19DT05UQUlORVJfSUQ6ICgpID0+IFNFTVJFU0FUVFJTX0NPTlRBSU5FUl9JRCxcbiAgU0VNUkVTQVRUUlNfQ09OVEFJTkVSX0lNQUdFX05BTUU6ICgpID0+IFNFTVJFU0FUVFJTX0NPTlRBSU5FUl9JTUFHRV9OQU1FLFxuICBTRU1SRVNBVFRSU19DT05UQUlORVJfSU1BR0VfVEFHOiAoKSA9PiBTRU1SRVNBVFRSU19DT05UQUlORVJfSU1BR0VfVEFHLFxuICBTRU1SRVNBVFRSU19DT05UQUlORVJfTkFNRTogKCkgPT4gU0VNUkVTQVRUUlNfQ09OVEFJTkVSX05BTUUsXG4gIFNFTVJFU0FUVFJTX0NPTlRBSU5FUl9SVU5USU1FOiAoKSA9PiBTRU1SRVNBVFRSU19DT05UQUlORVJfUlVOVElNRSxcbiAgU0VNUkVTQVRUUlNfREVQTE9ZTUVOVF9FTlZJUk9OTUVOVDogKCkgPT4gU0VNUkVTQVRUUlNfREVQTE9ZTUVOVF9FTlZJUk9OTUVOVCxcbiAgU0VNUkVTQVRUUlNfREVWSUNFX0lEOiAoKSA9PiBTRU1SRVNBVFRSU19ERVZJQ0VfSUQsXG4gIFNFTVJFU0FUVFJTX0RFVklDRV9NT0RFTF9JREVOVElGSUVSOiAoKSA9PiBTRU1SRVNBVFRSU19ERVZJQ0VfTU9ERUxfSURFTlRJRklFUixcbiAgU0VNUkVTQVRUUlNfREVWSUNFX01PREVMX05BTUU6ICgpID0+IFNFTVJFU0FUVFJTX0RFVklDRV9NT0RFTF9OQU1FLFxuICBTRU1SRVNBVFRSU19GQUFTX0lEOiAoKSA9PiBTRU1SRVNBVFRSU19GQUFTX0lELFxuICBTRU1SRVNBVFRSU19GQUFTX0lOU1RBTkNFOiAoKSA9PiBTRU1SRVNBVFRSU19GQUFTX0lOU1RBTkNFLFxuICBTRU1SRVNBVFRSU19GQUFTX01BWF9NRU1PUlk6ICgpID0+IFNFTVJFU0FUVFJTX0ZBQVNfTUFYX01FTU9SWSxcbiAgU0VNUkVTQVRUUlNfRkFBU19OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19GQUFTX05BTUUsXG4gIFNFTVJFU0FUVFJTX0ZBQVNfVkVSU0lPTjogKCkgPT4gU0VNUkVTQVRUUlNfRkFBU19WRVJTSU9OLFxuICBTRU1SRVNBVFRSU19IT1NUX0FSQ0g6ICgpID0+IFNFTVJFU0FUVFJTX0hPU1RfQVJDSCxcbiAgU0VNUkVTQVRUUlNfSE9TVF9JRDogKCkgPT4gU0VNUkVTQVRUUlNfSE9TVF9JRCxcbiAgU0VNUkVTQVRUUlNfSE9TVF9JTUFHRV9JRDogKCkgPT4gU0VNUkVTQVRUUlNfSE9TVF9JTUFHRV9JRCxcbiAgU0VNUkVTQVRUUlNfSE9TVF9JTUFHRV9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19IT1NUX0lNQUdFX05BTUUsXG4gIFNFTVJFU0FUVFJTX0hPU1RfSU1BR0VfVkVSU0lPTjogKCkgPT4gU0VNUkVTQVRUUlNfSE9TVF9JTUFHRV9WRVJTSU9OLFxuICBTRU1SRVNBVFRSU19IT1NUX05BTUU6ICgpID0+IFNFTVJFU0FUVFJTX0hPU1RfTkFNRSxcbiAgU0VNUkVTQVRUUlNfSE9TVF9UWVBFOiAoKSA9PiBTRU1SRVNBVFRSU19IT1NUX1RZUEUsXG4gIFNFTVJFU0FUVFJTX0s4U19DTFVTVEVSX05BTUU6ICgpID0+IFNFTVJFU0FUVFJTX0s4U19DTFVTVEVSX05BTUUsXG4gIFNFTVJFU0FUVFJTX0s4U19DT05UQUlORVJfTkFNRTogKCkgPT4gU0VNUkVTQVRUUlNfSzhTX0NPTlRBSU5FUl9OQU1FLFxuICBTRU1SRVNBVFRSU19LOFNfQ1JPTkpPQl9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfQ1JPTkpPQl9OQU1FLFxuICBTRU1SRVNBVFRSU19LOFNfQ1JPTkpPQl9VSUQ6ICgpID0+IFNFTVJFU0FUVFJTX0s4U19DUk9OSk9CX1VJRCxcbiAgU0VNUkVTQVRUUlNfSzhTX0RBRU1PTlNFVF9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfREFFTU9OU0VUX05BTUUsXG4gIFNFTVJFU0FUVFJTX0s4U19EQUVNT05TRVRfVUlEOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfREFFTU9OU0VUX1VJRCxcbiAgU0VNUkVTQVRUUlNfSzhTX0RFUExPWU1FTlRfTkFNRTogKCkgPT4gU0VNUkVTQVRUUlNfSzhTX0RFUExPWU1FTlRfTkFNRSxcbiAgU0VNUkVTQVRUUlNfSzhTX0RFUExPWU1FTlRfVUlEOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfREVQTE9ZTUVOVF9VSUQsXG4gIFNFTVJFU0FUVFJTX0s4U19KT0JfTkFNRTogKCkgPT4gU0VNUkVTQVRUUlNfSzhTX0pPQl9OQU1FLFxuICBTRU1SRVNBVFRSU19LOFNfSk9CX1VJRDogKCkgPT4gU0VNUkVTQVRUUlNfSzhTX0pPQl9VSUQsXG4gIFNFTVJFU0FUVFJTX0s4U19OQU1FU1BBQ0VfTkFNRTogKCkgPT4gU0VNUkVTQVRUUlNfSzhTX05BTUVTUEFDRV9OQU1FLFxuICBTRU1SRVNBVFRSU19LOFNfTk9ERV9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfTk9ERV9OQU1FLFxuICBTRU1SRVNBVFRSU19LOFNfTk9ERV9VSUQ6ICgpID0+IFNFTVJFU0FUVFJTX0s4U19OT0RFX1VJRCxcbiAgU0VNUkVTQVRUUlNfSzhTX1BPRF9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfUE9EX05BTUUsXG4gIFNFTVJFU0FUVFJTX0s4U19QT0RfVUlEOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfUE9EX1VJRCxcbiAgU0VNUkVTQVRUUlNfSzhTX1JFUExJQ0FTRVRfTkFNRTogKCkgPT4gU0VNUkVTQVRUUlNfSzhTX1JFUExJQ0FTRVRfTkFNRSxcbiAgU0VNUkVTQVRUUlNfSzhTX1JFUExJQ0FTRVRfVUlEOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfUkVQTElDQVNFVF9VSUQsXG4gIFNFTVJFU0FUVFJTX0s4U19TVEFURUZVTFNFVF9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19LOFNfU1RBVEVGVUxTRVRfTkFNRSxcbiAgU0VNUkVTQVRUUlNfSzhTX1NUQVRFRlVMU0VUX1VJRDogKCkgPT4gU0VNUkVTQVRUUlNfSzhTX1NUQVRFRlVMU0VUX1VJRCxcbiAgU0VNUkVTQVRUUlNfT1NfREVTQ1JJUFRJT046ICgpID0+IFNFTVJFU0FUVFJTX09TX0RFU0NSSVBUSU9OLFxuICBTRU1SRVNBVFRSU19PU19OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19PU19OQU1FLFxuICBTRU1SRVNBVFRSU19PU19UWVBFOiAoKSA9PiBTRU1SRVNBVFRSU19PU19UWVBFLFxuICBTRU1SRVNBVFRSU19PU19WRVJTSU9OOiAoKSA9PiBTRU1SRVNBVFRSU19PU19WRVJTSU9OLFxuICBTRU1SRVNBVFRSU19QUk9DRVNTX0NPTU1BTkQ6ICgpID0+IFNFTVJFU0FUVFJTX1BST0NFU1NfQ09NTUFORCxcbiAgU0VNUkVTQVRUUlNfUFJPQ0VTU19DT01NQU5EX0FSR1M6ICgpID0+IFNFTVJFU0FUVFJTX1BST0NFU1NfQ09NTUFORF9BUkdTLFxuICBTRU1SRVNBVFRSU19QUk9DRVNTX0NPTU1BTkRfTElORTogKCkgPT4gU0VNUkVTQVRUUlNfUFJPQ0VTU19DT01NQU5EX0xJTkUsXG4gIFNFTVJFU0FUVFJTX1BST0NFU1NfRVhFQ1VUQUJMRV9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19QUk9DRVNTX0VYRUNVVEFCTEVfTkFNRSxcbiAgU0VNUkVTQVRUUlNfUFJPQ0VTU19FWEVDVVRBQkxFX1BBVEg6ICgpID0+IFNFTVJFU0FUVFJTX1BST0NFU1NfRVhFQ1VUQUJMRV9QQVRILFxuICBTRU1SRVNBVFRSU19QUk9DRVNTX09XTkVSOiAoKSA9PiBTRU1SRVNBVFRSU19QUk9DRVNTX09XTkVSLFxuICBTRU1SRVNBVFRSU19QUk9DRVNTX1BJRDogKCkgPT4gU0VNUkVTQVRUUlNfUFJPQ0VTU19QSUQsXG4gIFNFTVJFU0FUVFJTX1BST0NFU1NfUlVOVElNRV9ERVNDUklQVElPTjogKCkgPT4gU0VNUkVTQVRUUlNfUFJPQ0VTU19SVU5USU1FX0RFU0NSSVBUSU9OLFxuICBTRU1SRVNBVFRSU19QUk9DRVNTX1JVTlRJTUVfTkFNRTogKCkgPT4gU0VNUkVTQVRUUlNfUFJPQ0VTU19SVU5USU1FX05BTUUsXG4gIFNFTVJFU0FUVFJTX1BST0NFU1NfUlVOVElNRV9WRVJTSU9OOiAoKSA9PiBTRU1SRVNBVFRSU19QUk9DRVNTX1JVTlRJTUVfVkVSU0lPTixcbiAgU0VNUkVTQVRUUlNfU0VSVklDRV9JTlNUQU5DRV9JRDogKCkgPT4gU0VNUkVTQVRUUlNfU0VSVklDRV9JTlNUQU5DRV9JRCxcbiAgU0VNUkVTQVRUUlNfU0VSVklDRV9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19TRVJWSUNFX05BTUUsXG4gIFNFTVJFU0FUVFJTX1NFUlZJQ0VfTkFNRVNQQUNFOiAoKSA9PiBTRU1SRVNBVFRSU19TRVJWSUNFX05BTUVTUEFDRSxcbiAgU0VNUkVTQVRUUlNfU0VSVklDRV9WRVJTSU9OOiAoKSA9PiBTRU1SRVNBVFRSU19TRVJWSUNFX1ZFUlNJT04sXG4gIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9BVVRPX1ZFUlNJT046ICgpID0+IFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9BVVRPX1ZFUlNJT04sXG4gIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfTEFOR1VBR0U6ICgpID0+IFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfTEFOR1VBR0UsXG4gIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfTkFNRTogKCkgPT4gU0VNUkVTQVRUUlNfVEVMRU1FVFJZX1NES19OQU1FLFxuICBTRU1SRVNBVFRSU19URUxFTUVUUllfU0RLX1ZFUlNJT046ICgpID0+IFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfVkVSU0lPTixcbiAgU0VNUkVTQVRUUlNfV0VCRU5HSU5FX0RFU0NSSVBUSU9OOiAoKSA9PiBTRU1SRVNBVFRSU19XRUJFTkdJTkVfREVTQ1JJUFRJT04sXG4gIFNFTVJFU0FUVFJTX1dFQkVOR0lORV9OQU1FOiAoKSA9PiBTRU1SRVNBVFRSU19XRUJFTkdJTkVfTkFNRSxcbiAgU0VNUkVTQVRUUlNfV0VCRU5HSU5FX1ZFUlNJT046ICgpID0+IFNFTVJFU0FUVFJTX1dFQkVOR0lORV9WRVJTSU9OLFxuICBTZW1hbnRpY0F0dHJpYnV0ZXM6ICgpID0+IFNlbWFudGljQXR0cmlidXRlcyxcbiAgU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXM6ICgpID0+IFNlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLFxuICBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19DUFA6ICgpID0+IFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0NQUCxcbiAgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfRE9UTkVUOiAoKSA9PiBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19ET1RORVQsXG4gIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0VSTEFORzogKCkgPT4gVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfRVJMQU5HLFxuICBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19HTzogKCkgPT4gVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfR08sXG4gIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0pBVkE6ICgpID0+IFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX0pBVkEsXG4gIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX05PREVKUzogKCkgPT4gVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfTk9ERUpTLFxuICBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19QSFA6ICgpID0+IFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1BIUCxcbiAgVEVMRU1FVFJZU0RLTEFOR1VBR0VWQUxVRVNfUFlUSE9OOiAoKSA9PiBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19QWVRIT04sXG4gIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1JVQlk6ICgpID0+IFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1JVQlksXG4gIFRFTEVNRVRSWVNES0xBTkdVQUdFVkFMVUVTX1dFQkpTOiAoKSA9PiBURUxFTUVUUllTREtMQU5HVUFHRVZBTFVFU19XRUJKUyxcbiAgVGVsZW1ldHJ5U2RrTGFuZ3VhZ2VWYWx1ZXM6ICgpID0+IFRlbGVtZXRyeVNka0xhbmd1YWdlVmFsdWVzXG59KTtcbnZhciBpbml0X2VzbTIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zL2J1aWxkL2VzbS9pbmRleC5qc1wiKCkge1xuICAgIGluaXRfdHJhY2UyKCk7XG4gICAgaW5pdF9yZXNvdXJjZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvc2RrLWluZm8uanNcbnZhciBfYSwgU0RLX0lORk87XG52YXIgaW5pdF9zZGtfaW5mbyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9zZGstaW5mby5qc1wiKCkge1xuICAgIGluaXRfdmVyc2lvbjIoKTtcbiAgICBpbml0X2VzbTIoKTtcbiAgICBTREtfSU5GTyA9IChfYSA9IHt9LCBfYVtTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX05BTUVdID0gXCJvcGVudGVsZW1ldHJ5XCIsIF9hW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9OQU1FXSA9IFwibm9kZVwiLCBfYVtTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX0xBTkdVQUdFXSA9IFRlbGVtZXRyeVNka0xhbmd1YWdlVmFsdWVzLk5PREVKUywgX2FbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19WRVJTSU9OXSA9IFZFUlNJT04yLCBfYSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS90aW1lci11dGlsLmpzXG5mdW5jdGlvbiB1bnJlZlRpbWVyKHRpbWVyKSB7XG4gIHRpbWVyLnVucmVmKCk7XG59XG52YXIgaW5pdF90aW1lcl91dGlsID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL3RpbWVyLXV0aWwuanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2luZGV4LmpzXG52YXIgaW5pdF9ub2RlMiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9pbmRleC5qc1wiKCkge1xuICAgIGluaXRfZW52aXJvbm1lbnQyKCk7XG4gICAgaW5pdF9nbG9iYWxUaGlzMygpO1xuICAgIGluaXRfaGV4X3RvX2Jhc2U2NCgpO1xuICAgIGluaXRfUmFuZG9tSWRHZW5lcmF0b3IoKTtcbiAgICBpbml0X3BlcmZvcm1hbmNlKCk7XG4gICAgaW5pdF9zZGtfaW5mbygpO1xuICAgIGluaXRfdGltZXJfdXRpbCgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL2luZGV4LmpzXG52YXIgaW5pdF9wbGF0Zm9ybTIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3BsYXRmb3JtL2luZGV4LmpzXCIoKSB7XG4gICAgaW5pdF9ub2RlMigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2NvbW1vbi90aW1lLmpzXG5mdW5jdGlvbiBtaWxsaXNUb0hyVGltZShlcG9jaE1pbGxpcykge1xuICB2YXIgZXBvY2hTZWNvbmRzID0gZXBvY2hNaWxsaXMgLyAxZTM7XG4gIHZhciBzZWNvbmRzID0gTWF0aC50cnVuYyhlcG9jaFNlY29uZHMpO1xuICB2YXIgbmFub3MgPSBNYXRoLnJvdW5kKGVwb2NoTWlsbGlzICUgMWUzICogTUlMTElTRUNPTkRTX1RPX05BTk9TRUNPTkRTKTtcbiAgcmV0dXJuIFtzZWNvbmRzLCBuYW5vc107XG59XG5mdW5jdGlvbiBnZXRUaW1lT3JpZ2luKCkge1xuICB2YXIgdGltZU9yaWdpbiA9IG90cGVyZm9ybWFuY2UudGltZU9yaWdpbjtcbiAgaWYgKHR5cGVvZiB0aW1lT3JpZ2luICE9PSBcIm51bWJlclwiKSB7XG4gICAgdmFyIHBlcmYgPSBvdHBlcmZvcm1hbmNlO1xuICAgIHRpbWVPcmlnaW4gPSBwZXJmLnRpbWluZyAmJiBwZXJmLnRpbWluZy5mZXRjaFN0YXJ0O1xuICB9XG4gIHJldHVybiB0aW1lT3JpZ2luO1xufVxuZnVuY3Rpb24gaHJUaW1lKHBlcmZvcm1hbmNlTm93KSB7XG4gIHZhciB0aW1lT3JpZ2luID0gbWlsbGlzVG9IclRpbWUoZ2V0VGltZU9yaWdpbigpKTtcbiAgdmFyIG5vdyA9IG1pbGxpc1RvSHJUaW1lKHR5cGVvZiBwZXJmb3JtYW5jZU5vdyA9PT0gXCJudW1iZXJcIiA/IHBlcmZvcm1hbmNlTm93IDogb3RwZXJmb3JtYW5jZS5ub3coKSk7XG4gIHJldHVybiBhZGRIclRpbWVzKHRpbWVPcmlnaW4sIG5vdyk7XG59XG5mdW5jdGlvbiB0aW1lSW5wdXRUb0hyVGltZSh0aW1lKSB7XG4gIGlmIChpc1RpbWVJbnB1dEhyVGltZSh0aW1lKSkge1xuICAgIHJldHVybiB0aW1lO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKHRpbWUgPCBnZXRUaW1lT3JpZ2luKCkpIHtcbiAgICAgIHJldHVybiBoclRpbWUodGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWxsaXNUb0hyVGltZSh0aW1lKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gbWlsbGlzVG9IclRpbWUodGltZS5nZXRUaW1lKCkpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaHJUaW1lRHVyYXRpb24oc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG4gIHZhciBzZWNvbmRzID0gZW5kVGltZVswXSAtIHN0YXJ0VGltZVswXTtcbiAgdmFyIG5hbm9zID0gZW5kVGltZVsxXSAtIHN0YXJ0VGltZVsxXTtcbiAgaWYgKG5hbm9zIDwgMCkge1xuICAgIHNlY29uZHMgLT0gMTtcbiAgICBuYW5vcyArPSBTRUNPTkRfVE9fTkFOT1NFQ09ORFM7XG4gIH1cbiAgcmV0dXJuIFtzZWNvbmRzLCBuYW5vc107XG59XG5mdW5jdGlvbiBoclRpbWVUb1RpbWVTdGFtcCh0aW1lKSB7XG4gIHZhciBwcmVjaXNpb24gPSBOQU5PU0VDT05EX0RJR0lUUztcbiAgdmFyIHRtcCA9IFwiXCIgKyBcIjBcIi5yZXBlYXQocHJlY2lzaW9uKSArIHRpbWVbMV0gKyBcIlpcIjtcbiAgdmFyIG5hbm9TdHJpbmcgPSB0bXAuc3Vic3RyKHRtcC5sZW5ndGggLSBwcmVjaXNpb24gLSAxKTtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lWzBdICogMWUzKS50b0lTT1N0cmluZygpO1xuICByZXR1cm4gZGF0ZS5yZXBsYWNlKFwiMDAwWlwiLCBuYW5vU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIGhyVGltZVRvTmFub3NlY29uZHModGltZSkge1xuICByZXR1cm4gdGltZVswXSAqIFNFQ09ORF9UT19OQU5PU0VDT05EUyArIHRpbWVbMV07XG59XG5mdW5jdGlvbiBoclRpbWVUb01pbGxpc2Vjb25kcyh0aW1lKSB7XG4gIHJldHVybiB0aW1lWzBdICogMWUzICsgdGltZVsxXSAvIDFlNjtcbn1cbmZ1bmN0aW9uIGhyVGltZVRvTWljcm9zZWNvbmRzKHRpbWUpIHtcbiAgcmV0dXJuIHRpbWVbMF0gKiAxZTYgKyB0aW1lWzFdIC8gMWUzO1xufVxuZnVuY3Rpb24gaXNUaW1lSW5wdXRIclRpbWUodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgdmFsdWVbMF0gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlWzFdID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNUaW1lSW5wdXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzVGltZUlucHV0SHJUaW1lKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufVxuZnVuY3Rpb24gYWRkSHJUaW1lcyh0aW1lMSwgdGltZTIpIHtcbiAgdmFyIG91dCA9IFt0aW1lMVswXSArIHRpbWUyWzBdLCB0aW1lMVsxXSArIHRpbWUyWzFdXTtcbiAgaWYgKG91dFsxXSA+PSBTRUNPTkRfVE9fTkFOT1NFQ09ORFMpIHtcbiAgICBvdXRbMV0gLT0gU0VDT05EX1RPX05BTk9TRUNPTkRTO1xuICAgIG91dFswXSArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG52YXIgTkFOT1NFQ09ORF9ESUdJVFMsIE5BTk9TRUNPTkRfRElHSVRTX0lOX01JTExJUywgTUlMTElTRUNPTkRTX1RPX05BTk9TRUNPTkRTLCBTRUNPTkRfVE9fTkFOT1NFQ09ORFM7XG52YXIgaW5pdF90aW1lID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9jb21tb24vdGltZS5qc1wiKCkge1xuICAgIGluaXRfcGxhdGZvcm0yKCk7XG4gICAgTkFOT1NFQ09ORF9ESUdJVFMgPSA5O1xuICAgIE5BTk9TRUNPTkRfRElHSVRTX0lOX01JTExJUyA9IDY7XG4gICAgTUlMTElTRUNPTkRTX1RPX05BTk9TRUNPTkRTID0gTWF0aC5wb3coMTAsIE5BTk9TRUNPTkRfRElHSVRTX0lOX01JTExJUyk7XG4gICAgU0VDT05EX1RPX05BTk9TRUNPTkRTID0gTWF0aC5wb3coMTAsIE5BTk9TRUNPTkRfRElHSVRTKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9jb21tb24vdHlwZXMuanNcbnZhciBpbml0X3R5cGVzMiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vY29tbW9uL3R5cGVzLmpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vRXhwb3J0UmVzdWx0LmpzXG52YXIgRXhwb3J0UmVzdWx0Q29kZTtcbnZhciBpbml0X0V4cG9ydFJlc3VsdCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vRXhwb3J0UmVzdWx0LmpzXCIoKSB7XG4gICAgKGZ1bmN0aW9uKEV4cG9ydFJlc3VsdENvZGUyKSB7XG4gICAgICBFeHBvcnRSZXN1bHRDb2RlMltFeHBvcnRSZXN1bHRDb2RlMltcIlNVQ0NFU1NcIl0gPSAwXSA9IFwiU1VDQ0VTU1wiO1xuICAgICAgRXhwb3J0UmVzdWx0Q29kZTJbRXhwb3J0UmVzdWx0Q29kZTJbXCJGQUlMRURcIl0gPSAxXSA9IFwiRkFJTEVEXCI7XG4gICAgfSkoRXhwb3J0UmVzdWx0Q29kZSB8fCAoRXhwb3J0UmVzdWx0Q29kZSA9IHt9KSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vcHJvcGFnYXRpb24vY29tcG9zaXRlLmpzXG52YXIgX192YWx1ZXMzLCBDb21wb3NpdGVQcm9wYWdhdG9yO1xudmFyIGluaXRfY29tcG9zaXRlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9wcm9wYWdhdGlvbi9jb21wb3NpdGUuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIF9fdmFsdWVzMyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgICBpZiAobSlcbiAgICAgICAgcmV0dXJuIG0uY2FsbChvKTtcbiAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpXG4gICAgICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIH07XG4gICAgQ29tcG9zaXRlUHJvcGFnYXRvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBvc2l0ZVByb3BhZ2F0b3IyKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EyO1xuICAgICAgICB0aGlzLl9wcm9wYWdhdG9ycyA9IChfYTIgPSBjb25maWcucHJvcGFnYXRvcnMpICE9PSBudWxsICYmIF9hMiAhPT0gdm9pZCAwID8gX2EyIDogW107XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IEFycmF5LmZyb20obmV3IFNldCh0aGlzLl9wcm9wYWdhdG9ycy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgcC5maWVsZHMgPT09IFwiZnVuY3Rpb25cIiA/IHAuZmllbGRzKCkgOiBbXTtcbiAgICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICByZXR1cm4geC5jb25jYXQoeSk7XG4gICAgICAgIH0sIFtdKSkpO1xuICAgICAgfVxuICAgICAgQ29tcG9zaXRlUHJvcGFnYXRvcjIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGNvbnRleHQyLCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMzKHRoaXMuX3Byb3BhZ2F0b3JzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHByb3BhZ2F0b3IgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHByb3BhZ2F0b3IuaW5qZWN0KGNvbnRleHQyLCBjYXJyaWVyLCBzZXR0ZXIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGRpYWcyLndhcm4oXCJGYWlsZWQgdG8gaW5qZWN0IHdpdGggXCIgKyBwcm9wYWdhdG9yLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi4gRXJyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYTIgPSBfYi5yZXR1cm4pKVxuICAgICAgICAgICAgICBfYTIuY2FsbChfYik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlXzEpXG4gICAgICAgICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21wb3NpdGVQcm9wYWdhdG9yMi5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uKGNvbnRleHQyLCBjYXJyaWVyLCBnZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BhZ2F0b3JzLnJlZHVjZShmdW5jdGlvbihjdHgsIHByb3BhZ2F0b3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BhZ2F0b3IuZXh0cmFjdChjdHgsIGNhcnJpZXIsIGdldHRlcik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkaWFnMi53YXJuKFwiRmFpbGVkIHRvIGluamVjdCB3aXRoIFwiICsgcHJvcGFnYXRvci5jb25zdHJ1Y3Rvci5uYW1lICsgXCIuIEVycjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH0sIGNvbnRleHQyKTtcbiAgICAgIH07XG4gICAgICBDb21wb3NpdGVQcm9wYWdhdG9yMi5wcm90b3R5cGUuZmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWVsZHMuc2xpY2UoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcG9zaXRlUHJvcGFnYXRvcjI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2ludGVybmFsL3ZhbGlkYXRvcnMuanNcbmZ1bmN0aW9uIHZhbGlkYXRlS2V5MihrZXkpIHtcbiAgcmV0dXJuIFZBTElEX0tFWV9SRUdFWDIudGVzdChrZXkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZTIodmFsdWUpIHtcbiAgcmV0dXJuIFZBTElEX1ZBTFVFX0JBU0VfUkVHRVgyLnRlc3QodmFsdWUpICYmICFJTlZBTElEX1ZBTFVFX0NPTU1BX0VRVUFMX1JFR0VYMi50ZXN0KHZhbHVlKTtcbn1cbnZhciBWQUxJRF9LRVlfQ0hBUl9SQU5HRTIsIFZBTElEX0tFWTIsIFZBTElEX1ZFTkRPUl9LRVkyLCBWQUxJRF9LRVlfUkVHRVgyLCBWQUxJRF9WQUxVRV9CQVNFX1JFR0VYMiwgSU5WQUxJRF9WQUxVRV9DT01NQV9FUVVBTF9SRUdFWDI7XG52YXIgaW5pdF92YWxpZGF0b3JzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS9pbnRlcm5hbC92YWxpZGF0b3JzLmpzXCIoKSB7XG4gICAgVkFMSURfS0VZX0NIQVJfUkFOR0UyID0gXCJbXzAtOWEtei0qL11cIjtcbiAgICBWQUxJRF9LRVkyID0gXCJbYS16XVwiICsgVkFMSURfS0VZX0NIQVJfUkFOR0UyICsgXCJ7MCwyNTV9XCI7XG4gICAgVkFMSURfVkVORE9SX0tFWTIgPSBcIlthLXowLTldXCIgKyBWQUxJRF9LRVlfQ0hBUl9SQU5HRTIgKyBcInswLDI0MH1AW2Etel1cIiArIFZBTElEX0tFWV9DSEFSX1JBTkdFMiArIFwiezAsMTN9XCI7XG4gICAgVkFMSURfS0VZX1JFR0VYMiA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBWQUxJRF9LRVkyICsgXCJ8XCIgKyBWQUxJRF9WRU5ET1JfS0VZMiArIFwiKSRcIik7XG4gICAgVkFMSURfVkFMVUVfQkFTRV9SRUdFWDIgPSAvXlsgLX5dezAsMjU1fVshLX5dJC87XG4gICAgSU5WQUxJRF9WQUxVRV9DT01NQV9FUVVBTF9SRUdFWDIgPSAvLHw9LztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9UcmFjZVN0YXRlLmpzXG52YXIgTUFYX1RSQUNFX1NUQVRFX0lURU1TMiwgTUFYX1RSQUNFX1NUQVRFX0xFTjIsIExJU1RfTUVNQkVSU19TRVBBUkFUT1IyLCBMSVNUX01FTUJFUl9LRVlfVkFMVUVfU1BMSVRURVIyLCBUcmFjZVN0YXRlO1xudmFyIGluaXRfVHJhY2VTdGF0ZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2UvVHJhY2VTdGF0ZS5qc1wiKCkge1xuICAgIGluaXRfdmFsaWRhdG9ycygpO1xuICAgIE1BWF9UUkFDRV9TVEFURV9JVEVNUzIgPSAzMjtcbiAgICBNQVhfVFJBQ0VfU1RBVEVfTEVOMiA9IDUxMjtcbiAgICBMSVNUX01FTUJFUlNfU0VQQVJBVE9SMiA9IFwiLFwiO1xuICAgIExJU1RfTUVNQkVSX0tFWV9WQUxVRV9TUExJVFRFUjIgPSBcIj1cIjtcbiAgICBUcmFjZVN0YXRlID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gVHJhY2VTdGF0ZTIocmF3VHJhY2VTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbFN0YXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHJhd1RyYWNlU3RhdGUpXG4gICAgICAgICAgdGhpcy5fcGFyc2UocmF3VHJhY2VTdGF0ZSk7XG4gICAgICB9XG4gICAgICBUcmFjZVN0YXRlMi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHJhY2VTdGF0ZSA9IHRoaXMuX2Nsb25lKCk7XG4gICAgICAgIGlmICh0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciB0cmFjZVN0YXRlID0gdGhpcy5fY2xvbmUoKTtcbiAgICAgICAgdHJhY2VTdGF0ZS5faW50ZXJuYWxTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZS5nZXQoa2V5KTtcbiAgICAgIH07XG4gICAgICBUcmFjZVN0YXRlMi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzKCkucmVkdWNlKGZ1bmN0aW9uKGFnZywga2V5KSB7XG4gICAgICAgICAgYWdnLnB1c2goa2V5ICsgTElTVF9NRU1CRVJfS0VZX1ZBTFVFX1NQTElUVEVSMiArIF90aGlzLmdldChrZXkpKTtcbiAgICAgICAgICByZXR1cm4gYWdnO1xuICAgICAgICB9LCBbXSkuam9pbihMSVNUX01FTUJFUlNfU0VQQVJBVE9SMik7XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLl9wYXJzZSA9IGZ1bmN0aW9uKHJhd1RyYWNlU3RhdGUpIHtcbiAgICAgICAgaWYgKHJhd1RyYWNlU3RhdGUubGVuZ3RoID4gTUFYX1RSQUNFX1NUQVRFX0xFTjIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbFN0YXRlID0gcmF3VHJhY2VTdGF0ZS5zcGxpdChMSVNUX01FTUJFUlNfU0VQQVJBVE9SMikucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbihhZ2csIHBhcnQpIHtcbiAgICAgICAgICB2YXIgbGlzdE1lbWJlciA9IHBhcnQudHJpbSgpO1xuICAgICAgICAgIHZhciBpID0gbGlzdE1lbWJlci5pbmRleE9mKExJU1RfTUVNQkVSX0tFWV9WQUxVRV9TUExJVFRFUjIpO1xuICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGxpc3RNZW1iZXIuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsaXN0TWVtYmVyLnNsaWNlKGkgKyAxLCBwYXJ0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVLZXkyKGtleSkgJiYgdmFsaWRhdGVWYWx1ZTIodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGFnZy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWdnO1xuICAgICAgICB9LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsU3RhdGUuc2l6ZSA+IE1BWF9UUkFDRV9TVEFURV9JVEVNUzIpIHtcbiAgICAgICAgICB0aGlzLl9pbnRlcm5hbFN0YXRlID0gbmV3IE1hcChBcnJheS5mcm9tKHRoaXMuX2ludGVybmFsU3RhdGUuZW50cmllcygpKS5yZXZlcnNlKCkuc2xpY2UoMCwgTUFYX1RSQUNFX1NUQVRFX0lURU1TMikpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLl9rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2ludGVybmFsU3RhdGUua2V5cygpKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgICAgVHJhY2VTdGF0ZTIucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdHJhY2VTdGF0ZSA9IG5ldyBUcmFjZVN0YXRlMigpO1xuICAgICAgICB0cmFjZVN0YXRlLl9pbnRlcm5hbFN0YXRlID0gbmV3IE1hcCh0aGlzLl9pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRyYWNlU3RhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRyYWNlU3RhdGUyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9XM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yLmpzXG5mdW5jdGlvbiBwYXJzZVRyYWNlUGFyZW50KHRyYWNlUGFyZW50KSB7XG4gIHZhciBtYXRjaCA9IFRSQUNFX1BBUkVOVF9SRUdFWC5leGVjKHRyYWNlUGFyZW50KTtcbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKG1hdGNoWzFdID09PSBcIjAwXCIgJiYgbWF0Y2hbNV0pXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgdHJhY2VJZDogbWF0Y2hbMl0sXG4gICAgc3BhbklkOiBtYXRjaFszXSxcbiAgICB0cmFjZUZsYWdzOiBwYXJzZUludChtYXRjaFs0XSwgMTYpXG4gIH07XG59XG52YXIgVFJBQ0VfUEFSRU5UX0hFQURFUiwgVFJBQ0VfU1RBVEVfSEVBREVSLCBWRVJTSU9OMywgVkVSU0lPTl9QQVJULCBUUkFDRV9JRF9QQVJULCBQQVJFTlRfSURfUEFSVCwgRkxBR1NfUEFSVCwgVFJBQ0VfUEFSRU5UX1JFR0VYLCBXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yO1xudmFyIGluaXRfVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2UvVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvci5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgaW5pdF9zdXBwcmVzc190cmFjaW5nKCk7XG4gICAgaW5pdF9UcmFjZVN0YXRlKCk7XG4gICAgVFJBQ0VfUEFSRU5UX0hFQURFUiA9IFwidHJhY2VwYXJlbnRcIjtcbiAgICBUUkFDRV9TVEFURV9IRUFERVIgPSBcInRyYWNlc3RhdGVcIjtcbiAgICBWRVJTSU9OMyA9IFwiMDBcIjtcbiAgICBWRVJTSU9OX1BBUlQgPSBcIig/IWZmKVtcXFxcZGEtZl17Mn1cIjtcbiAgICBUUkFDRV9JRF9QQVJUID0gXCIoPyFbMF17MzJ9KVtcXFxcZGEtZl17MzJ9XCI7XG4gICAgUEFSRU5UX0lEX1BBUlQgPSBcIig/IVswXXsxNn0pW1xcXFxkYS1mXXsxNn1cIjtcbiAgICBGTEFHU19QQVJUID0gXCJbXFxcXGRhLWZdezJ9XCI7XG4gICAgVFJBQ0VfUEFSRU5UX1JFR0VYID0gbmV3IFJlZ0V4cChcIl5cXFxccz8oXCIgKyBWRVJTSU9OX1BBUlQgKyBcIiktKFwiICsgVFJBQ0VfSURfUEFSVCArIFwiKS0oXCIgKyBQQVJFTlRfSURfUEFSVCArIFwiKS0oXCIgKyBGTEFHU19QQVJUICsgXCIpKC0uKik/XFxcXHM/JFwiKTtcbiAgICBXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvcjIoKSB7XG4gICAgICB9XG4gICAgICBXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yMi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24oY29udGV4dDIsIGNhcnJpZXIsIHNldHRlcikge1xuICAgICAgICB2YXIgc3BhbkNvbnRleHQgPSB0cmFjZS5nZXRTcGFuQ29udGV4dChjb250ZXh0Mik7XG4gICAgICAgIGlmICghc3BhbkNvbnRleHQgfHwgaXNUcmFjaW5nU3VwcHJlc3NlZChjb250ZXh0MikgfHwgIWlzU3BhbkNvbnRleHRWYWxpZChzcGFuQ29udGV4dCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdHJhY2VQYXJlbnQgPSBWRVJTSU9OMyArIFwiLVwiICsgc3BhbkNvbnRleHQudHJhY2VJZCArIFwiLVwiICsgc3BhbkNvbnRleHQuc3BhbklkICsgXCItMFwiICsgTnVtYmVyKHNwYW5Db250ZXh0LnRyYWNlRmxhZ3MgfHwgVHJhY2VGbGFncy5OT05FKS50b1N0cmluZygxNik7XG4gICAgICAgIHNldHRlci5zZXQoY2FycmllciwgVFJBQ0VfUEFSRU5UX0hFQURFUiwgdHJhY2VQYXJlbnQpO1xuICAgICAgICBpZiAoc3BhbkNvbnRleHQudHJhY2VTdGF0ZSkge1xuICAgICAgICAgIHNldHRlci5zZXQoY2FycmllciwgVFJBQ0VfU1RBVEVfSEVBREVSLCBzcGFuQ29udGV4dC50cmFjZVN0YXRlLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDIsIGNhcnJpZXIsIGdldHRlcikge1xuICAgICAgICB2YXIgdHJhY2VQYXJlbnRIZWFkZXIgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIFRSQUNFX1BBUkVOVF9IRUFERVIpO1xuICAgICAgICBpZiAoIXRyYWNlUGFyZW50SGVhZGVyKVxuICAgICAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICAgICAgdmFyIHRyYWNlUGFyZW50ID0gQXJyYXkuaXNBcnJheSh0cmFjZVBhcmVudEhlYWRlcikgPyB0cmFjZVBhcmVudEhlYWRlclswXSA6IHRyYWNlUGFyZW50SGVhZGVyO1xuICAgICAgICBpZiAodHlwZW9mIHRyYWNlUGFyZW50ICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICAgICAgdmFyIHNwYW5Db250ZXh0ID0gcGFyc2VUcmFjZVBhcmVudCh0cmFjZVBhcmVudCk7XG4gICAgICAgIGlmICghc3BhbkNvbnRleHQpXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQyO1xuICAgICAgICBzcGFuQ29udGV4dC5pc1JlbW90ZSA9IHRydWU7XG4gICAgICAgIHZhciB0cmFjZVN0YXRlSGVhZGVyID0gZ2V0dGVyLmdldChjYXJyaWVyLCBUUkFDRV9TVEFURV9IRUFERVIpO1xuICAgICAgICBpZiAodHJhY2VTdGF0ZUhlYWRlcikge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IEFycmF5LmlzQXJyYXkodHJhY2VTdGF0ZUhlYWRlcikgPyB0cmFjZVN0YXRlSGVhZGVyLmpvaW4oXCIsXCIpIDogdHJhY2VTdGF0ZUhlYWRlcjtcbiAgICAgICAgICBzcGFuQ29udGV4dC50cmFjZVN0YXRlID0gbmV3IFRyYWNlU3RhdGUodHlwZW9mIHN0YXRlID09PSBcInN0cmluZ1wiID8gc3RhdGUgOiB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFjZS5zZXRTcGFuQ29udGV4dChjb250ZXh0Miwgc3BhbkNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IyLnByb3RvdHlwZS5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUUkFDRV9QQVJFTlRfSEVBREVSLCBUUkFDRV9TVEFURV9IRUFERVJdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2UvSWRHZW5lcmF0b3IuanNcbnZhciBpbml0X0lkR2VuZXJhdG9yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9JZEdlbmVyYXRvci5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL3JwYy1tZXRhZGF0YS5qc1xuZnVuY3Rpb24gc2V0UlBDTWV0YWRhdGEoY29udGV4dDIsIG1ldGEpIHtcbiAgcmV0dXJuIGNvbnRleHQyLnNldFZhbHVlKFJQQ19NRVRBREFUQV9LRVksIG1ldGEpO1xufVxuZnVuY3Rpb24gZGVsZXRlUlBDTWV0YWRhdGEoY29udGV4dDIpIHtcbiAgcmV0dXJuIGNvbnRleHQyLmRlbGV0ZVZhbHVlKFJQQ19NRVRBREFUQV9LRVkpO1xufVxuZnVuY3Rpb24gZ2V0UlBDTWV0YWRhdGEoY29udGV4dDIpIHtcbiAgcmV0dXJuIGNvbnRleHQyLmdldFZhbHVlKFJQQ19NRVRBREFUQV9LRVkpO1xufVxudmFyIFJQQ19NRVRBREFUQV9LRVksIFJQQ1R5cGU7XG52YXIgaW5pdF9ycGNfbWV0YWRhdGEgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL3JwYy1tZXRhZGF0YS5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgUlBDX01FVEFEQVRBX0tFWSA9IGNyZWF0ZUNvbnRleHRLZXkoXCJPcGVuVGVsZW1ldHJ5IFNESyBDb250ZXh0IEtleSBSUENfTUVUQURBVEFcIik7XG4gICAgKGZ1bmN0aW9uKFJQQ1R5cGUyKSB7XG4gICAgICBSUENUeXBlMltcIkhUVFBcIl0gPSBcImh0dHBcIjtcbiAgICB9KShSUENUeXBlIHx8IChSUENUeXBlID0ge30pKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9zYW1wbGVyL0Fsd2F5c09mZlNhbXBsZXIuanNcbnZhciBBbHdheXNPZmZTYW1wbGVyO1xudmFyIGluaXRfQWx3YXlzT2ZmU2FtcGxlciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2Uvc2FtcGxlci9BbHdheXNPZmZTYW1wbGVyLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBBbHdheXNPZmZTYW1wbGVyID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gQWx3YXlzT2ZmU2FtcGxlcjMoKSB7XG4gICAgICB9XG4gICAgICBBbHdheXNPZmZTYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVjaXNpb246IFNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIEFsd2F5c09mZlNhbXBsZXIzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJBbHdheXNPZmZTYW1wbGVyXCI7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFsd2F5c09mZlNhbXBsZXIzO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS90cmFjZS9zYW1wbGVyL0Fsd2F5c09uU2FtcGxlci5qc1xudmFyIEFsd2F5c09uU2FtcGxlcjtcbnZhciBpbml0X0Fsd2F5c09uU2FtcGxlciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2Uvc2FtcGxlci9BbHdheXNPblNhbXBsZXIuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIEFsd2F5c09uU2FtcGxlciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEFsd2F5c09uU2FtcGxlcjMoKSB7XG4gICAgICB9XG4gICAgICBBbHdheXNPblNhbXBsZXIzLnByb3RvdHlwZS5zaG91bGRTYW1wbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWNpc2lvbjogU2FtcGxpbmdEZWNpc2lvbi5SRUNPUkRfQU5EX1NBTVBMRURcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBBbHdheXNPblNhbXBsZXIzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJBbHdheXNPblNhbXBsZXJcIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQWx3YXlzT25TYW1wbGVyMztcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2Uvc2FtcGxlci9QYXJlbnRCYXNlZFNhbXBsZXIuanNcbnZhciBQYXJlbnRCYXNlZFNhbXBsZXI7XG52YXIgaW5pdF9QYXJlbnRCYXNlZFNhbXBsZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL3NhbXBsZXIvUGFyZW50QmFzZWRTYW1wbGVyLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBpbml0X2dsb2JhbF9lcnJvcl9oYW5kbGVyKCk7XG4gICAgaW5pdF9BbHdheXNPZmZTYW1wbGVyKCk7XG4gICAgaW5pdF9BbHdheXNPblNhbXBsZXIoKTtcbiAgICBQYXJlbnRCYXNlZFNhbXBsZXIgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBQYXJlbnRCYXNlZFNhbXBsZXIzKGNvbmZpZykge1xuICAgICAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLl9yb290ID0gY29uZmlnLnJvb3Q7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdCkge1xuICAgICAgICAgIGdsb2JhbEVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJQYXJlbnRCYXNlZFNhbXBsZXIgbXVzdCBoYXZlIGEgcm9vdCBzYW1wbGVyIGNvbmZpZ3VyZWRcIikpO1xuICAgICAgICAgIHRoaXMuX3Jvb3QgPSBuZXcgQWx3YXlzT25TYW1wbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlUGFyZW50U2FtcGxlZCA9IChfYTIgPSBjb25maWcucmVtb3RlUGFyZW50U2FtcGxlZCkgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiBuZXcgQWx3YXlzT25TYW1wbGVyKCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVBhcmVudE5vdFNhbXBsZWQgPSAoX2IgPSBjb25maWcucmVtb3RlUGFyZW50Tm90U2FtcGxlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEFsd2F5c09mZlNhbXBsZXIoKTtcbiAgICAgICAgdGhpcy5fbG9jYWxQYXJlbnRTYW1wbGVkID0gKF9jID0gY29uZmlnLmxvY2FsUGFyZW50U2FtcGxlZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IEFsd2F5c09uU2FtcGxlcigpO1xuICAgICAgICB0aGlzLl9sb2NhbFBhcmVudE5vdFNhbXBsZWQgPSAoX2QgPSBjb25maWcubG9jYWxQYXJlbnROb3RTYW1wbGVkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBuZXcgQWx3YXlzT2ZmU2FtcGxlcigpO1xuICAgICAgfVxuICAgICAgUGFyZW50QmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oY29udGV4dDIsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpIHtcbiAgICAgICAgdmFyIHBhcmVudENvbnRleHQgPSB0cmFjZS5nZXRTcGFuQ29udGV4dChjb250ZXh0Mik7XG4gICAgICAgIGlmICghcGFyZW50Q29udGV4dCB8fCAhaXNTcGFuQ29udGV4dFZhbGlkKHBhcmVudENvbnRleHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Quc2hvdWxkU2FtcGxlKGNvbnRleHQyLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Q29udGV4dC5pc1JlbW90ZSkge1xuICAgICAgICAgIGlmIChwYXJlbnRDb250ZXh0LnRyYWNlRmxhZ3MgJiBUcmFjZUZsYWdzLlNBTVBMRUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVQYXJlbnRTYW1wbGVkLnNob3VsZFNhbXBsZShjb250ZXh0MiwgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVQYXJlbnROb3RTYW1wbGVkLnNob3VsZFNhbXBsZShjb250ZXh0MiwgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudENvbnRleHQudHJhY2VGbGFncyAmIFRyYWNlRmxhZ3MuU0FNUExFRCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFBhcmVudFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQyLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxQYXJlbnROb3RTYW1wbGVkLnNob3VsZFNhbXBsZShjb250ZXh0MiwgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcyk7XG4gICAgICB9O1xuICAgICAgUGFyZW50QmFzZWRTYW1wbGVyMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiUGFyZW50QmFzZWR7cm9vdD1cIiArIHRoaXMuX3Jvb3QudG9TdHJpbmcoKSArIFwiLCByZW1vdGVQYXJlbnRTYW1wbGVkPVwiICsgdGhpcy5fcmVtb3RlUGFyZW50U2FtcGxlZC50b1N0cmluZygpICsgXCIsIHJlbW90ZVBhcmVudE5vdFNhbXBsZWQ9XCIgKyB0aGlzLl9yZW1vdGVQYXJlbnROb3RTYW1wbGVkLnRvU3RyaW5nKCkgKyBcIiwgbG9jYWxQYXJlbnRTYW1wbGVkPVwiICsgdGhpcy5fbG9jYWxQYXJlbnRTYW1wbGVkLnRvU3RyaW5nKCkgKyBcIiwgbG9jYWxQYXJlbnROb3RTYW1wbGVkPVwiICsgdGhpcy5fbG9jYWxQYXJlbnROb3RTYW1wbGVkLnRvU3RyaW5nKCkgKyBcIn1cIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUGFyZW50QmFzZWRTYW1wbGVyMztcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdHJhY2Uvc2FtcGxlci9UcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIuanNcbnZhciBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXI7XG52YXIgaW5pdF9UcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3RyYWNlL3NhbXBsZXIvVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzKF9yYXRpbykge1xuICAgICAgICBpZiAoX3JhdGlvID09PSB2b2lkIDApIHtcbiAgICAgICAgICBfcmF0aW8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JhdGlvID0gX3JhdGlvO1xuICAgICAgICB0aGlzLl9yYXRpbyA9IHRoaXMuX25vcm1hbGl6ZShfcmF0aW8pO1xuICAgICAgICB0aGlzLl91cHBlckJvdW5kID0gTWF0aC5mbG9vcih0aGlzLl9yYXRpbyAqIDQyOTQ5NjcyOTUpO1xuICAgICAgfVxuICAgICAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuc2hvdWxkU2FtcGxlID0gZnVuY3Rpb24oY29udGV4dDIsIHRyYWNlSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWNpc2lvbjogaXNWYWxpZFRyYWNlSWQodHJhY2VJZCkgJiYgdGhpcy5fYWNjdW11bGF0ZSh0cmFjZUlkKSA8IHRoaXMuX3VwcGVyQm91bmQgPyBTYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRCA6IFNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlRyYWNlSWRSYXRpb0Jhc2Vke1wiICsgdGhpcy5fcmF0aW8gKyBcIn1cIjtcbiAgICAgIH07XG4gICAgICBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzLnByb3RvdHlwZS5fbm9ybWFsaXplID0gZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByYXRpbyAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihyYXRpbykpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiByYXRpbyA+PSAxID8gMSA6IHJhdGlvIDw9IDAgPyAwIDogcmF0aW87XG4gICAgICB9O1xuICAgICAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuX2FjY3VtdWxhdGUgPSBmdW5jdGlvbih0cmFjZUlkKSB7XG4gICAgICAgIHZhciBhY2N1bXVsYXRpb24gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNlSWQubGVuZ3RoIC8gODsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGkgKiA4O1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFyc2VJbnQodHJhY2VJZC5zbGljZShwb3MsIHBvcyArIDgpLCAxNik7XG4gICAgICAgICAgYWNjdW11bGF0aW9uID0gKGFjY3VtdWxhdGlvbiBeIHBhcnQpID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRpb247XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjM7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL2xvZGFzaC5tZXJnZS5qc1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9PSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSA/IGdldFJhd1RhZyh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLCB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gIHZhciB1bm1hc2tlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHZvaWQgMDtcbiAgICB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxudmFyIG9iamVjdFRhZywgbnVsbFRhZywgdW5kZWZpbmVkVGFnLCBmdW5jUHJvdG8sIGZ1bmNUb1N0cmluZywgb2JqZWN0Q3RvclN0cmluZywgZ2V0UHJvdG90eXBlLCBvYmplY3RQcm90bywgaGFzT3duUHJvcGVydHksIHN5bVRvU3RyaW5nVGFnLCBuYXRpdmVPYmplY3RUb1N0cmluZztcbnZhciBpbml0X2xvZGFzaF9tZXJnZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvbG9kYXNoLm1lcmdlLmpzXCIoKSB7XG4gICAgb2JqZWN0VGFnID0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgICBudWxsVGFnID0gXCJbb2JqZWN0IE51bGxdXCI7XG4gICAgdW5kZWZpbmVkVGFnID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIjtcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuICAgIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdm9pZCAwO1xuICAgIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvbWVyZ2UuanNcbmZ1bmN0aW9uIG1lcmdlKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gYXJncy5zaGlmdCgpO1xuICB2YXIgb2JqZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB3aGlsZSAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0ID0gbWVyZ2VUd29PYmplY3RzKHJlc3VsdCwgYXJncy5zaGlmdCgpLCAwLCBvYmplY3RzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdGFrZVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG1lcmdlVHdvT2JqZWN0cyhvbmUsIHR3bywgbGV2ZWwsIG9iamVjdHMpIHtcbiAgaWYgKGxldmVsID09PSB2b2lkIDApIHtcbiAgICBsZXZlbCA9IDA7XG4gIH1cbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGxldmVsID4gTUFYX0xFVkVMKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXZlbCsrO1xuICBpZiAoaXNQcmltaXRpdmUob25lKSB8fCBpc1ByaW1pdGl2ZSh0d28pIHx8IGlzRnVuY3Rpb24odHdvKSkge1xuICAgIHJlc3VsdCA9IHRha2VWYWx1ZSh0d28pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkob25lKSkge1xuICAgIHJlc3VsdCA9IG9uZS5zbGljZSgpO1xuICAgIGlmIChpc0FycmF5KHR3bykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdHdvLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCh0YWtlVmFsdWUodHdvW2ldKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh0d28pKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHR3byk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGtleXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXN1bHRba2V5XSA9IHRha2VWYWx1ZSh0d29ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9uZSkpIHtcbiAgICBpZiAoaXNPYmplY3QodHdvKSkge1xuICAgICAgaWYgKCFzaG91bGRNZXJnZShvbmUsIHR3bykpIHtcbiAgICAgICAgcmV0dXJuIHR3bztcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9uZSk7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHR3byk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGtleXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdHdvVmFsdWUgPSB0d29ba2V5XTtcbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHR3b1ZhbHVlKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHdvVmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0d29WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9iajEgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICB2YXIgb2JqMiA9IHR3b1ZhbHVlO1xuICAgICAgICAgIGlmICh3YXNPYmplY3RSZWZlcmVuY2VkKG9uZSwga2V5LCBvYmplY3RzKSB8fCB3YXNPYmplY3RSZWZlcmVuY2VkKHR3bywga2V5LCBvYmplY3RzKSkge1xuICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob2JqMSkgJiYgaXNPYmplY3Qob2JqMikpIHtcbiAgICAgICAgICAgICAgdmFyIGFycjEgPSBvYmplY3RzLmdldChvYmoxKSB8fCBbXTtcbiAgICAgICAgICAgICAgdmFyIGFycjIgPSBvYmplY3RzLmdldChvYmoyKSB8fCBbXTtcbiAgICAgICAgICAgICAgYXJyMS5wdXNoKHsgb2JqOiBvbmUsIGtleSB9KTtcbiAgICAgICAgICAgICAgYXJyMi5wdXNoKHsgb2JqOiB0d28sIGtleSB9KTtcbiAgICAgICAgICAgICAgb2JqZWN0cy5zZXQob2JqMSwgYXJyMSk7XG4gICAgICAgICAgICAgIG9iamVjdHMuc2V0KG9iajIsIGFycjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZVR3b09iamVjdHMocmVzdWx0W2tleV0sIHR3b1ZhbHVlLCBsZXZlbCwgb2JqZWN0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHR3bztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdhc09iamVjdFJlZmVyZW5jZWQob2JqLCBrZXksIG9iamVjdHMpIHtcbiAgdmFyIGFyciA9IG9iamVjdHMuZ2V0KG9ialtrZXldKSB8fCBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgdmFyIGluZm8gPSBhcnJbaV07XG4gICAgaWYgKGluZm8ua2V5ID09PSBrZXkgJiYgaW5mby5vYmogPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gIWlzUHJpbWl0aXZlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgIWlzRnVuY3Rpb24odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB2YWx1ZSA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNob3VsZE1lcmdlKG9uZSwgdHdvKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChvbmUpIHx8ICFpc1BsYWluT2JqZWN0KHR3bykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgTUFYX0xFVkVMO1xudmFyIGluaXRfbWVyZ2UgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL21lcmdlLmpzXCIoKSB7XG4gICAgaW5pdF9sb2Rhc2hfbWVyZ2UoKTtcbiAgICBNQVhfTEVWRUwgPSAyMDtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy90aW1lb3V0LmpzXG5mdW5jdGlvbiBjYWxsV2l0aFRpbWVvdXQocHJvbWlzZSwgdGltZW91dCkge1xuICB2YXIgdGltZW91dEhhbmRsZTtcbiAgdmFyIHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gdGltZW91dEZ1bmN0aW9uKF9yZXNvbHZlLCByZWplY3QpIHtcbiAgICB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0SGFuZGxlcigpIHtcbiAgICAgIHJlamVjdChuZXcgVGltZW91dEVycm9yKFwiT3BlcmF0aW9uIHRpbWVkIG91dC5cIikpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZW91dFByb21pc2VdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgdGhyb3cgcmVhc29uO1xuICB9KTtcbn1cbnZhciBfX2V4dGVuZHMyLCBUaW1lb3V0RXJyb3I7XG52YXIgaW5pdF90aW1lb3V0ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy90aW1lb3V0LmpzXCIoKSB7XG4gICAgX19leHRlbmRzMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgICBkMi5fX3Byb3RvX18gPSBiMjtcbiAgICAgICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIGIyKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiMiwgcCkpXG4gICAgICAgICAgICAgIGQyW3BdID0gYjJbcF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICAgICAgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgICB9O1xuICAgIH0oKTtcbiAgICBUaW1lb3V0RXJyb3IgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMyKFRpbWVvdXRFcnJvcjIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUaW1lb3V0RXJyb3IyKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBUaW1lb3V0RXJyb3IyLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBUaW1lb3V0RXJyb3IyO1xuICAgIH0oRXJyb3IpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3VybC5qc1xuZnVuY3Rpb24gdXJsTWF0Y2hlcyh1cmw0LCB1cmxUb01hdGNoKSB7XG4gIGlmICh0eXBlb2YgdXJsVG9NYXRjaCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB1cmw0ID09PSB1cmxUb01hdGNoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhIXVybDQubWF0Y2godXJsVG9NYXRjaCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVXJsSWdub3JlZCh1cmw0LCBpZ25vcmVkVXJscykge1xuICB2YXIgZV8xLCBfYTI7XG4gIGlmICghaWdub3JlZFVybHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBpZ25vcmVkVXJsc18xID0gX192YWx1ZXM0KGlnbm9yZWRVcmxzKSwgaWdub3JlZFVybHNfMV8xID0gaWdub3JlZFVybHNfMS5uZXh0KCk7ICFpZ25vcmVkVXJsc18xXzEuZG9uZTsgaWdub3JlZFVybHNfMV8xID0gaWdub3JlZFVybHNfMS5uZXh0KCkpIHtcbiAgICAgIHZhciBpZ25vcmVVcmwgPSBpZ25vcmVkVXJsc18xXzEudmFsdWU7XG4gICAgICBpZiAodXJsTWF0Y2hlcyh1cmw0LCBpZ25vcmVVcmwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoaWdub3JlZFVybHNfMV8xICYmICFpZ25vcmVkVXJsc18xXzEuZG9uZSAmJiAoX2EyID0gaWdub3JlZFVybHNfMS5yZXR1cm4pKVxuICAgICAgICBfYTIuY2FsbChpZ25vcmVkVXJsc18xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSlcbiAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgX192YWx1ZXM0O1xudmFyIGluaXRfdXJsID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy91cmwuanNcIigpIHtcbiAgICBfX3ZhbHVlczQgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgICAgaWYgKG0pXG4gICAgICAgIHJldHVybiBtLmNhbGwobyk7XG4gICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3dyYXAuanNcbmZ1bmN0aW9uIGlzV3JhcHBlZChmdW5jKSB7XG4gIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBmdW5jLl9fb3JpZ2luYWwgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZnVuYy5fX3Vud3JhcCA9PT0gXCJmdW5jdGlvblwiICYmIGZ1bmMuX193cmFwcGVkID09PSB0cnVlO1xufVxudmFyIGluaXRfd3JhcCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvd3JhcC5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3Byb21pc2UuanNcbnZhciBEZWZlcnJlZDtcbnZhciBpbml0X3Byb21pc2UgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3Byb21pc2UuanNcIigpIHtcbiAgICBEZWZlcnJlZCA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIERlZmVycmVkMigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIF90aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZlcnJlZDIucHJvdG90eXBlLCBcInByb21pc2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIERlZmVycmVkMi5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbCk7XG4gICAgICB9O1xuICAgICAgRGVmZXJyZWQyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KGVycik7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIERlZmVycmVkMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvY2FsbGJhY2suanNcbnZhciBfX3JlYWQ4LCBfX3NwcmVhZEFycmF5NSwgQmluZE9uY2VGdXR1cmU7XG52YXIgaW5pdF9jYWxsYmFjayA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vdXRpbHMvY2FsbGJhY2suanNcIigpIHtcbiAgICBpbml0X3Byb21pc2UoKTtcbiAgICBfX3JlYWQ4ID0gZnVuY3Rpb24obywgbikge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9O1xuICAgIF9fc3ByZWFkQXJyYXk1ID0gZnVuY3Rpb24odG8sIGZyb20sIHBhY2spIHtcbiAgICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICAgICAgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xuICAgIH07XG4gICAgQmluZE9uY2VGdXR1cmUgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBCaW5kT25jZUZ1dHVyZTIoX2NhbGxiYWNrLCBfdGhhdCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IF9jYWxsYmFjaztcbiAgICAgICAgdGhpcy5fdGhhdCA9IF90aGF0O1xuICAgICAgICB0aGlzLl9pc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmRPbmNlRnV0dXJlMi5wcm90b3R5cGUsIFwiaXNDYWxsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pc0NhbGxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZE9uY2VGdXR1cmUyLnByb3RvdHlwZSwgXCJwcm9taXNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBCaW5kT25jZUZ1dHVyZTIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbGxlZCkge1xuICAgICAgICAgIHRoaXMuX2lzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKChfYTIgPSB0aGlzLl9jYWxsYmFjaykuY2FsbC5hcHBseShfYTIsIF9fc3ByZWFkQXJyYXk1KFt0aGlzLl90aGF0XSwgX19yZWFkOChhcmdzKSwgZmFsc2UpKSkudGhlbihmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9kZWZlcnJlZC5yZXNvbHZlKHZhbCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9kZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCaW5kT25jZUZ1dHVyZTI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2ludGVybmFsL2V4cG9ydGVyLmpzXG5mdW5jdGlvbiBfZXhwb3J0KGV4cG9ydGVyLCBhcmcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICBjb250ZXh0LndpdGgoc3VwcHJlc3NUcmFjaW5nKGNvbnRleHQuYWN0aXZlKCkpLCBmdW5jdGlvbigpIHtcbiAgICAgIGV4cG9ydGVyLmV4cG9ydChhcmcsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG52YXIgaW5pdF9leHBvcnRlciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvY29yZS9idWlsZC9lc20vaW50ZXJuYWwvZXhwb3J0ZXIuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIGluaXRfc3VwcHJlc3NfdHJhY2luZygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2luZGV4LmpzXG52YXIgZXNtX2V4cG9ydHMzID0ge307XG5fX2V4cG9ydChlc21fZXhwb3J0czMsIHtcbiAgQWx3YXlzT2ZmU2FtcGxlcjogKCkgPT4gQWx3YXlzT2ZmU2FtcGxlcixcbiAgQWx3YXlzT25TYW1wbGVyOiAoKSA9PiBBbHdheXNPblNhbXBsZXIsXG4gIEFuY2hvcmVkQ2xvY2s6ICgpID0+IEFuY2hvcmVkQ2xvY2ssXG4gIEJpbmRPbmNlRnV0dXJlOiAoKSA9PiBCaW5kT25jZUZ1dHVyZSxcbiAgQ29tcG9zaXRlUHJvcGFnYXRvcjogKCkgPT4gQ29tcG9zaXRlUHJvcGFnYXRvcixcbiAgREVGQVVMVF9BVFRSSUJVVEVfQ09VTlRfTElNSVQ6ICgpID0+IERFRkFVTFRfQVRUUklCVVRFX0NPVU5UX0xJTUlULFxuICBERUZBVUxUX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQ6ICgpID0+IERFRkFVTFRfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCxcbiAgREVGQVVMVF9FTlZJUk9OTUVOVDogKCkgPT4gREVGQVVMVF9FTlZJUk9OTUVOVCxcbiAgREVGQVVMVF9TUEFOX0FUVFJJQlVURV9QRVJfRVZFTlRfQ09VTlRfTElNSVQ6ICgpID0+IERFRkFVTFRfU1BBTl9BVFRSSUJVVEVfUEVSX0VWRU5UX0NPVU5UX0xJTUlULFxuICBERUZBVUxUX1NQQU5fQVRUUklCVVRFX1BFUl9MSU5LX0NPVU5UX0xJTUlUOiAoKSA9PiBERUZBVUxUX1NQQU5fQVRUUklCVVRFX1BFUl9MSU5LX0NPVU5UX0xJTUlULFxuICBFeHBvcnRSZXN1bHRDb2RlOiAoKSA9PiBFeHBvcnRSZXN1bHRDb2RlLFxuICBQYXJlbnRCYXNlZFNhbXBsZXI6ICgpID0+IFBhcmVudEJhc2VkU2FtcGxlcixcbiAgUlBDVHlwZTogKCkgPT4gUlBDVHlwZSxcbiAgUmFuZG9tSWRHZW5lcmF0b3I6ICgpID0+IFJhbmRvbUlkR2VuZXJhdG9yLFxuICBTREtfSU5GTzogKCkgPT4gU0RLX0lORk8sXG4gIFRSQUNFX1BBUkVOVF9IRUFERVI6ICgpID0+IFRSQUNFX1BBUkVOVF9IRUFERVIsXG4gIFRSQUNFX1NUQVRFX0hFQURFUjogKCkgPT4gVFJBQ0VfU1RBVEVfSEVBREVSLFxuICBUaW1lb3V0RXJyb3I6ICgpID0+IFRpbWVvdXRFcnJvcixcbiAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyOiAoKSA9PiBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIsXG4gIFRyYWNlU3RhdGU6ICgpID0+IFRyYWNlU3RhdGUsXG4gIFRyYWNlc1NhbXBsZXJWYWx1ZXM6ICgpID0+IFRyYWNlc1NhbXBsZXJWYWx1ZXMsXG4gIFZFUlNJT046ICgpID0+IFZFUlNJT04yLFxuICBXM0NCYWdnYWdlUHJvcGFnYXRvcjogKCkgPT4gVzNDQmFnZ2FnZVByb3BhZ2F0b3IsXG4gIFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3I6ICgpID0+IFczQ1RyYWNlQ29udGV4dFByb3BhZ2F0b3IsXG4gIF9nbG9iYWxUaGlzOiAoKSA9PiBfZ2xvYmFsVGhpczMsXG4gIGFkZEhyVGltZXM6ICgpID0+IGFkZEhyVGltZXMsXG4gIGJhZ2dhZ2VVdGlsczogKCkgPT4gdXRpbHNfZXhwb3J0cyxcbiAgY2FsbFdpdGhUaW1lb3V0OiAoKSA9PiBjYWxsV2l0aFRpbWVvdXQsXG4gIGRlbGV0ZVJQQ01ldGFkYXRhOiAoKSA9PiBkZWxldGVSUENNZXRhZGF0YSxcbiAgZ2V0RW52OiAoKSA9PiBnZXRFbnYsXG4gIGdldEVudldpdGhvdXREZWZhdWx0czogKCkgPT4gZ2V0RW52V2l0aG91dERlZmF1bHRzLFxuICBnZXRSUENNZXRhZGF0YTogKCkgPT4gZ2V0UlBDTWV0YWRhdGEsXG4gIGdldFRpbWVPcmlnaW46ICgpID0+IGdldFRpbWVPcmlnaW4sXG4gIGdsb2JhbEVycm9ySGFuZGxlcjogKCkgPT4gZ2xvYmFsRXJyb3JIYW5kbGVyLFxuICBoZXhUb0Jhc2U2NDogKCkgPT4gaGV4VG9CYXNlNjQsXG4gIGhleFRvQmluYXJ5OiAoKSA9PiBoZXhUb0JpbmFyeSxcbiAgaHJUaW1lOiAoKSA9PiBoclRpbWUsXG4gIGhyVGltZUR1cmF0aW9uOiAoKSA9PiBoclRpbWVEdXJhdGlvbixcbiAgaHJUaW1lVG9NaWNyb3NlY29uZHM6ICgpID0+IGhyVGltZVRvTWljcm9zZWNvbmRzLFxuICBoclRpbWVUb01pbGxpc2Vjb25kczogKCkgPT4gaHJUaW1lVG9NaWxsaXNlY29uZHMsXG4gIGhyVGltZVRvTmFub3NlY29uZHM6ICgpID0+IGhyVGltZVRvTmFub3NlY29uZHMsXG4gIGhyVGltZVRvVGltZVN0YW1wOiAoKSA9PiBoclRpbWVUb1RpbWVTdGFtcCxcbiAgaW50ZXJuYWw6ICgpID0+IGludGVybmFsLFxuICBpc0F0dHJpYnV0ZUtleTogKCkgPT4gaXNBdHRyaWJ1dGVLZXksXG4gIGlzQXR0cmlidXRlVmFsdWU6ICgpID0+IGlzQXR0cmlidXRlVmFsdWUsXG4gIGlzVGltZUlucHV0OiAoKSA9PiBpc1RpbWVJbnB1dCxcbiAgaXNUaW1lSW5wdXRIclRpbWU6ICgpID0+IGlzVGltZUlucHV0SHJUaW1lLFxuICBpc1RyYWNpbmdTdXBwcmVzc2VkOiAoKSA9PiBpc1RyYWNpbmdTdXBwcmVzc2VkLFxuICBpc1VybElnbm9yZWQ6ICgpID0+IGlzVXJsSWdub3JlZCxcbiAgaXNXcmFwcGVkOiAoKSA9PiBpc1dyYXBwZWQsXG4gIGxvZ2dpbmdFcnJvckhhbmRsZXI6ICgpID0+IGxvZ2dpbmdFcnJvckhhbmRsZXIsXG4gIG1lcmdlOiAoKSA9PiBtZXJnZSxcbiAgbWlsbGlzVG9IclRpbWU6ICgpID0+IG1pbGxpc1RvSHJUaW1lLFxuICBvdHBlcmZvcm1hbmNlOiAoKSA9PiBvdHBlcmZvcm1hbmNlLFxuICBwYXJzZUVudmlyb25tZW50OiAoKSA9PiBwYXJzZUVudmlyb25tZW50LFxuICBwYXJzZVRyYWNlUGFyZW50OiAoKSA9PiBwYXJzZVRyYWNlUGFyZW50LFxuICBzYW5pdGl6ZUF0dHJpYnV0ZXM6ICgpID0+IHNhbml0aXplQXR0cmlidXRlcyxcbiAgc2V0R2xvYmFsRXJyb3JIYW5kbGVyOiAoKSA9PiBzZXRHbG9iYWxFcnJvckhhbmRsZXIsXG4gIHNldFJQQ01ldGFkYXRhOiAoKSA9PiBzZXRSUENNZXRhZGF0YSxcbiAgc3VwcHJlc3NUcmFjaW5nOiAoKSA9PiBzdXBwcmVzc1RyYWNpbmcsXG4gIHRpbWVJbnB1dFRvSHJUaW1lOiAoKSA9PiB0aW1lSW5wdXRUb0hyVGltZSxcbiAgdW5yZWZUaW1lcjogKCkgPT4gdW5yZWZUaW1lcixcbiAgdW5zdXBwcmVzc1RyYWNpbmc6ICgpID0+IHVuc3VwcHJlc3NUcmFjaW5nLFxuICB1cmxNYXRjaGVzOiAoKSA9PiB1cmxNYXRjaGVzXG59KTtcbnZhciBpbnRlcm5hbDtcbnZhciBpbml0X2VzbTMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2NvcmUvYnVpbGQvZXNtL2luZGV4LmpzXCIoKSB7XG4gICAgaW5pdF9XM0NCYWdnYWdlUHJvcGFnYXRvcigpO1xuICAgIGluaXRfYW5jaG9yZWRfY2xvY2soKTtcbiAgICBpbml0X2F0dHJpYnV0ZXMoKTtcbiAgICBpbml0X2dsb2JhbF9lcnJvcl9oYW5kbGVyKCk7XG4gICAgaW5pdF9sb2dnaW5nX2Vycm9yX2hhbmRsZXIoKTtcbiAgICBpbml0X3RpbWUoKTtcbiAgICBpbml0X3R5cGVzMigpO1xuICAgIGluaXRfaGV4X3RvX2JpbmFyeSgpO1xuICAgIGluaXRfRXhwb3J0UmVzdWx0KCk7XG4gICAgaW5pdF91dGlsczMoKTtcbiAgICBpbml0X3BsYXRmb3JtMigpO1xuICAgIGluaXRfY29tcG9zaXRlKCk7XG4gICAgaW5pdF9XM0NUcmFjZUNvbnRleHRQcm9wYWdhdG9yKCk7XG4gICAgaW5pdF9JZEdlbmVyYXRvcigpO1xuICAgIGluaXRfcnBjX21ldGFkYXRhKCk7XG4gICAgaW5pdF9BbHdheXNPZmZTYW1wbGVyKCk7XG4gICAgaW5pdF9BbHdheXNPblNhbXBsZXIoKTtcbiAgICBpbml0X1BhcmVudEJhc2VkU2FtcGxlcigpO1xuICAgIGluaXRfVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyKCk7XG4gICAgaW5pdF9zdXBwcmVzc190cmFjaW5nKCk7XG4gICAgaW5pdF9UcmFjZVN0YXRlKCk7XG4gICAgaW5pdF9lbnZpcm9ubWVudCgpO1xuICAgIGluaXRfbWVyZ2UoKTtcbiAgICBpbml0X3NhbXBsaW5nKCk7XG4gICAgaW5pdF90aW1lb3V0KCk7XG4gICAgaW5pdF91cmwoKTtcbiAgICBpbml0X3dyYXAoKTtcbiAgICBpbml0X2NhbGxiYWNrKCk7XG4gICAgaW5pdF92ZXJzaW9uMigpO1xuICAgIGluaXRfZXhwb3J0ZXIoKTtcbiAgICBpbnRlcm5hbCA9IHtcbiAgICAgIF9leHBvcnRcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Byb3BhZ2F0b3ItYjMvYnVpbGQvZXNtL2NvbW1vbi5qc1xudmFyIEIzX0RFQlVHX0ZMQUdfS0VZO1xudmFyIGluaXRfY29tbW9uID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9wcm9wYWdhdG9yLWIzL2J1aWxkL2VzbS9jb21tb24uanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIEIzX0RFQlVHX0ZMQUdfS0VZID0gY3JlYXRlQ29udGV4dEtleShcIk9wZW5UZWxlbWV0cnkgQ29udGV4dCBLZXkgQjMgRGVidWcgRmxhZ1wiKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9wcm9wYWdhdG9yLWIzL2J1aWxkL2VzbS9jb25zdGFudHMuanNcbnZhciBCM19DT05URVhUX0hFQURFUiwgWF9CM19UUkFDRV9JRCwgWF9CM19TUEFOX0lELCBYX0IzX1NBTVBMRUQsIFhfQjNfUEFSRU5UX1NQQU5fSUQsIFhfQjNfRkxBR1M7XG52YXIgaW5pdF9jb25zdGFudHMyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9wcm9wYWdhdG9yLWIzL2J1aWxkL2VzbS9jb25zdGFudHMuanNcIigpIHtcbiAgICBCM19DT05URVhUX0hFQURFUiA9IFwiYjNcIjtcbiAgICBYX0IzX1RSQUNFX0lEID0gXCJ4LWIzLXRyYWNlaWRcIjtcbiAgICBYX0IzX1NQQU5fSUQgPSBcIngtYjMtc3BhbmlkXCI7XG4gICAgWF9CM19TQU1QTEVEID0gXCJ4LWIzLXNhbXBsZWRcIjtcbiAgICBYX0IzX1BBUkVOVF9TUEFOX0lEID0gXCJ4LWIzLXBhcmVudHNwYW5pZFwiO1xuICAgIFhfQjNfRkxBR1MgPSBcIngtYjMtZmxhZ3NcIjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9wcm9wYWdhdG9yLWIzL2J1aWxkL2VzbS9CM011bHRpUHJvcGFnYXRvci5qc1xuZnVuY3Rpb24gaXNWYWxpZFNhbXBsZWRWYWx1ZShzYW1wbGVkKSB7XG4gIHJldHVybiBzYW1wbGVkID09PSBUcmFjZUZsYWdzLlNBTVBMRUQgfHwgc2FtcGxlZCA9PT0gVHJhY2VGbGFncy5OT05FO1xufVxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoaGVhZGVyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGhlYWRlcikgPyBoZWFkZXJbMF0gOiBoZWFkZXI7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJWYWx1ZShjYXJyaWVyLCBnZXR0ZXIsIGtleSkge1xuICB2YXIgaGVhZGVyID0gZ2V0dGVyLmdldChjYXJyaWVyLCBrZXkpO1xuICByZXR1cm4gcGFyc2VIZWFkZXIoaGVhZGVyKTtcbn1cbmZ1bmN0aW9uIGdldFRyYWNlSWQoY2FycmllciwgZ2V0dGVyKSB7XG4gIHZhciB0cmFjZUlkID0gZ2V0SGVhZGVyVmFsdWUoY2FycmllciwgZ2V0dGVyLCBYX0IzX1RSQUNFX0lEKTtcbiAgaWYgKHR5cGVvZiB0cmFjZUlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHRyYWNlSWQucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIGdldFNwYW5JZChjYXJyaWVyLCBnZXR0ZXIpIHtcbiAgdmFyIHNwYW5JZCA9IGdldEhlYWRlclZhbHVlKGNhcnJpZXIsIGdldHRlciwgWF9CM19TUEFOX0lEKTtcbiAgaWYgKHR5cGVvZiBzcGFuSWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc3BhbklkO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gZ2V0RGVidWcoY2FycmllciwgZ2V0dGVyKSB7XG4gIHZhciBkZWJ1ZyA9IGdldEhlYWRlclZhbHVlKGNhcnJpZXIsIGdldHRlciwgWF9CM19GTEFHUyk7XG4gIHJldHVybiBkZWJ1ZyA9PT0gXCIxXCIgPyBcIjFcIiA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFRyYWNlRmxhZ3MoY2FycmllciwgZ2V0dGVyKSB7XG4gIHZhciB0cmFjZUZsYWdzID0gZ2V0SGVhZGVyVmFsdWUoY2FycmllciwgZ2V0dGVyLCBYX0IzX1NBTVBMRUQpO1xuICB2YXIgZGVidWcgPSBnZXREZWJ1ZyhjYXJyaWVyLCBnZXR0ZXIpO1xuICBpZiAoZGVidWcgPT09IFwiMVwiIHx8IFZBTElEX1NBTVBMRURfVkFMVUVTLmhhcyh0cmFjZUZsYWdzKSkge1xuICAgIHJldHVybiBUcmFjZUZsYWdzLlNBTVBMRUQ7XG4gIH1cbiAgaWYgKHRyYWNlRmxhZ3MgPT09IHZvaWQgMCB8fCBWQUxJRF9VTlNBTVBMRURfVkFMVUVTLmhhcyh0cmFjZUZsYWdzKSkge1xuICAgIHJldHVybiBUcmFjZUZsYWdzLk5PTkU7XG4gIH1cbiAgcmV0dXJuO1xufVxudmFyIFZBTElEX1NBTVBMRURfVkFMVUVTLCBWQUxJRF9VTlNBTVBMRURfVkFMVUVTLCBCM011bHRpUHJvcGFnYXRvcjtcbnZhciBpbml0X0IzTXVsdGlQcm9wYWdhdG9yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9wcm9wYWdhdG9yLWIzL2J1aWxkL2VzbS9CM011bHRpUHJvcGFnYXRvci5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgaW5pdF9lc20zKCk7XG4gICAgaW5pdF9jb21tb24oKTtcbiAgICBpbml0X2NvbnN0YW50czIoKTtcbiAgICBWQUxJRF9TQU1QTEVEX1ZBTFVFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFt0cnVlLCBcInRydWVcIiwgXCJUcnVlXCIsIFwiMVwiLCAxXSk7XG4gICAgVkFMSURfVU5TQU1QTEVEX1ZBTFVFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtmYWxzZSwgXCJmYWxzZVwiLCBcIkZhbHNlXCIsIFwiMFwiLCAwXSk7XG4gICAgQjNNdWx0aVByb3BhZ2F0b3IgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBCM011bHRpUHJvcGFnYXRvcjIoKSB7XG4gICAgICB9XG4gICAgICBCM011bHRpUHJvcGFnYXRvcjIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGNvbnRleHQyLCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIHNwYW5Db250ZXh0ID0gdHJhY2UuZ2V0U3BhbkNvbnRleHQoY29udGV4dDIpO1xuICAgICAgICBpZiAoIXNwYW5Db250ZXh0IHx8ICFpc1NwYW5Db250ZXh0VmFsaWQoc3BhbkNvbnRleHQpIHx8IGlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dDIpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGRlYnVnID0gY29udGV4dDIuZ2V0VmFsdWUoQjNfREVCVUdfRkxBR19LRVkpO1xuICAgICAgICBzZXR0ZXIuc2V0KGNhcnJpZXIsIFhfQjNfVFJBQ0VfSUQsIHNwYW5Db250ZXh0LnRyYWNlSWQpO1xuICAgICAgICBzZXR0ZXIuc2V0KGNhcnJpZXIsIFhfQjNfU1BBTl9JRCwgc3BhbkNvbnRleHQuc3BhbklkKTtcbiAgICAgICAgaWYgKGRlYnVnID09PSBcIjFcIikge1xuICAgICAgICAgIHNldHRlci5zZXQoY2FycmllciwgWF9CM19GTEFHUywgZGVidWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHNwYW5Db250ZXh0LnRyYWNlRmxhZ3MgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHNldHRlci5zZXQoY2FycmllciwgWF9CM19TQU1QTEVELCAoVHJhY2VGbGFncy5TQU1QTEVEICYgc3BhbkNvbnRleHQudHJhY2VGbGFncykgPT09IFRyYWNlRmxhZ3MuU0FNUExFRCA/IFwiMVwiIDogXCIwXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQjNNdWx0aVByb3BhZ2F0b3IyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDIsIGNhcnJpZXIsIGdldHRlcikge1xuICAgICAgICB2YXIgdHJhY2VJZCA9IGdldFRyYWNlSWQoY2FycmllciwgZ2V0dGVyKTtcbiAgICAgICAgdmFyIHNwYW5JZCA9IGdldFNwYW5JZChjYXJyaWVyLCBnZXR0ZXIpO1xuICAgICAgICB2YXIgdHJhY2VGbGFncyA9IGdldFRyYWNlRmxhZ3MoY2FycmllciwgZ2V0dGVyKTtcbiAgICAgICAgdmFyIGRlYnVnID0gZ2V0RGVidWcoY2FycmllciwgZ2V0dGVyKTtcbiAgICAgICAgaWYgKGlzVmFsaWRUcmFjZUlkKHRyYWNlSWQpICYmIGlzVmFsaWRTcGFuSWQoc3BhbklkKSAmJiBpc1ZhbGlkU2FtcGxlZFZhbHVlKHRyYWNlRmxhZ3MpKSB7XG4gICAgICAgICAgY29udGV4dDIgPSBjb250ZXh0Mi5zZXRWYWx1ZShCM19ERUJVR19GTEFHX0tFWSwgZGVidWcpO1xuICAgICAgICAgIHJldHVybiB0cmFjZS5zZXRTcGFuQ29udGV4dChjb250ZXh0Miwge1xuICAgICAgICAgICAgdHJhY2VJZCxcbiAgICAgICAgICAgIHNwYW5JZCxcbiAgICAgICAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgICAgICAgdHJhY2VGbGFnc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0MjtcbiAgICAgIH07XG4gICAgICBCM011bHRpUHJvcGFnYXRvcjIucHJvdG90eXBlLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFhfQjNfVFJBQ0VfSUQsXG4gICAgICAgICAgWF9CM19TUEFOX0lELFxuICAgICAgICAgIFhfQjNfRkxBR1MsXG4gICAgICAgICAgWF9CM19TQU1QTEVELFxuICAgICAgICAgIFhfQjNfUEFSRU5UX1NQQU5fSURcbiAgICAgICAgXTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQjNNdWx0aVByb3BhZ2F0b3IyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9wcm9wYWdhdG9yLWIzL2J1aWxkL2VzbS9CM1NpbmdsZVByb3BhZ2F0b3IuanNcbmZ1bmN0aW9uIGNvbnZlcnRUb1RyYWNlSWQxMjgodHJhY2VJZCkge1xuICByZXR1cm4gdHJhY2VJZC5sZW5ndGggPT09IDMyID8gdHJhY2VJZCA6IFwiXCIgKyBQQURESU5HICsgdHJhY2VJZDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1RyYWNlRmxhZ3Moc2FtcGxpbmdTdGF0ZSkge1xuICBpZiAoc2FtcGxpbmdTdGF0ZSAmJiBTQU1QTEVEX1ZBTFVFUy5oYXMoc2FtcGxpbmdTdGF0ZSkpIHtcbiAgICByZXR1cm4gVHJhY2VGbGFncy5TQU1QTEVEO1xuICB9XG4gIHJldHVybiBUcmFjZUZsYWdzLk5PTkU7XG59XG52YXIgX19yZWFkOSwgQjNfQ09OVEVYVF9SRUdFWCwgUEFERElORywgU0FNUExFRF9WQUxVRVMsIERFQlVHX1NUQVRFLCBCM1NpbmdsZVByb3BhZ2F0b3I7XG52YXIgaW5pdF9CM1NpbmdsZVByb3BhZ2F0b3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Byb3BhZ2F0b3ItYjMvYnVpbGQvZXNtL0IzU2luZ2xlUHJvcGFnYXRvci5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgaW5pdF9lc20zKCk7XG4gICAgaW5pdF9jb21tb24oKTtcbiAgICBpbml0X2NvbnN0YW50czIoKTtcbiAgICBfX3JlYWQ5ID0gZnVuY3Rpb24obywgbikge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9O1xuICAgIEIzX0NPTlRFWFRfUkVHRVggPSAvKCg/OlswLTlhLWZdezE2fSl7MSwyfSktKFswLTlhLWZdezE2fSkoPzotKFswMWRdKD8hWzAtOWEtZl0pKSk/KD86LShbMC05YS1mXXsxNn0pKT8vO1xuICAgIFBBRERJTkcgPSBcIjBcIi5yZXBlYXQoMTYpO1xuICAgIFNBTVBMRURfVkFMVUVTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZFwiLCBcIjFcIl0pO1xuICAgIERFQlVHX1NUQVRFID0gXCJkXCI7XG4gICAgQjNTaW5nbGVQcm9wYWdhdG9yID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gQjNTaW5nbGVQcm9wYWdhdG9yMigpIHtcbiAgICAgIH1cbiAgICAgIEIzU2luZ2xlUHJvcGFnYXRvcjIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGNvbnRleHQyLCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIHNwYW5Db250ZXh0ID0gdHJhY2UuZ2V0U3BhbkNvbnRleHQoY29udGV4dDIpO1xuICAgICAgICBpZiAoIXNwYW5Db250ZXh0IHx8ICFpc1NwYW5Db250ZXh0VmFsaWQoc3BhbkNvbnRleHQpIHx8IGlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dDIpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNhbXBsaW5nU3RhdGUgPSBjb250ZXh0Mi5nZXRWYWx1ZShCM19ERUJVR19GTEFHX0tFWSkgfHwgc3BhbkNvbnRleHQudHJhY2VGbGFncyAmIDE7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNwYW5Db250ZXh0LnRyYWNlSWQgKyBcIi1cIiArIHNwYW5Db250ZXh0LnNwYW5JZCArIFwiLVwiICsgc2FtcGxpbmdTdGF0ZTtcbiAgICAgICAgc2V0dGVyLnNldChjYXJyaWVyLCBCM19DT05URVhUX0hFQURFUiwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIEIzU2luZ2xlUHJvcGFnYXRvcjIucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbihjb250ZXh0MiwgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIEIzX0NPTlRFWFRfSEVBREVSKTtcbiAgICAgICAgdmFyIGIzQ29udGV4dCA9IEFycmF5LmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlclswXSA6IGhlYWRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBiM0NvbnRleHQgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQyO1xuICAgICAgICB2YXIgbWF0Y2ggPSBiM0NvbnRleHQubWF0Y2goQjNfQ09OVEVYVF9SRUdFWCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQyO1xuICAgICAgICB2YXIgX2EyID0gX19yZWFkOShtYXRjaCwgNCksIGV4dHJhY3RlZFRyYWNlSWQgPSBfYTJbMV0sIHNwYW5JZCA9IF9hMlsyXSwgc2FtcGxpbmdTdGF0ZSA9IF9hMlszXTtcbiAgICAgICAgdmFyIHRyYWNlSWQgPSBjb252ZXJ0VG9UcmFjZUlkMTI4KGV4dHJhY3RlZFRyYWNlSWQpO1xuICAgICAgICBpZiAoIWlzVmFsaWRUcmFjZUlkKHRyYWNlSWQpIHx8ICFpc1ZhbGlkU3BhbklkKHNwYW5JZCkpXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQyO1xuICAgICAgICB2YXIgdHJhY2VGbGFncyA9IGNvbnZlcnRUb1RyYWNlRmxhZ3Moc2FtcGxpbmdTdGF0ZSk7XG4gICAgICAgIGlmIChzYW1wbGluZ1N0YXRlID09PSBERUJVR19TVEFURSkge1xuICAgICAgICAgIGNvbnRleHQyID0gY29udGV4dDIuc2V0VmFsdWUoQjNfREVCVUdfRkxBR19LRVksIHNhbXBsaW5nU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFjZS5zZXRTcGFuQ29udGV4dChjb250ZXh0Miwge1xuICAgICAgICAgIHRyYWNlSWQsXG4gICAgICAgICAgc3BhbklkLFxuICAgICAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgICAgIHRyYWNlRmxhZ3NcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQjNTaW5nbGVQcm9wYWdhdG9yMi5wcm90b3R5cGUuZmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbQjNfQ09OVEVYVF9IRUFERVJdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCM1NpbmdsZVByb3BhZ2F0b3IyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9wcm9wYWdhdG9yLWIzL2J1aWxkL2VzbS90eXBlcy5qc1xudmFyIEIzSW5qZWN0RW5jb2Rpbmc7XG52YXIgaW5pdF90eXBlczMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Byb3BhZ2F0b3ItYjMvYnVpbGQvZXNtL3R5cGVzLmpzXCIoKSB7XG4gICAgKGZ1bmN0aW9uKEIzSW5qZWN0RW5jb2RpbmcyKSB7XG4gICAgICBCM0luamVjdEVuY29kaW5nMltCM0luamVjdEVuY29kaW5nMltcIlNJTkdMRV9IRUFERVJcIl0gPSAwXSA9IFwiU0lOR0xFX0hFQURFUlwiO1xuICAgICAgQjNJbmplY3RFbmNvZGluZzJbQjNJbmplY3RFbmNvZGluZzJbXCJNVUxUSV9IRUFERVJcIl0gPSAxXSA9IFwiTVVMVElfSEVBREVSXCI7XG4gICAgfSkoQjNJbmplY3RFbmNvZGluZyB8fCAoQjNJbmplY3RFbmNvZGluZyA9IHt9KSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcHJvcGFnYXRvci1iMy9idWlsZC9lc20vQjNQcm9wYWdhdG9yLmpzXG52YXIgQjNQcm9wYWdhdG9yO1xudmFyIGluaXRfQjNQcm9wYWdhdG9yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9wcm9wYWdhdG9yLWIzL2J1aWxkL2VzbS9CM1Byb3BhZ2F0b3IuanNcIigpIHtcbiAgICBpbml0X2VzbTMoKTtcbiAgICBpbml0X0IzTXVsdGlQcm9wYWdhdG9yKCk7XG4gICAgaW5pdF9CM1NpbmdsZVByb3BhZ2F0b3IoKTtcbiAgICBpbml0X2NvbnN0YW50czIoKTtcbiAgICBpbml0X3R5cGVzMygpO1xuICAgIEIzUHJvcGFnYXRvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEIzUHJvcGFnYXRvcjIoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2IzTXVsdGlQcm9wYWdhdG9yID0gbmV3IEIzTXVsdGlQcm9wYWdhdG9yKCk7XG4gICAgICAgIHRoaXMuX2IzU2luZ2xlUHJvcGFnYXRvciA9IG5ldyBCM1NpbmdsZVByb3BhZ2F0b3IoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pbmplY3RFbmNvZGluZyA9PT0gQjNJbmplY3RFbmNvZGluZy5NVUxUSV9IRUFERVIpIHtcbiAgICAgICAgICB0aGlzLl9pbmplY3QgPSB0aGlzLl9iM011bHRpUHJvcGFnYXRvci5pbmplY3Q7XG4gICAgICAgICAgdGhpcy5fZmllbGRzID0gdGhpcy5fYjNNdWx0aVByb3BhZ2F0b3IuZmllbGRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faW5qZWN0ID0gdGhpcy5fYjNTaW5nbGVQcm9wYWdhdG9yLmluamVjdDtcbiAgICAgICAgICB0aGlzLl9maWVsZHMgPSB0aGlzLl9iM1NpbmdsZVByb3BhZ2F0b3IuZmllbGRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEIzUHJvcGFnYXRvcjIucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uKGNvbnRleHQyLCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICAgICAgaWYgKGlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dDIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luamVjdChjb250ZXh0MiwgY2Fycmllciwgc2V0dGVyKTtcbiAgICAgIH07XG4gICAgICBCM1Byb3BhZ2F0b3IyLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oY29udGV4dDIsIGNhcnJpZXIsIGdldHRlcikge1xuICAgICAgICB2YXIgaGVhZGVyID0gZ2V0dGVyLmdldChjYXJyaWVyLCBCM19DT05URVhUX0hFQURFUik7XG4gICAgICAgIHZhciBiM0NvbnRleHQgPSBBcnJheS5pc0FycmF5KGhlYWRlcikgPyBoZWFkZXJbMF0gOiBoZWFkZXI7XG4gICAgICAgIGlmIChiM0NvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYjNTaW5nbGVQcm9wYWdhdG9yLmV4dHJhY3QoY29udGV4dDIsIGNhcnJpZXIsIGdldHRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2IzTXVsdGlQcm9wYWdhdG9yLmV4dHJhY3QoY29udGV4dDIsIGNhcnJpZXIsIGdldHRlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBCM1Byb3BhZ2F0b3IyLnByb3RvdHlwZS5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gQjNQcm9wYWdhdG9yMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcHJvcGFnYXRvci1iMy9idWlsZC9lc20vaW5kZXguanNcbnZhciBlc21fZXhwb3J0czQgPSB7fTtcbl9fZXhwb3J0KGVzbV9leHBvcnRzNCwge1xuICBCM0luamVjdEVuY29kaW5nOiAoKSA9PiBCM0luamVjdEVuY29kaW5nLFxuICBCM1Byb3BhZ2F0b3I6ICgpID0+IEIzUHJvcGFnYXRvcixcbiAgQjNfQ09OVEVYVF9IRUFERVI6ICgpID0+IEIzX0NPTlRFWFRfSEVBREVSLFxuICBYX0IzX0ZMQUdTOiAoKSA9PiBYX0IzX0ZMQUdTLFxuICBYX0IzX1BBUkVOVF9TUEFOX0lEOiAoKSA9PiBYX0IzX1BBUkVOVF9TUEFOX0lELFxuICBYX0IzX1NBTVBMRUQ6ICgpID0+IFhfQjNfU0FNUExFRCxcbiAgWF9CM19TUEFOX0lEOiAoKSA9PiBYX0IzX1NQQU5fSUQsXG4gIFhfQjNfVFJBQ0VfSUQ6ICgpID0+IFhfQjNfVFJBQ0VfSURcbn0pO1xudmFyIGluaXRfZXNtNCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcHJvcGFnYXRvci1iMy9idWlsZC9lc20vaW5kZXguanNcIigpIHtcbiAgICBpbml0X0IzUHJvcGFnYXRvcigpO1xuICAgIGluaXRfY29uc3RhbnRzMigpO1xuICAgIGluaXRfdHlwZXMzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2VudW1zLmpzXG52YXIgRXhjZXB0aW9uRXZlbnROYW1lO1xudmFyIGluaXRfZW51bXMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9lbnVtcy5qc1wiKCkge1xuICAgIEV4Y2VwdGlvbkV2ZW50TmFtZSA9IFwiZXhjZXB0aW9uXCI7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL1NwYW4uanNcbnZhciBfX3ZhbHVlczUsIF9fcmVhZDEwLCBTcGFuO1xudmFyIGluaXRfU3BhbiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL1NwYW4uanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIGluaXRfZXNtMygpO1xuICAgIGluaXRfZXNtMigpO1xuICAgIGluaXRfZW51bXMoKTtcbiAgICBfX3ZhbHVlczUgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgICAgaWYgKG0pXG4gICAgICAgIHJldHVybiBtLmNhbGwobyk7XG4gICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB9O1xuICAgIF9fcmVhZDEwID0gZnVuY3Rpb24obywgbikge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9O1xuICAgIFNwYW4gPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBTcGFuNChwYXJlbnRUcmFjZXIsIGNvbnRleHQyLCBzcGFuTmFtZSwgc3BhbkNvbnRleHQsIGtpbmQsIHBhcmVudFNwYW5JZCwgbGlua3MsIHN0YXJ0VGltZSwgX2RlcHJlY2F0ZWRDbG9jaywgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAobGlua3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGxpbmtzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHRoaXMubGlua3MgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZHJvcHBlZEF0dHJpYnV0ZXNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2Ryb3BwZWRFdmVudHNDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2Ryb3BwZWRMaW5rc0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB7XG4gICAgICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuVU5TRVRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gWzAsIDBdO1xuICAgICAgICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IFstMSwgLTFdO1xuICAgICAgICB0aGlzLm5hbWUgPSBzcGFuTmFtZTtcbiAgICAgICAgdGhpcy5fc3BhbkNvbnRleHQgPSBzcGFuQ29udGV4dDtcbiAgICAgICAgdGhpcy5wYXJlbnRTcGFuSWQgPSBwYXJlbnRTcGFuSWQ7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMubGlua3MgPSBsaW5rcztcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuX3BlcmZvcm1hbmNlU3RhcnRUaW1lID0gb3RwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy5fcGVyZm9ybWFuY2VPZmZzZXQgPSBub3cgLSAodGhpcy5fcGVyZm9ybWFuY2VTdGFydFRpbWUgKyBnZXRUaW1lT3JpZ2luKCkpO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWVQcm92aWRlZCA9IHN0YXJ0VGltZSAhPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuX2dldFRpbWUoc3RhcnRUaW1lICE9PSBudWxsICYmIHN0YXJ0VGltZSAhPT0gdm9pZCAwID8gc3RhcnRUaW1lIDogbm93KTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHBhcmVudFRyYWNlci5yZXNvdXJjZTtcbiAgICAgICAgdGhpcy5pbnN0cnVtZW50YXRpb25MaWJyYXJ5ID0gcGFyZW50VHJhY2VyLmluc3RydW1lbnRhdGlvbkxpYnJhcnk7XG4gICAgICAgIHRoaXMuX3NwYW5MaW1pdHMgPSBwYXJlbnRUcmFjZXIuZ2V0U3BhbkxpbWl0cygpO1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0ID0gdGhpcy5fc3BhbkxpbWl0cy5hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0IHx8IDA7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3BhblByb2Nlc3NvciA9IHBhcmVudFRyYWNlci5nZXRBY3RpdmVTcGFuUHJvY2Vzc29yKCk7XG4gICAgICAgIHRoaXMuX3NwYW5Qcm9jZXNzb3Iub25TdGFydCh0aGlzLCBjb250ZXh0Mik7XG4gICAgICB9XG4gICAgICBTcGFuNC5wcm90b3R5cGUuc3BhbkNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NwYW5Db250ZXh0O1xuICAgICAgfTtcbiAgICAgIFNwYW40LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHRoaXMuX2lzU3BhbkVuZGVkKCkpXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGlhZzIud2FybihcIkludmFsaWQgYXR0cmlidXRlIGtleTogXCIgKyBrZXkpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBkaWFnMi53YXJuKFwiSW52YWxpZCBhdHRyaWJ1dGUgdmFsdWUgc2V0IGZvciBrZXk6IFwiICsga2V5KTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKS5sZW5ndGggPj0gdGhpcy5fc3BhbkxpbWl0cy5hdHRyaWJ1dGVDb3VudExpbWl0ICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBrZXkpKSB7XG4gICAgICAgICAgdGhpcy5fZHJvcHBlZEF0dHJpYnV0ZXNDb3VudCsrO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1trZXldID0gdGhpcy5fdHJ1bmNhdGVUb1NpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBTcGFuNC5wcm90b3R5cGUuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXM1KE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIF9kID0gX19yZWFkMTAoX2MudmFsdWUsIDIpLCBrID0gX2RbMF0sIHYgPSBfZFsxXTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGssIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hMiA9IF9iLnJldHVybikpXG4gICAgICAgICAgICAgIF9hMi5jYWxsKF9iKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfMSlcbiAgICAgICAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBTcGFuNC5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzT3JTdGFydFRpbWUsIHRpbWVTdGFtcCkge1xuICAgICAgICBpZiAodGhpcy5faXNTcGFuRW5kZWQoKSlcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3NwYW5MaW1pdHMuZXZlbnRDb3VudExpbWl0ID09PSAwKSB7XG4gICAgICAgICAgZGlhZzIud2FybihcIk5vIGV2ZW50cyBhbGxvd2VkLlwiKTtcbiAgICAgICAgICB0aGlzLl9kcm9wcGVkRXZlbnRzQ291bnQrKztcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ldmVudHMubGVuZ3RoID49IHRoaXMuX3NwYW5MaW1pdHMuZXZlbnRDb3VudExpbWl0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2Ryb3BwZWRFdmVudHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGlhZzIuZGVidWcoXCJEcm9wcGluZyBleHRyYSBldmVudHMuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50cy5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMuX2Ryb3BwZWRFdmVudHNDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RpbWVJbnB1dChhdHRyaWJ1dGVzT3JTdGFydFRpbWUpKSB7XG4gICAgICAgICAgaWYgKCFpc1RpbWVJbnB1dCh0aW1lU3RhbXApKSB7XG4gICAgICAgICAgICB0aW1lU3RhbXAgPSBhdHRyaWJ1dGVzT3JTdGFydFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZXNPclN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHNhbml0aXplQXR0cmlidXRlcyhhdHRyaWJ1dGVzT3JTdGFydFRpbWUpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgdGltZTogdGhpcy5fZ2V0VGltZSh0aW1lU3RhbXApLFxuICAgICAgICAgIGRyb3BwZWRBdHRyaWJ1dGVzQ291bnQ6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIFNwYW40LnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU3BhbkVuZGVkKCkpXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICBTcGFuNC5wcm90b3R5cGUudXBkYXRlTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU3BhbkVuZGVkKCkpXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIFNwYW40LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihlbmRUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1NwYW5FbmRlZCgpKSB7XG4gICAgICAgICAgZGlhZzIuZXJyb3IodGhpcy5uYW1lICsgXCIgXCIgKyB0aGlzLl9zcGFuQ29udGV4dC50cmFjZUlkICsgXCItXCIgKyB0aGlzLl9zcGFuQ29udGV4dC5zcGFuSWQgKyBcIiAtIFlvdSBjYW4gb25seSBjYWxsIGVuZCgpIG9uIGEgc3BhbiBvbmNlLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSB0aGlzLl9nZXRUaW1lKGVuZFRpbWUpO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGhyVGltZUR1cmF0aW9uKHRoaXMuc3RhcnRUaW1lLCB0aGlzLmVuZFRpbWUpO1xuICAgICAgICBpZiAodGhpcy5fZHVyYXRpb25bMF0gPCAwKSB7XG4gICAgICAgICAgZGlhZzIud2FybihcIkluY29uc2lzdGVudCBzdGFydCBhbmQgZW5kIHRpbWUsIHN0YXJ0VGltZSA+IGVuZFRpbWUuIFNldHRpbmcgc3BhbiBkdXJhdGlvbiB0byAwbXMuXCIsIHRoaXMuc3RhcnRUaW1lLCB0aGlzLmVuZFRpbWUpO1xuICAgICAgICAgIHRoaXMuZW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lLnNsaWNlKCk7XG4gICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BwZWRFdmVudHNDb3VudCA+IDApIHtcbiAgICAgICAgICBkaWFnMi53YXJuKFwiRHJvcHBlZCBcIiArIHRoaXMuX2Ryb3BwZWRFdmVudHNDb3VudCArIFwiIGV2ZW50cyBiZWNhdXNlIGV2ZW50Q291bnRMaW1pdCByZWFjaGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NwYW5Qcm9jZXNzb3Iub25FbmQodGhpcyk7XG4gICAgICB9O1xuICAgICAgU3BhbjQucHJvdG90eXBlLl9nZXRUaW1lID0gZnVuY3Rpb24oaW5wKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wID09PSBcIm51bWJlclwiICYmIGlucCA8IG90cGVyZm9ybWFuY2Uubm93KCkpIHtcbiAgICAgICAgICByZXR1cm4gaHJUaW1lKGlucCArIHRoaXMuX3BlcmZvcm1hbmNlT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlucCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJldHVybiBtaWxsaXNUb0hyVGltZShpbnApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnAgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG1pbGxpc1RvSHJUaW1lKGlucC5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RpbWVJbnB1dEhyVGltZShpbnApKSB7XG4gICAgICAgICAgcmV0dXJuIGlucDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhcnRUaW1lUHJvdmlkZWQpIHtcbiAgICAgICAgICByZXR1cm4gbWlsbGlzVG9IclRpbWUoRGF0ZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zRHVyYXRpb24gPSBvdHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5fcGVyZm9ybWFuY2VTdGFydFRpbWU7XG4gICAgICAgIHJldHVybiBhZGRIclRpbWVzKHRoaXMuc3RhcnRUaW1lLCBtaWxsaXNUb0hyVGltZShtc0R1cmF0aW9uKSk7XG4gICAgICB9O1xuICAgICAgU3BhbjQucHJvdG90eXBlLmlzUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRlZCA9PT0gZmFsc2U7XG4gICAgICB9O1xuICAgICAgU3BhbjQucHJvdG90eXBlLnJlY29yZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGV4Y2VwdGlvbiwgdGltZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGV4Y2VwdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9NRVNTQUdFXSA9IGV4Y2VwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChleGNlcHRpb24pIHtcbiAgICAgICAgICBpZiAoZXhjZXB0aW9uLmNvZGUpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9UWVBFXSA9IGV4Y2VwdGlvbi5jb2RlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChleGNlcHRpb24ubmFtZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuRVhDRVBUSU9OX1RZUEVdID0gZXhjZXB0aW9uLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGNlcHRpb24ubWVzc2FnZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuRVhDRVBUSU9OX01FU1NBR0VdID0gZXhjZXB0aW9uLm1lc3NhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGNlcHRpb24uc3RhY2spIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9TVEFDS1RSQUNFXSA9IGV4Y2VwdGlvbi5zdGFjaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkVYQ0VQVElPTl9UWVBFXSB8fCBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5FWENFUFRJT05fTUVTU0FHRV0pIHtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50KEV4Y2VwdGlvbkV2ZW50TmFtZSwgYXR0cmlidXRlcywgdGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlhZzIud2FybihcIkZhaWxlZCB0byByZWNvcmQgYW4gZXhjZXB0aW9uIFwiICsgZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGFuNC5wcm90b3R5cGUsIFwiZHVyYXRpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BhbjQucHJvdG90eXBlLCBcImVuZGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5kZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwYW40LnByb3RvdHlwZSwgXCJkcm9wcGVkQXR0cmlidXRlc0NvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZHJvcHBlZEF0dHJpYnV0ZXNDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BhbjQucHJvdG90eXBlLCBcImRyb3BwZWRFdmVudHNDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BwZWRFdmVudHNDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BhbjQucHJvdG90eXBlLCBcImRyb3BwZWRMaW5rc0NvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZHJvcHBlZExpbmtzQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgU3BhbjQucHJvdG90eXBlLl9pc1NwYW5FbmRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICAgICAgICBkaWFnMi53YXJuKFwiQ2FuIG5vdCBleGVjdXRlIHRoZSBvcGVyYXRpb24gb24gZW5kZWQgU3BhbiB7dHJhY2VJZDogXCIgKyB0aGlzLl9zcGFuQ29udGV4dC50cmFjZUlkICsgXCIsIHNwYW5JZDogXCIgKyB0aGlzLl9zcGFuQ29udGV4dC5zcGFuSWQgKyBcIn1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZGVkO1xuICAgICAgfTtcbiAgICAgIFNwYW40LnByb3RvdHlwZS5fdHJ1bmNhdGVUb0xpbWl0VXRpbCA9IGZ1bmN0aW9uKHZhbHVlLCBsaW1pdCkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IGxpbWl0KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoMCwgbGltaXQpO1xuICAgICAgfTtcbiAgICAgIFNwYW40LnByb3RvdHlwZS5fdHJ1bmNhdGVUb1NpemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGltaXQgPSB0aGlzLl9hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0O1xuICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgIGRpYWcyLndhcm4oXCJBdHRyaWJ1dGUgdmFsdWUgbGltaXQgbXVzdCBiZSBwb3NpdGl2ZSwgZ290IFwiICsgbGltaXQpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RydW5jYXRlVG9MaW1pdFV0aWwodmFsdWUsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBfdGhpcy5fdHJ1bmNhdGVUb0xpbWl0VXRpbCh2YWwsIGxpbWl0KSA6IHZhbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFNwYW40O1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vU2FtcGxlci5qc1xudmFyIFNhbXBsaW5nRGVjaXNpb24yO1xudmFyIGluaXRfU2FtcGxlciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL1NhbXBsZXIuanNcIigpIHtcbiAgICAoZnVuY3Rpb24oU2FtcGxpbmdEZWNpc2lvbjMpIHtcbiAgICAgIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiTk9UX1JFQ09SRFwiXSA9IDBdID0gXCJOT1RfUkVDT1JEXCI7XG4gICAgICBTYW1wbGluZ0RlY2lzaW9uM1tTYW1wbGluZ0RlY2lzaW9uM1tcIlJFQ09SRFwiXSA9IDFdID0gXCJSRUNPUkRcIjtcbiAgICAgIFNhbXBsaW5nRGVjaXNpb24zW1NhbXBsaW5nRGVjaXNpb24zW1wiUkVDT1JEX0FORF9TQU1QTEVEXCJdID0gMl0gPSBcIlJFQ09SRF9BTkRfU0FNUExFRFwiO1xuICAgIH0pKFNhbXBsaW5nRGVjaXNpb24yIHx8IChTYW1wbGluZ0RlY2lzaW9uMiA9IHt9KSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3NhbXBsZXIvQWx3YXlzT2ZmU2FtcGxlci5qc1xudmFyIEFsd2F5c09mZlNhbXBsZXIyO1xudmFyIGluaXRfQWx3YXlzT2ZmU2FtcGxlcjIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9zYW1wbGVyL0Fsd2F5c09mZlNhbXBsZXIuanNcIigpIHtcbiAgICBpbml0X1NhbXBsZXIoKTtcbiAgICBBbHdheXNPZmZTYW1wbGVyMiA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEFsd2F5c09mZlNhbXBsZXIzKCkge1xuICAgICAgfVxuICAgICAgQWx3YXlzT2ZmU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlY2lzaW9uOiBTYW1wbGluZ0RlY2lzaW9uMi5OT1RfUkVDT1JEXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgQWx3YXlzT2ZmU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIkFsd2F5c09mZlNhbXBsZXJcIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQWx3YXlzT2ZmU2FtcGxlcjM7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9zYW1wbGVyL0Fsd2F5c09uU2FtcGxlci5qc1xudmFyIEFsd2F5c09uU2FtcGxlcjI7XG52YXIgaW5pdF9BbHdheXNPblNhbXBsZXIyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vc2FtcGxlci9BbHdheXNPblNhbXBsZXIuanNcIigpIHtcbiAgICBpbml0X1NhbXBsZXIoKTtcbiAgICBBbHdheXNPblNhbXBsZXIyID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gQWx3YXlzT25TYW1wbGVyMygpIHtcbiAgICAgIH1cbiAgICAgIEFsd2F5c09uU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlY2lzaW9uOiBTYW1wbGluZ0RlY2lzaW9uMi5SRUNPUkRfQU5EX1NBTVBMRURcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBBbHdheXNPblNhbXBsZXIzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJBbHdheXNPblNhbXBsZXJcIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQWx3YXlzT25TYW1wbGVyMztcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3NhbXBsZXIvUGFyZW50QmFzZWRTYW1wbGVyLmpzXG52YXIgUGFyZW50QmFzZWRTYW1wbGVyMjtcbnZhciBpbml0X1BhcmVudEJhc2VkU2FtcGxlcjIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9zYW1wbGVyL1BhcmVudEJhc2VkU2FtcGxlci5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgaW5pdF9lc20zKCk7XG4gICAgaW5pdF9BbHdheXNPZmZTYW1wbGVyMigpO1xuICAgIGluaXRfQWx3YXlzT25TYW1wbGVyMigpO1xuICAgIFBhcmVudEJhc2VkU2FtcGxlcjIgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBQYXJlbnRCYXNlZFNhbXBsZXIzKGNvbmZpZykge1xuICAgICAgICB2YXIgX2EyLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLl9yb290ID0gY29uZmlnLnJvb3Q7XG4gICAgICAgIGlmICghdGhpcy5fcm9vdCkge1xuICAgICAgICAgIGdsb2JhbEVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJQYXJlbnRCYXNlZFNhbXBsZXIgbXVzdCBoYXZlIGEgcm9vdCBzYW1wbGVyIGNvbmZpZ3VyZWRcIikpO1xuICAgICAgICAgIHRoaXMuX3Jvb3QgPSBuZXcgQWx3YXlzT25TYW1wbGVyMigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW90ZVBhcmVudFNhbXBsZWQgPSAoX2EyID0gY29uZmlnLnJlbW90ZVBhcmVudFNhbXBsZWQpICE9PSBudWxsICYmIF9hMiAhPT0gdm9pZCAwID8gX2EyIDogbmV3IEFsd2F5c09uU2FtcGxlcjIoKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlUGFyZW50Tm90U2FtcGxlZCA9IChfYiA9IGNvbmZpZy5yZW1vdGVQYXJlbnROb3RTYW1wbGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgQWx3YXlzT2ZmU2FtcGxlcjIoKTtcbiAgICAgICAgdGhpcy5fbG9jYWxQYXJlbnRTYW1wbGVkID0gKF9jID0gY29uZmlnLmxvY2FsUGFyZW50U2FtcGxlZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IEFsd2F5c09uU2FtcGxlcjIoKTtcbiAgICAgICAgdGhpcy5fbG9jYWxQYXJlbnROb3RTYW1wbGVkID0gKF9kID0gY29uZmlnLmxvY2FsUGFyZW50Tm90U2FtcGxlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbmV3IEFsd2F5c09mZlNhbXBsZXIyKCk7XG4gICAgICB9XG4gICAgICBQYXJlbnRCYXNlZFNhbXBsZXIzLnByb3RvdHlwZS5zaG91bGRTYW1wbGUgPSBmdW5jdGlvbihjb250ZXh0MiwgdHJhY2VJZCwgc3Bhbk5hbWUsIHNwYW5LaW5kLCBhdHRyaWJ1dGVzLCBsaW5rcykge1xuICAgICAgICB2YXIgcGFyZW50Q29udGV4dCA9IHRyYWNlLmdldFNwYW5Db250ZXh0KGNvbnRleHQyKTtcbiAgICAgICAgaWYgKCFwYXJlbnRDb250ZXh0IHx8ICFpc1NwYW5Db250ZXh0VmFsaWQocGFyZW50Q29udGV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5zaG91bGRTYW1wbGUoY29udGV4dDIsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRDb250ZXh0LmlzUmVtb3RlKSB7XG4gICAgICAgICAgaWYgKHBhcmVudENvbnRleHQudHJhY2VGbGFncyAmIFRyYWNlRmxhZ3MuU0FNUExFRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVBhcmVudFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQyLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVBhcmVudE5vdFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQyLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Q29udGV4dC50cmFjZUZsYWdzICYgVHJhY2VGbGFncy5TQU1QTEVEKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsUGFyZW50U2FtcGxlZC5zaG91bGRTYW1wbGUoY29udGV4dDIsIHRyYWNlSWQsIHNwYW5OYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFBhcmVudE5vdFNhbXBsZWQuc2hvdWxkU2FtcGxlKGNvbnRleHQyLCB0cmFjZUlkLCBzcGFuTmFtZSwgc3BhbktpbmQsIGF0dHJpYnV0ZXMsIGxpbmtzKTtcbiAgICAgIH07XG4gICAgICBQYXJlbnRCYXNlZFNhbXBsZXIzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJQYXJlbnRCYXNlZHtyb290PVwiICsgdGhpcy5fcm9vdC50b1N0cmluZygpICsgXCIsIHJlbW90ZVBhcmVudFNhbXBsZWQ9XCIgKyB0aGlzLl9yZW1vdGVQYXJlbnRTYW1wbGVkLnRvU3RyaW5nKCkgKyBcIiwgcmVtb3RlUGFyZW50Tm90U2FtcGxlZD1cIiArIHRoaXMuX3JlbW90ZVBhcmVudE5vdFNhbXBsZWQudG9TdHJpbmcoKSArIFwiLCBsb2NhbFBhcmVudFNhbXBsZWQ9XCIgKyB0aGlzLl9sb2NhbFBhcmVudFNhbXBsZWQudG9TdHJpbmcoKSArIFwiLCBsb2NhbFBhcmVudE5vdFNhbXBsZWQ9XCIgKyB0aGlzLl9sb2NhbFBhcmVudE5vdFNhbXBsZWQudG9TdHJpbmcoKSArIFwifVwiO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQYXJlbnRCYXNlZFNhbXBsZXIzO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vc2FtcGxlci9UcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIuanNcbnZhciBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIyO1xudmFyIGluaXRfVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3NhbXBsZXIvVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBpbml0X1NhbXBsZXIoKTtcbiAgICBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIyID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMyhfcmF0aW8pIHtcbiAgICAgICAgaWYgKF9yYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgX3JhdGlvID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yYXRpbyA9IF9yYXRpbztcbiAgICAgICAgdGhpcy5fcmF0aW8gPSB0aGlzLl9ub3JtYWxpemUoX3JhdGlvKTtcbiAgICAgICAgdGhpcy5fdXBwZXJCb3VuZCA9IE1hdGguZmxvb3IodGhpcy5fcmF0aW8gKiA0Mjk0OTY3Mjk1KTtcbiAgICAgIH1cbiAgICAgIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLnNob3VsZFNhbXBsZSA9IGZ1bmN0aW9uKGNvbnRleHQyLCB0cmFjZUlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVjaXNpb246IGlzVmFsaWRUcmFjZUlkKHRyYWNlSWQpICYmIHRoaXMuX2FjY3VtdWxhdGUodHJhY2VJZCkgPCB0aGlzLl91cHBlckJvdW5kID8gU2FtcGxpbmdEZWNpc2lvbjIuUkVDT1JEX0FORF9TQU1QTEVEIDogU2FtcGxpbmdEZWNpc2lvbjIuTk9UX1JFQ09SRFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlRyYWNlSWRSYXRpb0Jhc2Vke1wiICsgdGhpcy5fcmF0aW8gKyBcIn1cIjtcbiAgICAgIH07XG4gICAgICBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIzLnByb3RvdHlwZS5fbm9ybWFsaXplID0gZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByYXRpbyAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihyYXRpbykpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiByYXRpbyA+PSAxID8gMSA6IHJhdGlvIDw9IDAgPyAwIDogcmF0aW87XG4gICAgICB9O1xuICAgICAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMy5wcm90b3R5cGUuX2FjY3VtdWxhdGUgPSBmdW5jdGlvbih0cmFjZUlkKSB7XG4gICAgICAgIHZhciBhY2N1bXVsYXRpb24gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNlSWQubGVuZ3RoIC8gODsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGkgKiA4O1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFyc2VJbnQodHJhY2VJZC5zbGljZShwb3MsIHBvcyArIDgpLCAxNik7XG4gICAgICAgICAgYWNjdW11bGF0aW9uID0gKGFjY3VtdWxhdGlvbiBeIHBhcnQpID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRpb247XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjM7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9jb25maWcuanNcbmZ1bmN0aW9uIGxvYWREZWZhdWx0Q29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXI6IGJ1aWxkU2FtcGxlckZyb21FbnYoZW52KSxcbiAgICBmb3JjZUZsdXNoVGltZW91dE1pbGxpczogM2U0LFxuICAgIGdlbmVyYWxMaW1pdHM6IHtcbiAgICAgIGF0dHJpYnV0ZVZhbHVlTGVuZ3RoTGltaXQ6IGdldEVudigpLk9URUxfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCxcbiAgICAgIGF0dHJpYnV0ZUNvdW50TGltaXQ6IGdldEVudigpLk9URUxfQVRUUklCVVRFX0NPVU5UX0xJTUlUXG4gICAgfSxcbiAgICBzcGFuTGltaXRzOiB7XG4gICAgICBhdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0OiBnZXRFbnYoKS5PVEVMX1NQQU5fQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVCxcbiAgICAgIGF0dHJpYnV0ZUNvdW50TGltaXQ6IGdldEVudigpLk9URUxfU1BBTl9BVFRSSUJVVEVfQ09VTlRfTElNSVQsXG4gICAgICBsaW5rQ291bnRMaW1pdDogZ2V0RW52KCkuT1RFTF9TUEFOX0xJTktfQ09VTlRfTElNSVQsXG4gICAgICBldmVudENvdW50TGltaXQ6IGdldEVudigpLk9URUxfU1BBTl9FVkVOVF9DT1VOVF9MSU1JVCxcbiAgICAgIGF0dHJpYnV0ZVBlckV2ZW50Q291bnRMaW1pdDogZ2V0RW52KCkuT1RFTF9TUEFOX0FUVFJJQlVURV9QRVJfRVZFTlRfQ09VTlRfTElNSVQsXG4gICAgICBhdHRyaWJ1dGVQZXJMaW5rQ291bnRMaW1pdDogZ2V0RW52KCkuT1RFTF9TUEFOX0FUVFJJQlVURV9QRVJfTElOS19DT1VOVF9MSU1JVFxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2FtcGxlckZyb21FbnYoZW52aXJvbm1lbnQpIHtcbiAgaWYgKGVudmlyb25tZW50ID09PSB2b2lkIDApIHtcbiAgICBlbnZpcm9ubWVudCA9IGdldEVudigpO1xuICB9XG4gIHN3aXRjaCAoZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUikge1xuICAgIGNhc2UgVHJhY2VzU2FtcGxlclZhbHVlcy5BbHdheXNPbjpcbiAgICAgIHJldHVybiBuZXcgQWx3YXlzT25TYW1wbGVyMigpO1xuICAgIGNhc2UgVHJhY2VzU2FtcGxlclZhbHVlcy5BbHdheXNPZmY6XG4gICAgICByZXR1cm4gbmV3IEFsd2F5c09mZlNhbXBsZXIyKCk7XG4gICAgY2FzZSBUcmFjZXNTYW1wbGVyVmFsdWVzLlBhcmVudEJhc2VkQWx3YXlzT246XG4gICAgICByZXR1cm4gbmV3IFBhcmVudEJhc2VkU2FtcGxlcjIoe1xuICAgICAgICByb290OiBuZXcgQWx3YXlzT25TYW1wbGVyMigpXG4gICAgICB9KTtcbiAgICBjYXNlIFRyYWNlc1NhbXBsZXJWYWx1ZXMuUGFyZW50QmFzZWRBbHdheXNPZmY6XG4gICAgICByZXR1cm4gbmV3IFBhcmVudEJhc2VkU2FtcGxlcjIoe1xuICAgICAgICByb290OiBuZXcgQWx3YXlzT2ZmU2FtcGxlcjIoKVxuICAgICAgfSk7XG4gICAgY2FzZSBUcmFjZXNTYW1wbGVyVmFsdWVzLlRyYWNlSWRSYXRpbzpcbiAgICAgIHJldHVybiBuZXcgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMihnZXRTYW1wbGVyUHJvYmFiaWxpdHlGcm9tRW52KGVudmlyb25tZW50KSk7XG4gICAgY2FzZSBUcmFjZXNTYW1wbGVyVmFsdWVzLlBhcmVudEJhc2VkVHJhY2VJZFJhdGlvOlxuICAgICAgcmV0dXJuIG5ldyBQYXJlbnRCYXNlZFNhbXBsZXIyKHtcbiAgICAgICAgcm9vdDogbmV3IFRyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjIoZ2V0U2FtcGxlclByb2JhYmlsaXR5RnJvbUVudihlbnZpcm9ubWVudCkpXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgZGlhZzIuZXJyb3IoJ09URUxfVFJBQ0VTX1NBTVBMRVIgdmFsdWUgXCInICsgZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUiArIFwiIGludmFsaWQsIGRlZmF1bHRpbmcgdG8gXCIgKyBGQUxMQkFDS19PVEVMX1RSQUNFU19TQU1QTEVSICsgJ1wiLicpO1xuICAgICAgcmV0dXJuIG5ldyBBbHdheXNPblNhbXBsZXIyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJQcm9iYWJpbGl0eUZyb21FbnYoZW52aXJvbm1lbnQpIHtcbiAgaWYgKGVudmlyb25tZW50Lk9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHID09PSB2b2lkIDAgfHwgZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUl9BUkcgPT09IFwiXCIpIHtcbiAgICBkaWFnMi5lcnJvcihcIk9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHIGlzIGJsYW5rLCBkZWZhdWx0aW5nIHRvIFwiICsgREVGQVVMVF9SQVRJTyArIFwiLlwiKTtcbiAgICByZXR1cm4gREVGQVVMVF9SQVRJTztcbiAgfVxuICB2YXIgcHJvYmFiaWxpdHkgPSBOdW1iZXIoZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUl9BUkcpO1xuICBpZiAoaXNOYU4ocHJvYmFiaWxpdHkpKSB7XG4gICAgZGlhZzIuZXJyb3IoXCJPVEVMX1RSQUNFU19TQU1QTEVSX0FSRz1cIiArIGVudmlyb25tZW50Lk9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHICsgXCIgd2FzIGdpdmVuLCBidXQgaXQgaXMgaW52YWxpZCwgZGVmYXVsdGluZyB0byBcIiArIERFRkFVTFRfUkFUSU8gKyBcIi5cIik7XG4gICAgcmV0dXJuIERFRkFVTFRfUkFUSU87XG4gIH1cbiAgaWYgKHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEpIHtcbiAgICBkaWFnMi5lcnJvcihcIk9URUxfVFJBQ0VTX1NBTVBMRVJfQVJHPVwiICsgZW52aXJvbm1lbnQuT1RFTF9UUkFDRVNfU0FNUExFUl9BUkcgKyBcIiB3YXMgZ2l2ZW4sIGJ1dCBpdCBpcyBvdXQgb2YgcmFuZ2UgKFswLi4xXSksIGRlZmF1bHRpbmcgdG8gXCIgKyBERUZBVUxUX1JBVElPICsgXCIuXCIpO1xuICAgIHJldHVybiBERUZBVUxUX1JBVElPO1xuICB9XG4gIHJldHVybiBwcm9iYWJpbGl0eTtcbn1cbnZhciBlbnYsIEZBTExCQUNLX09URUxfVFJBQ0VTX1NBTVBMRVIsIERFRkFVTFRfUkFUSU87XG52YXIgaW5pdF9jb25maWcgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9jb25maWcuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIGluaXRfZXNtMygpO1xuICAgIGluaXRfQWx3YXlzT2ZmU2FtcGxlcjIoKTtcbiAgICBpbml0X0Fsd2F5c09uU2FtcGxlcjIoKTtcbiAgICBpbml0X1BhcmVudEJhc2VkU2FtcGxlcjIoKTtcbiAgICBpbml0X1RyYWNlSWRSYXRpb0Jhc2VkU2FtcGxlcjIoKTtcbiAgICBlbnYgPSBnZXRFbnYoKTtcbiAgICBGQUxMQkFDS19PVEVMX1RSQUNFU19TQU1QTEVSID0gVHJhY2VzU2FtcGxlclZhbHVlcy5BbHdheXNPbjtcbiAgICBERUZBVUxUX1JBVElPID0gMTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vdXRpbGl0eS5qc1xuZnVuY3Rpb24gbWVyZ2VDb25maWcodXNlckNvbmZpZykge1xuICB2YXIgcGVySW5zdGFuY2VEZWZhdWx0cyA9IHtcbiAgICBzYW1wbGVyOiBidWlsZFNhbXBsZXJGcm9tRW52KClcbiAgfTtcbiAgdmFyIERFRkFVTFRfQ09ORklHID0gbG9hZERlZmF1bHRDb25maWcoKTtcbiAgdmFyIHRhcmdldCA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQ09ORklHLCBwZXJJbnN0YW5jZURlZmF1bHRzLCB1c2VyQ29uZmlnKTtcbiAgdGFyZ2V0LmdlbmVyYWxMaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRy5nZW5lcmFsTGltaXRzLCB1c2VyQ29uZmlnLmdlbmVyYWxMaW1pdHMgfHwge30pO1xuICB0YXJnZXQuc3BhbkxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQ09ORklHLnNwYW5MaW1pdHMsIHVzZXJDb25maWcuc3BhbkxpbWl0cyB8fCB7fSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiByZWNvbmZpZ3VyZUxpbWl0cyh1c2VyQ29uZmlnKSB7XG4gIHZhciBfYTIsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcbiAgdmFyIHNwYW5MaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCB1c2VyQ29uZmlnLnNwYW5MaW1pdHMpO1xuICB2YXIgcGFyc2VkRW52Q29uZmlnID0gZ2V0RW52V2l0aG91dERlZmF1bHRzKCk7XG4gIHNwYW5MaW1pdHMuYXR0cmlidXRlQ291bnRMaW1pdCA9IChfZiA9IChfZSA9IChfZCA9IChfYiA9IChfYTIgPSB1c2VyQ29uZmlnLnNwYW5MaW1pdHMpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmF0dHJpYnV0ZUNvdW50TGltaXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHVzZXJDb25maWcuZ2VuZXJhbExpbWl0cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmF0dHJpYnV0ZUNvdW50TGltaXQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHBhcnNlZEVudkNvbmZpZy5PVEVMX1NQQU5fQVRUUklCVVRFX0NPVU5UX0xJTUlUKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBwYXJzZWRFbnZDb25maWcuT1RFTF9BVFRSSUJVVEVfQ09VTlRfTElNSVQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IERFRkFVTFRfQVRUUklCVVRFX0NPVU5UX0xJTUlUO1xuICBzcGFuTGltaXRzLmF0dHJpYnV0ZVZhbHVlTGVuZ3RoTGltaXQgPSAoX20gPSAoX2wgPSAoX2sgPSAoX2ggPSAoX2cgPSB1c2VyQ29uZmlnLnNwYW5MaW1pdHMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0KSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAoX2ogPSB1c2VyQ29uZmlnLmdlbmVyYWxMaW1pdHMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5hdHRyaWJ1dGVWYWx1ZUxlbmd0aExpbWl0KSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBwYXJzZWRFbnZDb25maWcuT1RFTF9TUEFOX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IHBhcnNlZEVudkNvbmZpZy5PVEVMX0FUVFJJQlVURV9WQUxVRV9MRU5HVEhfTElNSVQpICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IERFRkFVTFRfQVRUUklCVVRFX1ZBTFVFX0xFTkdUSF9MSU1JVDtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHVzZXJDb25maWcsIHsgc3BhbkxpbWl0cyB9KTtcbn1cbnZhciBpbml0X3V0aWxpdHkgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS91dGlsaXR5LmpzXCIoKSB7XG4gICAgaW5pdF9jb25maWcoKTtcbiAgICBpbml0X2VzbTMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L0JhdGNoU3BhblByb2Nlc3NvckJhc2UuanNcbnZhciBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlO1xudmFyIGluaXRfQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZSA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2V4cG9ydC9CYXRjaFNwYW5Qcm9jZXNzb3JCYXNlLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBpbml0X2VzbTMoKTtcbiAgICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIoX2V4cG9ydGVyLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5fZXhwb3J0ZXIgPSBfZXhwb3J0ZXI7XG4gICAgICAgIHRoaXMuX2lzRXhwb3J0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fZHJvcHBlZFNwYW5zQ291bnQgPSAwO1xuICAgICAgICB2YXIgZW52MyA9IGdldEVudigpO1xuICAgICAgICB0aGlzLl9tYXhFeHBvcnRCYXRjaFNpemUgPSB0eXBlb2YgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5tYXhFeHBvcnRCYXRjaFNpemUpID09PSBcIm51bWJlclwiID8gY29uZmlnLm1heEV4cG9ydEJhdGNoU2l6ZSA6IGVudjMuT1RFTF9CU1BfTUFYX0VYUE9SVF9CQVRDSF9TSVpFO1xuICAgICAgICB0aGlzLl9tYXhRdWV1ZVNpemUgPSB0eXBlb2YgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5tYXhRdWV1ZVNpemUpID09PSBcIm51bWJlclwiID8gY29uZmlnLm1heFF1ZXVlU2l6ZSA6IGVudjMuT1RFTF9CU1BfTUFYX1FVRVVFX1NJWkU7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZERlbGF5TWlsbGlzID0gdHlwZW9mIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuc2NoZWR1bGVkRGVsYXlNaWxsaXMpID09PSBcIm51bWJlclwiID8gY29uZmlnLnNjaGVkdWxlZERlbGF5TWlsbGlzIDogZW52My5PVEVMX0JTUF9TQ0hFRFVMRV9ERUxBWTtcbiAgICAgICAgdGhpcy5fZXhwb3J0VGltZW91dE1pbGxpcyA9IHR5cGVvZiAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmV4cG9ydFRpbWVvdXRNaWxsaXMpID09PSBcIm51bWJlclwiID8gY29uZmlnLmV4cG9ydFRpbWVvdXRNaWxsaXMgOiBlbnYzLk9URUxfQlNQX0VYUE9SVF9USU1FT1VUO1xuICAgICAgICB0aGlzLl9zaHV0ZG93bk9uY2UgPSBuZXcgQmluZE9uY2VGdXR1cmUodGhpcy5fc2h1dGRvd24sIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fbWF4RXhwb3J0QmF0Y2hTaXplID4gdGhpcy5fbWF4UXVldWVTaXplKSB7XG4gICAgICAgICAgZGlhZzIud2FybihcIkJhdGNoU3BhblByb2Nlc3NvcjogbWF4RXhwb3J0QmF0Y2hTaXplIG11c3QgYmUgc21hbGxlciBvciBlcXVhbCB0byBtYXhRdWV1ZVNpemUsIHNldHRpbmcgbWF4RXhwb3J0QmF0Y2hTaXplIHRvIG1hdGNoIG1heFF1ZXVlU2l6ZVwiKTtcbiAgICAgICAgICB0aGlzLl9tYXhFeHBvcnRCYXRjaFNpemUgPSB0aGlzLl9tYXhRdWV1ZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5mb3JjZUZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaHV0ZG93bk9uY2UuaXNDYWxsZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2h1dGRvd25PbmNlLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsdXNoQWxsKCk7XG4gICAgICB9O1xuICAgICAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbihfc3BhbiwgX3BhcmVudENvbnRleHQpIHtcbiAgICAgIH07XG4gICAgICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihzcGFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaHV0ZG93bk9uY2UuaXNDYWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VGbGFncyAmIFRyYWNlRmxhZ3MuU0FNUExFRCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkVG9CdWZmZXIoc3Bhbik7XG4gICAgICB9O1xuICAgICAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaHV0ZG93bk9uY2UuY2FsbCgpO1xuICAgICAgfTtcbiAgICAgIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5fc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm9uU2h1dGRvd24oKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2ZsdXNoQWxsKCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9leHBvcnRlci5zaHV0ZG93bigpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUuX2FkZFRvQnVmZmVyID0gZnVuY3Rpb24oc3Bhbikge1xuICAgICAgICBpZiAodGhpcy5fZmluaXNoZWRTcGFucy5sZW5ndGggPj0gdGhpcy5fbWF4UXVldWVTaXplKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2Ryb3BwZWRTcGFuc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkaWFnMi5kZWJ1ZyhcIm1heFF1ZXVlU2l6ZSByZWFjaGVkLCBkcm9wcGluZyBzcGFuc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZHJvcHBlZFNwYW5zQ291bnQrKztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BwZWRTcGFuc0NvdW50ID4gMCkge1xuICAgICAgICAgIGRpYWcyLndhcm4oXCJEcm9wcGVkIFwiICsgdGhpcy5fZHJvcHBlZFNwYW5zQ291bnQgKyBcIiBzcGFucyBiZWNhdXNlIG1heFF1ZXVlU2l6ZSByZWFjaGVkXCIpO1xuICAgICAgICAgIHRoaXMuX2Ryb3BwZWRTcGFuc0NvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maW5pc2hlZFNwYW5zLnB1c2goc3Bhbik7XG4gICAgICAgIHRoaXMuX21heWJlU3RhcnRUaW1lcigpO1xuICAgICAgfTtcbiAgICAgIEJhdGNoU3BhblByb2Nlc3NvckJhc2UyLnByb3RvdHlwZS5fZmx1c2hBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgIHZhciBjb3VudCA9IE1hdGguY2VpbChfdGhpcy5fZmluaXNoZWRTcGFucy5sZW5ndGggLyBfdGhpcy5fbWF4RXhwb3J0QmF0Y2hTaXplKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNvdW50OyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKF90aGlzLl9mbHVzaE9uZUJhdGNoKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUuX2ZsdXNoT25lQmF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5fZmluaXNoZWRTcGFucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGltZW91dFwiKSk7XG4gICAgICAgICAgfSwgX3RoaXMuX2V4cG9ydFRpbWVvdXRNaWxsaXMpO1xuICAgICAgICAgIGNvbnRleHQud2l0aChzdXBwcmVzc1RyYWNpbmcoY29udGV4dC5hY3RpdmUoKSksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNwYW5zO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9maW5pc2hlZFNwYW5zLmxlbmd0aCA8PSBfdGhpcy5fbWF4RXhwb3J0QmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgIHNwYW5zID0gX3RoaXMuX2ZpbmlzaGVkU3BhbnM7XG4gICAgICAgICAgICAgIF90aGlzLl9maW5pc2hlZFNwYW5zID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcGFucyA9IF90aGlzLl9maW5pc2hlZFNwYW5zLnNwbGljZSgwLCBfdGhpcy5fbWF4RXhwb3J0QmF0Y2hTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkb0V4cG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2V4cG9ydGVyLmV4cG9ydChzcGFucywgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuY29kZSA9PT0gRXhwb3J0UmVzdWx0Q29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdCgoX2EyID0gcmVzdWx0LmVycm9yKSAhPT0gbnVsbCAmJiBfYTIgIT09IHZvaWQgMCA/IF9hMiA6IG5ldyBFcnJvcihcIkJhdGNoU3BhblByb2Nlc3Nvcjogc3BhbiBleHBvcnQgZmFpbGVkXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwZW5kaW5nUmVzb3VyY2VzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzcGFucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICAgICAgICBpZiAoc3Bhbi5yZXNvdXJjZS5hc3luY0F0dHJpYnV0ZXNQZW5kaW5nICYmIHNwYW4ucmVzb3VyY2Uud2FpdEZvckFzeW5jQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZXNvdXJjZXMgIT09IG51bGwgJiYgcGVuZGluZ1Jlc291cmNlcyAhPT0gdm9pZCAwID8gcGVuZGluZ1Jlc291cmNlcyA6IHBlbmRpbmdSZXNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVzb3VyY2VzLnB1c2goc3Bhbi5yZXNvdXJjZS53YWl0Rm9yQXN5bmNBdHRyaWJ1dGVzKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGVuZGluZ1Jlc291cmNlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBkb0V4cG9ydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ1Jlc291cmNlcykudGhlbihkb0V4cG9ydCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMi5wcm90b3R5cGUuX21heWJlU3RhcnRUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5faXNFeHBvcnRpbmcpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5faXNFeHBvcnRpbmcgPSB0cnVlO1xuICAgICAgICAgIF90aGlzLl9mbHVzaE9uZUJhdGNoKCkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLl9pc0V4cG9ydGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9maW5pc2hlZFNwYW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2NsZWFyVGltZXIoKTtcbiAgICAgICAgICAgICAgX3RoaXMuX21heWJlU3RhcnRUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9pc0V4cG9ydGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZ2xvYmFsRXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fZmluaXNoZWRTcGFucy5sZW5ndGggPj0gdGhpcy5fbWF4RXhwb3J0QmF0Y2hTaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGZsdXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyICE9PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGZsdXNoKCk7XG4gICAgICAgIH0sIHRoaXMuX3NjaGVkdWxlZERlbGF5TWlsbGlzKTtcbiAgICAgICAgdW5yZWZUaW1lcih0aGlzLl90aW1lcik7XG4gICAgICB9O1xuICAgICAgQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZTIucHJvdG90eXBlLl9jbGVhclRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgICAgICB0aGlzLl90aW1lciA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBCYXRjaFNwYW5Qcm9jZXNzb3JCYXNlMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvZXhwb3J0L0JhdGNoU3BhblByb2Nlc3Nvci5qc1xudmFyIF9fZXh0ZW5kczMsIEJhdGNoU3BhblByb2Nlc3NvcjtcbnZhciBpbml0X0JhdGNoU3BhblByb2Nlc3NvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvZXhwb3J0L0JhdGNoU3BhblByb2Nlc3Nvci5qc1wiKCkge1xuICAgIGluaXRfQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZSgpO1xuICAgIF9fZXh0ZW5kczMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgICAgZDIuX19wcm90b19fID0gYjI7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBiMilcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHApKVxuICAgICAgICAgICAgICBkMltwXSA9IGIyW3BdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgQmF0Y2hTcGFuUHJvY2Vzc29yID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzMyhCYXRjaFNwYW5Qcm9jZXNzb3IzLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQmF0Y2hTcGFuUHJvY2Vzc29yMygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgfVxuICAgICAgQmF0Y2hTcGFuUHJvY2Vzc29yMy5wcm90b3R5cGUub25TaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCYXRjaFNwYW5Qcm9jZXNzb3IzO1xuICAgIH0oQmF0Y2hTcGFuUHJvY2Vzc29yQmFzZSk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvUmFuZG9tSWRHZW5lcmF0b3IuanNcbmZ1bmN0aW9uIGdldElkR2VuZXJhdG9yMihieXRlcykge1xuICByZXR1cm4gZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzIC8gNDsgaSsrKSB7XG4gICAgICBTSEFSRURfQlVGRkVSMi53cml0ZVVJbnQzMkJFKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCAzMikgPj4+IDAsIGkgKiA0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICBpZiAoU0hBUkVEX0JVRkZFUjJbaV0gPiAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBieXRlcyAtIDEpIHtcbiAgICAgICAgU0hBUkVEX0JVRkZFUjJbYnl0ZXMgLSAxXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTSEFSRURfQlVGRkVSMi50b1N0cmluZyhcImhleFwiLCAwLCBieXRlcyk7XG4gIH07XG59XG52YXIgU1BBTl9JRF9CWVRFUzIsIFRSQUNFX0lEX0JZVEVTMiwgUmFuZG9tSWRHZW5lcmF0b3IyLCBTSEFSRURfQlVGRkVSMjtcbnZhciBpbml0X1JhbmRvbUlkR2VuZXJhdG9yMiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvUmFuZG9tSWRHZW5lcmF0b3IuanNcIigpIHtcbiAgICBTUEFOX0lEX0JZVEVTMiA9IDg7XG4gICAgVFJBQ0VfSURfQllURVMyID0gMTY7XG4gICAgUmFuZG9tSWRHZW5lcmF0b3IyID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gUmFuZG9tSWRHZW5lcmF0b3IzKCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlVHJhY2VJZCA9IGdldElkR2VuZXJhdG9yMihUUkFDRV9JRF9CWVRFUzIpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlU3BhbklkID0gZ2V0SWRHZW5lcmF0b3IyKFNQQU5fSURfQllURVMyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSYW5kb21JZEdlbmVyYXRvcjM7XG4gICAgfSgpO1xuICAgIFNIQVJFRF9CVUZGRVIyID0gQnVmZmVyLmFsbG9jVW5zYWZlKFRSQUNFX0lEX0JZVEVTMik7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvaW5kZXguanNcbnZhciBpbml0X25vZGUzID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9pbmRleC5qc1wiKCkge1xuICAgIGluaXRfQmF0Y2hTcGFuUHJvY2Vzc29yKCk7XG4gICAgaW5pdF9SYW5kb21JZEdlbmVyYXRvcjIoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vcGxhdGZvcm0vaW5kZXguanNcbnZhciBpbml0X3BsYXRmb3JtMyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL2luZGV4LmpzXCIoKSB7XG4gICAgaW5pdF9ub2RlMygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9UcmFjZXIuanNcbnZhciBUcmFjZXI7XG52YXIgaW5pdF9UcmFjZXIgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9UcmFjZXIuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIGluaXRfZXNtMygpO1xuICAgIGluaXRfU3BhbigpO1xuICAgIGluaXRfdXRpbGl0eSgpO1xuICAgIGluaXRfcGxhdGZvcm0zKCk7XG4gICAgVHJhY2VyID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gVHJhY2VyMihpbnN0cnVtZW50YXRpb25MaWJyYXJ5LCBjb25maWcsIF90cmFjZXJQcm92aWRlcikge1xuICAgICAgICB0aGlzLl90cmFjZXJQcm92aWRlciA9IF90cmFjZXJQcm92aWRlcjtcbiAgICAgICAgdmFyIGxvY2FsQ29uZmlnID0gbWVyZ2VDb25maWcoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fc2FtcGxlciA9IGxvY2FsQ29uZmlnLnNhbXBsZXI7XG4gICAgICAgIHRoaXMuX2dlbmVyYWxMaW1pdHMgPSBsb2NhbENvbmZpZy5nZW5lcmFsTGltaXRzO1xuICAgICAgICB0aGlzLl9zcGFuTGltaXRzID0gbG9jYWxDb25maWcuc3BhbkxpbWl0cztcbiAgICAgICAgdGhpcy5faWRHZW5lcmF0b3IgPSBjb25maWcuaWRHZW5lcmF0b3IgfHwgbmV3IFJhbmRvbUlkR2VuZXJhdG9yMigpO1xuICAgICAgICB0aGlzLnJlc291cmNlID0gX3RyYWNlclByb3ZpZGVyLnJlc291cmNlO1xuICAgICAgICB0aGlzLmluc3RydW1lbnRhdGlvbkxpYnJhcnkgPSBpbnN0cnVtZW50YXRpb25MaWJyYXJ5O1xuICAgICAgfVxuICAgICAgVHJhY2VyMi5wcm90b3R5cGUuc3RhcnRTcGFuID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucywgY29udGV4dDIpIHtcbiAgICAgICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0MiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGV4dDIgPSBjb250ZXh0LmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgICBjb250ZXh0MiA9IHRyYWNlLmRlbGV0ZVNwYW4oY29udGV4dDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRTcGFuID0gdHJhY2UuZ2V0U3Bhbihjb250ZXh0Mik7XG4gICAgICAgIGlmIChpc1RyYWNpbmdTdXBwcmVzc2VkKGNvbnRleHQyKSkge1xuICAgICAgICAgIGRpYWcyLmRlYnVnKFwiSW5zdHJ1bWVudGF0aW9uIHN1cHByZXNzZWQsIHJldHVybmluZyBOb29wIFNwYW5cIik7XG4gICAgICAgICAgdmFyIG5vblJlY29yZGluZ1NwYW4gPSB0cmFjZS53cmFwU3BhbkNvbnRleHQoSU5WQUxJRF9TUEFOX0NPTlRFWFQpO1xuICAgICAgICAgIHJldHVybiBub25SZWNvcmRpbmdTcGFuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRTcGFuQ29udGV4dCA9IHBhcmVudFNwYW4gPT09IG51bGwgfHwgcGFyZW50U3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpO1xuICAgICAgICB2YXIgc3BhbklkID0gdGhpcy5faWRHZW5lcmF0b3IuZ2VuZXJhdGVTcGFuSWQoKTtcbiAgICAgICAgdmFyIHRyYWNlSWQ7XG4gICAgICAgIHZhciB0cmFjZVN0YXRlO1xuICAgICAgICB2YXIgcGFyZW50U3BhbklkO1xuICAgICAgICBpZiAoIXBhcmVudFNwYW5Db250ZXh0IHx8ICF0cmFjZS5pc1NwYW5Db250ZXh0VmFsaWQocGFyZW50U3BhbkNvbnRleHQpKSB7XG4gICAgICAgICAgdHJhY2VJZCA9IHRoaXMuX2lkR2VuZXJhdG9yLmdlbmVyYXRlVHJhY2VJZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYWNlSWQgPSBwYXJlbnRTcGFuQ29udGV4dC50cmFjZUlkO1xuICAgICAgICAgIHRyYWNlU3RhdGUgPSBwYXJlbnRTcGFuQ29udGV4dC50cmFjZVN0YXRlO1xuICAgICAgICAgIHBhcmVudFNwYW5JZCA9IHBhcmVudFNwYW5Db250ZXh0LnNwYW5JZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3BhbktpbmQgPSAoX2EyID0gb3B0aW9ucy5raW5kKSAhPT0gbnVsbCAmJiBfYTIgIT09IHZvaWQgMCA/IF9hMiA6IFNwYW5LaW5kLklOVEVSTkFMO1xuICAgICAgICB2YXIgbGlua3MgPSAoKF9iID0gb3B0aW9ucy5saW5rcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pLm1hcChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGxpbmsuY29udGV4dCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNhbml0aXplQXR0cmlidXRlcyhsaW5rLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gc2FuaXRpemVBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgICAgIHZhciBzYW1wbGluZ1Jlc3VsdCA9IHRoaXMuX3NhbXBsZXIuc2hvdWxkU2FtcGxlKGNvbnRleHQyLCB0cmFjZUlkLCBuYW1lLCBzcGFuS2luZCwgYXR0cmlidXRlcywgbGlua3MpO1xuICAgICAgICB0cmFjZVN0YXRlID0gKF9jID0gc2FtcGxpbmdSZXN1bHQudHJhY2VTdGF0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJhY2VTdGF0ZTtcbiAgICAgICAgdmFyIHRyYWNlRmxhZ3MgPSBzYW1wbGluZ1Jlc3VsdC5kZWNpc2lvbiA9PT0gU2FtcGxpbmdEZWNpc2lvbi5SRUNPUkRfQU5EX1NBTVBMRUQgPyBUcmFjZUZsYWdzLlNBTVBMRUQgOiBUcmFjZUZsYWdzLk5PTkU7XG4gICAgICAgIHZhciBzcGFuQ29udGV4dCA9IHsgdHJhY2VJZCwgc3BhbklkLCB0cmFjZUZsYWdzLCB0cmFjZVN0YXRlIH07XG4gICAgICAgIGlmIChzYW1wbGluZ1Jlc3VsdC5kZWNpc2lvbiA9PT0gU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JEKSB7XG4gICAgICAgICAgZGlhZzIuZGVidWcoXCJSZWNvcmRpbmcgaXMgb2ZmLCBwcm9wYWdhdGluZyBjb250ZXh0IGluIGEgbm9uLXJlY29yZGluZyBzcGFuXCIpO1xuICAgICAgICAgIHZhciBub25SZWNvcmRpbmdTcGFuID0gdHJhY2Uud3JhcFNwYW5Db250ZXh0KHNwYW5Db250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gbm9uUmVjb3JkaW5nU3BhbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdEF0dHJpYnV0ZXMgPSBzYW5pdGl6ZUF0dHJpYnV0ZXMoT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBzYW1wbGluZ1Jlc3VsdC5hdHRyaWJ1dGVzKSk7XG4gICAgICAgIHZhciBzcGFuID0gbmV3IFNwYW4odGhpcywgY29udGV4dDIsIG5hbWUsIHNwYW5Db250ZXh0LCBzcGFuS2luZCwgcGFyZW50U3BhbklkLCBsaW5rcywgb3B0aW9ucy5zdGFydFRpbWUsIHZvaWQgMCwgaW5pdEF0dHJpYnV0ZXMpO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgIH07XG4gICAgICBUcmFjZXIyLnByb3RvdHlwZS5zdGFydEFjdGl2ZVNwYW4gPSBmdW5jdGlvbihuYW1lLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICAgIHZhciBvcHRzO1xuICAgICAgICB2YXIgY3R4O1xuICAgICAgICB2YXIgZm47XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgZm4gPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICBvcHRzID0gYXJnMjtcbiAgICAgICAgICBmbiA9IGFyZzM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0cyA9IGFyZzI7XG4gICAgICAgICAgY3R4ID0gYXJnMztcbiAgICAgICAgICBmbiA9IGFyZzQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudENvbnRleHQgPSBjdHggIT09IG51bGwgJiYgY3R4ICE9PSB2b2lkIDAgPyBjdHggOiBjb250ZXh0LmFjdGl2ZSgpO1xuICAgICAgICB2YXIgc3BhbiA9IHRoaXMuc3RhcnRTcGFuKG5hbWUsIG9wdHMsIHBhcmVudENvbnRleHQpO1xuICAgICAgICB2YXIgY29udGV4dFdpdGhTcGFuU2V0ID0gdHJhY2Uuc2V0U3BhbihwYXJlbnRDb250ZXh0LCBzcGFuKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQud2l0aChjb250ZXh0V2l0aFNwYW5TZXQsIGZuLCB2b2lkIDAsIHNwYW4pO1xuICAgICAgfTtcbiAgICAgIFRyYWNlcjIucHJvdG90eXBlLmdldEdlbmVyYWxMaW1pdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYWxMaW1pdHM7XG4gICAgICB9O1xuICAgICAgVHJhY2VyMi5wcm90b3R5cGUuZ2V0U3BhbkxpbWl0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BhbkxpbWl0cztcbiAgICAgIH07XG4gICAgICBUcmFjZXIyLnByb3RvdHlwZS5nZXRBY3RpdmVTcGFuUHJvY2Vzc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjZXJQcm92aWRlci5nZXRBY3RpdmVTcGFuUHJvY2Vzc29yKCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRyYWNlcjI7XG4gICAgfSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9kZWZhdWx0LXNlcnZpY2UtbmFtZS5qc1xuZnVuY3Rpb24gZGVmYXVsdFNlcnZpY2VOYW1lKCkge1xuICByZXR1cm4gXCJ1bmtub3duX3NlcnZpY2U6XCIgKyBwcm9jZXNzLmFyZ3YwO1xufVxudmFyIGluaXRfZGVmYXVsdF9zZXJ2aWNlX25hbWUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9kZWZhdWx0LXNlcnZpY2UtbmFtZS5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS91dGlscy5qc1xudmFyIG5vcm1hbGl6ZUFyY2gsIG5vcm1hbGl6ZVR5cGU7XG52YXIgaW5pdF91dGlsczUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS91dGlscy5qc1wiKCkge1xuICAgIG5vcm1hbGl6ZUFyY2ggPSBmdW5jdGlvbihub2RlQXJjaFN0cmluZykge1xuICAgICAgc3dpdGNoIChub2RlQXJjaFN0cmluZykge1xuICAgICAgICBjYXNlIFwiYXJtXCI6XG4gICAgICAgICAgcmV0dXJuIFwiYXJtMzJcIjtcbiAgICAgICAgY2FzZSBcInBwY1wiOlxuICAgICAgICAgIHJldHVybiBcInBwYzMyXCI7XG4gICAgICAgIGNhc2UgXCJ4NjRcIjpcbiAgICAgICAgICByZXR1cm4gXCJhbWQ2NFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBub2RlQXJjaFN0cmluZztcbiAgICAgIH1cbiAgICB9O1xuICAgIG5vcm1hbGl6ZVR5cGUgPSBmdW5jdGlvbihub2RlUGxhdGZvcm0pIHtcbiAgICAgIHN3aXRjaCAobm9kZVBsYXRmb3JtKSB7XG4gICAgICAgIGNhc2UgXCJzdW5vc1wiOlxuICAgICAgICAgIHJldHVybiBcInNvbGFyaXNcIjtcbiAgICAgICAgY2FzZSBcIndpbjMyXCI6XG4gICAgICAgICAgcmV0dXJuIFwid2luZG93c1wiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBub2RlUGxhdGZvcm07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvbWFjaGluZS1pZC9leGVjQXN5bmMuanNcbnZhciBjaGlsZF9wcm9jZXNzLCB1dGlsLCBleGVjQXN5bmM7XG52YXIgaW5pdF9leGVjQXN5bmMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9tYWNoaW5lLWlkL2V4ZWNBc3luYy5qc1wiKCkge1xuICAgIGNoaWxkX3Byb2Nlc3MgPSBfX3RvRVNNKHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpKTtcbiAgICB1dGlsID0gX190b0VTTShyZXF1aXJlKFwidXRpbFwiKSk7XG4gICAgZXhlY0FzeW5jID0gdXRpbC5wcm9taXNpZnkoY2hpbGRfcHJvY2Vzcy5leGVjKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvbWFjaGluZS1pZC9nZXRNYWNoaW5lSWQtZGFyd2luLmpzXG52YXIgZ2V0TWFjaGluZUlkX2Rhcndpbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChnZXRNYWNoaW5lSWRfZGFyd2luX2V4cG9ydHMsIHtcbiAgZ2V0TWFjaGluZUlkOiAoKSA9PiBnZXRNYWNoaW5lSWRcbn0pO1xuZnVuY3Rpb24gZ2V0TWFjaGluZUlkKCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0LCBpZExpbmUsIHBhcnRzLCBlXzE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9hMikge1xuICAgICAgc3dpdGNoIChfYTIubGFiZWwpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIF9hMi50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgIHJldHVybiBbNCwgZXhlY0FzeW5jKCdpb3JlZyAtcmQxIC1jIFwiSU9QbGF0Zm9ybUV4cGVydERldmljZVwiJyldO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmVzdWx0ID0gX2EyLnNlbnQoKTtcbiAgICAgICAgICBpZExpbmUgPSByZXN1bHQuc3Rkb3V0LnNwbGl0KFwiXFxuXCIpLmZpbmQoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaW5jbHVkZXMoXCJJT1BsYXRmb3JtVVVJRFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWlkTGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIFsyLCBcIlwiXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMgPSBpZExpbmUuc3BsaXQoJ1wiID0gXCInKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIsIHBhcnRzWzFdLnNsaWNlKDAsIC0xKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBlXzEgPSBfYTIuc2VudCgpO1xuICAgICAgICAgIGRpYWcyLmRlYnVnKFwiZXJyb3IgcmVhZGluZyBtYWNoaW5lIGlkOiBcIiArIGVfMSk7XG4gICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBbMiwgXCJcIl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxudmFyIF9fYXdhaXRlciwgX19nZW5lcmF0b3I7XG52YXIgaW5pdF9nZXRNYWNoaW5lSWRfZGFyd2luID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvbWFjaGluZS1pZC9nZXRNYWNoaW5lSWQtZGFyd2luLmpzXCIoKSB7XG4gICAgaW5pdF9leGVjQXN5bmMoKTtcbiAgICBpbml0X2VzbSgpO1xuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodFswXSAmIDEpXG4gICAgICAgICAgdGhyb3cgdFsxXTtcbiAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pLCBnO1xuICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSlcbiAgICAgICAgICB0aHJvdyBvcFsxXTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9tYWNoaW5lLWlkL2dldE1hY2hpbmVJZC1saW51eC5qc1xudmFyIGdldE1hY2hpbmVJZF9saW51eF9leHBvcnRzID0ge307XG5fX2V4cG9ydChnZXRNYWNoaW5lSWRfbGludXhfZXhwb3J0cywge1xuICBnZXRNYWNoaW5lSWQ6ICgpID0+IGdldE1hY2hpbmVJZDJcbn0pO1xuZnVuY3Rpb24gZ2V0TWFjaGluZUlkMigpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcjIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXRocywgcGF0aHNfMSwgcGF0aHNfMV8xLCBwYXRoMywgcmVzdWx0LCBlXzEsIGVfMl8xO1xuICAgIHZhciBlXzIsIF9hMjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IyKHRoaXMsIGZ1bmN0aW9uKF9iKSB7XG4gICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBwYXRocyA9IFtcIi9ldGMvbWFjaGluZS1pZFwiLCBcIi92YXIvbGliL2RidXMvbWFjaGluZS1pZFwiXTtcbiAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDgsIDksIDEwXSk7XG4gICAgICAgICAgcGF0aHNfMSA9IF9fdmFsdWVzNihwYXRocyksIHBhdGhzXzFfMSA9IHBhdGhzXzEubmV4dCgpO1xuICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmICghIXBhdGhzXzFfMS5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIFszLCA3XTtcbiAgICAgICAgICBwYXRoMyA9IHBhdGhzXzFfMS52YWx1ZTtcbiAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBfYi50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuICAgICAgICAgIHJldHVybiBbNCwgaW1wb3J0X2ZzLnByb21pc2VzLnJlYWRGaWxlKHBhdGgzLCB7IGVuY29kaW5nOiBcInV0ZjhcIiB9KV07XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXN1bHQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgcmV0dXJuIFsyLCByZXN1bHQudHJpbSgpXTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGVfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICBkaWFnMi5kZWJ1ZyhcImVycm9yIHJlYWRpbmcgbWFjaGluZSBpZDogXCIgKyBlXzEpO1xuICAgICAgICAgIHJldHVybiBbMywgNl07XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBwYXRoc18xXzEgPSBwYXRoc18xLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gWzMsIDJdO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIFszLCAxMF07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBlXzJfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgIHJldHVybiBbMywgMTBdO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChwYXRoc18xXzEgJiYgIXBhdGhzXzFfMS5kb25lICYmIChfYTIgPSBwYXRoc18xLnJldHVybikpXG4gICAgICAgICAgICAgIF9hMi5jYWxsKHBhdGhzXzEpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8yKVxuICAgICAgICAgICAgICB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICA3XG4gICAgICAgICAgICAvKmVuZGZpbmFsbHkqL1xuICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIFsyLCBcIlwiXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG52YXIgaW1wb3J0X2ZzLCBfX2F3YWl0ZXIyLCBfX2dlbmVyYXRvcjIsIF9fdmFsdWVzNjtcbnZhciBpbml0X2dldE1hY2hpbmVJZF9saW51eCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL21hY2hpbmUtaWQvZ2V0TWFjaGluZUlkLWxpbnV4LmpzXCIoKSB7XG4gICAgaW1wb3J0X2ZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIGluaXRfZXNtKCk7XG4gICAgX19hd2FpdGVyMiA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX19nZW5lcmF0b3IyID0gZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRbMF0gJiAxKVxuICAgICAgICAgIHRocm93IHRbMV07XG4gICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KSwgZztcbiAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXylcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpXG4gICAgICAgICAgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBfX3ZhbHVlczYgPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgICAgaWYgKG0pXG4gICAgICAgIHJldHVybiBtLmNhbGwobyk7XG4gICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9tYWNoaW5lLWlkL2dldE1hY2hpbmVJZC1ic2QuanNcbnZhciBnZXRNYWNoaW5lSWRfYnNkX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGdldE1hY2hpbmVJZF9ic2RfZXhwb3J0cywge1xuICBnZXRNYWNoaW5lSWQ6ICgpID0+IGdldE1hY2hpbmVJZDNcbn0pO1xuZnVuY3Rpb24gZ2V0TWFjaGluZUlkMygpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcjModGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQsIGVfMSwgcmVzdWx0LCBlXzI7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yMyh0aGlzLCBmdW5jdGlvbihfYTIpIHtcbiAgICAgIHN3aXRjaCAoX2EyLmxhYmVsKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBfYTIudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICByZXR1cm4gWzQsIGltcG9ydF9mczIucHJvbWlzZXMucmVhZEZpbGUoXCIvZXRjL2hvc3RpZFwiLCB7IGVuY29kaW5nOiBcInV0ZjhcIiB9KV07XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXN1bHQgPSBfYTIuc2VudCgpO1xuICAgICAgICAgIHJldHVybiBbMiwgcmVzdWx0LnRyaW0oKV07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBlXzEgPSBfYTIuc2VudCgpO1xuICAgICAgICAgIGRpYWcyLmRlYnVnKFwiZXJyb3IgcmVhZGluZyBtYWNoaW5lIGlkOiBcIiArIGVfMSk7XG4gICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIF9hMi50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuICAgICAgICAgIHJldHVybiBbNCwgZXhlY0FzeW5jKFwia2VudiAtcSBzbWJpb3Muc3lzdGVtLnV1aWRcIildO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmVzdWx0ID0gX2EyLnNlbnQoKTtcbiAgICAgICAgICByZXR1cm4gWzIsIHJlc3VsdC5zdGRvdXQudHJpbSgpXTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGVfMiA9IF9hMi5zZW50KCk7XG4gICAgICAgICAgZGlhZzIuZGVidWcoXCJlcnJvciByZWFkaW5nIG1hY2hpbmUgaWQ6IFwiICsgZV8yKTtcbiAgICAgICAgICByZXR1cm4gWzMsIDZdO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIFsyLCBcIlwiXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG52YXIgaW1wb3J0X2ZzMiwgX19hd2FpdGVyMywgX19nZW5lcmF0b3IzO1xudmFyIGluaXRfZ2V0TWFjaGluZUlkX2JzZCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL21hY2hpbmUtaWQvZ2V0TWFjaGluZUlkLWJzZC5qc1wiKCkge1xuICAgIGltcG9ydF9mczIgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgaW5pdF9leGVjQXN5bmMoKTtcbiAgICBpbml0X2VzbSgpO1xuICAgIF9fYXdhaXRlcjMgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9fZ2VuZXJhdG9yMyA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0WzBdICYgMSlcbiAgICAgICAgICB0aHJvdyB0WzFdO1xuICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSksIGc7XG4gICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdClcbiAgICAgICAgICAgICAgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgICAgICBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcCA9IFs2LCBlXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KVxuICAgICAgICAgIHRocm93IG9wWzFdO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL21hY2hpbmUtaWQvZ2V0TWFjaGluZUlkLXdpbi5qc1xudmFyIGdldE1hY2hpbmVJZF93aW5fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZ2V0TWFjaGluZUlkX3dpbl9leHBvcnRzLCB7XG4gIGdldE1hY2hpbmVJZDogKCkgPT4gZ2V0TWFjaGluZUlkNFxufSk7XG5mdW5jdGlvbiBnZXRNYWNoaW5lSWQ0KCkge1xuICByZXR1cm4gX19hd2FpdGVyNCh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MsIGNvbW1hbmQsIHJlc3VsdCwgcGFydHMsIGVfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3I0KHRoaXMsIGZ1bmN0aW9uKF9hMikge1xuICAgICAgc3dpdGNoIChfYTIubGFiZWwpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGFyZ3MgPSBcIlFVRVJZIEhLRVlfTE9DQUxfTUFDSElORVxcXFxTT0ZUV0FSRVxcXFxNaWNyb3NvZnRcXFxcQ3J5cHRvZ3JhcGh5IC92IE1hY2hpbmVHdWlkXCI7XG4gICAgICAgICAgY29tbWFuZCA9IFwiJXdpbmRpciVcXFxcU3lzdGVtMzJcXFxcUkVHLmV4ZVwiO1xuICAgICAgICAgIGlmIChwcm9jZXNzMi5hcmNoID09PSBcImlhMzJcIiAmJiBcIlBST0NFU1NPUl9BUkNISVRFVzY0MzJcIiBpbiBwcm9jZXNzMi5lbnYpIHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSBcIiV3aW5kaXIlXFxcXHN5c25hdGl2ZVxcXFxjbWQuZXhlIC9jIFwiICsgY29tbWFuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2EyLmxhYmVsID0gMTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIF9hMi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgIHJldHVybiBbNCwgZXhlY0FzeW5jKGNvbW1hbmQgKyBcIiBcIiArIGFyZ3MpXTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJlc3VsdCA9IF9hMi5zZW50KCk7XG4gICAgICAgICAgcGFydHMgPSByZXN1bHQuc3Rkb3V0LnNwbGl0KFwiUkVHX1NaXCIpO1xuICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiwgcGFydHNbMV0udHJpbSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGVfMSA9IF9hMi5zZW50KCk7XG4gICAgICAgICAgZGlhZzIuZGVidWcoXCJlcnJvciByZWFkaW5nIG1hY2hpbmUgaWQ6IFwiICsgZV8xKTtcbiAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIFsyLCBcIlwiXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG52YXIgcHJvY2VzczIsIF9fYXdhaXRlcjQsIF9fZ2VuZXJhdG9yNDtcbnZhciBpbml0X2dldE1hY2hpbmVJZF93aW4gPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9tYWNoaW5lLWlkL2dldE1hY2hpbmVJZC13aW4uanNcIigpIHtcbiAgICBwcm9jZXNzMiA9IF9fdG9FU00ocmVxdWlyZShcInByb2Nlc3NcIikpO1xuICAgIGluaXRfZXhlY0FzeW5jKCk7XG4gICAgaW5pdF9lc20oKTtcbiAgICBfX2F3YWl0ZXI0ID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfX2dlbmVyYXRvcjQgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodFswXSAmIDEpXG4gICAgICAgICAgdGhyb3cgdFsxXTtcbiAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pLCBnO1xuICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSlcbiAgICAgICAgICB0aHJvdyBvcFsxXTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9tYWNoaW5lLWlkL2dldE1hY2hpbmVJZC11bnN1cHBvcnRlZC5qc1xudmFyIGdldE1hY2hpbmVJZF91bnN1cHBvcnRlZF9leHBvcnRzID0ge307XG5fX2V4cG9ydChnZXRNYWNoaW5lSWRfdW5zdXBwb3J0ZWRfZXhwb3J0cywge1xuICBnZXRNYWNoaW5lSWQ6ICgpID0+IGdldE1hY2hpbmVJZDVcbn0pO1xuZnVuY3Rpb24gZ2V0TWFjaGluZUlkNSgpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcjUodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfX2dlbmVyYXRvcjUodGhpcywgZnVuY3Rpb24oX2EyKSB7XG4gICAgICBkaWFnMi5kZWJ1ZyhcImNvdWxkIG5vdCByZWFkIG1hY2hpbmUtaWQ6IHVuc3VwcG9ydGVkIHBsYXRmb3JtXCIpO1xuICAgICAgcmV0dXJuIFsyLCBcIlwiXTtcbiAgICB9KTtcbiAgfSk7XG59XG52YXIgX19hd2FpdGVyNSwgX19nZW5lcmF0b3I1O1xudmFyIGluaXRfZ2V0TWFjaGluZUlkX3Vuc3VwcG9ydGVkID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvbWFjaGluZS1pZC9nZXRNYWNoaW5lSWQtdW5zdXBwb3J0ZWQuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIF9fYXdhaXRlcjUgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9fZ2VuZXJhdG9yNSA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0WzBdICYgMSlcbiAgICAgICAgICB0aHJvdyB0WzFdO1xuICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSksIGc7XG4gICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKVxuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdClcbiAgICAgICAgICAgICAgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRbMl0pXG4gICAgICAgICAgICAgICAgICBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcCA9IFs2LCBlXTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KVxuICAgICAgICAgIHRocm93IG9wWzFdO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL21hY2hpbmUtaWQvZ2V0TWFjaGluZUlkLmpzXG52YXIgcHJvY2VzczMsIGdldE1hY2hpbmVJZDY7XG52YXIgaW5pdF9nZXRNYWNoaW5lSWQgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9tYWNoaW5lLWlkL2dldE1hY2hpbmVJZC5qc1wiKCkge1xuICAgIHByb2Nlc3MzID0gX190b0VTTShyZXF1aXJlKFwicHJvY2Vzc1wiKSk7XG4gICAgc3dpdGNoIChwcm9jZXNzMy5wbGF0Zm9ybSkge1xuICAgICAgY2FzZSBcImRhcndpblwiOlxuICAgICAgICBnZXRNYWNoaW5lSWQ2ID0gKGluaXRfZ2V0TWFjaGluZUlkX2RhcndpbigpLCBfX3RvQ29tbW9uSlMoZ2V0TWFjaGluZUlkX2Rhcndpbl9leHBvcnRzKSkuZ2V0TWFjaGluZUlkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsaW51eFwiOlxuICAgICAgICBnZXRNYWNoaW5lSWQ2ID0gKGluaXRfZ2V0TWFjaGluZUlkX2xpbnV4KCksIF9fdG9Db21tb25KUyhnZXRNYWNoaW5lSWRfbGludXhfZXhwb3J0cykpLmdldE1hY2hpbmVJZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZnJlZWJzZFwiOlxuICAgICAgICBnZXRNYWNoaW5lSWQ2ID0gKGluaXRfZ2V0TWFjaGluZUlkX2JzZCgpLCBfX3RvQ29tbW9uSlMoZ2V0TWFjaGluZUlkX2JzZF9leHBvcnRzKSkuZ2V0TWFjaGluZUlkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3aW4zMlwiOlxuICAgICAgICBnZXRNYWNoaW5lSWQ2ID0gKGluaXRfZ2V0TWFjaGluZUlkX3dpbigpLCBfX3RvQ29tbW9uSlMoZ2V0TWFjaGluZUlkX3dpbl9leHBvcnRzKSkuZ2V0TWFjaGluZUlkO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGdldE1hY2hpbmVJZDYgPSAoaW5pdF9nZXRNYWNoaW5lSWRfdW5zdXBwb3J0ZWQoKSwgX190b0NvbW1vbkpTKGdldE1hY2hpbmVJZF91bnN1cHBvcnRlZF9leHBvcnRzKSkuZ2V0TWFjaGluZUlkO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvSG9zdERldGVjdG9yU3luYy5qc1xudmFyIGltcG9ydF9vcywgSG9zdERldGVjdG9yU3luYywgaG9zdERldGVjdG9yU3luYztcbnZhciBpbml0X0hvc3REZXRlY3RvclN5bmMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9Ib3N0RGV0ZWN0b3JTeW5jLmpzXCIoKSB7XG4gICAgaW5pdF9lc20yKCk7XG4gICAgaW5pdF9SZXNvdXJjZSgpO1xuICAgIGltcG9ydF9vcyA9IHJlcXVpcmUoXCJvc1wiKTtcbiAgICBpbml0X3V0aWxzNSgpO1xuICAgIGluaXRfZ2V0TWFjaGluZUlkKCk7XG4gICAgSG9zdERldGVjdG9yU3luYyA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEhvc3REZXRlY3RvclN5bmMyKCkge1xuICAgICAgfVxuICAgICAgSG9zdERldGVjdG9yU3luYzIucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uKF9jb25maWcpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSAoX2EyID0ge30sIF9hMltTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5IT1NUX05BTUVdID0gKDAsIGltcG9ydF9vcy5ob3N0bmFtZSkoKSwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLkhPU1RfQVJDSF0gPSBub3JtYWxpemVBcmNoKCgwLCBpbXBvcnRfb3MuYXJjaCkoKSksIF9hMik7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2UoYXR0cmlidXRlcywgdGhpcy5fZ2V0QXN5bmNBdHRyaWJ1dGVzKCkpO1xuICAgICAgfTtcbiAgICAgIEhvc3REZXRlY3RvclN5bmMyLnByb3RvdHlwZS5fZ2V0QXN5bmNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRNYWNoaW5lSWQ2KCkudGhlbihmdW5jdGlvbihtYWNoaW5lSWQpIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIGlmIChtYWNoaW5lSWQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuSE9TVF9JRF0gPSBtYWNoaW5lSWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSG9zdERldGVjdG9yU3luYzI7XG4gICAgfSgpO1xuICAgIGhvc3REZXRlY3RvclN5bmMgPSBuZXcgSG9zdERldGVjdG9yU3luYygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9Ib3N0RGV0ZWN0b3IuanNcbnZhciBIb3N0RGV0ZWN0b3IsIGhvc3REZXRlY3RvcjtcbnZhciBpbml0X0hvc3REZXRlY3RvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL0hvc3REZXRlY3Rvci5qc1wiKCkge1xuICAgIGluaXRfSG9zdERldGVjdG9yU3luYygpO1xuICAgIEhvc3REZXRlY3RvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEhvc3REZXRlY3RvcjIoKSB7XG4gICAgICB9XG4gICAgICBIb3N0RGV0ZWN0b3IyLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbihfY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaG9zdERldGVjdG9yU3luYy5kZXRlY3QoX2NvbmZpZykpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBIb3N0RGV0ZWN0b3IyO1xuICAgIH0oKTtcbiAgICBob3N0RGV0ZWN0b3IgPSBuZXcgSG9zdERldGVjdG9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL09TRGV0ZWN0b3JTeW5jLmpzXG52YXIgaW1wb3J0X29zMiwgT1NEZXRlY3RvclN5bmMsIG9zRGV0ZWN0b3JTeW5jO1xudmFyIGluaXRfT1NEZXRlY3RvclN5bmMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9PU0RldGVjdG9yU3luYy5qc1wiKCkge1xuICAgIGluaXRfZXNtMigpO1xuICAgIGluaXRfUmVzb3VyY2UoKTtcbiAgICBpbXBvcnRfb3MyID0gcmVxdWlyZShcIm9zXCIpO1xuICAgIGluaXRfdXRpbHM1KCk7XG4gICAgT1NEZXRlY3RvclN5bmMgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBPU0RldGVjdG9yU3luYzIoKSB7XG4gICAgICB9XG4gICAgICBPU0RldGVjdG9yU3luYzIucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uKF9jb25maWcpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSAoX2EyID0ge30sIF9hMltTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5PU19UWVBFXSA9IG5vcm1hbGl6ZVR5cGUoKDAsIGltcG9ydF9vczIucGxhdGZvcm0pKCkpLCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuT1NfVkVSU0lPTl0gPSAoMCwgaW1wb3J0X29zMi5yZWxlYXNlKSgpLCBfYTIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlKGF0dHJpYnV0ZXMpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBPU0RldGVjdG9yU3luYzI7XG4gICAgfSgpO1xuICAgIG9zRGV0ZWN0b3JTeW5jID0gbmV3IE9TRGV0ZWN0b3JTeW5jKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL09TRGV0ZWN0b3IuanNcbnZhciBPU0RldGVjdG9yLCBvc0RldGVjdG9yO1xudmFyIGluaXRfT1NEZXRlY3RvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL09TRGV0ZWN0b3IuanNcIigpIHtcbiAgICBpbml0X09TRGV0ZWN0b3JTeW5jKCk7XG4gICAgT1NEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIE9TRGV0ZWN0b3IyKCkge1xuICAgICAgfVxuICAgICAgT1NEZXRlY3RvcjIucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uKF9jb25maWcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvc0RldGVjdG9yU3luYy5kZXRlY3QoX2NvbmZpZykpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBPU0RldGVjdG9yMjtcbiAgICB9KCk7XG4gICAgb3NEZXRlY3RvciA9IG5ldyBPU0RldGVjdG9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL1Byb2Nlc3NEZXRlY3RvclN5bmMuanNcbnZhciBvcywgX19yZWFkMTEsIF9fc3ByZWFkQXJyYXk2LCBQcm9jZXNzRGV0ZWN0b3JTeW5jLCBwcm9jZXNzRGV0ZWN0b3JTeW5jO1xudmFyIGluaXRfUHJvY2Vzc0RldGVjdG9yU3luYyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL1Byb2Nlc3NEZXRlY3RvclN5bmMuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIGluaXRfZXNtMigpO1xuICAgIGluaXRfUmVzb3VyY2UoKTtcbiAgICBvcyA9IF9fdG9FU00ocmVxdWlyZShcIm9zXCIpKTtcbiAgICBfX3JlYWQxMSA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghbSlcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0geyBlcnJvciB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgICAgICBtLmNhbGwoaSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXI7XG4gICAgfTtcbiAgICBfX3NwcmVhZEFycmF5NiA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpXG4gICAgICAgICAgICAgIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbiAgICB9O1xuICAgIFByb2Nlc3NEZXRlY3RvclN5bmMgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBQcm9jZXNzRGV0ZWN0b3JTeW5jMigpIHtcbiAgICAgIH1cbiAgICAgIFByb2Nlc3NEZXRlY3RvclN5bmMyLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbihfY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gKF9hMiA9IHt9LCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19QSURdID0gcHJvY2Vzcy5waWQsIF9hMltTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX0VYRUNVVEFCTEVfTkFNRV0gPSBwcm9jZXNzLnRpdGxlLCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19FWEVDVVRBQkxFX1BBVEhdID0gcHJvY2Vzcy5leGVjUGF0aCwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfQ09NTUFORF9BUkdTXSA9IF9fc3ByZWFkQXJyYXk2KF9fc3ByZWFkQXJyYXk2KFtcbiAgICAgICAgICBwcm9jZXNzLmFyZ3ZbMF1cbiAgICAgICAgXSwgX19yZWFkMTEocHJvY2Vzcy5leGVjQXJndiksIGZhbHNlKSwgX19yZWFkMTEocHJvY2Vzcy5hcmd2LnNsaWNlKDEpKSwgZmFsc2UpLCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX1ZFUlNJT05dID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX05BTUVdID0gXCJub2RlanNcIiwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9ERVNDUklQVElPTl0gPSBcIk5vZGUuanNcIiwgX2EyKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX0NPTU1BTkRdID0gcHJvY2Vzcy5hcmd2WzFdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHVzZXJJbmZvMiA9IG9zLnVzZXJJbmZvKCk7XG4gICAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5QUk9DRVNTX09XTkVSXSA9IHVzZXJJbmZvMi51c2VybmFtZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRpYWcyLmRlYnVnKFwiZXJyb3Igb2J0YWluaW5nIHByb2Nlc3Mgb3duZXI6IFwiICsgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZShhdHRyaWJ1dGVzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvY2Vzc0RldGVjdG9yU3luYzI7XG4gICAgfSgpO1xuICAgIHByb2Nlc3NEZXRlY3RvclN5bmMgPSBuZXcgUHJvY2Vzc0RldGVjdG9yU3luYygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9Qcm9jZXNzRGV0ZWN0b3IuanNcbnZhciBQcm9jZXNzRGV0ZWN0b3IsIHByb2Nlc3NEZXRlY3RvcjtcbnZhciBpbml0X1Byb2Nlc3NEZXRlY3RvciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL1Byb2Nlc3NEZXRlY3Rvci5qc1wiKCkge1xuICAgIGluaXRfUHJvY2Vzc0RldGVjdG9yU3luYygpO1xuICAgIFByb2Nlc3NEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIFByb2Nlc3NEZXRlY3RvcjIoKSB7XG4gICAgICB9XG4gICAgICBQcm9jZXNzRGV0ZWN0b3IyLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzRGV0ZWN0b3JTeW5jLmRldGVjdChjb25maWcpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvY2Vzc0RldGVjdG9yMjtcbiAgICB9KCk7XG4gICAgcHJvY2Vzc0RldGVjdG9yID0gbmV3IFByb2Nlc3NEZXRlY3RvcigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9pbmRleC5qc1xudmFyIGluaXRfbm9kZTQgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9pbmRleC5qc1wiKCkge1xuICAgIGluaXRfZGVmYXVsdF9zZXJ2aWNlX25hbWUoKTtcbiAgICBpbml0X0hvc3REZXRlY3RvcigpO1xuICAgIGluaXRfT1NEZXRlY3RvcigpO1xuICAgIGluaXRfSG9zdERldGVjdG9yU3luYygpO1xuICAgIGluaXRfT1NEZXRlY3RvclN5bmMoKTtcbiAgICBpbml0X1Byb2Nlc3NEZXRlY3RvcigpO1xuICAgIGluaXRfUHJvY2Vzc0RldGVjdG9yU3luYygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vaW5kZXguanNcbnZhciBpbml0X3BsYXRmb3JtNCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9pbmRleC5qc1wiKCkge1xuICAgIGluaXRfbm9kZTQoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL1Jlc291cmNlLmpzXG52YXIgX19hc3NpZ24sIF9fYXdhaXRlcjYsIF9fZ2VuZXJhdG9yNiwgX19yZWFkMTIsIFJlc291cmNlO1xudmFyIGluaXRfUmVzb3VyY2UgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vUmVzb3VyY2UuanNcIigpIHtcbiAgICBpbml0X2VzbSgpO1xuICAgIGluaXRfZXNtMigpO1xuICAgIGluaXRfZXNtMygpO1xuICAgIGluaXRfcGxhdGZvcm00KCk7XG4gICAgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBfX2F3YWl0ZXI2ID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfX2dlbmVyYXRvcjYgPSBmdW5jdGlvbih0aGlzQXJnLCBib2R5KSB7XG4gICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodFswXSAmIDEpXG4gICAgICAgICAgdGhyb3cgdFsxXTtcbiAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pLCBnO1xuICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSlcbiAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpXG4gICAgICAgICAgICAgIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICAgICAgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSlcbiAgICAgICAgICB0aHJvdyBvcFsxXTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fcmVhZDEyID0gZnVuY3Rpb24obywgbikge1xuICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgICAgIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9O1xuICAgIFJlc291cmNlID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gUmVzb3VyY2UzKGF0dHJpYnV0ZXMsIGFzeW5jQXR0cmlidXRlc1Byb21pc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuYXN5bmNBdHRyaWJ1dGVzUGVuZGluZyA9IGFzeW5jQXR0cmlidXRlc1Byb21pc2UgIT0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3luY0F0dHJpYnV0ZXMgPSAoX2EyID0gdGhpcy5fYXR0cmlidXRlcykgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiB7fTtcbiAgICAgICAgdGhpcy5fYXN5bmNBdHRyaWJ1dGVzUHJvbWlzZSA9IGFzeW5jQXR0cmlidXRlc1Byb21pc2UgPT09IG51bGwgfHwgYXN5bmNBdHRyaWJ1dGVzUHJvbWlzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXN5bmNBdHRyaWJ1dGVzUHJvbWlzZS50aGVuKGZ1bmN0aW9uKGFzeW5jQXR0cmlidXRlcykge1xuICAgICAgICAgIF90aGlzLl9hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMuX2F0dHJpYnV0ZXMsIGFzeW5jQXR0cmlidXRlcyk7XG4gICAgICAgICAgX3RoaXMuYXN5bmNBdHRyaWJ1dGVzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBhc3luY0F0dHJpYnV0ZXM7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGRpYWcyLmRlYnVnKFwiYSByZXNvdXJjZSdzIGFzeW5jIGF0dHJpYnV0ZXMgcHJvbWlzZSByZWplY3RlZDogJXNcIiwgZXJyKTtcbiAgICAgICAgICBfdGhpcy5hc3luY0F0dHJpYnV0ZXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFJlc291cmNlMy5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2UzLkVNUFRZO1xuICAgICAgfTtcbiAgICAgIFJlc291cmNlMy5kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2UzKChfYTIgPSB7fSwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlNFUlZJQ0VfTkFNRV0gPSBkZWZhdWx0U2VydmljZU5hbWUoKSwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlRFTEVNRVRSWV9TREtfTEFOR1VBR0VdID0gU0RLX0lORk9bU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19MQU5HVUFHRV0sIF9hMltTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX05BTUVdID0gU0RLX0lORk9bU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuVEVMRU1FVFJZX1NES19OQU1FXSwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlRFTEVNRVRSWV9TREtfVkVSU0lPTl0gPSBTREtfSU5GT1tTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5URUxFTUVUUllfU0RLX1ZFUlNJT05dLCBfYTIpKTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzb3VyY2UzLnByb3RvdHlwZSwgXCJhdHRyaWJ1dGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgIGlmICh0aGlzLmFzeW5jQXR0cmlidXRlc1BlbmRpbmcpIHtcbiAgICAgICAgICAgIGRpYWcyLmVycm9yKFwiQWNjZXNzaW5nIHJlc291cmNlIGF0dHJpYnV0ZXMgYmVmb3JlIGFzeW5jIGF0dHJpYnV0ZXMgc2V0dGxlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChfYTIgPSB0aGlzLl9hdHRyaWJ1dGVzKSAhPT0gbnVsbCAmJiBfYTIgIT09IHZvaWQgMCA/IF9hMiA6IHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFJlc291cmNlMy5wcm90b3R5cGUud2FpdEZvckFzeW5jQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyNih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yNih0aGlzLCBmdW5jdGlvbihfYTIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EyLmxhYmVsKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXN5bmNBdHRyaWJ1dGVzUGVuZGluZylcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLl9hc3luY0F0dHJpYnV0ZXNQcm9taXNlXTtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hMi5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EyLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAvKnJldHVybiovXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgUmVzb3VyY2UzLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGlmICghb3RoZXIpXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBtZXJnZWRTeW5jQXR0cmlidXRlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLl9zeW5jQXR0cmlidXRlcyksIChfYTIgPSBvdGhlci5fc3luY0F0dHJpYnV0ZXMpICE9PSBudWxsICYmIF9hMiAhPT0gdm9pZCAwID8gX2EyIDogb3RoZXIuYXR0cmlidXRlcyk7XG4gICAgICAgIGlmICghdGhpcy5fYXN5bmNBdHRyaWJ1dGVzUHJvbWlzZSAmJiAhb3RoZXIuX2FzeW5jQXR0cmlidXRlc1Byb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlMyhtZXJnZWRTeW5jQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lcmdlZEF0dHJpYnV0ZXNQcm9taXNlID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIHRoaXMuX2FzeW5jQXR0cmlidXRlc1Byb21pc2UsXG4gICAgICAgICAgb3RoZXIuX2FzeW5jQXR0cmlidXRlc1Byb21pc2VcbiAgICAgICAgXSkudGhlbihmdW5jdGlvbihfYTMpIHtcbiAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgdmFyIF9jID0gX19yZWFkMTIoX2EzLCAyKSwgdGhpc0FzeW5jQXR0cmlidXRlcyA9IF9jWzBdLCBvdGhlckFzeW5jQXR0cmlidXRlcyA9IF9jWzFdO1xuICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgX3RoaXMuX3N5bmNBdHRyaWJ1dGVzKSwgdGhpc0FzeW5jQXR0cmlidXRlcyksIChfYiA9IG90aGVyLl9zeW5jQXR0cmlidXRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogb3RoZXIuYXR0cmlidXRlcyksIG90aGVyQXN5bmNBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2UzKG1lcmdlZFN5bmNBdHRyaWJ1dGVzLCBtZXJnZWRBdHRyaWJ1dGVzUHJvbWlzZSk7XG4gICAgICB9O1xuICAgICAgUmVzb3VyY2UzLkVNUFRZID0gbmV3IFJlc291cmNlMyh7fSk7XG4gICAgICByZXR1cm4gUmVzb3VyY2UzO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL0lSZXNvdXJjZS5qc1xudmFyIGluaXRfSVJlc291cmNlID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL0lSZXNvdXJjZS5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vdHlwZXMuanNcbnZhciBpbml0X3R5cGVzNCA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS90eXBlcy5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vY29uZmlnLmpzXG52YXIgaW5pdF9jb25maWcyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL2NvbmZpZy5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vZGV0ZWN0b3JzL0Jyb3dzZXJEZXRlY3Rvci5qc1xudmFyIEJyb3dzZXJEZXRlY3RvciwgYnJvd3NlckRldGVjdG9yO1xudmFyIGluaXRfQnJvd3NlckRldGVjdG9yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL2RldGVjdG9ycy9Ccm93c2VyRGV0ZWN0b3IuanNcIigpIHtcbiAgICBpbml0X2VzbTUoKTtcbiAgICBCcm93c2VyRGV0ZWN0b3IgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBCcm93c2VyRGV0ZWN0b3IyKCkge1xuICAgICAgfVxuICAgICAgQnJvd3NlckRldGVjdG9yMi5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYnJvd3NlckRldGVjdG9yU3luYy5kZXRlY3QoY29uZmlnKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEJyb3dzZXJEZXRlY3RvcjI7XG4gICAgfSgpO1xuICAgIGJyb3dzZXJEZXRlY3RvciA9IG5ldyBCcm93c2VyRGV0ZWN0b3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL2RldGVjdG9ycy9FbnZEZXRlY3RvclN5bmMuanNcbnZhciBfX3ZhbHVlczcsIF9fcmVhZDEzLCBFbnZEZXRlY3RvclN5bmMsIGVudkRldGVjdG9yU3luYztcbnZhciBpbml0X0VudkRldGVjdG9yU3luYyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9kZXRlY3RvcnMvRW52RGV0ZWN0b3JTeW5jLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBpbml0X2VzbTMoKTtcbiAgICBpbml0X2VzbTIoKTtcbiAgICBpbml0X1Jlc291cmNlKCk7XG4gICAgX192YWx1ZXM3ID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICAgIGlmIChtKVxuICAgICAgICByZXR1cm4gbS5jYWxsKG8pO1xuICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aClcbiAgICAgICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgfTtcbiAgICBfX3JlYWQxMyA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghbSlcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0geyBlcnJvciB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgICAgICBtLmNhbGwoaSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXI7XG4gICAgfTtcbiAgICBFbnZEZXRlY3RvclN5bmMgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBFbnZEZXRlY3RvclN5bmMyKCkge1xuICAgICAgICB0aGlzLl9NQVhfTEVOR1RIID0gMjU1O1xuICAgICAgICB0aGlzLl9DT01NQV9TRVBBUkFUT1IgPSBcIixcIjtcbiAgICAgICAgdGhpcy5fTEFCRUxfS0VZX1ZBTFVFX1NQTElUVEVSID0gXCI9XCI7XG4gICAgICAgIHRoaXMuX0VSUk9SX01FU1NBR0VfSU5WQUxJRF9DSEFSUyA9IFwic2hvdWxkIGJlIGEgQVNDSUkgc3RyaW5nIHdpdGggYSBsZW5ndGggZ3JlYXRlciB0aGFuIDAgYW5kIG5vdCBleGNlZWQgXCIgKyB0aGlzLl9NQVhfTEVOR1RIICsgXCIgY2hhcmFjdGVycy5cIjtcbiAgICAgICAgdGhpcy5fRVJST1JfTUVTU0FHRV9JTlZBTElEX1ZBTFVFID0gXCJzaG91bGQgYmUgYSBBU0NJSSBzdHJpbmcgd2l0aCBhIGxlbmd0aCBub3QgZXhjZWVkIFwiICsgdGhpcy5fTUFYX0xFTkdUSCArIFwiIGNoYXJhY3RlcnMuXCI7XG4gICAgICB9XG4gICAgICBFbnZEZXRlY3RvclN5bmMyLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbihfY29uZmlnKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHZhciBlbnYzID0gZ2V0RW52KCk7XG4gICAgICAgIHZhciByYXdBdHRyaWJ1dGVzID0gZW52My5PVEVMX1JFU09VUkNFX0FUVFJJQlVURVM7XG4gICAgICAgIHZhciBzZXJ2aWNlTmFtZSA9IGVudjMuT1RFTF9TRVJWSUNFX05BTUU7XG4gICAgICAgIGlmIChyYXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gdGhpcy5fcGFyc2VSZXNvdXJjZUF0dHJpYnV0ZXMocmF3QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHBhcnNlZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRpYWcyLmRlYnVnKFwiRW52RGV0ZWN0b3IgZmFpbGVkOiBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJ2aWNlTmFtZSkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuU0VSVklDRV9OQU1FXSA9IHNlcnZpY2VOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2UoYXR0cmlidXRlcyk7XG4gICAgICB9O1xuICAgICAgRW52RGV0ZWN0b3JTeW5jMi5wcm90b3R5cGUuX3BhcnNlUmVzb3VyY2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24ocmF3RW52QXR0cmlidXRlcykge1xuICAgICAgICB2YXIgZV8xLCBfYTI7XG4gICAgICAgIGlmICghcmF3RW52QXR0cmlidXRlcylcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHZhciByYXdBdHRyaWJ1dGVzID0gcmF3RW52QXR0cmlidXRlcy5zcGxpdCh0aGlzLl9DT01NQV9TRVBBUkFUT1IsIC0xKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciByYXdBdHRyaWJ1dGVzXzEgPSBfX3ZhbHVlczcocmF3QXR0cmlidXRlcyksIHJhd0F0dHJpYnV0ZXNfMV8xID0gcmF3QXR0cmlidXRlc18xLm5leHQoKTsgIXJhd0F0dHJpYnV0ZXNfMV8xLmRvbmU7IHJhd0F0dHJpYnV0ZXNfMV8xID0gcmF3QXR0cmlidXRlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHJhd0F0dHJpYnV0ZSA9IHJhd0F0dHJpYnV0ZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlUGFpciA9IHJhd0F0dHJpYnV0ZS5zcGxpdCh0aGlzLl9MQUJFTF9LRVlfVkFMVUVfU1BMSVRURVIsIC0xKTtcbiAgICAgICAgICAgIGlmIChrZXlWYWx1ZVBhaXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkMTMoa2V5VmFsdWVQYWlyLCAyKSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgICAgICBrZXkgPSBrZXkudHJpbSgpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCkuc3BsaXQoL15cInxcIiQvKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkQW5kTm90RW1wdHkoa2V5KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyaWJ1dGUga2V5IFwiICsgdGhpcy5fRVJST1JfTUVTU0FHRV9JTlZBTElEX0NIQVJTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0cmlidXRlIHZhbHVlIFwiICsgdGhpcy5fRVJST1JfTUVTU0FHRV9JTlZBTElEX1ZBTFVFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyYXdBdHRyaWJ1dGVzXzFfMSAmJiAhcmF3QXR0cmlidXRlc18xXzEuZG9uZSAmJiAoX2EyID0gcmF3QXR0cmlidXRlc18xLnJldHVybikpXG4gICAgICAgICAgICAgIF9hMi5jYWxsKHJhd0F0dHJpYnV0ZXNfMSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlXzEpXG4gICAgICAgICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9O1xuICAgICAgRW52RGV0ZWN0b3JTeW5jMi5wcm90b3R5cGUuX2lzVmFsaWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA8PSB0aGlzLl9NQVhfTEVOR1RIICYmIHRoaXMuX2lzQmFnZ2FnZU9jdGV0U3RyaW5nKG5hbWUpO1xuICAgICAgfTtcbiAgICAgIEVudkRldGVjdG9yU3luYzIucHJvdG90eXBlLl9pc0JhZ2dhZ2VPY3RldFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIGlmIChjaCA8IDMzIHx8IGNoID09PSA0NCB8fCBjaCA9PT0gNTkgfHwgY2ggPT09IDkyIHx8IGNoID4gMTI2KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIEVudkRldGVjdG9yU3luYzIucHJvdG90eXBlLl9pc1ZhbGlkQW5kTm90RW1wdHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5sZW5ndGggPiAwICYmIHRoaXMuX2lzVmFsaWQoc3RyKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW52RGV0ZWN0b3JTeW5jMjtcbiAgICB9KCk7XG4gICAgZW52RGV0ZWN0b3JTeW5jID0gbmV3IEVudkRldGVjdG9yU3luYygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vZGV0ZWN0b3JzL0VudkRldGVjdG9yLmpzXG52YXIgRW52RGV0ZWN0b3IsIGVudkRldGVjdG9yO1xudmFyIGluaXRfRW52RGV0ZWN0b3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vZGV0ZWN0b3JzL0VudkRldGVjdG9yLmpzXCIoKSB7XG4gICAgaW5pdF9FbnZEZXRlY3RvclN5bmMoKTtcbiAgICBFbnZEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEVudkRldGVjdG9yMigpIHtcbiAgICAgIH1cbiAgICAgIEVudkRldGVjdG9yMi5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW52RGV0ZWN0b3JTeW5jLmRldGVjdChjb25maWcpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW52RGV0ZWN0b3IyO1xuICAgIH0oKTtcbiAgICBlbnZEZXRlY3RvciA9IG5ldyBFbnZEZXRlY3RvcigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vZGV0ZWN0b3JzL0Jyb3dzZXJEZXRlY3RvclN5bmMuanNcbnZhciBfX2Fzc2lnbjIsIEJyb3dzZXJEZXRlY3RvclN5bmMsIGJyb3dzZXJEZXRlY3RvclN5bmM7XG52YXIgaW5pdF9Ccm93c2VyRGV0ZWN0b3JTeW5jID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL2RldGVjdG9ycy9Ccm93c2VyRGV0ZWN0b3JTeW5jLmpzXCIoKSB7XG4gICAgaW5pdF9lc20yKCk7XG4gICAgaW5pdF9lc201KCk7XG4gICAgaW5pdF9lc20oKTtcbiAgICBfX2Fzc2lnbjIgPSBmdW5jdGlvbigpIHtcbiAgICAgIF9fYXNzaWduMiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHAgaW4gcylcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfX2Fzc2lnbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIEJyb3dzZXJEZXRlY3RvclN5bmMgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBCcm93c2VyRGV0ZWN0b3JTeW5jMigpIHtcbiAgICAgIH1cbiAgICAgIEJyb3dzZXJEZXRlY3RvclN5bmMyLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgdmFyIGlzQnJvd3NlciA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIFJlc291cmNlLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJyb3dzZXJSZXNvdXJjZSA9IChfYTIgPSB7fSwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9OQU1FXSA9IFwiYnJvd3NlclwiLCBfYTJbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX0RFU0NSSVBUSU9OXSA9IFwiV2ViIEJyb3dzZXJcIiwgX2EyW1NlbWFudGljUmVzb3VyY2VBdHRyaWJ1dGVzLlBST0NFU1NfUlVOVElNRV9WRVJTSU9OXSA9IG5hdmlnYXRvci51c2VyQWdlbnQsIF9hMik7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSZXNvdXJjZUF0dHJpYnV0ZXMoYnJvd3NlclJlc291cmNlLCBjb25maWcpO1xuICAgICAgfTtcbiAgICAgIEJyb3dzZXJEZXRlY3RvclN5bmMyLnByb3RvdHlwZS5fZ2V0UmVzb3VyY2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24oYnJvd3NlclJlc291cmNlLCBfY29uZmlnKSB7XG4gICAgICAgIGlmIChicm93c2VyUmVzb3VyY2VbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuUFJPQ0VTU19SVU5USU1FX1ZFUlNJT05dID09PSBcIlwiKSB7XG4gICAgICAgICAgZGlhZzIuZGVidWcoXCJCcm93c2VyRGV0ZWN0b3IgZmFpbGVkOiBVbmFibGUgdG8gZmluZCByZXF1aXJlZCBicm93c2VyIHJlc291cmNlcy4gXCIpO1xuICAgICAgICAgIHJldHVybiBSZXNvdXJjZS5lbXB0eSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2UoX19hc3NpZ24yKHt9LCBicm93c2VyUmVzb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBCcm93c2VyRGV0ZWN0b3JTeW5jMjtcbiAgICB9KCk7XG4gICAgYnJvd3NlckRldGVjdG9yU3luYyA9IG5ldyBCcm93c2VyRGV0ZWN0b3JTeW5jKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9kZXRlY3RvcnMvaW5kZXguanNcbnZhciBpbml0X2RldGVjdG9ycyA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9kZXRlY3RvcnMvaW5kZXguanNcIigpIHtcbiAgICBpbml0X0Jyb3dzZXJEZXRlY3RvcigpO1xuICAgIGluaXRfRW52RGV0ZWN0b3IoKTtcbiAgICBpbml0X0Jyb3dzZXJEZXRlY3RvclN5bmMoKTtcbiAgICBpbml0X0VudkRldGVjdG9yU3luYygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vdXRpbHMuanNcbnZhciBpc1Byb21pc2VMaWtlO1xudmFyIGluaXRfdXRpbHM2ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL3V0aWxzLmpzXCIoKSB7XG4gICAgaXNQcm9taXNlTGlrZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9kZXRlY3QtcmVzb3VyY2VzLmpzXG52YXIgX19hd2FpdGVyNywgX19nZW5lcmF0b3I3LCBkZXRlY3RSZXNvdXJjZXMsIGRldGVjdFJlc291cmNlc1N5bmMsIGxvZ1Jlc291cmNlcztcbnZhciBpbml0X2RldGVjdF9yZXNvdXJjZXMgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vZGV0ZWN0LXJlc291cmNlcy5qc1wiKCkge1xuICAgIGluaXRfUmVzb3VyY2UoKTtcbiAgICBpbml0X2VzbSgpO1xuICAgIGluaXRfdXRpbHM2KCk7XG4gICAgX19hd2FpdGVyNyA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX19nZW5lcmF0b3I3ID0gZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRbMF0gJiAxKVxuICAgICAgICAgIHRocm93IHRbMV07XG4gICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KSwgZztcbiAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXylcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpXG4gICAgICAgICAgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBkZXRlY3RSZXNvdXJjZXMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX2F3YWl0ZXI3KHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzb3VyY2VzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3I3KHRoaXMsIGZ1bmN0aW9uKF9hMikge1xuICAgICAgICAgIHN3aXRjaCAoX2EyLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBbNCwgUHJvbWlzZS5hbGwoKGNvbmZpZy5kZXRlY3RvcnMgfHwgW10pLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcjcodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UsIGVfMTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcjcodGhpcywgZnVuY3Rpb24oX2EzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EzLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EzLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGQuZGV0ZWN0KGNvbmZpZyldO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gX2EzLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpYWcyLmRlYnVnKGQuY29uc3RydWN0b3IubmFtZSArIFwiIGZvdW5kIHJlc291cmNlLlwiLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc291cmNlXTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYTMuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlhZzIuZGVidWcoZC5jb25zdHJ1Y3Rvci5uYW1lICsgXCIgZmFpbGVkOiBcIiArIGVfMS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgUmVzb3VyY2UuZW1wdHkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAvKnJldHVybiovXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcmVzb3VyY2VzID0gX2EyLnNlbnQoKTtcbiAgICAgICAgICAgICAgbG9nUmVzb3VyY2VzKHJlc291cmNlcyk7XG4gICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzb3VyY2VzLnJlZHVjZShmdW5jdGlvbihhY2MsIHJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5tZXJnZShyZXNvdXJjZSk7XG4gICAgICAgICAgICAgIH0sIFJlc291cmNlLmVtcHR5KCkpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBkZXRlY3RSZXNvdXJjZXNTeW5jID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc291cmNlcyA9ICgoX2EyID0gY29uZmlnLmRldGVjdG9ycykgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiBbXSkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVzb3VyY2VPclByb21pc2VfMSA9IGQuZGV0ZWN0KGNvbmZpZyk7XG4gICAgICAgICAgdmFyIHJlc291cmNlXzE7XG4gICAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UocmVzb3VyY2VPclByb21pc2VfMSkpIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGVQcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXI3KHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZFJlc291cmNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcjcodGhpcywgZnVuY3Rpb24oX2EzKSB7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hMy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCByZXNvdXJjZU9yUHJvbWlzZV8xXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUmVzb3VyY2UgPSBfYTMuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzb2x2ZWRSZXNvdXJjZS5hdHRyaWJ1dGVzXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb3VyY2VfMSA9IG5ldyBSZXNvdXJjZSh7fSwgY3JlYXRlUHJvbWlzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb3VyY2VfMSA9IHJlc291cmNlT3JQcm9taXNlXzE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNvdXJjZV8xLndhaXRGb3JBc3luY0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZvaWQgcmVzb3VyY2VfMS53YWl0Rm9yQXN5bmNBdHRyaWJ1dGVzKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRpYWcyLmRlYnVnKGQuY29uc3RydWN0b3IubmFtZSArIFwiIGZvdW5kIHJlc291cmNlLlwiLCByZXNvdXJjZV8xKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWFnMi5kZWJ1ZyhkLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiBmb3VuZCByZXNvdXJjZS5cIiwgcmVzb3VyY2VfMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvdXJjZV8xO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGlhZzIuZXJyb3IoZC5jb25zdHJ1Y3Rvci5uYW1lICsgXCIgZmFpbGVkOiBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuIFJlc291cmNlLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG1lcmdlZFJlc291cmNlcyA9IHJlc291cmNlcy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCByZXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gYWNjLm1lcmdlKHJlc291cmNlKTtcbiAgICAgIH0sIFJlc291cmNlLmVtcHR5KCkpO1xuICAgICAgaWYgKG1lcmdlZFJlc291cmNlcy53YWl0Rm9yQXN5bmNBdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZvaWQgbWVyZ2VkUmVzb3VyY2VzLndhaXRGb3JBc3luY0F0dHJpYnV0ZXMoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvZ1Jlc291cmNlcyhyZXNvdXJjZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRSZXNvdXJjZXM7XG4gICAgfTtcbiAgICBsb2dSZXNvdXJjZXMgPSBmdW5jdGlvbihyZXNvdXJjZXMpIHtcbiAgICAgIHJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXNvdXJjZS5hdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHJlc291cmNlRGVidWdTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShyZXNvdXJjZS5hdHRyaWJ1dGVzLCBudWxsLCA0KTtcbiAgICAgICAgICBkaWFnMi52ZXJib3NlKHJlc291cmNlRGVidWdTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vaW5kZXguanNcbnZhciBlc21fZXhwb3J0czUgPSB7fTtcbl9fZXhwb3J0KGVzbV9leHBvcnRzNSwge1xuICBSZXNvdXJjZTogKCkgPT4gUmVzb3VyY2UsXG4gIGJyb3dzZXJEZXRlY3RvcjogKCkgPT4gYnJvd3NlckRldGVjdG9yLFxuICBicm93c2VyRGV0ZWN0b3JTeW5jOiAoKSA9PiBicm93c2VyRGV0ZWN0b3JTeW5jLFxuICBkZWZhdWx0U2VydmljZU5hbWU6ICgpID0+IGRlZmF1bHRTZXJ2aWNlTmFtZSxcbiAgZGV0ZWN0UmVzb3VyY2VzOiAoKSA9PiBkZXRlY3RSZXNvdXJjZXMsXG4gIGRldGVjdFJlc291cmNlc1N5bmM6ICgpID0+IGRldGVjdFJlc291cmNlc1N5bmMsXG4gIGVudkRldGVjdG9yOiAoKSA9PiBlbnZEZXRlY3RvcixcbiAgZW52RGV0ZWN0b3JTeW5jOiAoKSA9PiBlbnZEZXRlY3RvclN5bmMsXG4gIGhvc3REZXRlY3RvcjogKCkgPT4gaG9zdERldGVjdG9yLFxuICBob3N0RGV0ZWN0b3JTeW5jOiAoKSA9PiBob3N0RGV0ZWN0b3JTeW5jLFxuICBvc0RldGVjdG9yOiAoKSA9PiBvc0RldGVjdG9yLFxuICBvc0RldGVjdG9yU3luYzogKCkgPT4gb3NEZXRlY3RvclN5bmMsXG4gIHByb2Nlc3NEZXRlY3RvcjogKCkgPT4gcHJvY2Vzc0RldGVjdG9yLFxuICBwcm9jZXNzRGV0ZWN0b3JTeW5jOiAoKSA9PiBwcm9jZXNzRGV0ZWN0b3JTeW5jXG59KTtcbnZhciBpbml0X2VzbTUgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vaW5kZXguanNcIigpIHtcbiAgICBpbml0X1Jlc291cmNlKCk7XG4gICAgaW5pdF9JUmVzb3VyY2UoKTtcbiAgICBpbml0X3BsYXRmb3JtNCgpO1xuICAgIGluaXRfdHlwZXM0KCk7XG4gICAgaW5pdF9jb25maWcyKCk7XG4gICAgaW5pdF9kZXRlY3RvcnMoKTtcbiAgICBpbml0X2RldGVjdF9yZXNvdXJjZXMoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vTXVsdGlTcGFuUHJvY2Vzc29yLmpzXG52YXIgX192YWx1ZXM4LCBNdWx0aVNwYW5Qcm9jZXNzb3I7XG52YXIgaW5pdF9NdWx0aVNwYW5Qcm9jZXNzb3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9NdWx0aVNwYW5Qcm9jZXNzb3IuanNcIigpIHtcbiAgICBpbml0X2VzbTMoKTtcbiAgICBfX3ZhbHVlczggPSBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgICAgaWYgKG0pXG4gICAgICAgIHJldHVybiBtLmNhbGwobyk7XG4gICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB9O1xuICAgIE11bHRpU3BhblByb2Nlc3NvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIE11bHRpU3BhblByb2Nlc3NvcjIoX3NwYW5Qcm9jZXNzb3JzKSB7XG4gICAgICAgIHRoaXMuX3NwYW5Qcm9jZXNzb3JzID0gX3NwYW5Qcm9jZXNzb3JzO1xuICAgICAgfVxuICAgICAgTXVsdGlTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuZm9yY2VGbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTI7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXM4KHRoaXMuX3NwYW5Qcm9jZXNzb3JzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHNwYW5Qcm9jZXNzb3IgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3BhblByb2Nlc3Nvci5mb3JjZUZsdXNoKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hMiA9IF9iLnJldHVybikpXG4gICAgICAgICAgICAgIF9hMi5jYWxsKF9iKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfMSlcbiAgICAgICAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBnbG9iYWxFcnJvckhhbmRsZXIoZXJyb3IgfHwgbmV3IEVycm9yKFwiTXVsdGlTcGFuUHJvY2Vzc29yOiBmb3JjZUZsdXNoIGZhaWxlZFwiKSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIE11bHRpU3BhblByb2Nlc3NvcjIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbihzcGFuLCBjb250ZXh0Mikge1xuICAgICAgICB2YXIgZV8yLCBfYTI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlczgodGhpcy5fc3BhblByb2Nlc3NvcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgc3BhblByb2Nlc3NvciA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgc3BhblByb2Nlc3Nvci5vblN0YXJ0KHNwYW4sIGNvbnRleHQyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYTIgPSBfYi5yZXR1cm4pKVxuICAgICAgICAgICAgICBfYTIuY2FsbChfYik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlXzIpXG4gICAgICAgICAgICAgIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBNdWx0aVNwYW5Qcm9jZXNzb3IyLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHNwYW4pIHtcbiAgICAgICAgdmFyIGVfMywgX2EyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXM4KHRoaXMuX3NwYW5Qcm9jZXNzb3JzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHNwYW5Qcm9jZXNzb3IgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIHNwYW5Qcm9jZXNzb3Iub25FbmQoc3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EyID0gX2IucmV0dXJuKSlcbiAgICAgICAgICAgICAgX2EyLmNhbGwoX2IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8zKVxuICAgICAgICAgICAgICB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgTXVsdGlTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVfNCwgX2EyO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzOCh0aGlzLl9zcGFuUHJvY2Vzc29ycyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBzcGFuUHJvY2Vzc29yID0gX2MudmFsdWU7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHNwYW5Qcm9jZXNzb3Iuc2h1dGRvd24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzRfMSkge1xuICAgICAgICAgIGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EyID0gX2IucmV0dXJuKSlcbiAgICAgICAgICAgICAgX2EyLmNhbGwoX2IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV80KVxuICAgICAgICAgICAgICB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTXVsdGlTcGFuUHJvY2Vzc29yMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2V4cG9ydC9Ob29wU3BhblByb2Nlc3Nvci5qc1xudmFyIE5vb3BTcGFuUHJvY2Vzc29yO1xudmFyIGluaXRfTm9vcFNwYW5Qcm9jZXNzb3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9leHBvcnQvTm9vcFNwYW5Qcm9jZXNzb3IuanNcIigpIHtcbiAgICBOb29wU3BhblByb2Nlc3NvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIE5vb3BTcGFuUHJvY2Vzc29yMigpIHtcbiAgICAgIH1cbiAgICAgIE5vb3BTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKF9zcGFuLCBfY29udGV4dCkge1xuICAgICAgfTtcbiAgICAgIE5vb3BTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihfc3Bhbikge1xuICAgICAgfTtcbiAgICAgIE5vb3BTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIE5vb3BTcGFuUHJvY2Vzc29yMi5wcm90b3R5cGUuZm9yY2VGbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIE5vb3BTcGFuUHJvY2Vzc29yMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL0Jhc2ljVHJhY2VyUHJvdmlkZXIuanNcbnZhciBGb3JjZUZsdXNoU3RhdGUsIEJhc2ljVHJhY2VyUHJvdmlkZXI7XG52YXIgaW5pdF9CYXNpY1RyYWNlclByb3ZpZGVyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vQmFzaWNUcmFjZXJQcm92aWRlci5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgaW5pdF9lc20zKCk7XG4gICAgaW5pdF9lc201KCk7XG4gICAgaW5pdF9lc202KCk7XG4gICAgaW5pdF9jb25maWcoKTtcbiAgICBpbml0X011bHRpU3BhblByb2Nlc3NvcigpO1xuICAgIGluaXRfTm9vcFNwYW5Qcm9jZXNzb3IoKTtcbiAgICBpbml0X3BsYXRmb3JtMygpO1xuICAgIGluaXRfdXRpbGl0eSgpO1xuICAgIChmdW5jdGlvbihGb3JjZUZsdXNoU3RhdGUyKSB7XG4gICAgICBGb3JjZUZsdXNoU3RhdGUyW0ZvcmNlRmx1c2hTdGF0ZTJbXCJyZXNvbHZlZFwiXSA9IDBdID0gXCJyZXNvbHZlZFwiO1xuICAgICAgRm9yY2VGbHVzaFN0YXRlMltGb3JjZUZsdXNoU3RhdGUyW1widGltZW91dFwiXSA9IDFdID0gXCJ0aW1lb3V0XCI7XG4gICAgICBGb3JjZUZsdXNoU3RhdGUyW0ZvcmNlRmx1c2hTdGF0ZTJbXCJlcnJvclwiXSA9IDJdID0gXCJlcnJvclwiO1xuICAgICAgRm9yY2VGbHVzaFN0YXRlMltGb3JjZUZsdXNoU3RhdGUyW1widW5yZXNvbHZlZFwiXSA9IDNdID0gXCJ1bnJlc29sdmVkXCI7XG4gICAgfSkoRm9yY2VGbHVzaFN0YXRlIHx8IChGb3JjZUZsdXNoU3RhdGUgPSB7fSkpO1xuICAgIEJhc2ljVHJhY2VyUHJvdmlkZXIgPSAvKiogQGNsYXNzICovXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBCYXNpY1RyYWNlclByb3ZpZGVyMihjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZFNwYW5Qcm9jZXNzb3JzID0gW107XG4gICAgICAgIHRoaXMuX3RyYWNlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgbWVyZ2VkQ29uZmlnID0gbWVyZ2Uoe30sIGxvYWREZWZhdWx0Q29uZmlnKCksIHJlY29uZmlndXJlTGltaXRzKGNvbmZpZykpO1xuICAgICAgICB0aGlzLnJlc291cmNlID0gKF9hMiA9IG1lcmdlZENvbmZpZy5yZXNvdXJjZSkgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiBSZXNvdXJjZS5lbXB0eSgpO1xuICAgICAgICB0aGlzLnJlc291cmNlID0gUmVzb3VyY2UuZGVmYXVsdCgpLm1lcmdlKHRoaXMucmVzb3VyY2UpO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBtZXJnZWRDb25maWcsIHtcbiAgICAgICAgICByZXNvdXJjZTogdGhpcy5yZXNvdXJjZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnRlciA9IHRoaXMuX2J1aWxkRXhwb3J0ZXJGcm9tRW52KCk7XG4gICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBiYXRjaFByb2Nlc3NvciA9IG5ldyBCYXRjaFNwYW5Qcm9jZXNzb3IoZGVmYXVsdEV4cG9ydGVyKTtcbiAgICAgICAgICB0aGlzLmFjdGl2ZVNwYW5Qcm9jZXNzb3IgPSBiYXRjaFByb2Nlc3NvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFjdGl2ZVNwYW5Qcm9jZXNzb3IgPSBuZXcgTm9vcFNwYW5Qcm9jZXNzb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmdldFRyYWNlciA9IGZ1bmN0aW9uKG5hbWUsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGtleSA9IG5hbWUgKyBcIkBcIiArICh2ZXJzaW9uIHx8IFwiXCIpICsgXCI6XCIgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2hlbWFVcmwpIHx8IFwiXCIpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYWNlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICB0aGlzLl90cmFjZXJzLnNldChrZXksIG5ldyBUcmFjZXIoeyBuYW1lLCB2ZXJzaW9uLCBzY2hlbWFVcmw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2hlbWFVcmwgfSwgdGhpcy5fY29uZmlnLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNlcnMuZ2V0KGtleSk7XG4gICAgICB9O1xuICAgICAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmFkZFNwYW5Qcm9jZXNzb3IgPSBmdW5jdGlvbihzcGFuUHJvY2Vzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWdpc3RlcmVkU3BhblByb2Nlc3NvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVTcGFuUHJvY2Vzc29yLnNodXRkb3duKCkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlhZzIuZXJyb3IoXCJFcnJvciB3aGlsZSB0cnlpbmcgdG8gc2h1dGRvd24gY3VycmVudCBzcGFuIHByb2Nlc3NvclwiLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyZWRTcGFuUHJvY2Vzc29ycy5wdXNoKHNwYW5Qcm9jZXNzb3IpO1xuICAgICAgICB0aGlzLmFjdGl2ZVNwYW5Qcm9jZXNzb3IgPSBuZXcgTXVsdGlTcGFuUHJvY2Vzc29yKHRoaXMuX3JlZ2lzdGVyZWRTcGFuUHJvY2Vzc29ycyk7XG4gICAgICB9O1xuICAgICAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLmdldEFjdGl2ZVNwYW5Qcm9jZXNzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlU3BhblByb2Nlc3NvcjtcbiAgICAgIH07XG4gICAgICBCYXNpY1RyYWNlclByb3ZpZGVyMi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2Uuc2V0R2xvYmFsVHJhY2VyUHJvdmlkZXIodGhpcyk7XG4gICAgICAgIGlmIChjb25maWcucHJvcGFnYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uZmlnLnByb3BhZ2F0b3IgPSB0aGlzLl9idWlsZFByb3BhZ2F0b3JGcm9tRW52KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0TWFuYWdlcikge1xuICAgICAgICAgIGNvbnRleHQuc2V0R2xvYmFsQ29udGV4dE1hbmFnZXIoY29uZmlnLmNvbnRleHRNYW5hZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnByb3BhZ2F0b3IpIHtcbiAgICAgICAgICBwcm9wYWdhdGlvbi5zZXRHbG9iYWxQcm9wYWdhdG9yKGNvbmZpZy5wcm9wYWdhdG9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5mb3JjZUZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fY29uZmlnLmZvcmNlRmx1c2hUaW1lb3V0TWlsbGlzO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSB0aGlzLl9yZWdpc3RlcmVkU3BhblByb2Nlc3NvcnMubWFwKGZ1bmN0aW9uKHNwYW5Qcm9jZXNzb3IpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXRJbnRlcnZhbCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobmV3IEVycm9yKFwiU3BhbiBwcm9jZXNzb3IgZGlkIG5vdCBjb21wbGV0ZWQgd2l0aGluIHRpbWVvdXQgcGVyaW9kIG9mIFwiICsgdGltZW91dCArIFwiIG1zXCIpKTtcbiAgICAgICAgICAgICAgc3RhdGUgPSBGb3JjZUZsdXNoU3RhdGUudGltZW91dDtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgc3BhblByb2Nlc3Nvci5mb3JjZUZsdXNoKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJbnRlcnZhbCk7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gRm9yY2VGbHVzaFN0YXRlLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IEZvcmNlRmx1c2hTdGF0ZS5yZXNvbHZlZDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJbnRlcnZhbCk7XG4gICAgICAgICAgICAgIHN0YXRlID0gRm9yY2VGbHVzaFN0YXRlLmVycm9yO1xuICAgICAgICAgICAgICByZXNvbHZlKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSByZXN1bHRzLmZpbHRlcihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gRm9yY2VGbHVzaFN0YXRlLnJlc29sdmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoW2Vycm9yXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIEJhc2ljVHJhY2VyUHJvdmlkZXIyLnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVTcGFuUHJvY2Vzc29yLnNodXRkb3duKCk7XG4gICAgICB9O1xuICAgICAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLl9nZXRQcm9wYWdhdG9yID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKF9hMiA9IHRoaXMuY29uc3RydWN0b3IuX3JlZ2lzdGVyZWRQcm9wYWdhdG9ycy5nZXQobmFtZSkpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyKCk7XG4gICAgICB9O1xuICAgICAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLl9nZXRTcGFuRXhwb3J0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gdGhpcy5jb25zdHJ1Y3Rvci5fcmVnaXN0ZXJlZEV4cG9ydGVycy5nZXQobmFtZSkpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyKCk7XG4gICAgICB9O1xuICAgICAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLl9idWlsZFByb3BhZ2F0b3JGcm9tRW52ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1bmlxdWVQcm9wYWdhdG9yTmFtZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoZ2V0RW52KCkuT1RFTF9QUk9QQUdBVE9SUykpO1xuICAgICAgICB2YXIgcHJvcGFnYXRvcnMgPSB1bmlxdWVQcm9wYWdhdG9yTmFtZXMubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJvcGFnYXRvciA9IF90aGlzLl9nZXRQcm9wYWdhdG9yKG5hbWUpO1xuICAgICAgICAgIGlmICghcHJvcGFnYXRvcikge1xuICAgICAgICAgICAgZGlhZzIud2FybignUHJvcGFnYXRvciBcIicgKyBuYW1lICsgJ1wiIHJlcXVlc3RlZCB0aHJvdWdoIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHVuYXZhaWxhYmxlLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJvcGFnYXRvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2YWxpZFByb3BhZ2F0b3JzID0gcHJvcGFnYXRvcnMucmVkdWNlKGZ1bmN0aW9uKGxpc3QsIGl0ZW0pIHtcbiAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBpZiAodmFsaWRQcm9wYWdhdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAodW5pcXVlUHJvcGFnYXRvck5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB2YWxpZFByb3BhZ2F0b3JzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlUHJvcGFnYXRvcih7XG4gICAgICAgICAgICBwcm9wYWdhdG9yczogdmFsaWRQcm9wYWdhdG9yc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmFzaWNUcmFjZXJQcm92aWRlcjIucHJvdG90eXBlLl9idWlsZEV4cG9ydGVyRnJvbUVudiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXhwb3J0ZXJOYW1lID0gZ2V0RW52KCkuT1RFTF9UUkFDRVNfRVhQT1JURVI7XG4gICAgICAgIGlmIChleHBvcnRlck5hbWUgPT09IFwibm9uZVwiIHx8IGV4cG9ydGVyTmFtZSA9PT0gXCJcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBleHBvcnRlciA9IHRoaXMuX2dldFNwYW5FeHBvcnRlcihleHBvcnRlck5hbWUpO1xuICAgICAgICBpZiAoIWV4cG9ydGVyKSB7XG4gICAgICAgICAgZGlhZzIuZXJyb3IoJ0V4cG9ydGVyIFwiJyArIGV4cG9ydGVyTmFtZSArICdcIiByZXF1ZXN0ZWQgdGhyb3VnaCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyB1bmF2YWlsYWJsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0ZXI7XG4gICAgICB9O1xuICAgICAgQmFzaWNUcmFjZXJQcm92aWRlcjIuX3JlZ2lzdGVyZWRQcm9wYWdhdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICAgICAgW1widHJhY2Vjb250ZXh0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVzNDVHJhY2VDb250ZXh0UHJvcGFnYXRvcigpO1xuICAgICAgICB9XSxcbiAgICAgICAgW1wiYmFnZ2FnZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFczQ0JhZ2dhZ2VQcm9wYWdhdG9yKCk7XG4gICAgICAgIH1dXG4gICAgICBdKTtcbiAgICAgIEJhc2ljVHJhY2VyUHJvdmlkZXIyLl9yZWdpc3RlcmVkRXhwb3J0ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHJldHVybiBCYXNpY1RyYWNlclByb3ZpZGVyMjtcbiAgICB9KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2V4cG9ydC9Db25zb2xlU3BhbkV4cG9ydGVyLmpzXG52YXIgX192YWx1ZXM5LCBDb25zb2xlU3BhbkV4cG9ydGVyO1xudmFyIGluaXRfQ29uc29sZVNwYW5FeHBvcnRlciA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2V4cG9ydC9Db25zb2xlU3BhbkV4cG9ydGVyLmpzXCIoKSB7XG4gICAgaW5pdF9lc20zKCk7XG4gICAgX192YWx1ZXM5ID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICAgIGlmIChtKVxuICAgICAgICByZXR1cm4gbS5jYWxsKG8pO1xuICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aClcbiAgICAgICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgfTtcbiAgICBDb25zb2xlU3BhbkV4cG9ydGVyID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gQ29uc29sZVNwYW5FeHBvcnRlcjMoKSB7XG4gICAgICB9XG4gICAgICBDb25zb2xlU3BhbkV4cG9ydGVyMy5wcm90b3R5cGUuZXhwb3J0ID0gZnVuY3Rpb24oc3BhbnMsIHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kU3BhbnMoc3BhbnMsIHJlc3VsdENhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgICBDb25zb2xlU3BhbkV4cG9ydGVyMy5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc2VuZFNwYW5zKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yY2VGbHVzaCgpO1xuICAgICAgfTtcbiAgICAgIENvbnNvbGVTcGFuRXhwb3J0ZXIzLnByb3RvdHlwZS5mb3JjZUZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICBDb25zb2xlU3BhbkV4cG9ydGVyMy5wcm90b3R5cGUuX2V4cG9ydEluZm8gPSBmdW5jdGlvbihzcGFuKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhY2VJZDogc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQsXG4gICAgICAgICAgcGFyZW50SWQ6IHNwYW4ucGFyZW50U3BhbklkLFxuICAgICAgICAgIHRyYWNlU3RhdGU6IChfYTIgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VTdGF0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuc2VyaWFsaXplKCksXG4gICAgICAgICAgbmFtZTogc3Bhbi5uYW1lLFxuICAgICAgICAgIGlkOiBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkLFxuICAgICAgICAgIGtpbmQ6IHNwYW4ua2luZCxcbiAgICAgICAgICB0aW1lc3RhbXA6IGhyVGltZVRvTWljcm9zZWNvbmRzKHNwYW4uc3RhcnRUaW1lKSxcbiAgICAgICAgICBkdXJhdGlvbjogaHJUaW1lVG9NaWNyb3NlY29uZHMoc3Bhbi5kdXJhdGlvbiksXG4gICAgICAgICAgYXR0cmlidXRlczogc3Bhbi5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHN0YXR1czogc3Bhbi5zdGF0dXMsXG4gICAgICAgICAgZXZlbnRzOiBzcGFuLmV2ZW50cyxcbiAgICAgICAgICBsaW5rczogc3Bhbi5saW5rc1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIENvbnNvbGVTcGFuRXhwb3J0ZXIzLnByb3RvdHlwZS5fc2VuZFNwYW5zID0gZnVuY3Rpb24oc3BhbnMsIGRvbmUpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIHNwYW5zXzEgPSBfX3ZhbHVlczkoc3BhbnMpLCBzcGFuc18xXzEgPSBzcGFuc18xLm5leHQoKTsgIXNwYW5zXzFfMS5kb25lOyBzcGFuc18xXzEgPSBzcGFuc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBzcGFuc18xXzEudmFsdWU7XG4gICAgICAgICAgICBjb25zb2xlLmRpcih0aGlzLl9leHBvcnRJbmZvKHNwYW4pLCB7IGRlcHRoOiAzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc3BhbnNfMV8xICYmICFzcGFuc18xXzEuZG9uZSAmJiAoX2EyID0gc3BhbnNfMS5yZXR1cm4pKVxuICAgICAgICAgICAgICBfYTIuY2FsbChzcGFuc18xKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfMSlcbiAgICAgICAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHJldHVybiBkb25lKHsgY29kZTogRXhwb3J0UmVzdWx0Q29kZS5TVUNDRVNTIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbnNvbGVTcGFuRXhwb3J0ZXIzO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L0luTWVtb3J5U3BhbkV4cG9ydGVyLmpzXG52YXIgX19yZWFkMTQsIF9fc3ByZWFkQXJyYXk3LCBJbk1lbW9yeVNwYW5FeHBvcnRlcjtcbnZhciBpbml0X0luTWVtb3J5U3BhbkV4cG9ydGVyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L0luTWVtb3J5U3BhbkV4cG9ydGVyLmpzXCIoKSB7XG4gICAgaW5pdF9lc20zKCk7XG4gICAgX19yZWFkMTQgPSBmdW5jdGlvbihvLCBuKSB7XG4gICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3IgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICAgICAgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFyO1xuICAgIH07XG4gICAgX19zcHJlYWRBcnJheTcgPSBmdW5jdGlvbih0bywgZnJvbSwgcGFjaykge1xuICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKVxuICAgICAgICAgICAgICBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeVNwYW5FeHBvcnRlciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEluTWVtb3J5U3BhbkV4cG9ydGVyMigpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoZWRTcGFucyA9IFtdO1xuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBJbk1lbW9yeVNwYW5FeHBvcnRlcjIucHJvdG90eXBlLmV4cG9ydCA9IGZ1bmN0aW9uKHNwYW5zLCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAodGhpcy5fc3RvcHBlZClcbiAgICAgICAgICByZXR1cm4gcmVzdWx0Q2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogRXhwb3J0UmVzdWx0Q29kZS5GQUlMRUQsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiRXhwb3J0ZXIgaGFzIGJlZW4gc3RvcHBlZFwiKVxuICAgICAgICAgIH0pO1xuICAgICAgICAoX2EyID0gdGhpcy5fZmluaXNoZWRTcGFucykucHVzaC5hcHBseShfYTIsIF9fc3ByZWFkQXJyYXk3KFtdLCBfX3JlYWQxNChzcGFucyksIGZhbHNlKSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdENhbGxiYWNrKHsgY29kZTogRXhwb3J0UmVzdWx0Q29kZS5TVUNDRVNTIH0pO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG4gICAgICBJbk1lbW9yeVNwYW5FeHBvcnRlcjIucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9maW5pc2hlZFNwYW5zID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLmZvcmNlRmx1c2goKTtcbiAgICAgIH07XG4gICAgICBJbk1lbW9yeVNwYW5FeHBvcnRlcjIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIEluTWVtb3J5U3BhbkV4cG9ydGVyMi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoZWRTcGFucyA9IFtdO1xuICAgICAgfTtcbiAgICAgIEluTWVtb3J5U3BhbkV4cG9ydGVyMi5wcm90b3R5cGUuZ2V0RmluaXNoZWRTcGFucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluaXNoZWRTcGFucztcbiAgICAgIH07XG4gICAgICByZXR1cm4gSW5NZW1vcnlTcGFuRXhwb3J0ZXIyO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L1JlYWRhYmxlU3Bhbi5qc1xudmFyIGluaXRfUmVhZGFibGVTcGFuID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L1JlYWRhYmxlU3Bhbi5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9leHBvcnQvU2ltcGxlU3BhblByb2Nlc3Nvci5qc1xudmFyIF9fYXdhaXRlcjgsIF9fZ2VuZXJhdG9yOCwgU2ltcGxlU3BhblByb2Nlc3NvcjtcbnZhciBpbml0X1NpbXBsZVNwYW5Qcm9jZXNzb3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9leHBvcnQvU2ltcGxlU3BhblByb2Nlc3Nvci5qc1wiKCkge1xuICAgIGluaXRfZXNtKCk7XG4gICAgaW5pdF9lc20zKCk7XG4gICAgX19hd2FpdGVyOCA9IGZ1bmN0aW9uKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX19nZW5lcmF0b3I4ID0gZnVuY3Rpb24odGhpc0FyZywgYm9keSkge1xuICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRbMF0gJiAxKVxuICAgICAgICAgIHRocm93IHRbMV07XG4gICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KSwgZztcbiAgICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXylcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KVxuICAgICAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodFsyXSlcbiAgICAgICAgICAgICAgICAgIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpXG4gICAgICAgICAgdGhyb3cgb3BbMV07XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBTaW1wbGVTcGFuUHJvY2Vzc29yID0gLyoqIEBjbGFzcyAqL1xuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gU2ltcGxlU3BhblByb2Nlc3NvcjMoX2V4cG9ydGVyKSB7XG4gICAgICAgIHRoaXMuX2V4cG9ydGVyID0gX2V4cG9ydGVyO1xuICAgICAgICB0aGlzLl9zaHV0ZG93bk9uY2UgPSBuZXcgQmluZE9uY2VGdXR1cmUodGhpcy5fc2h1dGRvd24sIHRoaXMpO1xuICAgICAgICB0aGlzLl91bnJlc29sdmVkRXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBTaW1wbGVTcGFuUHJvY2Vzc29yMy5wcm90b3R5cGUuZm9yY2VGbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyOCh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yOCh0aGlzLCBmdW5jdGlvbihfYTIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EyLmxhYmVsKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIFByb21pc2UuYWxsKEFycmF5LmZyb20odGhpcy5fdW5yZXNvbHZlZEV4cG9ydHMpKV07XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYTIuc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZXhwb3J0ZXIuZm9yY2VGbHVzaClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLl9leHBvcnRlci5mb3JjZUZsdXNoKCldO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2EyLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYTIubGFiZWwgPSAzO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgIC8qcmV0dXJuKi9cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBTaW1wbGVTcGFuUHJvY2Vzc29yMy5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uKF9zcGFuLCBfcGFyZW50Q29udGV4dCkge1xuICAgICAgfTtcbiAgICAgIFNpbXBsZVNwYW5Qcm9jZXNzb3IzLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKHNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIGlmICh0aGlzLl9zaHV0ZG93bk9uY2UuaXNDYWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VGbGFncyAmIFRyYWNlRmxhZ3MuU0FNUExFRCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvRXhwb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVybmFsLl9leHBvcnQoX3RoaXMuX2V4cG9ydGVyLCBbc3Bhbl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jb2RlICE9PSBFeHBvcnRSZXN1bHRDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsRXJyb3JIYW5kbGVyKChfYTMgPSByZXN1bHQuZXJyb3IpICE9PSBudWxsICYmIF9hMyAhPT0gdm9pZCAwID8gX2EzIDogbmV3IEVycm9yKFwiU2ltcGxlU3BhblByb2Nlc3Nvcjogc3BhbiBleHBvcnQgZmFpbGVkIChzdGF0dXMgXCIgKyByZXN1bHQgKyBcIilcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBnbG9iYWxFcnJvckhhbmRsZXIoZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc3Bhbi5yZXNvdXJjZS5hc3luY0F0dHJpYnV0ZXNQZW5kaW5nKSB7XG4gICAgICAgICAgdmFyIGV4cG9ydFByb21pc2VfMSA9IChfYiA9IChfYTIgPSBzcGFuLnJlc291cmNlKS53YWl0Rm9yQXN5bmNBdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYTIpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZXhwb3J0UHJvbWlzZV8xICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX3VucmVzb2x2ZWRFeHBvcnRzLmRlbGV0ZShleHBvcnRQcm9taXNlXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvRXhwb3J0KCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGV4cG9ydFByb21pc2VfMSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnJlc29sdmVkRXhwb3J0cy5hZGQoZXhwb3J0UHJvbWlzZV8xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm9pZCBkb0V4cG9ydCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgU2ltcGxlU3BhblByb2Nlc3NvcjMucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaHV0ZG93bk9uY2UuY2FsbCgpO1xuICAgICAgfTtcbiAgICAgIFNpbXBsZVNwYW5Qcm9jZXNzb3IzLnByb3RvdHlwZS5fc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cG9ydGVyLnNodXRkb3duKCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFNpbXBsZVNwYW5Qcm9jZXNzb3IzO1xuICAgIH0oKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L1NwYW5FeHBvcnRlci5qc1xudmFyIGluaXRfU3BhbkV4cG9ydGVyID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vZXhwb3J0L1NwYW5FeHBvcnRlci5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9TcGFuUHJvY2Vzc29yLmpzXG52YXIgaW5pdF9TcGFuUHJvY2Vzc29yID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vU3BhblByb2Nlc3Nvci5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS9UaW1lZEV2ZW50LmpzXG52YXIgaW5pdF9UaW1lZEV2ZW50ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vVGltZWRFdmVudC5qc1wiKCkge1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1iYXNlL2J1aWxkL2VzbS90eXBlcy5qc1xudmFyIGluaXRfdHlwZXM1ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vdHlwZXMuanNcIigpIHtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vSWRHZW5lcmF0b3IuanNcbnZhciBpbml0X0lkR2VuZXJhdG9yMiA9IF9fZXNtKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL0lkR2VuZXJhdG9yLmpzXCIoKSB7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UvYnVpbGQvZXNtL2luZGV4LmpzXG52YXIgZXNtX2V4cG9ydHM2ID0ge307XG5fX2V4cG9ydChlc21fZXhwb3J0czYsIHtcbiAgQWx3YXlzT2ZmU2FtcGxlcjogKCkgPT4gQWx3YXlzT2ZmU2FtcGxlcjIsXG4gIEFsd2F5c09uU2FtcGxlcjogKCkgPT4gQWx3YXlzT25TYW1wbGVyMixcbiAgQmFzaWNUcmFjZXJQcm92aWRlcjogKCkgPT4gQmFzaWNUcmFjZXJQcm92aWRlcixcbiAgQmF0Y2hTcGFuUHJvY2Vzc29yOiAoKSA9PiBCYXRjaFNwYW5Qcm9jZXNzb3IsXG4gIENvbnNvbGVTcGFuRXhwb3J0ZXI6ICgpID0+IENvbnNvbGVTcGFuRXhwb3J0ZXIsXG4gIEZvcmNlRmx1c2hTdGF0ZTogKCkgPT4gRm9yY2VGbHVzaFN0YXRlLFxuICBJbk1lbW9yeVNwYW5FeHBvcnRlcjogKCkgPT4gSW5NZW1vcnlTcGFuRXhwb3J0ZXIsXG4gIE5vb3BTcGFuUHJvY2Vzc29yOiAoKSA9PiBOb29wU3BhblByb2Nlc3NvcixcbiAgUGFyZW50QmFzZWRTYW1wbGVyOiAoKSA9PiBQYXJlbnRCYXNlZFNhbXBsZXIyLFxuICBSYW5kb21JZEdlbmVyYXRvcjogKCkgPT4gUmFuZG9tSWRHZW5lcmF0b3IyLFxuICBTYW1wbGluZ0RlY2lzaW9uOiAoKSA9PiBTYW1wbGluZ0RlY2lzaW9uMixcbiAgU2ltcGxlU3BhblByb2Nlc3NvcjogKCkgPT4gU2ltcGxlU3BhblByb2Nlc3NvcixcbiAgU3BhbjogKCkgPT4gU3BhbixcbiAgVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyOiAoKSA9PiBUcmFjZUlkUmF0aW9CYXNlZFNhbXBsZXIyLFxuICBUcmFjZXI6ICgpID0+IFRyYWNlclxufSk7XG52YXIgaW5pdF9lc202ID0gX19lc20oe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZS9idWlsZC9lc20vaW5kZXguanNcIigpIHtcbiAgICBpbml0X1RyYWNlcigpO1xuICAgIGluaXRfQmFzaWNUcmFjZXJQcm92aWRlcigpO1xuICAgIGluaXRfcGxhdGZvcm0zKCk7XG4gICAgaW5pdF9Db25zb2xlU3BhbkV4cG9ydGVyKCk7XG4gICAgaW5pdF9Jbk1lbW9yeVNwYW5FeHBvcnRlcigpO1xuICAgIGluaXRfUmVhZGFibGVTcGFuKCk7XG4gICAgaW5pdF9TaW1wbGVTcGFuUHJvY2Vzc29yKCk7XG4gICAgaW5pdF9TcGFuRXhwb3J0ZXIoKTtcbiAgICBpbml0X05vb3BTcGFuUHJvY2Vzc29yKCk7XG4gICAgaW5pdF9BbHdheXNPZmZTYW1wbGVyMigpO1xuICAgIGluaXRfQWx3YXlzT25TYW1wbGVyMigpO1xuICAgIGluaXRfUGFyZW50QmFzZWRTYW1wbGVyMigpO1xuICAgIGluaXRfVHJhY2VJZFJhdGlvQmFzZWRTYW1wbGVyMigpO1xuICAgIGluaXRfU2FtcGxlcigpO1xuICAgIGluaXRfU3BhbigpO1xuICAgIGluaXRfU3BhblByb2Nlc3NvcigpO1xuICAgIGluaXRfVGltZWRFdmVudCgpO1xuICAgIGluaXRfdHlwZXM1KCk7XG4gICAgaW5pdF9JZEdlbmVyYXRvcjIoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvY29uc3RhbnRzLmpzXG52YXIgcmVxdWlyZV9jb25zdGFudHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgU0VNVkVSX1NQRUNfVkVSU0lPTiA9IFwiMi4wLjBcIjtcbiAgICB2YXIgTUFYX0xFTkdUSCA9IDI1NjtcbiAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOTAwNzE5OTI1NDc0MDk5MTtcbiAgICB2YXIgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2O1xuICAgIHZhciBNQVhfU0FGRV9CVUlMRF9MRU5HVEggPSBNQVhfTEVOR1RIIC0gNjtcbiAgICB2YXIgUkVMRUFTRV9UWVBFUyA9IFtcbiAgICAgIFwibWFqb3JcIixcbiAgICAgIFwicHJlbWFqb3JcIixcbiAgICAgIFwibWlub3JcIixcbiAgICAgIFwicHJlbWlub3JcIixcbiAgICAgIFwicGF0Y2hcIixcbiAgICAgIFwicHJlcGF0Y2hcIixcbiAgICAgIFwicHJlcmVsZWFzZVwiXG4gICAgXTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBNQVhfTEVOR1RILFxuICAgICAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgICAgIE1BWF9TQUZFX0JVSUxEX0xFTkdUSCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBSRUxFQVNFX1RZUEVTLFxuICAgICAgU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgICAgIEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFOiAxLFxuICAgICAgRkxBR19MT09TRTogMlxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzXG52YXIgcmVxdWlyZV9kZWJ1ZyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGRlYnVnID0gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJiAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKFwiU0VNVkVSXCIsIC4uLmFyZ3MpIDogKCkgPT4ge1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZGVidWc7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzXG52YXIgcmVxdWlyZV9yZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcmUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIHtcbiAgICAgIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgsXG4gICAgICBNQVhfU0FGRV9CVUlMRF9MRU5HVEgsXG4gICAgICBNQVhfTEVOR1RIXG4gICAgfSA9IHJlcXVpcmVfY29uc3RhbnRzKCk7XG4gICAgdmFyIGRlYnVnID0gcmVxdWlyZV9kZWJ1ZygpO1xuICAgIGV4cG9ydHMgPSBtb2R1bGUyLmV4cG9ydHMgPSB7fTtcbiAgICB2YXIgcmUyID0gZXhwb3J0cy5yZSA9IFtdO1xuICAgIHZhciBzYWZlUmUgPSBleHBvcnRzLnNhZmVSZSA9IFtdO1xuICAgIHZhciBzcmMgPSBleHBvcnRzLnNyYyA9IFtdO1xuICAgIHZhciB0ID0gZXhwb3J0cy50ID0ge307XG4gICAgdmFyIFIgPSAwO1xuICAgIHZhciBMRVRURVJEQVNITlVNQkVSID0gXCJbYS16QS1aMC05LV1cIjtcbiAgICB2YXIgc2FmZVJlZ2V4UmVwbGFjZW1lbnRzID0gW1xuICAgICAgW1wiXFxcXHNcIiwgMV0sXG4gICAgICBbXCJcXFxcZFwiLCBNQVhfTEVOR1RIXSxcbiAgICAgIFtMRVRURVJEQVNITlVNQkVSLCBNQVhfU0FGRV9CVUlMRF9MRU5HVEhdXG4gICAgXTtcbiAgICB2YXIgbWFrZVNhZmVSZWdleCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbdG9rZW4sIG1heF0gb2Ygc2FmZVJlZ2V4UmVwbGFjZW1lbnRzKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoYCR7dG9rZW59KmApLmpvaW4oYCR7dG9rZW59ezAsJHttYXh9fWApLnNwbGl0KGAke3Rva2VufStgKS5qb2luKGAke3Rva2VufXsxLCR7bWF4fX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgICAgIGNvbnN0IHNhZmUgPSBtYWtlU2FmZVJlZ2V4KHZhbHVlKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gUisrO1xuICAgICAgZGVidWcobmFtZSwgaW5kZXgsIHZhbHVlKTtcbiAgICAgIHRbbmFtZV0gPSBpbmRleDtcbiAgICAgIHNyY1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgIHJlMltpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/IFwiZ1wiIDogdm9pZCAwKTtcbiAgICAgIHNhZmVSZVtpbmRleF0gPSBuZXcgUmVnRXhwKHNhZmUsIGlzR2xvYmFsID8gXCJnXCIgOiB2b2lkIDApO1xuICAgIH07XG4gICAgY3JlYXRlVG9rZW4oXCJOVU1FUklDSURFTlRJRklFUlwiLCBcIjB8WzEtOV1cXFxcZCpcIik7XG4gICAgY3JlYXRlVG9rZW4oXCJOVU1FUklDSURFTlRJRklFUkxPT1NFXCIsIFwiXFxcXGQrXCIpO1xuICAgIGNyZWF0ZVRva2VuKFwiTk9OTlVNRVJJQ0lERU5USUZJRVJcIiwgYFxcXFxkKlthLXpBLVotXSR7TEVUVEVSREFTSE5VTUJFUn0qYCk7XG4gICAgY3JlYXRlVG9rZW4oXCJNQUlOVkVSU0lPTlwiLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLigke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC4oJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApO1xuICAgIGNyZWF0ZVRva2VuKFwiTUFJTlZFUlNJT05MT09TRVwiLCBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KWApO1xuICAgIGNyZWF0ZVRva2VuKFwiUFJFUkVMRUFTRUlERU5USUZJRVJcIiwgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYCk7XG4gICAgY3JlYXRlVG9rZW4oXCJQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXCIsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYCk7XG4gICAgY3JlYXRlVG9rZW4oXCJQUkVSRUxFQVNFXCIsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdfSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApO1xuICAgIGNyZWF0ZVRva2VuKFwiUFJFUkVMRUFTRUxPT1NFXCIsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYCk7XG4gICAgY3JlYXRlVG9rZW4oXCJCVUlMRElERU5USUZJRVJcIiwgYCR7TEVUVEVSREFTSE5VTUJFUn0rYCk7XG4gICAgY3JlYXRlVG9rZW4oXCJCVUlMRFwiLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKTtcbiAgICBjcmVhdGVUb2tlbihcIkZVTExQTEFJTlwiLCBgdj8ke3NyY1t0Lk1BSU5WRVJTSU9OXX0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke3NyY1t0LkJVSUxEXX0/YCk7XG4gICAgY3JlYXRlVG9rZW4oXCJGVUxMXCIsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKTtcbiAgICBjcmVhdGVUb2tlbihcIkxPT1NFUExBSU5cIiwgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdfSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtzcmNbdC5CVUlMRF19P2ApO1xuICAgIGNyZWF0ZVRva2VuKFwiTE9PU0VcIiwgYF4ke3NyY1t0LkxPT1NFUExBSU5dfSRgKTtcbiAgICBjcmVhdGVUb2tlbihcIkdUTFRcIiwgXCIoKD86PHw+KT89PylcIik7XG4gICAgY3JlYXRlVG9rZW4oXCJYUkFOR0VJREVOVElGSUVSTE9PU0VcIiwgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19fHh8WHxcXFxcKmApO1xuICAgIGNyZWF0ZVRva2VuKFwiWFJBTkdFSURFTlRJRklFUlwiLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApO1xuICAgIGNyZWF0ZVRva2VuKFwiWFJBTkdFUExBSU5cIiwgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pPyR7c3JjW3QuQlVJTERdfT8pPyk/YCk7XG4gICAgY3JlYXRlVG9rZW4oXCJYUkFOR0VQTEFJTkxPT1NFXCIsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSkoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KSg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7c3JjW3QuQlVJTERdfT8pPyk/YCk7XG4gICAgY3JlYXRlVG9rZW4oXCJYUkFOR0VcIiwgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKTtcbiAgICBjcmVhdGVUb2tlbihcIlhSQU5HRUxPT1NFXCIsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKTtcbiAgICBjcmVhdGVUb2tlbihcIkNPRVJDRVwiLCBgJHtcIihefFteXFxcXGRdKShcXFxcZHsxLFwifSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT8oPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/KD86JHxbXlxcXFxkXSlgKTtcbiAgICBjcmVhdGVUb2tlbihcIkNPRVJDRVJUTFwiLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKTtcbiAgICBjcmVhdGVUb2tlbihcIkxPTkVUSUxERVwiLCBcIig/On4+PylcIik7XG4gICAgY3JlYXRlVG9rZW4oXCJUSUxERVRSSU1cIiwgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpO1xuICAgIGV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9IFwiJDF+XCI7XG4gICAgY3JlYXRlVG9rZW4oXCJUSUxERVwiLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYCk7XG4gICAgY3JlYXRlVG9rZW4oXCJUSUxERUxPT1NFXCIsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApO1xuICAgIGNyZWF0ZVRva2VuKFwiTE9ORUNBUkVUXCIsIFwiKD86XFxcXF4pXCIpO1xuICAgIGNyZWF0ZVRva2VuKFwiQ0FSRVRUUklNXCIsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKTtcbiAgICBleHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSBcIiQxXlwiO1xuICAgIGNyZWF0ZVRva2VuKFwiQ0FSRVRcIiwgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApO1xuICAgIGNyZWF0ZVRva2VuKFwiQ0FSRVRMT09TRVwiLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKTtcbiAgICBjcmVhdGVUb2tlbihcIkNPTVBBUkFUT1JMT09TRVwiLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKTtcbiAgICBjcmVhdGVUb2tlbihcIkNPTVBBUkFUT1JcIiwgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKTtcbiAgICBjcmVhdGVUb2tlbihcIkNPTVBBUkFUT1JUUklNXCIsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKTtcbiAgICBleHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9IFwiJDEkMiQzXCI7XG4gICAgY3JlYXRlVG9rZW4oXCJIWVBIRU5SQU5HRVwiLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pXFxcXHMrLVxcXFxzKygke3NyY1t0LlhSQU5HRVBMQUlOXX0pXFxcXHMqJGApO1xuICAgIGNyZWF0ZVRva2VuKFwiSFlQSEVOUkFOR0VMT09TRVwiLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlcXFxccystXFxcXHMrKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KVxcXFxzKiRgKTtcbiAgICBjcmVhdGVUb2tlbihcIlNUQVJcIiwgXCIoPHw+KT89P1xcXFxzKlxcXFwqXCIpO1xuICAgIGNyZWF0ZVRva2VuKFwiR1RFMFwiLCBcIl5cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjBcXFxccyokXCIpO1xuICAgIGNyZWF0ZVRva2VuKFwiR1RFMFBSRVwiLCBcIl5cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjAtMFxcXFxzKiRcIik7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanNcbnZhciByZXF1aXJlX3BhcnNlX29wdGlvbnMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGxvb3NlT3B0aW9uID0gT2JqZWN0LmZyZWV6ZSh7IGxvb3NlOiB0cnVlIH0pO1xuICAgIHZhciBlbXB0eU9wdHMgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICB2YXIgcGFyc2VPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZW1wdHlPcHRzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBsb29zZU9wdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcGFyc2VPcHRpb25zO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qc1xudmFyIHJlcXVpcmVfaWRlbnRpZmllcnMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBudW1lcmljID0gL15bMC05XSskLztcbiAgICB2YXIgY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSk7XG4gICAgICBjb25zdCBibnVtID0gbnVtZXJpYy50ZXN0KGIpO1xuICAgICAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGFudW0gJiYgIWJudW0gPyAtMSA6IGJudW0gJiYgIWFudW0gPyAxIDogYSA8IGIgPyAtMSA6IDE7XG4gICAgfTtcbiAgICB2YXIgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgY29tcGFyZUlkZW50aWZpZXJzLFxuICAgICAgcmNvbXBhcmVJZGVudGlmaWVyc1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzXG52YXIgcmVxdWlyZV9zZW12ZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBkZWJ1ZyA9IHJlcXVpcmVfZGVidWcoKTtcbiAgICB2YXIgeyBNQVhfTEVOR1RILCBNQVhfU0FGRV9JTlRFR0VSIH0gPSByZXF1aXJlX2NvbnN0YW50cygpO1xuICAgIHZhciB7IHNhZmVSZTogcmUyLCB0IH0gPSByZXF1aXJlX3JlKCk7XG4gICAgdmFyIHBhcnNlT3B0aW9ucyA9IHJlcXVpcmVfcGFyc2Vfb3B0aW9ucygpO1xuICAgIHZhciB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZV9pZGVudGlmaWVycygpO1xuICAgIHZhciBTZW1WZXIgPSBjbGFzcyBfU2VtVmVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBfU2VtVmVyKSB7XG4gICAgICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJiB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmVyc2lvbi4gTXVzdCBiZSBhIHN0cmluZy4gR290IHR5cGUgXCIke3R5cGVvZiB2ZXJzaW9ufVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYHZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJHtNQVhfTEVOR1RIfSBjaGFyYWN0ZXJzYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJTZW1WZXJcIiwgdmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2U7XG4gICAgICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2U7XG4gICAgICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmUyW3QuTE9PU0VdIDogcmUyW3QuRlVMTF0pO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHZlcnNpb247XG4gICAgICAgIHRoaXMubWFqb3IgPSArbVsxXTtcbiAgICAgICAgdGhpcy5taW5vciA9ICttWzJdO1xuICAgICAgICB0aGlzLnBhdGNoID0gK21bM107XG4gICAgICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIG1ham9yIHZlcnNpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWlub3IgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgbWlub3IgdmVyc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBwYXRjaCB2ZXJzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbVs0XSkge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IG1bNF0uc3BsaXQoXCIuXCIpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG51bSA9ICtpZDtcbiAgICAgICAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KFwiLlwiKSA6IFtdO1xuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgICAgfVxuICAgICAgZm9ybWF0KCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gO1xuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oXCIuXCIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgICAgfVxuICAgICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICBkZWJ1ZyhcIlNlbVZlci5jb21wYXJlXCIsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcik7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgX1NlbVZlcikpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG90aGVyID09PSBcInN0cmluZ1wiICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdGhlciA9IG5ldyBfU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKTtcbiAgICAgIH1cbiAgICAgIGNvbXBhcmVNYWluKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgX1NlbVZlcikpIHtcbiAgICAgICAgICBvdGhlciA9IG5ldyBfU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8IGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHwgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKTtcbiAgICAgIH1cbiAgICAgIGNvbXBhcmVQcmUob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBfU2VtVmVyKSkge1xuICAgICAgICAgIG90aGVyID0gbmV3IF9TZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY29uc3QgYSA9IHRoaXMucHJlcmVsZWFzZVtpXTtcbiAgICAgICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTtcbiAgICAgICAgICBkZWJ1ZyhcInByZXJlbGVhc2UgY29tcGFyZVwiLCBpLCBhLCBiKTtcbiAgICAgICAgICBpZiAoYSA9PT0gdm9pZCAwICYmIGIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChiID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCsraSk7XG4gICAgICB9XG4gICAgICBjb21wYXJlQnVpbGQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBfU2VtVmVyKSkge1xuICAgICAgICAgIG90aGVyID0gbmV3IF9TZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV07XG4gICAgICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldO1xuICAgICAgICAgIGRlYnVnKFwicHJlcmVsZWFzZSBjb21wYXJlXCIsIGksIGEsIGIpO1xuICAgICAgICAgIGlmIChhID09PSB2b2lkIDAgJiYgYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKytpKTtcbiAgICAgIH1cbiAgICAgIC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cbiAgICAgIGluYyhyZWxlYXNlMiwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICAgICAgc3dpdGNoIChyZWxlYXNlMikge1xuICAgICAgICAgIGNhc2UgXCJwcmVtYWpvclwiOlxuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgICAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgICAgICAgdGhpcy5pbmMoXCJwcmVcIiwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInByZW1pbm9yXCI6XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgICAgICAgdGhpcy5pbmMoXCJwcmVcIiwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInByZXBhdGNoXCI6XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5jKFwicGF0Y2hcIiwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpO1xuICAgICAgICAgICAgdGhpcy5pbmMoXCJwcmVcIiwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInByZXJlbGVhc2VcIjpcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5jKFwicGF0Y2hcIiwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmMoXCJwcmVcIiwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1ham9yXCI6XG4gICAgICAgICAgICBpZiAodGhpcy5taW5vciAhPT0gMCB8fCB0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICAgICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1pbm9yXCI6XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMubWlub3IrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicGF0Y2hcIjpcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMucGF0Y2grKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInByZVwiOiB7XG4gICAgICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwO1xuICAgICAgICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBpcyBlbXB0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtiYXNlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldCBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrO1xuICAgICAgICAgICAgICAgICAgaSA9IC0yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oXCIuXCIpICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXTtcbiAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJHtyZWxlYXNlMn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHRoaXMuZm9ybWF0KCk7XG4gICAgICAgIGlmICh0aGlzLmJ1aWxkLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucmF3ICs9IGArJHt0aGlzLmJ1aWxkLmpvaW4oXCIuXCIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBTZW1WZXI7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qc1xudmFyIHJlcXVpcmVfcGFyc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgU2VtVmVyID0gcmVxdWlyZV9zZW12ZXIoKTtcbiAgICB2YXIgcGFyc2U0ID0gKHZlcnNpb24sIG9wdGlvbnMsIHRocm93RXJyb3JzID0gZmFsc2UpID0+IHtcbiAgICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoIXRocm93RXJyb3JzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXI7XG4gICAgICB9XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwYXJzZTQ7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qc1xudmFyIHJlcXVpcmVfdmFsaWQgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgcGFyc2U0ID0gcmVxdWlyZV9wYXJzZSgpO1xuICAgIHZhciB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCB2ID0gcGFyc2U0KHZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gdmFsaWQ7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qc1xudmFyIHJlcXVpcmVfY2xlYW4gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgcGFyc2U0ID0gcmVxdWlyZV9wYXJzZSgpO1xuICAgIHZhciBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBzID0gcGFyc2U0KHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sIFwiXCIpLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbDtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNsZWFuO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvaW5jLmpzXG52YXIgcmVxdWlyZV9pbmMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIFNlbVZlciA9IHJlcXVpcmVfc2VtdmVyKCk7XG4gICAgdmFyIGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlMiwgb3B0aW9ucywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZGVudGlmaWVyQmFzZSA9IGlkZW50aWZpZXI7XG4gICAgICAgIGlkZW50aWZpZXIgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZW1WZXIoXG4gICAgICAgICAgdmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlciA/IHZlcnNpb24udmVyc2lvbiA6IHZlcnNpb24sXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApLmluYyhyZWxlYXNlMiwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpLnZlcnNpb247XG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGluYztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanNcbnZhciByZXF1aXJlX2RpZmYgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBwYXJzZTQgPSByZXF1aXJlX3BhcnNlKCk7XG4gICAgdmFyIGRpZmYgPSAodmVyc2lvbjEsIHZlcnNpb24yKSA9PiB7XG4gICAgICBjb25zdCB2MSA9IHBhcnNlNCh2ZXJzaW9uMSwgbnVsbCwgdHJ1ZSk7XG4gICAgICBjb25zdCB2MiA9IHBhcnNlNCh2ZXJzaW9uMiwgbnVsbCwgdHJ1ZSk7XG4gICAgICBjb25zdCBjb21wYXJpc29uID0gdjEuY29tcGFyZSh2Mik7XG4gICAgICBpZiAoY29tcGFyaXNvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHYxSGlnaGVyID0gY29tcGFyaXNvbiA+IDA7XG4gICAgICBjb25zdCBoaWdoVmVyc2lvbiA9IHYxSGlnaGVyID8gdjEgOiB2MjtcbiAgICAgIGNvbnN0IGxvd1ZlcnNpb24gPSB2MUhpZ2hlciA/IHYyIDogdjE7XG4gICAgICBjb25zdCBoaWdoSGFzUHJlID0gISFoaWdoVmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGxvd0hhc1ByZSA9ICEhbG93VmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgIGlmIChsb3dIYXNQcmUgJiYgIWhpZ2hIYXNQcmUpIHtcbiAgICAgICAgaWYgKCFsb3dWZXJzaW9uLnBhdGNoICYmICFsb3dWZXJzaW9uLm1pbm9yKSB7XG4gICAgICAgICAgcmV0dXJuIFwibWFqb3JcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlnaFZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gXCJwYXRjaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdoVmVyc2lvbi5taW5vcikge1xuICAgICAgICAgIHJldHVybiBcIm1pbm9yXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibWFqb3JcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZWZpeCA9IGhpZ2hIYXNQcmUgPyBcInByZVwiIDogXCJcIjtcbiAgICAgIGlmICh2MS5tYWpvciAhPT0gdjIubWFqb3IpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIFwibWFqb3JcIjtcbiAgICAgIH1cbiAgICAgIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIFwibWlub3JcIjtcbiAgICAgIH1cbiAgICAgIGlmICh2MS5wYXRjaCAhPT0gdjIucGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIFwicGF0Y2hcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcInByZXJlbGVhc2VcIjtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGRpZmY7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qc1xudmFyIHJlcXVpcmVfbWFqb3IgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgU2VtVmVyID0gcmVxdWlyZV9zZW12ZXIoKTtcbiAgICB2YXIgbWFqb3IyID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvcjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBtYWpvcjI7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qc1xudmFyIHJlcXVpcmVfbWlub3IgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgU2VtVmVyID0gcmVxdWlyZV9zZW12ZXIoKTtcbiAgICB2YXIgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IG1pbm9yO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanNcbnZhciByZXF1aXJlX3BhdGNoID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIFNlbVZlciA9IHJlcXVpcmVfc2VtdmVyKCk7XG4gICAgdmFyIHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaDtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwYXRjaDtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ByZXJlbGVhc2UuanNcbnZhciByZXF1aXJlX3ByZXJlbGVhc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBwYXJzZTQgPSByZXF1aXJlX3BhcnNlKCk7XG4gICAgdmFyIHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2U0KHZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGggPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGw7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwcmVyZWxlYXNlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS5qc1xudmFyIHJlcXVpcmVfY29tcGFyZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIFNlbVZlciA9IHJlcXVpcmVfc2VtdmVyKCk7XG4gICAgdmFyIGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNvbXBhcmU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yY29tcGFyZS5qc1xudmFyIHJlcXVpcmVfcmNvbXBhcmUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yY29tcGFyZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY29tcGFyZSA9IHJlcXVpcmVfY29tcGFyZSgpO1xuICAgIHZhciByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmNvbXBhcmU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlLmpzXG52YXIgcmVxdWlyZV9jb21wYXJlX2xvb3NlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY29tcGFyZSA9IHJlcXVpcmVfY29tcGFyZSgpO1xuICAgIHZhciBjb21wYXJlTG9vc2UgPSAoYSwgYikgPT4gY29tcGFyZShhLCBiLCB0cnVlKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBjb21wYXJlTG9vc2U7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzXG52YXIgcmVxdWlyZV9jb21wYXJlX2J1aWxkID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1idWlsZC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgU2VtVmVyID0gcmVxdWlyZV9zZW12ZXIoKTtcbiAgICB2YXIgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gICAgICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpO1xuICAgICAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKTtcbiAgICAgIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY29tcGFyZUJ1aWxkO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc29ydC5qc1xudmFyIHJlcXVpcmVfc29ydCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NvcnQuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGNvbXBhcmVCdWlsZCA9IHJlcXVpcmVfY29tcGFyZV9idWlsZCgpO1xuICAgIHZhciBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHNvcnQ7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qc1xudmFyIHJlcXVpcmVfcnNvcnQgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY29tcGFyZUJ1aWxkID0gcmVxdWlyZV9jb21wYXJlX2J1aWxkKCk7XG4gICAgdmFyIHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJzb3J0O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3QuanNcbnZhciByZXF1aXJlX2d0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3QuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGNvbXBhcmUgPSByZXF1aXJlX2NvbXBhcmUoKTtcbiAgICB2YXIgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMDtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBndDtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzXG52YXIgcmVxdWlyZV9sdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBjb21wYXJlID0gcmVxdWlyZV9jb21wYXJlKCk7XG4gICAgdmFyIGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDA7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gbHQ7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9lcS5qc1xudmFyIHJlcXVpcmVfZXEgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9lcS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY29tcGFyZSA9IHJlcXVpcmVfY29tcGFyZSgpO1xuICAgIHZhciBlcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDA7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZXE7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9uZXEuanNcbnZhciByZXF1aXJlX25lcSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY29tcGFyZSA9IHJlcXVpcmVfY29tcGFyZSgpO1xuICAgIHZhciBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IG5lcTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qc1xudmFyIHJlcXVpcmVfZ3RlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBjb21wYXJlID0gcmVxdWlyZV9jb21wYXJlKCk7XG4gICAgdmFyIGd0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMDtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBndGU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanNcbnZhciByZXF1aXJlX2x0ZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0ZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgY29tcGFyZSA9IHJlcXVpcmVfY29tcGFyZSgpO1xuICAgIHZhciBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDA7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gbHRlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzXG52YXIgcmVxdWlyZV9jbXAgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGVxID0gcmVxdWlyZV9lcSgpO1xuICAgIHZhciBuZXEgPSByZXF1aXJlX25lcSgpO1xuICAgIHZhciBndCA9IHJlcXVpcmVfZ3QoKTtcbiAgICB2YXIgZ3RlID0gcmVxdWlyZV9ndGUoKTtcbiAgICB2YXIgbHQgPSByZXF1aXJlX2x0KCk7XG4gICAgdmFyIGx0ZSA9IHJlcXVpcmVfbHRlKCk7XG4gICAgdmFyIGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSBcIj09PVwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYSA9IGEudmVyc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBiID0gYi52ZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgY2FzZSBcIiE9PVwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYSA9IGEudmVyc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBiID0gYi52ZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYSAhPT0gYjtcbiAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpO1xuICAgICAgICBjYXNlIFwiIT1cIjpcbiAgICAgICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKTtcbiAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpO1xuICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKTtcbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpO1xuICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApO1xuICAgICAgfVxuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gY21wO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzXG52YXIgcmVxdWlyZV9jb2VyY2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIFNlbVZlciA9IHJlcXVpcmVfc2VtdmVyKCk7XG4gICAgdmFyIHBhcnNlNCA9IHJlcXVpcmVfcGFyc2UoKTtcbiAgICB2YXIgeyBzYWZlUmU6IHJlMiwgdCB9ID0gcmVxdWlyZV9yZSgpO1xuICAgIHZhciBjb2VyY2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgIGlmICghb3B0aW9ucy5ydGwpIHtcbiAgICAgICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlMlt0LkNPRVJDRV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIHdoaWxlICgobmV4dCA9IHJlMlt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaCB8fCBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXRjaCA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlMlt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gbmV4dC5pbmRleCArIG5leHRbMV0ubGVuZ3RoICsgbmV4dFsyXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmUyW3QuQ09FUkNFUlRMXS5sYXN0SW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZTQoYCR7bWF0Y2hbMl19LiR7bWF0Y2hbM10gfHwgXCIwXCJ9LiR7bWF0Y2hbNF0gfHwgXCIwXCJ9YCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBjb2VyY2U7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qc1xudmFyIHJlcXVpcmVfaXRlcmF0b3IgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihZYWxsaXN0KSB7XG4gICAgICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXI7IHdhbGtlciA9IHdhbGtlci5uZXh0KSB7XG4gICAgICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzXG52YXIgcmVxdWlyZV95YWxsaXN0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBZYWxsaXN0O1xuICAgIFlhbGxpc3QuTm9kZSA9IE5vZGU7XG4gICAgWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0O1xuICAgIGZ1bmN0aW9uIFlhbGxpc3QobGlzdCkge1xuICAgICAgdmFyIHNlbGYyID0gdGhpcztcbiAgICAgIGlmICghKHNlbGYyIGluc3RhbmNlb2YgWWFsbGlzdCkpIHtcbiAgICAgICAgc2VsZjIgPSBuZXcgWWFsbGlzdCgpO1xuICAgICAgfVxuICAgICAgc2VsZjIudGFpbCA9IG51bGw7XG4gICAgICBzZWxmMi5oZWFkID0gbnVsbDtcbiAgICAgIHNlbGYyLmxlbmd0aCA9IDA7XG4gICAgICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBzZWxmMi5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgc2VsZjIucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjI7XG4gICAgfVxuICAgIFlhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgdmFyIHByZXYgPSBub2RlLnByZXY7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgfVxuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgdGhpcy50YWlsID0gcHJldjtcbiAgICAgIH1cbiAgICAgIG5vZGUubGlzdC5sZW5ndGgtLTtcbiAgICAgIG5vZGUubmV4dCA9IG51bGw7XG4gICAgICBub2RlLnByZXYgPSBudWxsO1xuICAgICAgbm9kZS5saXN0ID0gbnVsbDtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gICAgWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmxpc3QpIHtcbiAgICAgICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZDtcbiAgICAgIG5vZGUubGlzdCA9IHRoaXM7XG4gICAgICBub2RlLm5leHQgPSBoZWFkO1xuICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5wcmV2ID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICBpZiAoIXRoaXMudGFpbCkge1xuICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9O1xuICAgIFlhbGxpc3QucHJvdG90eXBlLnB1c2hOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5saXN0KSB7XG4gICAgICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgfVxuICAgICAgdmFyIHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgICBub2RlLmxpc3QgPSB0aGlzO1xuICAgICAgbm9kZS5wcmV2ID0gdGFpbDtcbiAgICAgIGlmICh0YWlsKSB7XG4gICAgICAgIHRhaWwubmV4dCA9IG5vZGU7XG4gICAgICB9XG4gICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfTtcbiAgICBZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcHVzaCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH07XG4gICAgWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHVuc2hpZnQodGhpcywgYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9O1xuICAgIFlhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWU7XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldjtcbiAgICAgIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdGhpcy5oZWFkLnZhbHVlO1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFlhbGxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmbiwgdGhpc3ApIHtcbiAgICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgICAgIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgaSwgdGhpcyk7XG4gICAgICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICAgICAgfVxuICAgIH07XG4gICAgWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbihmbiwgdGhpc3ApIHtcbiAgICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgICAgIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKTtcbiAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gICAgICB9XG4gICAgfTtcbiAgICBZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgICAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLnZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgWWFsbGlzdC5wcm90b3R5cGUuZ2V0UmV2ZXJzZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmbiwgdGhpc3ApIHtcbiAgICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgICAgIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpO1xuICAgICAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7ICkge1xuICAgICAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKTtcbiAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgWWFsbGlzdC5wcm90b3R5cGUubWFwUmV2ZXJzZSA9IGZ1bmN0aW9uKGZuLCB0aGlzcCkge1xuICAgICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICAgICAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KCk7XG4gICAgICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgKSB7XG4gICAgICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpO1xuICAgICAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbihmbiwgaW5pdGlhbCkge1xuICAgICAgdmFyIGFjYztcbiAgICAgIHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYWNjID0gaW5pdGlhbDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgIHdhbGtlciA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKTtcbiAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH07XG4gICAgWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uKGZuLCBpbml0aWFsKSB7XG4gICAgICB2YXIgYWNjO1xuICAgICAgdmFyIHdhbGtlciA9IHRoaXMudGFpbDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBhY2MgPSBpbml0aWFsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXY7XG4gICAgICAgIGFjYyA9IHRoaXMudGFpbC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgICAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSk7XG4gICAgICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIFlhbGxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlO1xuICAgICAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgICBZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWU7XG4gICAgICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICAgIFlhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgIHRvID0gdG8gfHwgdGhpcy5sZW5ndGg7XG4gICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgIHRvICs9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZnJvbSA9IGZyb20gfHwgMDtcbiAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBmcm9tICs9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KCk7XG4gICAgICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGZyb20gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdG8gPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICAgICAgfVxuICAgICAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aDtcbiAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgdG8gKz0gdGhpcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmcm9tID0gZnJvbSB8fCAwO1xuICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGZyb20gKz0gdGhpcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKTtcbiAgICAgIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgZnJvbSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0byA9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgICAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgICAgIH1cbiAgICAgIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICAgICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbihzdGFydCwgZGVsZXRlQ291bnQsIC4uLm5vZGVzKSB7XG4gICAgICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICAgICAgfVxuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgICAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpO1xuICAgICAgICB3YWxrZXIgPSB0aGlzLnJlbW92ZU5vZGUod2Fsa2VyKTtcbiAgICAgIH1cbiAgICAgIGlmICh3YWxrZXIgPT09IG51bGwpIHtcbiAgICAgICAgd2Fsa2VyID0gdGhpcy50YWlsO1xuICAgICAgfVxuICAgICAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgWWFsbGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgdGFpbCA9IHRoaXMudGFpbDtcbiAgICAgIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICAgICAgdmFyIHAgPSB3YWxrZXIucHJldjtcbiAgICAgICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dDtcbiAgICAgICAgd2Fsa2VyLm5leHQgPSBwO1xuICAgICAgfVxuICAgICAgdGhpcy5oZWFkID0gdGFpbDtcbiAgICAgIHRoaXMudGFpbCA9IGhlYWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGluc2VydChzZWxmMiwgbm9kZSwgdmFsdWUpIHtcbiAgICAgIHZhciBpbnNlcnRlZCA9IG5vZGUgPT09IHNlbGYyLmhlYWQgPyBuZXcgTm9kZSh2YWx1ZSwgbnVsbCwgbm9kZSwgc2VsZjIpIDogbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZjIpO1xuICAgICAgaWYgKGluc2VydGVkLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgc2VsZjIudGFpbCA9IGluc2VydGVkO1xuICAgICAgfVxuICAgICAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICAgICAgc2VsZjIuaGVhZCA9IGluc2VydGVkO1xuICAgICAgfVxuICAgICAgc2VsZjIubGVuZ3RoKys7XG4gICAgICByZXR1cm4gaW5zZXJ0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goc2VsZjIsIGl0ZW0pIHtcbiAgICAgIHNlbGYyLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmMi50YWlsLCBudWxsLCBzZWxmMik7XG4gICAgICBpZiAoIXNlbGYyLmhlYWQpIHtcbiAgICAgICAgc2VsZjIuaGVhZCA9IHNlbGYyLnRhaWw7XG4gICAgICB9XG4gICAgICBzZWxmMi5sZW5ndGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zaGlmdChzZWxmMiwgaXRlbSkge1xuICAgICAgc2VsZjIuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYyLmhlYWQsIHNlbGYyKTtcbiAgICAgIGlmICghc2VsZjIudGFpbCkge1xuICAgICAgICBzZWxmMi50YWlsID0gc2VsZjIuaGVhZDtcbiAgICAgIH1cbiAgICAgIHNlbGYyLmxlbmd0aCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBwcmV2Lm5leHQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIG5leHQucHJldiA9IHRoaXM7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmVxdWlyZV9pdGVyYXRvcigpKFlhbGxpc3QpO1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfbHJ1X2NhY2hlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgWWFsbGlzdCA9IHJlcXVpcmVfeWFsbGlzdCgpO1xuICAgIHZhciBNQVggPSBTeW1ib2woXCJtYXhcIik7XG4gICAgdmFyIExFTkdUSCA9IFN5bWJvbChcImxlbmd0aFwiKTtcbiAgICB2YXIgTEVOR1RIX0NBTENVTEFUT1IgPSBTeW1ib2woXCJsZW5ndGhDYWxjdWxhdG9yXCIpO1xuICAgIHZhciBBTExPV19TVEFMRSA9IFN5bWJvbChcImFsbG93U3RhbGVcIik7XG4gICAgdmFyIE1BWF9BR0UgPSBTeW1ib2woXCJtYXhBZ2VcIik7XG4gICAgdmFyIERJU1BPU0UgPSBTeW1ib2woXCJkaXNwb3NlXCIpO1xuICAgIHZhciBOT19ESVNQT1NFX09OX1NFVCA9IFN5bWJvbChcIm5vRGlzcG9zZU9uU2V0XCIpO1xuICAgIHZhciBMUlVfTElTVCA9IFN5bWJvbChcImxydUxpc3RcIik7XG4gICAgdmFyIENBQ0hFID0gU3ltYm9sKFwiY2FjaGVcIik7XG4gICAgdmFyIFVQREFURV9BR0VfT05fR0VUID0gU3ltYm9sKFwidXBkYXRlQWdlT25HZXRcIik7XG4gICAgdmFyIG5haXZlTGVuZ3RoID0gKCkgPT4gMTtcbiAgICB2YXIgTFJVQ2FjaGUgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfTtcbiAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4ICYmICh0eXBlb2Ygb3B0aW9ucy5tYXggIT09IFwibnVtYmVyXCIgfHwgb3B0aW9ucy5tYXggPCAwKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heCB8fCBJbmZpbml0eTtcbiAgICAgICAgY29uc3QgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aDtcbiAgICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSB0eXBlb2YgbGMgIT09IFwiZnVuY3Rpb25cIiA/IG5haXZlTGVuZ3RoIDogbGM7XG4gICAgICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4QWdlICYmIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWF4QWdlIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgIHRoaXNbTUFYX0FHRV0gPSBvcHRpb25zLm1heEFnZSB8fCAwO1xuICAgICAgICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlO1xuICAgICAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2U7XG4gICAgICAgIHRoaXNbVVBEQVRFX0FHRV9PTl9HRVRdID0gb3B0aW9ucy51cGRhdGVBZ2VPbkdldCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgfVxuICAgICAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cbiAgICAgIHNldCBtYXgobUwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtTCAhPT0gXCJudW1iZXJcIiB8fCBtTCA8IDApXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclwiKTtcbiAgICAgICAgdGhpc1tNQVhdID0gbUwgfHwgSW5maW5pdHk7XG4gICAgICAgIHRyaW0odGhpcyk7XG4gICAgICB9XG4gICAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpc1tNQVhdO1xuICAgICAgfVxuICAgICAgc2V0IGFsbG93U3RhbGUoYWxsb3dTdGFsZSkge1xuICAgICAgICB0aGlzW0FMTE9XX1NUQUxFXSA9ICEhYWxsb3dTdGFsZTtcbiAgICAgIH1cbiAgICAgIGdldCBhbGxvd1N0YWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV07XG4gICAgICB9XG4gICAgICBzZXQgbWF4QWdlKG1BKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbUEgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1heEFnZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclwiKTtcbiAgICAgICAgdGhpc1tNQVhfQUdFXSA9IG1BO1xuICAgICAgICB0cmltKHRoaXMpO1xuICAgICAgfVxuICAgICAgZ2V0IG1heEFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbTUFYX0FHRV07XG4gICAgICB9XG4gICAgICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIGxlbmd0aENhbGN1bGF0b3IgY2hhbmdlcy5cbiAgICAgIHNldCBsZW5ndGhDYWxjdWxhdG9yKGxDKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbEMgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBsQyA9IG5haXZlTGVuZ3RoO1xuICAgICAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsQztcbiAgICAgICAgICB0aGlzW0xFTkdUSF0gPSAwO1xuICAgICAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goKGhpdCkgPT4ge1xuICAgICAgICAgICAgaGl0Lmxlbmd0aCA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSk7XG4gICAgICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cmltKHRoaXMpO1xuICAgICAgfVxuICAgICAgZ2V0IGxlbmd0aENhbGN1bGF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXTtcbiAgICAgIH1cbiAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0xFTkdUSF07XG4gICAgICB9XG4gICAgICBnZXQgaXRlbUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmZvckVhY2goZm4sIHRoaXNwKSB7XG4gICAgICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgICAgICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0udGFpbDsgd2Fsa2VyICE9PSBudWxsOyApIHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXY7XG4gICAgICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApO1xuICAgICAgICAgIHdhbGtlciA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvckVhY2goZm4sIHRoaXNwKSB7XG4gICAgICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgICAgICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOyApIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gd2Fsa2VyLm5leHQ7XG4gICAgICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApO1xuICAgICAgICAgIHdhbGtlciA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKChrKSA9PiBrLmtleSk7XG4gICAgICB9XG4gICAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKChrKSA9PiBrLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpc1tESVNQT1NFXSAmJiB0aGlzW0xSVV9MSVNUXSAmJiB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKChoaXQpID0+IHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tDQUNIRV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCk7XG4gICAgICAgIHRoaXNbTEVOR1RIXSA9IDA7XG4gICAgICB9XG4gICAgICBkdW1wKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKChoaXQpID0+IGlzU3RhbGUodGhpcywgaGl0KSA/IGZhbHNlIDoge1xuICAgICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgICB9KS50b0FycmF5KCkuZmlsdGVyKChoKSA9PiBoKTtcbiAgICAgIH1cbiAgICAgIGR1bXBMcnUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXTtcbiAgICAgIH1cbiAgICAgIHNldChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgICAgICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV07XG4gICAgICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWF4QWdlIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KTtcbiAgICAgICAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgICAgICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpO1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlLnZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXNbTk9fRElTUE9TRV9PTl9TRVRdKVxuICAgICAgICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0ubm93ID0gbm93O1xuICAgICAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlO1xuICAgICAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgaXRlbS5sZW5ndGggPSBsZW47XG4gICAgICAgICAgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICB0cmltKHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKTtcbiAgICAgICAgaWYgKGhpdC5sZW5ndGggPiB0aGlzW01BWF0pIHtcbiAgICAgICAgICBpZiAodGhpc1tESVNQT1NFXSlcbiAgICAgICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoO1xuICAgICAgICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdCk7XG4gICAgICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpO1xuICAgICAgICB0cmltKHRoaXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlO1xuICAgICAgICByZXR1cm4gIWlzU3RhbGUodGhpcywgaGl0KTtcbiAgICAgIH1cbiAgICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpO1xuICAgICAgfVxuICAgICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVsKHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGRlbChrZXkpIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKTtcbiAgICAgIH1cbiAgICAgIGxvYWQoYXJyKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZm9yIChsZXQgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICAgIGNvbnN0IGhpdCA9IGFycltsXTtcbiAgICAgICAgICBjb25zdCBleHBpcmVzQXQgPSBoaXQuZSB8fCAwO1xuICAgICAgICAgIGlmIChleHBpcmVzQXQgPT09IDApXG4gICAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93O1xuICAgICAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJ1bmUoKSB7XG4gICAgICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGdldCh0aGlzLCBrZXksIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZ2V0ID0gKHNlbGYyLCBrZXksIGRvVXNlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gc2VsZjJbQ0FDSEVdLmdldChrZXkpO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZTtcbiAgICAgICAgaWYgKGlzU3RhbGUoc2VsZjIsIGhpdCkpIHtcbiAgICAgICAgICBkZWwoc2VsZjIsIG5vZGUpO1xuICAgICAgICAgIGlmICghc2VsZjJbQUxMT1dfU1RBTEVdKVxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgICAgIGlmIChzZWxmMltVUERBVEVfQUdFX09OX0dFVF0pXG4gICAgICAgICAgICAgIG5vZGUudmFsdWUubm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHNlbGYyW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpc1N0YWxlID0gKHNlbGYyLCBoaXQpID0+IHtcbiAgICAgIGlmICghaGl0IHx8ICFoaXQubWF4QWdlICYmICFzZWxmMltNQVhfQUdFXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93O1xuICAgICAgcmV0dXJuIGhpdC5tYXhBZ2UgPyBkaWZmID4gaGl0Lm1heEFnZSA6IHNlbGYyW01BWF9BR0VdICYmIGRpZmYgPiBzZWxmMltNQVhfQUdFXTtcbiAgICB9O1xuICAgIHZhciB0cmltID0gKHNlbGYyKSA9PiB7XG4gICAgICBpZiAoc2VsZjJbTEVOR1RIXSA+IHNlbGYyW01BWF0pIHtcbiAgICAgICAgZm9yIChsZXQgd2Fsa2VyID0gc2VsZjJbTFJVX0xJU1RdLnRhaWw7IHNlbGYyW0xFTkdUSF0gPiBzZWxmMltNQVhdICYmIHdhbGtlciAhPT0gbnVsbDsgKSB7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2O1xuICAgICAgICAgIGRlbChzZWxmMiwgd2Fsa2VyKTtcbiAgICAgICAgICB3YWxrZXIgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGVsID0gKHNlbGYyLCBub2RlKSA9PiB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlO1xuICAgICAgICBpZiAoc2VsZjJbRElTUE9TRV0pXG4gICAgICAgICAgc2VsZjJbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKTtcbiAgICAgICAgc2VsZjJbTEVOR1RIXSAtPSBoaXQubGVuZ3RoO1xuICAgICAgICBzZWxmMltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpO1xuICAgICAgICBzZWxmMltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBFbnRyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMubm93ID0gbm93O1xuICAgICAgICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGZvckVhY2hTdGVwID0gKHNlbGYyLCBmbiwgbm9kZSwgdGhpc3ApID0+IHtcbiAgICAgIGxldCBoaXQgPSBub2RlLnZhbHVlO1xuICAgICAgaWYgKGlzU3RhbGUoc2VsZjIsIGhpdCkpIHtcbiAgICAgICAgZGVsKHNlbGYyLCBub2RlKTtcbiAgICAgICAgaWYgKCFzZWxmMltBTExPV19TVEFMRV0pXG4gICAgICAgICAgaGl0ID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKGhpdClcbiAgICAgICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmMik7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBMUlVDYWNoZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qc1xudmFyIHJlcXVpcmVfcmFuZ2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIFJhbmdlID0gY2xhc3MgX1JhbmdlIHtcbiAgICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIF9SYW5nZSkge1xuICAgICAgICAgIGlmIChyYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV07XG4gICAgICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlO1xuICAgICAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlO1xuICAgICAgICB0aGlzLnJhdyA9IHJhbmdlLnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpO1xuICAgICAgICB0aGlzLnNldCA9IHRoaXMucmF3LnNwbGl0KFwifHxcIikubWFwKChyKSA9PiB0aGlzLnBhcnNlUmFuZ2Uoci50cmltKCkpKS5maWx0ZXIoKGMpID0+IGMubGVuZ3RoKTtcbiAgICAgICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHt0aGlzLnJhd31gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF07XG4gICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5maWx0ZXIoKGMpID0+ICFpc051bGxTZXQoY1swXSkpO1xuICAgICAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDEgJiYgaXNBbnkoY1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IFtjXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgICAgfVxuICAgICAgZm9ybWF0KCkge1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5zZXQubWFwKChjb21wcykgPT4gY29tcHMuam9pbihcIiBcIikudHJpbSgpKS5qb2luKFwifHxcIikudHJpbSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZTtcbiAgICAgIH1cbiAgICAgIHBhcnNlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgY29uc3QgbWVtb09wdHMgPSAodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFKSB8ICh0aGlzLm9wdGlvbnMubG9vc2UgJiYgRkxBR19MT09TRSk7XG4gICAgICAgIGNvbnN0IG1lbW9LZXkgPSBtZW1vT3B0cyArIFwiOlwiICsgcmFuZ2U7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2U7XG4gICAgICAgIGNvbnN0IGhyID0gbG9vc2UgPyByZTJbdC5IWVBIRU5SQU5HRUxPT1NFXSA6IHJlMlt0LkhZUEhFTlJBTkdFXTtcbiAgICAgICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkpO1xuICAgICAgICBkZWJ1ZyhcImh5cGhlbiByZXBsYWNlXCIsIHJhbmdlKTtcbiAgICAgICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlMlt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKTtcbiAgICAgICAgZGVidWcoXCJjb21wYXJhdG9yIHRyaW1cIiwgcmFuZ2UpO1xuICAgICAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmUyW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7XG4gICAgICAgIGRlYnVnKFwidGlsZGUgdHJpbVwiLCByYW5nZSk7XG4gICAgICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZTJbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKTtcbiAgICAgICAgZGVidWcoXCJjYXJldCB0cmltXCIsIHJhbmdlKTtcbiAgICAgICAgbGV0IHJhbmdlTGlzdCA9IHJhbmdlLnNwbGl0KFwiIFwiKS5tYXAoKGNvbXApID0+IHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKS5qb2luKFwiIFwiKS5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgIGlmIChsb29zZSkge1xuICAgICAgICAgIHJhbmdlTGlzdCA9IHJhbmdlTGlzdC5maWx0ZXIoKGNvbXApID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwibG9vc2UgaW52YWxpZCBmaWx0ZXJcIiwgY29tcCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiAhIWNvbXAubWF0Y2gocmUyW3QuQ09NUEFSQVRPUkxPT1NFXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJyYW5nZSBsaXN0XCIsIHJhbmdlTGlzdCk7XG4gICAgICAgIGNvbnN0IHJhbmdlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZUxpc3QubWFwKChjb21wKSA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKTtcbiAgICAgICAgZm9yIChjb25zdCBjb21wIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICAgICAgaWYgKGlzTnVsbFNldChjb21wKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb21wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmFuZ2VNYXAuc2V0KGNvbXAudmFsdWUsIGNvbXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZU1hcC5zaXplID4gMSAmJiByYW5nZU1hcC5oYXMoXCJcIikpIHtcbiAgICAgICAgICByYW5nZU1hcC5kZWxldGUoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gWy4uLnJhbmdlTWFwLnZhbHVlcygpXTtcbiAgICAgICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpbnRlcnNlY3RzKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgX1JhbmdlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhIFJhbmdlIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNldC5zb21lKCh0aGlzQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmIHJhbmdlLnNldC5zb21lKChyYW5nZUNvbXBhcmF0b3JzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJiB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoKHRoaXNDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KChyYW5nZUNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgICAgIHRlc3QodmVyc2lvbikge1xuICAgICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gUmFuZ2U7XG4gICAgdmFyIExSVSA9IHJlcXVpcmVfbHJ1X2NhY2hlKCk7XG4gICAgdmFyIGNhY2hlID0gbmV3IExSVSh7IG1heDogMWUzIH0pO1xuICAgIHZhciBwYXJzZU9wdGlvbnMgPSByZXF1aXJlX3BhcnNlX29wdGlvbnMoKTtcbiAgICB2YXIgQ29tcGFyYXRvciA9IHJlcXVpcmVfY29tcGFyYXRvcigpO1xuICAgIHZhciBkZWJ1ZyA9IHJlcXVpcmVfZGVidWcoKTtcbiAgICB2YXIgU2VtVmVyID0gcmVxdWlyZV9zZW12ZXIoKTtcbiAgICB2YXIge1xuICAgICAgc2FmZVJlOiByZTIsXG4gICAgICB0LFxuICAgICAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICAgICAgdGlsZGVUcmltUmVwbGFjZSxcbiAgICAgIGNhcmV0VHJpbVJlcGxhY2VcbiAgICB9ID0gcmVxdWlyZV9yZSgpO1xuICAgIHZhciB7IEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFLCBGTEFHX0xPT1NFIH0gPSByZXF1aXJlX2NvbnN0YW50cygpO1xuICAgIHZhciBpc051bGxTZXQgPSAoYykgPT4gYy52YWx1ZSA9PT0gXCI8MC4wLjAtMFwiO1xuICAgIHZhciBpc0FueSA9IChjKSA9PiBjLnZhbHVlID09PSBcIlwiO1xuICAgIHZhciBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKTtcbiAgICAgIGxldCB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpO1xuICAgICAgd2hpbGUgKHJlc3VsdCAmJiByZW1haW5pbmdDb21wYXJhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHZhciBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICAgICAgZGVidWcoXCJjb21wXCIsIGNvbXAsIG9wdGlvbnMpO1xuICAgICAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucyk7XG4gICAgICBkZWJ1ZyhcImNhcmV0XCIsIGNvbXApO1xuICAgICAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucyk7XG4gICAgICBkZWJ1ZyhcInRpbGRlc1wiLCBjb21wKTtcbiAgICAgIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKTtcbiAgICAgIGRlYnVnKFwieHJhbmdlXCIsIGNvbXApO1xuICAgICAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKTtcbiAgICAgIGRlYnVnKFwic3RhcnNcIiwgY29tcCk7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9O1xuICAgIHZhciBpc1ggPSAoaWQpID0+ICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSBcInhcIiB8fCBpZCA9PT0gXCIqXCI7XG4gICAgdmFyIHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjKSA9PiByZXBsYWNlVGlsZGUoYywgb3B0aW9ucykpLmpvaW4oXCIgXCIpO1xuICAgIH07XG4gICAgdmFyIHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlMlt0LlRJTERFTE9PU0VdIDogcmUyW3QuVElMREVdO1xuICAgICAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICAgICAgZGVidWcoXCJ0aWxkZVwiLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIGlmIChpc1goTSkpIHtcbiAgICAgICAgICByZXQgPSBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uMC4wIDwkeytNICsgMX0uMC4wLTBgO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wIDwke019LiR7K20gKyAxfS4wLTBgO1xuICAgICAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICAgICAgZGVidWcoXCJyZXBsYWNlVGlsZGUgcHJcIiwgcHIpO1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJ9IDwke019LiR7K20gKyAxfS4wLTBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9IDwke019LiR7K20gKyAxfS4wLTBgO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwidGlsZGUgcmV0dXJuXCIsIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoYykgPT4gcmVwbGFjZUNhcmV0KGMsIG9wdGlvbnMpKS5qb2luKFwiIFwiKTtcbiAgICB9O1xuICAgIHZhciByZXBsYWNlQ2FyZXQgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICAgICAgZGVidWcoXCJjYXJldFwiLCBjb21wLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmUyW3QuQ0FSRVRMT09TRV0gOiByZTJbdC5DQVJFVF07XG4gICAgICBjb25zdCB6ID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IFwiLTBcIiA6IFwiXCI7XG4gICAgICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChfLCBNLCBtLCBwLCBwcikgPT4ge1xuICAgICAgICBkZWJ1ZyhcImNhcmV0XCIsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICAgICAgbGV0IHJldDtcbiAgICAgICAgaWYgKGlzWChNKSkge1xuICAgICAgICAgIHJldCA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgICAgIGlmIChNID09PSBcIjBcIikge1xuICAgICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICAgICAgZGVidWcoXCJyZXBsYWNlQ2FyZXQgcHJcIiwgcHIpO1xuICAgICAgICAgIGlmIChNID09PSBcIjBcIikge1xuICAgICAgICAgICAgaWYgKG0gPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJ9IDwke019LiR7bX0uJHsrcCArIDF9LTBgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwcn0gPCR7TX0uJHsrbSArIDF9LjAtMGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJ9IDwkeytNICsgMX0uMC4wLTBgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZyhcIm5vIHByXCIpO1xuICAgICAgICAgIGlmIChNID09PSBcIjBcIikge1xuICAgICAgICAgICAgaWYgKG0gPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9JHt6fSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9JHt6fSA8JHtNfS4keyttICsgMX0uMC0wYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0gPCR7K00gKyAxfS4wLjAtMGA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwiY2FyZXQgcmV0dXJuXCIsIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gICAgICBkZWJ1ZyhcInJlcGxhY2VYUmFuZ2VzXCIsIGNvbXAsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoKGMpID0+IHJlcGxhY2VYUmFuZ2UoYywgb3B0aW9ucykpLmpvaW4oXCIgXCIpO1xuICAgIH07XG4gICAgdmFyIHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICAgICAgY29tcCA9IGNvbXAudHJpbSgpO1xuICAgICAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZTJbdC5YUkFOR0VMT09TRV0gOiByZTJbdC5YUkFOR0VdO1xuICAgICAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAocmV0LCBndGx0LCBNLCBtLCBwLCBwcikgPT4ge1xuICAgICAgICBkZWJ1ZyhcInhSYW5nZVwiLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKTtcbiAgICAgICAgY29uc3QgeE0gPSBpc1goTSk7XG4gICAgICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pO1xuICAgICAgICBjb25zdCB4cCA9IHhtIHx8IGlzWChwKTtcbiAgICAgICAgY29uc3QgYW55WCA9IHhwO1xuICAgICAgICBpZiAoZ3RsdCA9PT0gXCI9XCIgJiYgYW55WCkge1xuICAgICAgICAgIGd0bHQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IFwiLTBcIiA6IFwiXCI7XG4gICAgICAgIGlmICh4TSkge1xuICAgICAgICAgIGlmIChndGx0ID09PSBcIj5cIiB8fCBndGx0ID09PSBcIjxcIikge1xuICAgICAgICAgICAgcmV0ID0gXCI8MC4wLjAtMFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBcIipcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgICBtID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgICAgaWYgKGd0bHQgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICBndGx0ID0gXCI+PVwiO1xuICAgICAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgICAgICBwID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gXCI8PVwiKSB7XG4gICAgICAgICAgICBndGx0ID0gXCI8XCI7XG4gICAgICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChndGx0ID09PSBcIjxcIikge1xuICAgICAgICAgICAgcHIgPSBcIi0wXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldCA9IGAke2d0bHQgKyBNfS4ke219LiR7cH0ke3ByfWA7XG4gICAgICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LjAuMCR7cHJ9IDwkeytNICsgMX0uMC4wLTBgO1xuICAgICAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3ByfSA8JHtNfS4keyttICsgMX0uMC0wYDtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInhSYW5nZSByZXR1cm5cIiwgcmV0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gICAgICBkZWJ1ZyhcInJlcGxhY2VTdGFyc1wiLCBjb21wLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlMlt0LlNUQVJdLCBcIlwiKTtcbiAgICB9O1xuICAgIHZhciByZXBsYWNlR1RFMCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gICAgICBkZWJ1ZyhcInJlcGxhY2VHVEUwXCIsIGNvbXAsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmUyW29wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyB0LkdURTBQUkUgOiB0LkdURTBdLCBcIlwiKTtcbiAgICB9O1xuICAgIHZhciBoeXBoZW5SZXBsYWNlID0gKGluY1ByKSA9PiAoJDAsIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSA9PiB7XG4gICAgICBpZiAoaXNYKGZNKSkge1xuICAgICAgICBmcm9tID0gXCJcIjtcbiAgICAgIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgICAgICBmcm9tID0gYD49JHtmTX0uMC4wJHtpbmNQciA/IFwiLTBcIiA6IFwiXCJ9YDtcbiAgICAgIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgICAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyBcIi0wXCIgOiBcIlwifWA7XG4gICAgICB9IGVsc2UgaWYgKGZwcikge1xuICAgICAgICBmcm9tID0gYD49JHtmcm9tfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0gYD49JHtmcm9tfSR7aW5jUHIgPyBcIi0wXCIgOiBcIlwifWA7XG4gICAgICB9XG4gICAgICBpZiAoaXNYKHRNKSkge1xuICAgICAgICB0byA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICAgICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgO1xuICAgICAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGA7XG4gICAgICB9IGVsc2UgaWYgKHRwcikge1xuICAgICAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWA7XG4gICAgICB9IGVsc2UgaWYgKGluY1ByKSB7XG4gICAgICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG8gPSBgPD0ke3RvfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7ZnJvbX0gJHt0b31gLnRyaW0oKTtcbiAgICB9O1xuICAgIHZhciB0ZXN0U2V0ID0gKHNldCwgdmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKTtcbiAgICAgICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQ29tcGFyYXRvci5BTlkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyO1xuICAgICAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiYgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJiBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanNcbnZhciByZXF1aXJlX2NvbXBhcmF0b3IgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgQU5ZID0gU3ltYm9sKFwiU2VtVmVyIEFOWVwiKTtcbiAgICB2YXIgQ29tcGFyYXRvciA9IGNsYXNzIF9Db21wYXJhdG9yIHtcbiAgICAgIHN0YXRpYyBnZXQgQU5ZKCkge1xuICAgICAgICByZXR1cm4gQU5ZO1xuICAgICAgfVxuICAgICAgY29uc3RydWN0b3IoY29tcCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIF9Db21wYXJhdG9yKSB7XG4gICAgICAgICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXAgPSBjb21wLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb21wID0gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKFwiIFwiKTtcbiAgICAgICAgZGVidWcoXCJjb21wYXJhdG9yXCIsIGNvbXAsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlO1xuICAgICAgICB0aGlzLnBhcnNlKGNvbXApO1xuICAgICAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcImNvbXBcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgICBwYXJzZShjb21wKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZTJbdC5DT01QQVJBVE9STE9PU0VdIDogcmUyW3QuQ09NUEFSQVRPUl07XG4gICAgICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNvbXBhcmF0b3I6ICR7Y29tcH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdm9pZCAwID8gbVsxXSA6IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbVsyXSkge1xuICAgICAgICAgIHRoaXMuc2VtdmVyID0gQU5ZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLm9wdGlvbnMubG9vc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgICB0ZXN0KHZlcnNpb24pIHtcbiAgICAgICAgZGVidWcoXCJDb21wYXJhdG9yLnRlc3RcIiwgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKTtcbiAgICAgICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGludGVyc2VjdHMoY29tcCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgX0NvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImEgQ29tcGFyYXRvciBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gXCJcIikge1xuICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAoY29tcC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucykudGVzdChjb21wLnNlbXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgKHRoaXMudmFsdWUgPT09IFwiPDAuMC4wLTBcIiB8fCBjb21wLnZhbHVlID09PSBcIjwwLjAuMC0wXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiAodGhpcy52YWx1ZS5zdGFydHNXaXRoKFwiPDAuMC4wXCIpIHx8IGNvbXAudmFsdWUuc3RhcnRzV2l0aChcIjwwLjAuMFwiKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aChcIj5cIikgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKFwiPlwiKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoXCI8XCIpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aChcIjxcIikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvbiAmJiB0aGlzLm9wZXJhdG9yLmluY2x1ZGVzKFwiPVwiKSAmJiBjb21wLm9wZXJhdG9yLmluY2x1ZGVzKFwiPVwiKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbXAodGhpcy5zZW12ZXIsIFwiPFwiLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiYgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKFwiPlwiKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoXCI8XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtcCh0aGlzLnNlbXZlciwgXCI+XCIsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJiB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoXCI8XCIpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aChcIj5cIikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBDb21wYXJhdG9yO1xuICAgIHZhciBwYXJzZU9wdGlvbnMgPSByZXF1aXJlX3BhcnNlX29wdGlvbnMoKTtcbiAgICB2YXIgeyBzYWZlUmU6IHJlMiwgdCB9ID0gcmVxdWlyZV9yZSgpO1xuICAgIHZhciBjbXAgPSByZXF1aXJlX2NtcCgpO1xuICAgIHZhciBkZWJ1ZyA9IHJlcXVpcmVfZGVidWcoKTtcbiAgICB2YXIgU2VtVmVyID0gcmVxdWlyZV9zZW12ZXIoKTtcbiAgICB2YXIgUmFuZ2UgPSByZXF1aXJlX3JhbmdlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanNcbnZhciByZXF1aXJlX3NhdGlzZmllcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcy5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgUmFuZ2UgPSByZXF1aXJlX3JhbmdlKCk7XG4gICAgdmFyIHNhdGlzZmllczIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gc2F0aXNmaWVzMjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzXG52YXIgcmVxdWlyZV90b19jb21wYXJhdG9ycyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBSYW5nZSA9IHJlcXVpcmVfcmFuZ2UoKTtcbiAgICB2YXIgdG9Db21wYXJhdG9ycyA9IChyYW5nZSwgb3B0aW9ucykgPT4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXQubWFwKChjb21wKSA9PiBjb21wLm1hcCgoYykgPT4gYy52YWx1ZSkuam9pbihcIiBcIikudHJpbSgpLnNwbGl0KFwiIFwiKSk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gdG9Db21wYXJhdG9ycztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzXG52YXIgcmVxdWlyZV9tYXhfc2F0aXNmeWluZyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBTZW1WZXIgPSByZXF1aXJlX3NlbXZlcigpO1xuICAgIHZhciBSYW5nZSA9IHJlcXVpcmVfcmFuZ2UoKTtcbiAgICB2YXIgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgbGV0IG1heFNWID0gbnVsbDtcbiAgICAgIGxldCByYW5nZU9iaiA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkge1xuICAgICAgICAgICAgbWF4ID0gdjtcbiAgICAgICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF4O1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gbWF4U2F0aXNmeWluZztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzXG52YXIgcmVxdWlyZV9taW5fc2F0aXNmeWluZyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBTZW1WZXIgPSByZXF1aXJlX3NlbXZlcigpO1xuICAgIHZhciBSYW5nZSA9IHJlcXVpcmVfcmFuZ2UoKTtcbiAgICB2YXIgbWluU2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgbGV0IG1pblNWID0gbnVsbDtcbiAgICAgIGxldCByYW5nZU9iaiA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgICAgICBtaW4gPSB2O1xuICAgICAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtaW47XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanNcbnZhciByZXF1aXJlX21pbl92ZXJzaW9uID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIFNlbVZlciA9IHJlcXVpcmVfc2VtdmVyKCk7XG4gICAgdmFyIFJhbmdlID0gcmVxdWlyZV9yYW5nZSgpO1xuICAgIHZhciBndCA9IHJlcXVpcmVfZ3QoKTtcbiAgICB2YXIgbWluVmVyc2lvbiA9IChyYW5nZSwgbG9vc2UpID0+IHtcbiAgICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gICAgICBsZXQgbWludmVyID0gbmV3IFNlbVZlcihcIjAuMC4wXCIpO1xuICAgICAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgICAgICByZXR1cm4gbWludmVyO1xuICAgICAgfVxuICAgICAgbWludmVyID0gbmV3IFNlbVZlcihcIjAuMC4wLTBcIik7XG4gICAgICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgICAgIHJldHVybiBtaW52ZXI7XG4gICAgICB9XG4gICAgICBtaW52ZXIgPSBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV07XG4gICAgICAgIGxldCBzZXRNaW4gPSBudWxsO1xuICAgICAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbik7XG4gICAgICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KCk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSkge1xuICAgICAgICAgIG1pbnZlciA9IHNldE1pbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICAgICAgcmV0dXJuIG1pbnZlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gbWluVmVyc2lvbjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzXG52YXIgcmVxdWlyZV92YWxpZDIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgUmFuZ2UgPSByZXF1aXJlX3JhbmdlKCk7XG4gICAgdmFyIHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8IFwiKlwiO1xuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB2YWxpZFJhbmdlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvb3V0c2lkZS5qc1xudmFyIHJlcXVpcmVfb3V0c2lkZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIFNlbVZlciA9IHJlcXVpcmVfc2VtdmVyKCk7XG4gICAgdmFyIENvbXBhcmF0b3IgPSByZXF1aXJlX2NvbXBhcmF0b3IoKTtcbiAgICB2YXIgeyBBTlkgfSA9IENvbXBhcmF0b3I7XG4gICAgdmFyIFJhbmdlID0gcmVxdWlyZV9yYW5nZSgpO1xuICAgIHZhciBzYXRpc2ZpZXMyID0gcmVxdWlyZV9zYXRpc2ZpZXMoKTtcbiAgICB2YXIgZ3QgPSByZXF1aXJlX2d0KCk7XG4gICAgdmFyIGx0ID0gcmVxdWlyZV9sdCgpO1xuICAgIHZhciBsdGUgPSByZXF1aXJlX2x0ZSgpO1xuICAgIHZhciBndGUgPSByZXF1aXJlX2d0ZSgpO1xuICAgIHZhciBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgICAgIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXA7XG4gICAgICBzd2l0Y2ggKGhpbG8pIHtcbiAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICBndGZuID0gZ3Q7XG4gICAgICAgICAgbHRlZm4gPSBsdGU7XG4gICAgICAgICAgbHRmbiA9IGx0O1xuICAgICAgICAgIGNvbXAgPSBcIj5cIjtcbiAgICAgICAgICBlY29tcCA9IFwiPj1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICBndGZuID0gbHQ7XG4gICAgICAgICAgbHRlZm4gPSBndGU7XG4gICAgICAgICAgbHRmbiA9IGd0O1xuICAgICAgICAgIGNvbXAgPSBcIjxcIjtcbiAgICAgICAgICBlY29tcCA9IFwiPD1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpO1xuICAgICAgfVxuICAgICAgaWYgKHNhdGlzZmllczIodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldO1xuICAgICAgICBsZXQgaGlnaCA9IG51bGw7XG4gICAgICAgIGxldCBsb3cgPSBudWxsO1xuICAgICAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcihcIj49MC4wLjBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3I7XG4gICAgICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3I7XG4gICAgICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3I7XG4gICAgICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgbG93ID0gY29tcGFyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJiBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gb3V0c2lkZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qc1xudmFyIHJlcXVpcmVfZ3RyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvZ3RyLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBvdXRzaWRlID0gcmVxdWlyZV9vdXRzaWRlKCk7XG4gICAgdmFyIGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgXCI+XCIsIG9wdGlvbnMpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGd0cjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2x0ci5qc1xudmFyIHJlcXVpcmVfbHRyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbHRyLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBvdXRzaWRlID0gcmVxdWlyZV9vdXRzaWRlKCk7XG4gICAgdmFyIGx0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgXCI8XCIsIG9wdGlvbnMpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGx0cjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanNcbnZhciByZXF1aXJlX2ludGVyc2VjdHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBSYW5nZSA9IHJlcXVpcmVfcmFuZ2UoKTtcbiAgICB2YXIgaW50ZXJzZWN0cyA9IChyMSwgcjIsIG9wdGlvbnMpID0+IHtcbiAgICAgIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKTtcbiAgICAgIHIyID0gbmV3IFJhbmdlKHIyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiByMS5pbnRlcnNlY3RzKHIyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGludGVyc2VjdHM7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qc1xudmFyIHJlcXVpcmVfc2ltcGxpZnkgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICB2YXIgc2F0aXNmaWVzMiA9IHJlcXVpcmVfc2F0aXNmaWVzKCk7XG4gICAgdmFyIGNvbXBhcmUgPSByZXF1aXJlX2NvbXBhcmUoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBzZXQgPSBbXTtcbiAgICAgIGxldCBmaXJzdCA9IG51bGw7XG4gICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSk7XG4gICAgICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygdikge1xuICAgICAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllczIodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgICAgICBwcmV2ID0gdmVyc2lvbjtcbiAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICBmaXJzdCA9IHZlcnNpb247XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IG51bGw7XG4gICAgICAgICAgZmlyc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgc2V0LnB1c2goW2ZpcnN0LCBudWxsXSk7XG4gICAgICB9XG4gICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBzZXQpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICAgICAgcmFuZ2VzLnB1c2gobWluKTtcbiAgICAgICAgfSBlbHNlIGlmICghbWF4ICYmIG1pbiA9PT0gdlswXSkge1xuICAgICAgICAgIHJhbmdlcy5wdXNoKFwiKlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghbWF4KSB7XG4gICAgICAgICAgcmFuZ2VzLnB1c2goYD49JHttaW59YCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWluID09PSB2WzBdKSB7XG4gICAgICAgICAgcmFuZ2VzLnB1c2goYDw9JHttYXh9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2VzLnB1c2goYCR7bWlufSAtICR7bWF4fWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oXCIgfHwgXCIpO1xuICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSBcInN0cmluZ1wiID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKTtcbiAgICAgIHJldHVybiBzaW1wbGlmaWVkLmxlbmd0aCA8IG9yaWdpbmFsLmxlbmd0aCA/IHNpbXBsaWZpZWQgOiByYW5nZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc3Vic2V0LmpzXG52YXIgcmVxdWlyZV9zdWJzZXQgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIFJhbmdlID0gcmVxdWlyZV9yYW5nZSgpO1xuICAgIHZhciBDb21wYXJhdG9yID0gcmVxdWlyZV9jb21wYXJhdG9yKCk7XG4gICAgdmFyIHsgQU5ZIH0gPSBDb21wYXJhdG9yO1xuICAgIHZhciBzYXRpc2ZpZXMyID0gcmVxdWlyZV9zYXRpc2ZpZXMoKTtcbiAgICB2YXIgY29tcGFyZSA9IHJlcXVpcmVfY29tcGFyZSgpO1xuICAgIHZhciBzdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucyk7XG4gICAgICBkb20gPSBuZXcgUmFuZ2UoZG9tLCBvcHRpb25zKTtcbiAgICAgIGxldCBzYXdOb25OdWxsID0gZmFsc2U7XG4gICAgICBPVVRFUjpcbiAgICAgICAgZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHNhd05vbk51bGwgPSBzYXdOb25OdWxsIHx8IGlzU3ViICE9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIE9VVEVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2F3Tm9uTnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB2YXIgbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZSA9IFtuZXcgQ29tcGFyYXRvcihcIj49MC4wLjAtMFwiKV07XG4gICAgdmFyIG1pbmltdW1WZXJzaW9uID0gW25ldyBDb21wYXJhdG9yKFwiPj0wLjAuMFwiKV07XG4gICAgdmFyIHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YiA9IG1pbmltdW1WZXJzaW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20gPSBtaW5pbXVtVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZXFTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgbGV0IGd0LCBsdDtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBzdWIpIHtcbiAgICAgICAgaWYgKGMub3BlcmF0b3IgPT09IFwiPlwiIHx8IGMub3BlcmF0b3IgPT09IFwiPj1cIikge1xuICAgICAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGMub3BlcmF0b3IgPT09IFwiPFwiIHx8IGMub3BlcmF0b3IgPT09IFwiPD1cIikge1xuICAgICAgICAgIGx0ID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVxU2V0LnNpemUgPiAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbGV0IGd0bHRDb21wO1xuICAgICAgaWYgKGd0ICYmIGx0KSB7XG4gICAgICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChndGx0Q29tcCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09IFwiPj1cIiB8fCBsdC5vcGVyYXRvciAhPT0gXCI8PVwiKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgICAgIGlmIChndCAmJiAhc2F0aXNmaWVzMihlcSwgU3RyaW5nKGd0KSwgb3B0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobHQgJiYgIXNhdGlzZmllczIoZXEsIFN0cmluZyhsdCksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgICAgIGlmICghc2F0aXNmaWVzMihlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBoaWdoZXIsIGxvd2VyO1xuICAgICAgbGV0IGhhc0RvbUxULCBoYXNEb21HVDtcbiAgICAgIGxldCBuZWVkRG9tTFRQcmUgPSBsdCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBsdC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBsdC5zZW12ZXIgOiBmYWxzZTtcbiAgICAgIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBndC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBndC5zZW12ZXIgOiBmYWxzZTtcbiAgICAgIGlmIChuZWVkRG9tTFRQcmUgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2UubGVuZ3RoID09PSAxICYmIGx0Lm9wZXJhdG9yID09PSBcIjxcIiAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZVswXSA9PT0gMCkge1xuICAgICAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICAgICAgaGFzRG9tR1QgPSBoYXNEb21HVCB8fCBjLm9wZXJhdG9yID09PSBcIj5cIiB8fCBjLm9wZXJhdG9yID09PSBcIj49XCI7XG4gICAgICAgIGhhc0RvbUxUID0gaGFzRG9tTFQgfHwgYy5vcGVyYXRvciA9PT0gXCI8XCIgfHwgYy5vcGVyYXRvciA9PT0gXCI8PVwiO1xuICAgICAgICBpZiAoZ3QpIHtcbiAgICAgICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJiBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tR1RQcmUubWlub3IgJiYgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21HVFByZS5wYXRjaCkge1xuICAgICAgICAgICAgICBuZWVkRG9tR1RQcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMub3BlcmF0b3IgPT09IFwiPlwiIHx8IGMub3BlcmF0b3IgPT09IFwiPj1cIikge1xuICAgICAgICAgICAgaGlnaGVyID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGhpZ2hlciA9PT0gYyAmJiBoaWdoZXIgIT09IGd0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSBcIj49XCIgJiYgIXNhdGlzZmllczIoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsdCkge1xuICAgICAgICAgIGlmIChuZWVkRG9tTFRQcmUpIHtcbiAgICAgICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tTFRQcmUubWFqb3IgJiYgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21MVFByZS5taW5vciAmJiBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgICAgIG5lZWREb21MVFByZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYy5vcGVyYXRvciA9PT0gXCI8XCIgfHwgYy5vcGVyYXRvciA9PT0gXCI8PVwiKSB7XG4gICAgICAgICAgICBsb3dlciA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsdC5vcGVyYXRvciA9PT0gXCI8PVwiICYmICFzYXRpc2ZpZXMyKGx0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGd0ICYmIGhhc0RvbUxUICYmICFsdCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobHQgJiYgaGFzRG9tR1QgJiYgIWd0ICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdmFyIGhpZ2hlckdUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgICAgIGlmICghYSkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gY29tcCA+IDAgPyBhIDogY29tcCA8IDAgPyBiIDogYi5vcGVyYXRvciA9PT0gXCI+XCIgJiYgYS5vcGVyYXRvciA9PT0gXCI+PVwiID8gYiA6IGE7XG4gICAgfTtcbiAgICB2YXIgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoIWEpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNvbXAgPCAwID8gYSA6IGNvbXAgPiAwID8gYiA6IGIub3BlcmF0b3IgPT09IFwiPFwiICYmIGEub3BlcmF0b3IgPT09IFwiPD1cIiA/IGIgOiBhO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gc3Vic2V0O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3NlbXZlci9pbmRleC5qc1xudmFyIHJlcXVpcmVfc2VtdmVyMiA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGludGVybmFsUmUgPSByZXF1aXJlX3JlKCk7XG4gICAgdmFyIGNvbnN0YW50cyA9IHJlcXVpcmVfY29uc3RhbnRzKCk7XG4gICAgdmFyIFNlbVZlciA9IHJlcXVpcmVfc2VtdmVyKCk7XG4gICAgdmFyIGlkZW50aWZpZXJzID0gcmVxdWlyZV9pZGVudGlmaWVycygpO1xuICAgIHZhciBwYXJzZTQgPSByZXF1aXJlX3BhcnNlKCk7XG4gICAgdmFyIHZhbGlkID0gcmVxdWlyZV92YWxpZCgpO1xuICAgIHZhciBjbGVhbiA9IHJlcXVpcmVfY2xlYW4oKTtcbiAgICB2YXIgaW5jID0gcmVxdWlyZV9pbmMoKTtcbiAgICB2YXIgZGlmZiA9IHJlcXVpcmVfZGlmZigpO1xuICAgIHZhciBtYWpvcjIgPSByZXF1aXJlX21ham9yKCk7XG4gICAgdmFyIG1pbm9yID0gcmVxdWlyZV9taW5vcigpO1xuICAgIHZhciBwYXRjaCA9IHJlcXVpcmVfcGF0Y2goKTtcbiAgICB2YXIgcHJlcmVsZWFzZSA9IHJlcXVpcmVfcHJlcmVsZWFzZSgpO1xuICAgIHZhciBjb21wYXJlID0gcmVxdWlyZV9jb21wYXJlKCk7XG4gICAgdmFyIHJjb21wYXJlID0gcmVxdWlyZV9yY29tcGFyZSgpO1xuICAgIHZhciBjb21wYXJlTG9vc2UgPSByZXF1aXJlX2NvbXBhcmVfbG9vc2UoKTtcbiAgICB2YXIgY29tcGFyZUJ1aWxkID0gcmVxdWlyZV9jb21wYXJlX2J1aWxkKCk7XG4gICAgdmFyIHNvcnQgPSByZXF1aXJlX3NvcnQoKTtcbiAgICB2YXIgcnNvcnQgPSByZXF1aXJlX3Jzb3J0KCk7XG4gICAgdmFyIGd0ID0gcmVxdWlyZV9ndCgpO1xuICAgIHZhciBsdCA9IHJlcXVpcmVfbHQoKTtcbiAgICB2YXIgZXEgPSByZXF1aXJlX2VxKCk7XG4gICAgdmFyIG5lcSA9IHJlcXVpcmVfbmVxKCk7XG4gICAgdmFyIGd0ZSA9IHJlcXVpcmVfZ3RlKCk7XG4gICAgdmFyIGx0ZSA9IHJlcXVpcmVfbHRlKCk7XG4gICAgdmFyIGNtcCA9IHJlcXVpcmVfY21wKCk7XG4gICAgdmFyIGNvZXJjZSA9IHJlcXVpcmVfY29lcmNlKCk7XG4gICAgdmFyIENvbXBhcmF0b3IgPSByZXF1aXJlX2NvbXBhcmF0b3IoKTtcbiAgICB2YXIgUmFuZ2UgPSByZXF1aXJlX3JhbmdlKCk7XG4gICAgdmFyIHNhdGlzZmllczIgPSByZXF1aXJlX3NhdGlzZmllcygpO1xuICAgIHZhciB0b0NvbXBhcmF0b3JzID0gcmVxdWlyZV90b19jb21wYXJhdG9ycygpO1xuICAgIHZhciBtYXhTYXRpc2Z5aW5nID0gcmVxdWlyZV9tYXhfc2F0aXNmeWluZygpO1xuICAgIHZhciBtaW5TYXRpc2Z5aW5nID0gcmVxdWlyZV9taW5fc2F0aXNmeWluZygpO1xuICAgIHZhciBtaW5WZXJzaW9uID0gcmVxdWlyZV9taW5fdmVyc2lvbigpO1xuICAgIHZhciB2YWxpZFJhbmdlID0gcmVxdWlyZV92YWxpZDIoKTtcbiAgICB2YXIgb3V0c2lkZSA9IHJlcXVpcmVfb3V0c2lkZSgpO1xuICAgIHZhciBndHIgPSByZXF1aXJlX2d0cigpO1xuICAgIHZhciBsdHIgPSByZXF1aXJlX2x0cigpO1xuICAgIHZhciBpbnRlcnNlY3RzID0gcmVxdWlyZV9pbnRlcnNlY3RzKCk7XG4gICAgdmFyIHNpbXBsaWZ5UmFuZ2UgPSByZXF1aXJlX3NpbXBsaWZ5KCk7XG4gICAgdmFyIHN1YnNldCA9IHJlcXVpcmVfc3Vic2V0KCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgcGFyc2U6IHBhcnNlNCxcbiAgICAgIHZhbGlkLFxuICAgICAgY2xlYW4sXG4gICAgICBpbmMsXG4gICAgICBkaWZmLFxuICAgICAgbWFqb3I6IG1ham9yMixcbiAgICAgIG1pbm9yLFxuICAgICAgcGF0Y2gsXG4gICAgICBwcmVyZWxlYXNlLFxuICAgICAgY29tcGFyZSxcbiAgICAgIHJjb21wYXJlLFxuICAgICAgY29tcGFyZUxvb3NlLFxuICAgICAgY29tcGFyZUJ1aWxkLFxuICAgICAgc29ydCxcbiAgICAgIHJzb3J0LFxuICAgICAgZ3QsXG4gICAgICBsdCxcbiAgICAgIGVxLFxuICAgICAgbmVxLFxuICAgICAgZ3RlLFxuICAgICAgbHRlLFxuICAgICAgY21wLFxuICAgICAgY29lcmNlLFxuICAgICAgQ29tcGFyYXRvcixcbiAgICAgIFJhbmdlLFxuICAgICAgc2F0aXNmaWVzOiBzYXRpc2ZpZXMyLFxuICAgICAgdG9Db21wYXJhdG9ycyxcbiAgICAgIG1heFNhdGlzZnlpbmcsXG4gICAgICBtaW5TYXRpc2Z5aW5nLFxuICAgICAgbWluVmVyc2lvbixcbiAgICAgIHZhbGlkUmFuZ2UsXG4gICAgICBvdXRzaWRlLFxuICAgICAgZ3RyLFxuICAgICAgbHRyLFxuICAgICAgaW50ZXJzZWN0cyxcbiAgICAgIHNpbXBsaWZ5UmFuZ2UsXG4gICAgICBzdWJzZXQsXG4gICAgICBTZW1WZXIsXG4gICAgICByZTogaW50ZXJuYWxSZS5yZSxcbiAgICAgIHNyYzogaW50ZXJuYWxSZS5zcmMsXG4gICAgICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgICAgIFNFTVZFUl9TUEVDX1ZFUlNJT046IGNvbnN0YW50cy5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICAgICAgUkVMRUFTRV9UWVBFUzogY29uc3RhbnRzLlJFTEVBU0VfVFlQRVMsXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgICAgIHJjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLnJjb21wYXJlSWRlbnRpZmllcnNcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Byb3BhZ2F0b3ItamFlZ2VyL2J1aWxkL2VzbS9KYWVnZXJQcm9wYWdhdG9yLmpzXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVNwYW5Db250ZXh0KHNlcmlhbGl6ZWRTdHJpbmcpIHtcbiAgdmFyIGhlYWRlcnMgPSBkZWNvZGVVUklDb21wb25lbnQoc2VyaWFsaXplZFN0cmluZykuc3BsaXQoXCI6XCIpO1xuICBpZiAoaGVhZGVycy5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgX2EyID0gX19yZWFkMTUoaGVhZGVycywgNCksIF90cmFjZUlkID0gX2EyWzBdLCBfc3BhbklkID0gX2EyWzFdLCBmbGFncyA9IF9hMlszXTtcbiAgdmFyIHRyYWNlSWQgPSBfdHJhY2VJZC5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICB2YXIgc3BhbklkID0gX3NwYW5JZC5wYWRTdGFydCgxNiwgXCIwXCIpO1xuICB2YXIgdHJhY2VGbGFncyA9IFZBTElEX0hFWF9SRS50ZXN0KGZsYWdzKSA/IHBhcnNlSW50KGZsYWdzLCAxNikgJiAxIDogMTtcbiAgcmV0dXJuIHsgdHJhY2VJZCwgc3BhbklkLCBpc1JlbW90ZTogdHJ1ZSwgdHJhY2VGbGFncyB9O1xufVxudmFyIF9fdmFsdWVzMTAsIF9fcmVhZDE1LCBVQkVSX1RSQUNFX0lEX0hFQURFUiwgVUJFUl9CQUdHQUdFX0hFQURFUl9QUkVGSVgsIEphZWdlclByb3BhZ2F0b3IsIFZBTElEX0hFWF9SRTtcbnZhciBpbml0X0phZWdlclByb3BhZ2F0b3IgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Byb3BhZ2F0b3ItamFlZ2VyL2J1aWxkL2VzbS9KYWVnZXJQcm9wYWdhdG9yLmpzXCIoKSB7XG4gICAgaW5pdF9lc20oKTtcbiAgICBpbml0X2VzbTMoKTtcbiAgICBfX3ZhbHVlczEwID0gZnVuY3Rpb24obykge1xuICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICAgIGlmIChtKVxuICAgICAgICByZXR1cm4gbS5jYWxsKG8pO1xuICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aClcbiAgICAgICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgfTtcbiAgICBfX3JlYWQxNSA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghbSlcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0geyBlcnJvciB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgICAgICBtLmNhbGwoaSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXI7XG4gICAgfTtcbiAgICBVQkVSX1RSQUNFX0lEX0hFQURFUiA9IFwidWJlci10cmFjZS1pZFwiO1xuICAgIFVCRVJfQkFHR0FHRV9IRUFERVJfUFJFRklYID0gXCJ1YmVyY3R4XCI7XG4gICAgSmFlZ2VyUHJvcGFnYXRvciA9IC8qKiBAY2xhc3MgKi9cbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIEphZWdlclByb3BhZ2F0b3IyKGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRoaXMuX2phZWdlclRyYWNlSGVhZGVyID0gY29uZmlnO1xuICAgICAgICAgIHRoaXMuX2phZWdlckJhZ2dhZ2VIZWFkZXJQcmVmaXggPSBVQkVSX0JBR0dBR0VfSEVBREVSX1BSRUZJWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9qYWVnZXJUcmFjZUhlYWRlciA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuY3VzdG9tVHJhY2VIZWFkZXIpIHx8IFVCRVJfVFJBQ0VfSURfSEVBREVSO1xuICAgICAgICAgIHRoaXMuX2phZWdlckJhZ2dhZ2VIZWFkZXJQcmVmaXggPSAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmN1c3RvbUJhZ2dhZ2VIZWFkZXJQcmVmaXgpIHx8IFVCRVJfQkFHR0FHRV9IRUFERVJfUFJFRklYO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBKYWVnZXJQcm9wYWdhdG9yMi5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24oY29udGV4dDIsIGNhcnJpZXIsIHNldHRlcikge1xuICAgICAgICB2YXIgZV8xLCBfYTI7XG4gICAgICAgIHZhciBzcGFuQ29udGV4dCA9IHRyYWNlLmdldFNwYW5Db250ZXh0KGNvbnRleHQyKTtcbiAgICAgICAgdmFyIGJhZ2dhZ2UgPSBwcm9wYWdhdGlvbi5nZXRCYWdnYWdlKGNvbnRleHQyKTtcbiAgICAgICAgaWYgKHNwYW5Db250ZXh0ICYmIGlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dDIpID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciB0cmFjZUZsYWdzID0gXCIwXCIgKyAoc3BhbkNvbnRleHQudHJhY2VGbGFncyB8fCBUcmFjZUZsYWdzLk5PTkUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICBzZXR0ZXIuc2V0KGNhcnJpZXIsIHRoaXMuX2phZWdlclRyYWNlSGVhZGVyLCBzcGFuQ29udGV4dC50cmFjZUlkICsgXCI6XCIgKyBzcGFuQ29udGV4dC5zcGFuSWQgKyBcIjowOlwiICsgdHJhY2VGbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhZ2dhZ2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlczEwKGJhZ2dhZ2UuZ2V0QWxsRW50cmllcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICB2YXIgX2QgPSBfX3JlYWQxNShfYy52YWx1ZSwgMiksIGtleSA9IF9kWzBdLCBlbnRyeSA9IF9kWzFdO1xuICAgICAgICAgICAgICBzZXR0ZXIuc2V0KGNhcnJpZXIsIHRoaXMuX2phZWdlckJhZ2dhZ2VIZWFkZXJQcmVmaXggKyBcIi1cIiArIGtleSwgZW5jb2RlVVJJQ29tcG9uZW50KGVudHJ5LnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EyID0gX2IucmV0dXJuKSlcbiAgICAgICAgICAgICAgICBfYTIuY2FsbChfYik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoZV8xKVxuICAgICAgICAgICAgICAgIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBKYWVnZXJQcm9wYWdhdG9yMi5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uKGNvbnRleHQyLCBjYXJyaWVyLCBnZXR0ZXIpIHtcbiAgICAgICAgdmFyIGVfMiwgX2EyO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciB1YmVyVHJhY2VJZEhlYWRlciA9IGdldHRlci5nZXQoY2FycmllciwgdGhpcy5famFlZ2VyVHJhY2VIZWFkZXIpO1xuICAgICAgICB2YXIgdWJlclRyYWNlSWQgPSBBcnJheS5pc0FycmF5KHViZXJUcmFjZUlkSGVhZGVyKSA/IHViZXJUcmFjZUlkSGVhZGVyWzBdIDogdWJlclRyYWNlSWRIZWFkZXI7XG4gICAgICAgIHZhciBiYWdnYWdlVmFsdWVzID0gZ2V0dGVyLmtleXMoY2FycmllcikuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkuc3RhcnRzV2l0aChfdGhpcy5famFlZ2VyQmFnZ2FnZUhlYWRlclByZWZpeCArIFwiLVwiKTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlci5nZXQoY2Fycmllciwga2V5KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBrZXkuc3Vic3RyaW5nKF90aGlzLl9qYWVnZXJCYWdnYWdlSGVhZGVyUHJlZml4Lmxlbmd0aCArIDEpLFxuICAgICAgICAgICAgdmFsdWU6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmV3Q29udGV4dCA9IGNvbnRleHQyO1xuICAgICAgICBpZiAodHlwZW9mIHViZXJUcmFjZUlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFyIHNwYW5Db250ZXh0ID0gZGVzZXJpYWxpemVTcGFuQ29udGV4dCh1YmVyVHJhY2VJZCk7XG4gICAgICAgICAgaWYgKHNwYW5Db250ZXh0KSB7XG4gICAgICAgICAgICBuZXdDb250ZXh0ID0gdHJhY2Uuc2V0U3BhbkNvbnRleHQobmV3Q29udGV4dCwgc3BhbkNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFnZ2FnZVZhbHVlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIG5ld0NvbnRleHQ7XG4gICAgICAgIHZhciBjdXJyZW50QmFnZ2FnZSA9IChfYiA9IHByb3BhZ2F0aW9uLmdldEJhZ2dhZ2UoY29udGV4dDIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwcm9wYWdhdGlvbi5jcmVhdGVCYWdnYWdlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgYmFnZ2FnZVZhbHVlc18xID0gX192YWx1ZXMxMChiYWdnYWdlVmFsdWVzKSwgYmFnZ2FnZVZhbHVlc18xXzEgPSBiYWdnYWdlVmFsdWVzXzEubmV4dCgpOyAhYmFnZ2FnZVZhbHVlc18xXzEuZG9uZTsgYmFnZ2FnZVZhbHVlc18xXzEgPSBiYWdnYWdlVmFsdWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgYmFnZ2FnZUVudHJ5ID0gYmFnZ2FnZVZhbHVlc18xXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAoYmFnZ2FnZUVudHJ5LnZhbHVlID09PSB2b2lkIDApXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY3VycmVudEJhZ2dhZ2UgPSBjdXJyZW50QmFnZ2FnZS5zZXRFbnRyeShiYWdnYWdlRW50cnkua2V5LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQoYmFnZ2FnZUVudHJ5LnZhbHVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICAgIGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChiYWdnYWdlVmFsdWVzXzFfMSAmJiAhYmFnZ2FnZVZhbHVlc18xXzEuZG9uZSAmJiAoX2EyID0gYmFnZ2FnZVZhbHVlc18xLnJldHVybikpXG4gICAgICAgICAgICAgIF9hMi5jYWxsKGJhZ2dhZ2VWYWx1ZXNfMSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlXzIpXG4gICAgICAgICAgICAgIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q29udGV4dCA9IHByb3BhZ2F0aW9uLnNldEJhZ2dhZ2UobmV3Q29udGV4dCwgY3VycmVudEJhZ2dhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3Q29udGV4dDtcbiAgICAgIH07XG4gICAgICBKYWVnZXJQcm9wYWdhdG9yMi5wcm90b3R5cGUuZmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5famFlZ2VyVHJhY2VIZWFkZXJdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBKYWVnZXJQcm9wYWdhdG9yMjtcbiAgICB9KCk7XG4gICAgVkFMSURfSEVYX1JFID0gL15bMC05YS1mXXsxLDJ9JC9pO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Byb3BhZ2F0b3ItamFlZ2VyL2J1aWxkL2VzbS9pbmRleC5qc1xudmFyIGVzbV9leHBvcnRzNyA9IHt9O1xuX19leHBvcnQoZXNtX2V4cG9ydHM3LCB7XG4gIEphZWdlclByb3BhZ2F0b3I6ICgpID0+IEphZWdlclByb3BhZ2F0b3IsXG4gIFVCRVJfQkFHR0FHRV9IRUFERVJfUFJFRklYOiAoKSA9PiBVQkVSX0JBR0dBR0VfSEVBREVSX1BSRUZJWCxcbiAgVUJFUl9UUkFDRV9JRF9IRUFERVI6ICgpID0+IFVCRVJfVFJBQ0VfSURfSEVBREVSXG59KTtcbnZhciBpbml0X2VzbTcgPSBfX2VzbSh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Byb3BhZ2F0b3ItamFlZ2VyL2J1aWxkL2VzbS9pbmRleC5qc1wiKCkge1xuICAgIGluaXRfSmFlZ2VyUHJvcGFnYXRvcigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1ub2RlL2J1aWxkL3NyYy9Ob2RlVHJhY2VyUHJvdmlkZXIuanNcbnZhciByZXF1aXJlX05vZGVUcmFjZXJQcm92aWRlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2Utbm9kZS9idWlsZC9zcmMvTm9kZVRyYWNlclByb3ZpZGVyLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLk5vZGVUcmFjZXJQcm92aWRlciA9IHZvaWQgMDtcbiAgICB2YXIgY29udGV4dF9hc3luY19ob29rc18xID0gcmVxdWlyZV9zcmMoKTtcbiAgICB2YXIgcHJvcGFnYXRvcl9iM18xID0gKGluaXRfZXNtNCgpLCBfX3RvQ29tbW9uSlMoZXNtX2V4cG9ydHM0KSk7XG4gICAgdmFyIHNka190cmFjZV9iYXNlXzEgPSAoaW5pdF9lc202KCksIF9fdG9Db21tb25KUyhlc21fZXhwb3J0czYpKTtcbiAgICB2YXIgc2VtdmVyID0gcmVxdWlyZV9zZW12ZXIyKCk7XG4gICAgdmFyIHByb3BhZ2F0b3JfamFlZ2VyXzEgPSAoaW5pdF9lc203KCksIF9fdG9Db21tb25KUyhlc21fZXhwb3J0czcpKTtcbiAgICB2YXIgTm9kZVRyYWNlclByb3ZpZGVyMiA9IGNsYXNzIGV4dGVuZHMgc2RrX3RyYWNlX2Jhc2VfMS5CYXNpY1RyYWNlclByb3ZpZGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZWdpc3Rlcihjb25maWcgPSB7fSkge1xuICAgICAgICBpZiAoY29uZmlnLmNvbnRleHRNYW5hZ2VyID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCBDb250ZXh0TWFuYWdlciA9IHNlbXZlci5ndGUocHJvY2Vzcy52ZXJzaW9uLCBcIjE0LjguMFwiKSA/IGNvbnRleHRfYXN5bmNfaG9va3NfMS5Bc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyIDogY29udGV4dF9hc3luY19ob29rc18xLkFzeW5jSG9va3NDb250ZXh0TWFuYWdlcjtcbiAgICAgICAgICBjb25maWcuY29udGV4dE1hbmFnZXIgPSBuZXcgQ29udGV4dE1hbmFnZXIoKTtcbiAgICAgICAgICBjb25maWcuY29udGV4dE1hbmFnZXIuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuTm9kZVRyYWNlclByb3ZpZGVyID0gTm9kZVRyYWNlclByb3ZpZGVyMjtcbiAgICBOb2RlVHJhY2VyUHJvdmlkZXIyLl9yZWdpc3RlcmVkUHJvcGFnYXRvcnMgPSBuZXcgTWFwKFtcbiAgICAgIC4uLnNka190cmFjZV9iYXNlXzEuQmFzaWNUcmFjZXJQcm92aWRlci5fcmVnaXN0ZXJlZFByb3BhZ2F0b3JzLFxuICAgICAgW1xuICAgICAgICBcImIzXCIsXG4gICAgICAgICgpID0+IG5ldyBwcm9wYWdhdG9yX2IzXzEuQjNQcm9wYWdhdG9yKHsgaW5qZWN0RW5jb2Rpbmc6IHByb3BhZ2F0b3JfYjNfMS5CM0luamVjdEVuY29kaW5nLlNJTkdMRV9IRUFERVIgfSlcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFwiYjNtdWx0aVwiLFxuICAgICAgICAoKSA9PiBuZXcgcHJvcGFnYXRvcl9iM18xLkIzUHJvcGFnYXRvcih7IGluamVjdEVuY29kaW5nOiBwcm9wYWdhdG9yX2IzXzEuQjNJbmplY3RFbmNvZGluZy5NVUxUSV9IRUFERVIgfSlcbiAgICAgIF0sXG4gICAgICBbXCJqYWVnZXJcIiwgKCkgPT4gbmV3IHByb3BhZ2F0b3JfamFlZ2VyXzEuSmFlZ2VyUHJvcGFnYXRvcigpXVxuICAgIF0pO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Nkay10cmFjZS1ub2RlL2J1aWxkL3NyYy9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3JjMiA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9zZGstdHJhY2Utbm9kZS9idWlsZC9zcmMvaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgICAgaWYgKGsyID09PSB2b2lkIDApXG4gICAgICAgIGsyID0gaztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH0gfSk7XG4gICAgfSA6IGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgICBpZiAoazIgPT09IHZvaWQgMClcbiAgICAgICAgazIgPSBrO1xuICAgICAgb1trMl0gPSBtW2tdO1xuICAgIH0pO1xuICAgIHZhciBfX2V4cG9ydFN0YXIgPSBleHBvcnRzICYmIGV4cG9ydHMuX19leHBvcnRTdGFyIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMyKSB7XG4gICAgICBmb3IgKHZhciBwIGluIG0pXG4gICAgICAgIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMyLCBwKSlcbiAgICAgICAgICBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0czIsIG0sIHApO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIF9fZXhwb3J0U3RhcihyZXF1aXJlX05vZGVUcmFjZXJQcm92aWRlcigpLCBleHBvcnRzKTtcbiAgICBfX2V4cG9ydFN0YXIoKGluaXRfZXNtNigpLCBfX3RvQ29tbW9uSlMoZXNtX2V4cG9ydHM2KSksIGV4cG9ydHMpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlLWRldGVjdG9yLWF3cy9idWlsZC9zcmMvZGV0ZWN0b3JzL0F3c0VjMkRldGVjdG9yLmpzXG52YXIgcmVxdWlyZV9Bd3NFYzJEZXRlY3RvciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZS1kZXRlY3Rvci1hd3MvYnVpbGQvc3JjL2RldGVjdG9ycy9Bd3NFYzJEZXRlY3Rvci5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgZXhwb3J0cy5hd3NFYzJEZXRlY3RvciA9IHZvaWQgMDtcbiAgICB2YXIgcmVzb3VyY2VzXzEgPSAoaW5pdF9lc201KCksIF9fdG9Db21tb25KUyhlc21fZXhwb3J0czUpKTtcbiAgICB2YXIgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IChpbml0X2VzbTIoKSwgX190b0NvbW1vbkpTKGVzbV9leHBvcnRzMikpO1xuICAgIHZhciBodHRwMiA9IHJlcXVpcmUoXCJodHRwXCIpO1xuICAgIHZhciBBd3NFYzJEZXRlY3RvciA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLkFXU19JRE1TX0VORFBPSU5UID0gXCIxNjkuMjU0LjE2OS4yNTRcIjtcbiAgICAgICAgdGhpcy5BV1NfSU5TVEFOQ0VfVE9LRU5fRE9DVU1FTlRfUEFUSCA9IFwiL2xhdGVzdC9hcGkvdG9rZW5cIjtcbiAgICAgICAgdGhpcy5BV1NfSU5TVEFOQ0VfSURFTlRJVFlfRE9DVU1FTlRfUEFUSCA9IFwiL2xhdGVzdC9keW5hbWljL2luc3RhbmNlLWlkZW50aXR5L2RvY3VtZW50XCI7XG4gICAgICAgIHRoaXMuQVdTX0lOU1RBTkNFX0hPU1RfRE9DVU1FTlRfUEFUSCA9IFwiL2xhdGVzdC9tZXRhLWRhdGEvaG9zdG5hbWVcIjtcbiAgICAgICAgdGhpcy5BV1NfTUVUQURBVEFfVFRMX0hFQURFUiA9IFwiWC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuLXR0bC1zZWNvbmRzXCI7XG4gICAgICAgIHRoaXMuQVdTX01FVEFEQVRBX1RPS0VOX0hFQURFUiA9IFwiWC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuXCI7XG4gICAgICAgIHRoaXMuTUlMTElTRUNPTkRfVElNRV9PVVQgPSA1ZTM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEF0dGVtcHRzIHRvIGNvbm5lY3QgYW5kIG9idGFpbiBhbiBBV1MgaW5zdGFuY2UgSWRlbnRpdHkgZG9jdW1lbnQuIElmIHRoZVxuICAgICAgICogY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsIGl0IHJldHVybnMgYSBwcm9taXNlIGNvbnRhaW5pbmcgYSB7QGxpbmsgUmVzb3VyY2V9XG4gICAgICAgKiBwb3B1bGF0ZWQgd2l0aCBpbnN0YW5jZSBtZXRhZGF0YS4gUmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyBhblxuICAgICAgICogZW1wdHkge0BsaW5rIFJlc291cmNlfSBpZiB0aGUgY29ubmVjdGlvbiBvciBwYXJzaW5nIG9mIHRoZSBpZGVudGl0eVxuICAgICAgICogZG9jdW1lbnQgZmFpbHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGNvbmZpZyAodW51c2VkKSBUaGUgcmVzb3VyY2UgZGV0ZWN0aW9uIGNvbmZpZ1xuICAgICAgICovXG4gICAgICBhc3luYyBkZXRlY3QoX2NvbmZpZykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuX2ZldGNoVG9rZW4oKTtcbiAgICAgICAgY29uc3QgeyBhY2NvdW50SWQsIGluc3RhbmNlSWQsIGluc3RhbmNlVHlwZSwgcmVnaW9uLCBhdmFpbGFiaWxpdHlab25lIH0gPSBhd2FpdCB0aGlzLl9mZXRjaElkZW50aXR5KHRva2VuKTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUyID0gYXdhaXQgdGhpcy5fZmV0Y2hIb3N0KHRva2VuKTtcbiAgICAgICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfMS5SZXNvdXJjZSh7XG4gICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfQ0xPVURfUFJPVklERVJdOiBzZW1hbnRpY19jb252ZW50aW9uc18xLkNMT1VEUFJPVklERVJWQUxVRVNfQVdTLFxuICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0NMT1VEX1BMQVRGT1JNXTogc2VtYW50aWNfY29udmVudGlvbnNfMS5DTE9VRFBMQVRGT1JNVkFMVUVTX0FXU19FQzIsXG4gICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfQ0xPVURfQUNDT1VOVF9JRF06IGFjY291bnRJZCxcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DTE9VRF9SRUdJT05dOiByZWdpb24sXG4gICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfQ0xPVURfQVZBSUxBQklMSVRZX1pPTkVdOiBhdmFpbGFiaWxpdHlab25lLFxuICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0hPU1RfSURdOiBpbnN0YW5jZUlkLFxuICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0hPU1RfVFlQRV06IGluc3RhbmNlVHlwZSxcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19IT1NUX05BTUVdOiBob3N0bmFtZTJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhc3luYyBfZmV0Y2hUb2tlbigpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBob3N0OiB0aGlzLkFXU19JRE1TX0VORFBPSU5ULFxuICAgICAgICAgIHBhdGg6IHRoaXMuQVdTX0lOU1RBTkNFX1RPS0VOX0RPQ1VNRU5UX1BBVEgsXG4gICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuTUlMTElTRUNPTkRfVElNRV9PVVQsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgW3RoaXMuQVdTX01FVEFEQVRBX1RUTF9IRUFERVJdOiBcIjYwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9mZXRjaFN0cmluZyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGFzeW5jIF9mZXRjaElkZW50aXR5KHRva2VuKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgaG9zdDogdGhpcy5BV1NfSURNU19FTkRQT0lOVCxcbiAgICAgICAgICBwYXRoOiB0aGlzLkFXU19JTlNUQU5DRV9JREVOVElUWV9ET0NVTUVOVF9QQVRILFxuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICB0aW1lb3V0OiB0aGlzLk1JTExJU0VDT05EX1RJTUVfT1VULFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFt0aGlzLkFXU19NRVRBREFUQV9UT0tFTl9IRUFERVJdOiB0b2tlblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaWRlbnRpdHkyID0gYXdhaXQgdGhpcy5fZmV0Y2hTdHJpbmcob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGlkZW50aXR5Mik7XG4gICAgICB9XG4gICAgICBhc3luYyBfZmV0Y2hIb3N0KHRva2VuKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgaG9zdDogdGhpcy5BV1NfSURNU19FTkRQT0lOVCxcbiAgICAgICAgICBwYXRoOiB0aGlzLkFXU19JTlNUQU5DRV9IT1NUX0RPQ1VNRU5UX1BBVEgsXG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuTUlMTElTRUNPTkRfVElNRV9PVVQsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgW3RoaXMuQVdTX01FVEFEQVRBX1RPS0VOX0hFQURFUl06IHRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZmV0Y2hTdHJpbmcob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEVzdGFibGlzaGVzIGFuIEhUVFAgY29ubmVjdGlvbiB0byBBV1MgaW5zdGFuY2UgZG9jdW1lbnQgdXJsLlxuICAgICAgICogSWYgdGhlIGFwcGxpY2F0aW9uIGlzIHJ1bm5pbmcgb24gYW4gRUMyIGluc3RhbmNlLCB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICogdG8gZ2V0IGJhY2sgYSB2YWxpZCBKU09OIGRvY3VtZW50LiBQYXJzZXMgdGhhdCBkb2N1bWVudCBhbmQgc3RvcmVzXG4gICAgICAgKiB0aGUgaWRlbnRpdHkgcHJvcGVydGllcyBpbiBhIGxvY2FsIG1hcC5cbiAgICAgICAqL1xuICAgICAgYXN5bmMgX2ZldGNoU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkVDMiBtZXRhZGF0YSBhcGkgcmVxdWVzdCB0aW1lZCBvdXQuXCIpKTtcbiAgICAgICAgICB9LCAxZTMpO1xuICAgICAgICAgIGNvbnN0IHJlcSA9IGh0dHAyLnJlcXVlc3Qob3B0aW9ucywgKHJlcykgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXR1c0NvZGUgfSA9IHJlcztcbiAgICAgICAgICAgIHJlcy5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG4gICAgICAgICAgICBsZXQgcmF3RGF0YSA9IFwiXCI7XG4gICAgICAgICAgICByZXMub24oXCJkYXRhXCIsIChjaHVuaykgPT4gcmF3RGF0YSArPSBjaHVuayk7XG4gICAgICAgICAgICByZXMub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSAmJiBzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmF3RGF0YSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcGFnZSwgc3RhdHVzIGNvZGU6IFwiICsgc3RhdHVzQ29kZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXEub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcS5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmF3c0VjMkRldGVjdG9yID0gbmV3IEF3c0VjMkRldGVjdG9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2UtZGV0ZWN0b3ItYXdzL2J1aWxkL3NyYy9kZXRlY3RvcnMvQXdzQmVhbnN0YWxrRGV0ZWN0b3IuanNcbnZhciByZXF1aXJlX0F3c0JlYW5zdGFsa0RldGVjdG9yID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlLWRldGVjdG9yLWF3cy9idWlsZC9zcmMvZGV0ZWN0b3JzL0F3c0JlYW5zdGFsa0RldGVjdG9yLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLmF3c0JlYW5zdGFsa0RldGVjdG9yID0gZXhwb3J0cy5Bd3NCZWFuc3RhbGtEZXRlY3RvciA9IHZvaWQgMDtcbiAgICB2YXIgYXBpXzEgPSAoaW5pdF9lc20oKSwgX190b0NvbW1vbkpTKGVzbV9leHBvcnRzKSk7XG4gICAgdmFyIHJlc291cmNlc18xID0gKGluaXRfZXNtNSgpLCBfX3RvQ29tbW9uSlMoZXNtX2V4cG9ydHM1KSk7XG4gICAgdmFyIHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSAoaW5pdF9lc20yKCksIF9fdG9Db21tb25KUyhlc21fZXhwb3J0czIpKTtcbiAgICB2YXIgZnMzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuICAgIHZhciBERUZBVUxUX0JFQU5TVEFMS19DT05GX1BBVEggPSBcIi92YXIvZWxhc3RpY2JlYW5zdGFsay94cmF5L2Vudmlyb25tZW50LmNvbmZcIjtcbiAgICB2YXIgV0lOX09TX0JFQU5TVEFMS19DT05GX1BBVEggPSBcIkM6XFxcXFByb2dyYW0gRmlsZXNcXFxcQW1hem9uXFxcXFhSYXlcXFxcZW52aXJvbm1lbnQuY29uZlwiO1xuICAgIHZhciBBd3NCZWFuc3RhbGtEZXRlY3RvciA9IGNsYXNzIF9Bd3NCZWFuc3RhbGtEZXRlY3RvciB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICAgIHRoaXMuQkVBTlNUQUxLX0NPTkZfUEFUSCA9IFdJTl9PU19CRUFOU1RBTEtfQ09ORl9QQVRIO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuQkVBTlNUQUxLX0NPTkZfUEFUSCA9IERFRkFVTFRfQkVBTlNUQUxLX0NPTkZfUEFUSDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXN5bmMgZGV0ZWN0KF9jb25maWcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBfQXdzQmVhbnN0YWxrRGV0ZWN0b3IuZmlsZUFjY2Vzc0FzeW5jKHRoaXMuQkVBTlNUQUxLX0NPTkZfUEFUSCwgZnMzLmNvbnN0YW50cy5SX09LKTtcbiAgICAgICAgICBjb25zdCByYXdEYXRhID0gYXdhaXQgX0F3c0JlYW5zdGFsa0RldGVjdG9yLnJlYWRGaWxlQXN5bmModGhpcy5CRUFOU1RBTEtfQ09ORl9QQVRILCBcInV0ZjhcIik7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfMS5SZXNvdXJjZSh7XG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DTE9VRF9QUk9WSURFUl06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuQ0xPVURQUk9WSURFUlZBTFVFU19BV1MsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DTE9VRF9QTEFURk9STV06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUxBU1RJQ19CRUFOU1RBTEssXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19TRVJWSUNFX05BTUVdOiBzZW1hbnRpY19jb252ZW50aW9uc18xLkNMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VMQVNUSUNfQkVBTlNUQUxLLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfU0VSVklDRV9OQU1FU1BBQ0VdOiBwYXJzZWREYXRhLmVudmlyb25tZW50X25hbWUsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19TRVJWSUNFX1ZFUlNJT05dOiBwYXJzZWREYXRhLnZlcnNpb25fbGFiZWwsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19TRVJWSUNFX0lOU1RBTkNFX0lEXTogcGFyc2VkRGF0YS5kZXBsb3ltZW50X2lkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBhcGlfMS5kaWFnLmRlYnVnKGBBd3NCZWFuc3RhbGtEZXRlY3RvciBmYWlsZWQ6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgIHJldHVybiByZXNvdXJjZXNfMS5SZXNvdXJjZS5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkF3c0JlYW5zdGFsa0RldGVjdG9yID0gQXdzQmVhbnN0YWxrRGV0ZWN0b3I7XG4gICAgQXdzQmVhbnN0YWxrRGV0ZWN0b3IucmVhZEZpbGVBc3luYyA9IHV0aWwyLnByb21pc2lmeShmczMucmVhZEZpbGUpO1xuICAgIEF3c0JlYW5zdGFsa0RldGVjdG9yLmZpbGVBY2Nlc3NBc3luYyA9IHV0aWwyLnByb21pc2lmeShmczMuYWNjZXNzKTtcbiAgICBleHBvcnRzLmF3c0JlYW5zdGFsa0RldGVjdG9yID0gbmV3IEF3c0JlYW5zdGFsa0RldGVjdG9yKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2UtZGV0ZWN0b3ItYXdzL2J1aWxkL3NyYy9kZXRlY3RvcnMvQXdzRWNzRGV0ZWN0b3IuanNcbnZhciByZXF1aXJlX0F3c0Vjc0RldGVjdG9yID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlLWRldGVjdG9yLWF3cy9idWlsZC9zcmMvZGV0ZWN0b3JzL0F3c0Vjc0RldGVjdG9yLmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLmF3c0Vjc0RldGVjdG9yID0gZXhwb3J0cy5Bd3NFY3NEZXRlY3RvciA9IHZvaWQgMDtcbiAgICB2YXIgYXBpXzEgPSAoaW5pdF9lc20oKSwgX190b0NvbW1vbkpTKGVzbV9leHBvcnRzKSk7XG4gICAgdmFyIHJlc291cmNlc18xID0gKGluaXRfZXNtNSgpLCBfX3RvQ29tbW9uSlMoZXNtX2V4cG9ydHM1KSk7XG4gICAgdmFyIHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSAoaW5pdF9lc20yKCksIF9fdG9Db21tb25KUyhlc21fZXhwb3J0czIpKTtcbiAgICB2YXIgaHR0cDIgPSByZXF1aXJlKFwiaHR0cFwiKTtcbiAgICB2YXIgdXRpbDIgPSByZXF1aXJlKFwidXRpbFwiKTtcbiAgICB2YXIgZnMzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIHZhciBvczIgPSByZXF1aXJlKFwib3NcIik7XG4gICAgdmFyIGNvcmVfMSA9IChpbml0X2VzbTMoKSwgX190b0NvbW1vbkpTKGVzbV9leHBvcnRzMykpO1xuICAgIHZhciBIVFRQX1RJTUVPVVRfSU5fTVMgPSAxZTM7XG4gICAgdmFyIEF3c0Vjc0RldGVjdG9yID0gY2xhc3MgX0F3c0Vjc0RldGVjdG9yIHtcbiAgICAgIGFzeW5jIGRldGVjdCgpIHtcbiAgICAgICAgY29uc3QgZW52MyA9ICgwLCBjb3JlXzEuZ2V0RW52KSgpO1xuICAgICAgICBpZiAoIWVudjMuRUNTX0NPTlRBSU5FUl9NRVRBREFUQV9VUklfVjQgJiYgIWVudjMuRUNTX0NPTlRBSU5FUl9NRVRBREFUQV9VUkkpIHtcbiAgICAgICAgICBhcGlfMS5kaWFnLmRlYnVnKFwiQXdzRWNzRGV0ZWN0b3IgZmFpbGVkOiBQcm9jZXNzIGlzIG5vdCBvbiBFQ1NcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc291cmNlc18xLlJlc291cmNlLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc291cmNlID0gbmV3IHJlc291cmNlc18xLlJlc291cmNlKHtcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DTE9VRF9QUk9WSURFUl06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuQ0xPVURQUk9WSURFUlZBTFVFU19BV1MsXG4gICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfQ0xPVURfUExBVEZPUk1dOiBzZW1hbnRpY19jb252ZW50aW9uc18xLkNMT1VEUExBVEZPUk1WQUxVRVNfQVdTX0VDU1xuICAgICAgICB9KS5tZXJnZShhd2FpdCBfQXdzRWNzRGV0ZWN0b3IuX2dldENvbnRhaW5lcklkQW5kSG9zdG5hbWVSZXNvdXJjZSgpKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFVcmwgPSAoMCwgY29yZV8xLmdldEVudikoKS5FQ1NfQ09OVEFJTkVSX01FVEFEQVRBX1VSSV9WNDtcbiAgICAgICAgaWYgKG1ldGFkYXRhVXJsKSB7XG4gICAgICAgICAgY29uc3QgW2NvbnRhaW5lck1ldGFkYXRhLCB0YXNrTWV0YWRhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgX0F3c0Vjc0RldGVjdG9yLl9nZXRVcmxBc0pzb24obWV0YWRhdGFVcmwpLFxuICAgICAgICAgICAgX0F3c0Vjc0RldGVjdG9yLl9nZXRVcmxBc0pzb24oYCR7bWV0YWRhdGFVcmx9L3Rhc2tgKVxuICAgICAgICAgIF0pO1xuICAgICAgICAgIGNvbnN0IG1ldGFkYXRhdjRSZXNvdXJjZSA9IGF3YWl0IF9Bd3NFY3NEZXRlY3Rvci5fZ2V0TWV0YWRhdGFWNFJlc291cmNlKGNvbnRhaW5lck1ldGFkYXRhLCB0YXNrTWV0YWRhdGEpO1xuICAgICAgICAgIGNvbnN0IGxvZ3NSZXNvdXJjZSA9IGF3YWl0IF9Bd3NFY3NEZXRlY3Rvci5fZ2V0TG9nUmVzb3VyY2UoY29udGFpbmVyTWV0YWRhdGEpO1xuICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2UubWVyZ2UobWV0YWRhdGF2NFJlc291cmNlKS5tZXJnZShsb2dzUmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvdXJjZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmVhZCBjb250YWluZXIgSUQgZnJvbSBjZ3JvdXAgZmlsZVxuICAgICAgICogSW4gRUNTLCBldmVuIGlmIHdlIGZhaWwgdG8gZmluZCB0YXJnZXQgZmlsZVxuICAgICAgICogb3IgdGFyZ2V0IGZpbGUgZG9lcyBub3QgY29udGFpbiBjb250YWluZXIgSURcbiAgICAgICAqIHdlIGRvIG5vdCB0aHJvdyBhbiBlcnJvciBidXQgdGhyb3cgd2FybmluZyBtZXNzYWdlXG4gICAgICAgKiBhbmQgdGhlbiByZXR1cm4gbnVsbCBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgc3RhdGljIGFzeW5jIF9nZXRDb250YWluZXJJZEFuZEhvc3RuYW1lUmVzb3VyY2UoKSB7XG4gICAgICAgIGNvbnN0IGhvc3ROYW1lID0gb3MyLmhvc3RuYW1lKCk7XG4gICAgICAgIGxldCBjb250YWluZXJJZCA9IFwiXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmF3RGF0YSA9IGF3YWl0IF9Bd3NFY3NEZXRlY3Rvci5yZWFkRmlsZUFzeW5jKF9Bd3NFY3NEZXRlY3Rvci5ERUZBVUxUX0NHUk9VUF9QQVRILCBcInV0ZjhcIik7XG4gICAgICAgICAgY29uc3Qgc3BsaXREYXRhID0gcmF3RGF0YS50cmltKCkuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBzdHIgb2Ygc3BsaXREYXRhKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IF9Bd3NFY3NEZXRlY3Rvci5DT05UQUlORVJfSURfTEVOR1RIKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lcklkID0gc3RyLnN1YnN0cmluZyhzdHIubGVuZ3RoIC0gX0F3c0Vjc0RldGVjdG9yLkNPTlRBSU5FUl9JRF9MRU5HVEgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBhcGlfMS5kaWFnLndhcm4oXCJBd3NFY3NEZXRlY3RvciBmYWlsZWQgdG8gcmVhZCBjb250YWluZXIgSURcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3ROYW1lIHx8IGNvbnRhaW5lcklkKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfMS5SZXNvdXJjZSh7XG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DT05UQUlORVJfTkFNRV06IGhvc3ROYW1lIHx8IFwiXCIsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DT05UQUlORVJfSURdOiBjb250YWluZXJJZCB8fCBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc291cmNlc18xLlJlc291cmNlLmVtcHR5KCk7XG4gICAgICB9XG4gICAgICBzdGF0aWMgYXN5bmMgX2dldE1ldGFkYXRhVjRSZXNvdXJjZShjb250YWluZXJNZXRhZGF0YSwgdGFza01ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGxhdW5jaFR5cGUgPSB0YXNrTWV0YWRhdGFbXCJMYXVuY2hUeXBlXCJdO1xuICAgICAgICBjb25zdCB0YXNrQXJuID0gdGFza01ldGFkYXRhW1wiVGFza0FSTlwiXTtcbiAgICAgICAgY29uc3QgYmFzZUFybiA9IHRhc2tBcm4uc3Vic3RyaW5nKDAsIHRhc2tBcm4ubGFzdEluZGV4T2YoXCI6XCIpKTtcbiAgICAgICAgY29uc3QgY2x1c3RlciA9IHRhc2tNZXRhZGF0YVtcIkNsdXN0ZXJcIl07XG4gICAgICAgIGNvbnN0IGFjY291bnRJZCA9IF9Bd3NFY3NEZXRlY3Rvci5fZ2V0QWNjb3VudEZyb21Bcm4odGFza0Fybik7XG4gICAgICAgIGNvbnN0IHJlZ2lvbiA9IF9Bd3NFY3NEZXRlY3Rvci5fZ2V0UmVnaW9uRnJvbUFybih0YXNrQXJuKTtcbiAgICAgICAgY29uc3QgYXZhaWxhYmlsaXR5Wm9uZSA9IHRhc2tNZXRhZGF0YSA9PT0gbnVsbCB8fCB0YXNrTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhc2tNZXRhZGF0YVtcIkF2YWlsYWJpbGl0eVpvbmVcIl07XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJBcm4gPSBjbHVzdGVyLnN0YXJ0c1dpdGgoXCJhcm46XCIpID8gY2x1c3RlciA6IGAke2Jhc2VBcm59OmNsdXN0ZXIvJHtjbHVzdGVyfWA7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckFybiA9IGNvbnRhaW5lck1ldGFkYXRhW1wiQ29udGFpbmVyQVJOXCJdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0FXU19FQ1NfQ09OVEFJTkVSX0FSTl06IGNvbnRhaW5lckFybixcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19BV1NfRUNTX0NMVVNURVJfQVJOXTogY2x1c3RlckFybixcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19BV1NfRUNTX0xBVU5DSFRZUEVdOiBsYXVuY2hUeXBlID09PSBudWxsIHx8IGxhdW5jaFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhdW5jaFR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19BV1NfRUNTX1RBU0tfQVJOXTogdGFza0FybixcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19BV1NfRUNTX1RBU0tfRkFNSUxZXTogdGFza01ldGFkYXRhW1wiRmFtaWx5XCJdLFxuICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0FXU19FQ1NfVEFTS19SRVZJU0lPTl06IHRhc2tNZXRhZGF0YVtcIlJldmlzaW9uXCJdLFxuICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0NMT1VEX0FDQ09VTlRfSURdOiBhY2NvdW50SWQsXG4gICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfQ0xPVURfUkVHSU9OXTogcmVnaW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhdmFpbGFiaWxpdHlab25lKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0NMT1VEX0FWQUlMQUJJTElUWV9aT05FXSA9IGF2YWlsYWJpbGl0eVpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfMS5SZXNvdXJjZShhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBhc3luYyBfZ2V0TG9nUmVzb3VyY2UoY29udGFpbmVyTWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lck1ldGFkYXRhW1wiTG9nRHJpdmVyXCJdICE9PSBcImF3c2xvZ3NcIiB8fCAhY29udGFpbmVyTWV0YWRhdGFbXCJMb2dPcHRpb25zXCJdKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc291cmNlc18xLlJlc291cmNlLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckFybiA9IGNvbnRhaW5lck1ldGFkYXRhW1wiQ29udGFpbmVyQVJOXCJdO1xuICAgICAgICBjb25zdCBsb2dPcHRpb25zID0gY29udGFpbmVyTWV0YWRhdGFbXCJMb2dPcHRpb25zXCJdO1xuICAgICAgICBjb25zdCBsb2dzUmVnaW9uID0gbG9nT3B0aW9uc1tcImF3c2xvZ3MtcmVnaW9uXCJdIHx8IF9Bd3NFY3NEZXRlY3Rvci5fZ2V0UmVnaW9uRnJvbUFybihjb250YWluZXJBcm4pO1xuICAgICAgICBjb25zdCBhd3NBY2NvdW50ID0gX0F3c0Vjc0RldGVjdG9yLl9nZXRBY2NvdW50RnJvbUFybihjb250YWluZXJBcm4pO1xuICAgICAgICBjb25zdCBsb2dzR3JvdXBOYW1lID0gbG9nT3B0aW9uc1tcImF3c2xvZ3MtZ3JvdXBcIl07XG4gICAgICAgIGNvbnN0IGxvZ3NHcm91cEFybiA9IGBhcm46YXdzOmxvZ3M6JHtsb2dzUmVnaW9ufToke2F3c0FjY291bnR9OmxvZy1ncm91cDoke2xvZ3NHcm91cE5hbWV9YDtcbiAgICAgICAgY29uc3QgbG9nc1N0cmVhbU5hbWUgPSBsb2dPcHRpb25zW1wiYXdzbG9ncy1zdHJlYW1cIl07XG4gICAgICAgIGNvbnN0IGxvZ3NTdHJlYW1Bcm4gPSBgYXJuOmF3czpsb2dzOiR7bG9nc1JlZ2lvbn06JHthd3NBY2NvdW50fTpsb2ctZ3JvdXA6JHtsb2dzR3JvdXBOYW1lfTpsb2ctc3RyZWFtOiR7bG9nc1N0cmVhbU5hbWV9YDtcbiAgICAgICAgcmV0dXJuIG5ldyByZXNvdXJjZXNfMS5SZXNvdXJjZSh7XG4gICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfQVdTX0xPR19HUk9VUF9OQU1FU106IFtsb2dzR3JvdXBOYW1lXSxcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19BV1NfTE9HX0dST1VQX0FSTlNdOiBbbG9nc0dyb3VwQXJuXSxcbiAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19BV1NfTE9HX1NUUkVBTV9OQU1FU106IFtsb2dzU3RyZWFtTmFtZV0sXG4gICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfQVdTX0xPR19TVFJFQU1fQVJOU106IFtsb2dzU3RyZWFtQXJuXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBfZ2V0QWNjb3VudEZyb21Bcm4oY29udGFpbmVyQXJuKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gL2Fybjphd3M6ZWNzOlteOl0rOihbXjpdKyk6LiovLmV4ZWMoY29udGFpbmVyQXJuKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgfVxuICAgICAgc3RhdGljIF9nZXRSZWdpb25Gcm9tQXJuKGNvbnRhaW5lckFybikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9hcm46YXdzOmVjczooW146XSspOi4qLy5leGVjKGNvbnRhaW5lckFybik7XG4gICAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBfZ2V0VXJsQXNKc29uKHVybDQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0MyA9IGh0dHAyLmdldCh1cmw0LCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFJlcXVlc3QgdG8gJyR7dXJsNH0nIGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlQm9keSA9IFwiXCI7XG4gICAgICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiByZXNwb25zZUJvZHkgKz0gY2h1bmsudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCAoKSA9PiByZXNvbHZlKHJlc3BvbnNlQm9keSkpO1xuICAgICAgICAgICAgcmVxdWVzdDMub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3QzLnNldFRpbWVvdXQoSFRUUF9USU1FT1VUX0lOX01TLCAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0My5kZXN0cm95KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxdWVzdDMub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgIHJlcXVlc3QzLmVuZCgpO1xuICAgICAgICB9KS50aGVuKChyZXNwb25zZUJvZHlSYXcpID0+IEpTT04ucGFyc2UocmVzcG9uc2VCb2R5UmF3KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLkF3c0Vjc0RldGVjdG9yID0gQXdzRWNzRGV0ZWN0b3I7XG4gICAgQXdzRWNzRGV0ZWN0b3IuQ09OVEFJTkVSX0lEX0xFTkdUSCA9IDY0O1xuICAgIEF3c0Vjc0RldGVjdG9yLkRFRkFVTFRfQ0dST1VQX1BBVEggPSBcIi9wcm9jL3NlbGYvY2dyb3VwXCI7XG4gICAgQXdzRWNzRGV0ZWN0b3IucmVhZEZpbGVBc3luYyA9IHV0aWwyLnByb21pc2lmeShmczMucmVhZEZpbGUpO1xuICAgIGV4cG9ydHMuYXdzRWNzRGV0ZWN0b3IgPSBuZXcgQXdzRWNzRGV0ZWN0b3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZS1kZXRlY3Rvci1hd3MvYnVpbGQvc3JjL2RldGVjdG9ycy9Bd3NFa3NEZXRlY3Rvci5qc1xudmFyIHJlcXVpcmVfQXdzRWtzRGV0ZWN0b3IgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2UtZGV0ZWN0b3ItYXdzL2J1aWxkL3NyYy9kZXRlY3RvcnMvQXdzRWtzRGV0ZWN0b3IuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuYXdzRWtzRGV0ZWN0b3IgPSBleHBvcnRzLkF3c0Vrc0RldGVjdG9yID0gdm9pZCAwO1xuICAgIHZhciByZXNvdXJjZXNfMSA9IChpbml0X2VzbTUoKSwgX190b0NvbW1vbkpTKGVzbV9leHBvcnRzNSkpO1xuICAgIHZhciBzZW1hbnRpY19jb252ZW50aW9uc18xID0gKGluaXRfZXNtMigpLCBfX3RvQ29tbW9uSlMoZXNtX2V4cG9ydHMyKSk7XG4gICAgdmFyIGh0dHBzMiA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbiAgICB2YXIgZnMzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIHZhciB1dGlsMiA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuICAgIHZhciBhcGlfMSA9IChpbml0X2VzbSgpLCBfX3RvQ29tbW9uSlMoZXNtX2V4cG9ydHMpKTtcbiAgICB2YXIgQXdzRWtzRGV0ZWN0b3IgPSBjbGFzcyBfQXdzRWtzRGV0ZWN0b3Ige1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuSzhTX1NWQ19VUkwgPSBcImt1YmVybmV0ZXMuZGVmYXVsdC5zdmNcIjtcbiAgICAgICAgdGhpcy5LOFNfVE9LRU5fUEFUSCA9IFwiL3Zhci9ydW4vc2VjcmV0cy9rdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3Rva2VuXCI7XG4gICAgICAgIHRoaXMuSzhTX0NFUlRfUEFUSCA9IFwiL3Zhci9ydW4vc2VjcmV0cy9rdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L2NhLmNydFwiO1xuICAgICAgICB0aGlzLkFVVEhfQ09ORklHTUFQX1BBVEggPSBcIi9hcGkvdjEvbmFtZXNwYWNlcy9rdWJlLXN5c3RlbS9jb25maWdtYXBzL2F3cy1hdXRoXCI7XG4gICAgICAgIHRoaXMuQ1dfQ09ORklHTUFQX1BBVEggPSBcIi9hcGkvdjEvbmFtZXNwYWNlcy9hbWF6b24tY2xvdWR3YXRjaC9jb25maWdtYXBzL2NsdXN0ZXItaW5mb1wiO1xuICAgICAgICB0aGlzLkNPTlRBSU5FUl9JRF9MRU5HVEggPSA2NDtcbiAgICAgICAgdGhpcy5ERUZBVUxUX0NHUk9VUF9QQVRIID0gXCIvcHJvYy9zZWxmL2Nncm91cFwiO1xuICAgICAgICB0aGlzLlRJTUVPVVRfTVMgPSAyZTM7XG4gICAgICAgIHRoaXMuVVRGOF9VTklDT0RFID0gXCJ1dGY4XCI7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBBd3NFa3NEZXRlY3RvciBjYW4gYmUgdXNlZCB0byBkZXRlY3QgaWYgYSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gQW1hem9uXG4gICAgICAgKiBFbGFzdGljIEt1YmVybmV0ZXMgYW5kIHJldHVybnMgYSBwcm9taXNlIGNvbnRhaW5pbmcgYSB7QGxpbmsgUmVzb3VyY2V9XG4gICAgICAgKiBwb3B1bGF0ZWQgd2l0aCBpbnN0YW5jZSBtZXRhZGF0YS4gUmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyBhblxuICAgICAgICogZW1wdHkge0BsaW5rIFJlc291cmNlfSBpZiB0aGUgY29ubmVjdGlvbiB0byBrdWJlcm5ldGVzIHByb2Nlc3NcbiAgICAgICAqIG9yIGF3cyBjb25maWcgbWFwcyBmYWlsc1xuICAgICAgICogQHBhcmFtIGNvbmZpZyBUaGUgcmVzb3VyY2UgZGV0ZWN0aW9uIGNvbmZpZ1xuICAgICAgICovXG4gICAgICBhc3luYyBkZXRlY3QoX2NvbmZpZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IF9Bd3NFa3NEZXRlY3Rvci5maWxlQWNjZXNzQXN5bmModGhpcy5LOFNfVE9LRU5fUEFUSCk7XG4gICAgICAgICAgY29uc3QgazhzY2VydCA9IGF3YWl0IF9Bd3NFa3NEZXRlY3Rvci5yZWFkRmlsZUFzeW5jKHRoaXMuSzhTX0NFUlRfUEFUSCk7XG4gICAgICAgICAgaWYgKCFhd2FpdCB0aGlzLl9pc0VrcyhrOHNjZXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlc18xLlJlc291cmNlLmVtcHR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcklkID0gYXdhaXQgdGhpcy5fZ2V0Q29udGFpbmVySWQoKTtcbiAgICAgICAgICBjb25zdCBjbHVzdGVyTmFtZSA9IGF3YWl0IHRoaXMuX2dldENsdXN0ZXJOYW1lKGs4c2NlcnQpO1xuICAgICAgICAgIHJldHVybiAhY29udGFpbmVySWQgJiYgIWNsdXN0ZXJOYW1lID8gcmVzb3VyY2VzXzEuUmVzb3VyY2UuZW1wdHkoKSA6IG5ldyByZXNvdXJjZXNfMS5SZXNvdXJjZSh7XG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DTE9VRF9QUk9WSURFUl06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuQ0xPVURQUk9WSURFUlZBTFVFU19BV1MsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DTE9VRF9QTEFURk9STV06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuQ0xPVURQTEFURk9STVZBTFVFU19BV1NfRUtTLFxuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfSzhTX0NMVVNURVJfTkFNRV06IGNsdXN0ZXJOYW1lIHx8IFwiXCIsXG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19DT05UQUlORVJfSURdOiBjb250YWluZXJJZCB8fCBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBhcGlfMS5kaWFnLndhcm4oXCJQcm9jZXNzIGlzIG5vdCBydW5uaW5nIG9uIEs4U1wiLCBlKTtcbiAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzXzEuUmVzb3VyY2UuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBdHRlbXB0cyB0byBtYWtlIGEgY29ubmVjdGlvbiB0byBBV1MgQ29uZmlnIG1hcCB3aGljaCB3aWxsXG4gICAgICAgKiBkZXRlcm1pbmUgd2hldGhlciB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGFuIEVLU1xuICAgICAgICogcHJvY2VzcyBpZiB0aGUgY29uZmlnIG1hcCBpcyBlbXB0eSBvciBub3RcbiAgICAgICAqL1xuICAgICAgYXN5bmMgX2lzRWtzKGNlcnQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBjYTogY2VydCxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhd2FpdCB0aGlzLl9nZXRLOHNDcmVkSGVhZGVyKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvc3RuYW1lOiB0aGlzLks4U19TVkNfVVJMLFxuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBwYXRoOiB0aGlzLkFVVEhfQ09ORklHTUFQX1BBVEgsXG4gICAgICAgICAgdGltZW91dDogdGhpcy5USU1FT1VUX01TXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAhIWF3YWl0IHRoaXMuX2ZldGNoU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBdHRlbXB0cyB0byBtYWtlIGEgY29ubmVjdGlvbiB0byBBbWF6b24gQ2xvdWR3YXRjaFxuICAgICAgICogQ29uZmlnIE1hcHMgdG8gZ3JhYiBjbHVzdGVyIG5hbWVcbiAgICAgICAqL1xuICAgICAgYXN5bmMgX2dldENsdXN0ZXJOYW1lKGNlcnQpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBjYTogY2VydCxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhd2FpdCB0aGlzLl9nZXRLOHNDcmVkSGVhZGVyKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvc3Q6IHRoaXMuSzhTX1NWQ19VUkwsXG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIHBhdGg6IHRoaXMuQ1dfQ09ORklHTUFQX1BBVEgsXG4gICAgICAgICAgdGltZW91dDogdGhpcy5USU1FT1VUX01TXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hTdHJpbmcob3B0aW9ucyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UpLmRhdGFbXCJjbHVzdGVyLm5hbWVcIl07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBhcGlfMS5kaWFnLndhcm4oXCJDYW5ub3QgZ2V0IGNsdXN0ZXIgbmFtZSBvbiBFS1NcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJlYWRzIHRoZSBLdWJlcm5ldGVzIHRva2VuIHBhdGggYW5kIHJldHVybnMga3ViZXJuZXRlc1xuICAgICAgICogY3JlZGVudGlhbCBoZWFkZXJcbiAgICAgICAqL1xuICAgICAgYXN5bmMgX2dldEs4c0NyZWRIZWFkZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IF9Bd3NFa3NEZXRlY3Rvci5yZWFkRmlsZUFzeW5jKHRoaXMuSzhTX1RPS0VOX1BBVEgsIHRoaXMuVVRGOF9VTklDT0RFKTtcbiAgICAgICAgICByZXR1cm4gXCJCZWFyZXIgXCIgKyBjb250ZW50O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgYXBpXzEuZGlhZy53YXJuKFwiVW5hYmxlIHRvIHJlYWQgS3ViZXJuZXRlcyBjbGllbnQgdG9rZW4uXCIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZWFkIGNvbnRhaW5lciBJRCBmcm9tIGNncm91cCBmaWxlIGdlbmVyYXRlZCBmcm9tIGRvY2tlciB3aGljaCBsaXN0cyB0aGUgZnVsbFxuICAgICAgICogdW50cnVuY2F0ZWQgZG9ja2VyIGNvbnRhaW5lciBJRCBhdCB0aGUgZW5kIG9mIGVhY2ggbGluZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgcHJlZGVmaW5lZCBzdHJ1Y3R1cmUgb2YgY2FsbGluZyAvcHJvYy9zZWxmL2Nncm91cCB3aGVuIGluIGEgZG9ja2VyIGNvbnRhaW5lciBoYXMgdGhlIHN0cnVjdHVyZTpcbiAgICAgICAqXG4gICAgICAgKiAjOnh4eHh4eDovXG4gICAgICAgKlxuICAgICAgICogb3JcbiAgICAgICAqXG4gICAgICAgKiAjOnh4eHh4eDovZG9ja2VyLzY0Y2hhcmFjdGVySURcbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFkdmFudGFnZSBvZiB0aGF0IGZhY3QgYnkganVzdCByZWFkaW5nIHRoZSA2NC1jaGFyYWN0ZXIgSUQgZnJvbSB0aGUgZW5kIG9mIHRoZVxuICAgICAgICogZmlyc3QgbGluZS4gSW4gRUtTLCBldmVuIGlmIHdlIGZhaWwgdG8gZmluZCB0YXJnZXQgZmlsZSBvciB0YXJnZXQgZmlsZSBkb2VzXG4gICAgICAgKiBub3QgY29udGFpbiBjb250YWluZXIgSUQgd2UgZG8gbm90IHRocm93IGFuIGVycm9yIGJ1dCB0aHJvdyB3YXJuaW5nIG1lc3NhZ2VcbiAgICAgICAqIGFuZCB0aGVuIHJldHVybiBudWxsIHN0cmluZ1xuICAgICAgICovXG4gICAgICBhc3luYyBfZ2V0Q29udGFpbmVySWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmF3RGF0YSA9IGF3YWl0IF9Bd3NFa3NEZXRlY3Rvci5yZWFkRmlsZUFzeW5jKHRoaXMuREVGQVVMVF9DR1JPVVBfUEFUSCwgdGhpcy5VVEY4X1VOSUNPREUpO1xuICAgICAgICAgIGNvbnN0IHNwbGl0RGF0YSA9IHJhd0RhdGEudHJpbSgpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3RyIG9mIHNwbGl0RGF0YSkge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiB0aGlzLkNPTlRBSU5FUl9JRF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RyLmxlbmd0aCAtIHRoaXMuQ09OVEFJTkVSX0lEX0xFTkdUSCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgYXBpXzEuZGlhZy53YXJuKGBBd3NFa3NEZXRlY3RvciBmYWlsZWQgdG8gcmVhZCBjb250YWluZXIgSUQ6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEVzdGFibGlzaGVzIGFuIEhUVFAgY29ubmVjdGlvbiB0byBBV1MgaW5zdGFuY2UgZG9jdW1lbnQgdXJsLlxuICAgICAgICogSWYgdGhlIGFwcGxpY2F0aW9uIGlzIHJ1bm5pbmcgb24gYW4gRUtTIGluc3RhbmNlLCB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICogdG8gZ2V0IGJhY2sgYSB2YWxpZCBKU09OIGRvY3VtZW50LiBQYXJzZXMgdGhhdCBkb2N1bWVudCBhbmQgc3RvcmVzXG4gICAgICAgKiB0aGUgaWRlbnRpdHkgcHJvcGVydGllcyBpbiBhIGxvY2FsIG1hcC5cbiAgICAgICAqL1xuICAgICAgYXN5bmMgX2ZldGNoU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkVLUyBtZXRhZGF0YSBhcGkgcmVxdWVzdCB0aW1lZCBvdXQuXCIpKTtcbiAgICAgICAgICB9LCAyZTMpO1xuICAgICAgICAgIGNvbnN0IHJlcSA9IGh0dHBzMi5yZXF1ZXN0KG9wdGlvbnMsIChyZXMpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0dXNDb2RlIH0gPSByZXM7XG4gICAgICAgICAgICByZXMuc2V0RW5jb2RpbmcodGhpcy5VVEY4X1VOSUNPREUpO1xuICAgICAgICAgICAgbGV0IHJhd0RhdGEgPSBcIlwiO1xuICAgICAgICAgICAgcmVzLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHJhd0RhdGEgKz0gY2h1bmspO1xuICAgICAgICAgICAgcmVzLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgJiYgc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJhd0RhdGEpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIHBhZ2UsIHN0YXR1cyBjb2RlOiBcIiArIHN0YXR1c0NvZGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXEuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5Bd3NFa3NEZXRlY3RvciA9IEF3c0Vrc0RldGVjdG9yO1xuICAgIEF3c0Vrc0RldGVjdG9yLnJlYWRGaWxlQXN5bmMgPSB1dGlsMi5wcm9taXNpZnkoZnMzLnJlYWRGaWxlKTtcbiAgICBBd3NFa3NEZXRlY3Rvci5maWxlQWNjZXNzQXN5bmMgPSB1dGlsMi5wcm9taXNpZnkoZnMzLmFjY2Vzcyk7XG4gICAgZXhwb3J0cy5hd3NFa3NEZXRlY3RvciA9IG5ldyBBd3NFa3NEZXRlY3RvcigpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlLWRldGVjdG9yLWF3cy9idWlsZC9zcmMvZGV0ZWN0b3JzL0F3c0xhbWJkYURldGVjdG9yLmpzXG52YXIgcmVxdWlyZV9Bd3NMYW1iZGFEZXRlY3RvciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZS1kZXRlY3Rvci1hd3MvYnVpbGQvc3JjL2RldGVjdG9ycy9Bd3NMYW1iZGFEZXRlY3Rvci5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgZXhwb3J0cy5hd3NMYW1iZGFEZXRlY3RvciA9IGV4cG9ydHMuQXdzTGFtYmRhRGV0ZWN0b3IgPSB2b2lkIDA7XG4gICAgdmFyIHJlc291cmNlc18xID0gKGluaXRfZXNtNSgpLCBfX3RvQ29tbW9uSlMoZXNtX2V4cG9ydHM1KSk7XG4gICAgdmFyIHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSAoaW5pdF9lc20yKCksIF9fdG9Db21tb25KUyhlc21fZXhwb3J0czIpKTtcbiAgICB2YXIgQXdzTGFtYmRhRGV0ZWN0b3IgPSBjbGFzcyB7XG4gICAgICBhc3luYyBkZXRlY3QoX2NvbmZpZykge1xuICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBwcm9jZXNzLmVudi5BV1NfTEFNQkRBX0ZVTkNUSU9OX05BTUU7XG4gICAgICAgIGlmICghZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc291cmNlc18xLlJlc291cmNlLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25WZXJzaW9uID0gcHJvY2Vzcy5lbnYuQVdTX0xBTUJEQV9GVU5DVElPTl9WRVJTSU9OO1xuICAgICAgICBjb25zdCByZWdpb24gPSBwcm9jZXNzLmVudi5BV1NfUkVHSU9OO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0NMT1VEX1BST1ZJREVSXTogU3RyaW5nKHNlbWFudGljX2NvbnZlbnRpb25zXzEuQ0xPVURQUk9WSURFUlZBTFVFU19BV1MpLFxuICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0NMT1VEX1BMQVRGT1JNXTogU3RyaW5nKHNlbWFudGljX2NvbnZlbnRpb25zXzEuQ0xPVURQTEFURk9STVZBTFVFU19BV1NfTEFNQkRBKVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVnaW9uKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTVJFU0FUVFJTX0NMT1VEX1JFR0lPTl0gPSByZWdpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1SRVNBVFRSU19GQUFTX05BTUVdID0gZnVuY3Rpb25OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jdGlvblZlcnNpb24pIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNUkVTQVRUUlNfRkFBU19WRVJTSU9OXSA9IGZ1bmN0aW9uVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHJlc291cmNlc18xLlJlc291cmNlKGF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5Bd3NMYW1iZGFEZXRlY3RvciA9IEF3c0xhbWJkYURldGVjdG9yO1xuICAgIGV4cG9ydHMuYXdzTGFtYmRhRGV0ZWN0b3IgPSBuZXcgQXdzTGFtYmRhRGV0ZWN0b3IoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZS1kZXRlY3Rvci1hd3MvYnVpbGQvc3JjL2RldGVjdG9ycy9pbmRleC5qc1xudmFyIHJlcXVpcmVfZGV0ZWN0b3JzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlLWRldGVjdG9yLWF3cy9idWlsZC9zcmMvZGV0ZWN0b3JzL2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBleHBvcnRzICYmIGV4cG9ydHMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICAgIGlmIChrMiA9PT0gdm9pZCAwKVxuICAgICAgICBrMiA9IGs7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9IH0pO1xuICAgIH0gOiBmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgICAgaWYgKGsyID09PSB2b2lkIDApXG4gICAgICAgIGsyID0gaztcbiAgICAgIG9bazJdID0gbVtrXTtcbiAgICB9KTtcbiAgICB2YXIgX19leHBvcnRTdGFyID0gZXhwb3J0cyAmJiBleHBvcnRzLl9fZXhwb3J0U3RhciB8fCBmdW5jdGlvbihtLCBleHBvcnRzMikge1xuICAgICAgZm9yICh2YXIgcCBpbiBtKVxuICAgICAgICBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzMiwgcCkpXG4gICAgICAgICAgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMyLCBtLCBwKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Bd3NFYzJEZXRlY3RvcigpLCBleHBvcnRzKTtcbiAgICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Bd3NCZWFuc3RhbGtEZXRlY3RvcigpLCBleHBvcnRzKTtcbiAgICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Bd3NFY3NEZXRlY3RvcigpLCBleHBvcnRzKTtcbiAgICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Bd3NFa3NEZXRlY3RvcigpLCBleHBvcnRzKTtcbiAgICBfX2V4cG9ydFN0YXIocmVxdWlyZV9Bd3NMYW1iZGFEZXRlY3RvcigpLCBleHBvcnRzKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZS1kZXRlY3Rvci1hd3MvYnVpbGQvc3JjL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zcmMzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlLWRldGVjdG9yLWF3cy9idWlsZC9zcmMvaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgICAgaWYgKGsyID09PSB2b2lkIDApXG4gICAgICAgIGsyID0gaztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH0gfSk7XG4gICAgfSA6IGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgICBpZiAoazIgPT09IHZvaWQgMClcbiAgICAgICAgazIgPSBrO1xuICAgICAgb1trMl0gPSBtW2tdO1xuICAgIH0pO1xuICAgIHZhciBfX2V4cG9ydFN0YXIgPSBleHBvcnRzICYmIGV4cG9ydHMuX19leHBvcnRTdGFyIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMyKSB7XG4gICAgICBmb3IgKHZhciBwIGluIG0pXG4gICAgICAgIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMyLCBwKSlcbiAgICAgICAgICBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0czIsIG0sIHApO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIF9fZXhwb3J0U3RhcihyZXF1aXJlX2RldGVjdG9ycygpLCBleHBvcnRzKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zaGltbWVyL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zaGltbWVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3NoaW1tZXIvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbjIoZnVua3Rpb24pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZnVua3Rpb24gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgdmFyIGxvZ2dlciA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcbiAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgZW51bWVyYWJsZSA9ICEhb2JqW25hbWVdICYmIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZShuYW1lKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaGltbWVyMihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxvZ2dlcikge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24yKG9wdGlvbnMubG9nZ2VyKSlcbiAgICAgICAgICBsb2dnZXIoXCJuZXcgbG9nZ2VyIGlzbid0IGEgZnVuY3Rpb24sIG5vdCByZXBsYWNpbmdcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsb2dnZXIgPSBvcHRpb25zLmxvZ2dlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd3JhcDMobm9kdWxlLCBuYW1lLCB3cmFwcGVyKSB7XG4gICAgICBpZiAoIW5vZHVsZSB8fCAhbm9kdWxlW25hbWVdKSB7XG4gICAgICAgIGxvZ2dlcihcIm5vIG9yaWdpbmFsIGZ1bmN0aW9uIFwiICsgbmFtZSArIFwiIHRvIHdyYXBcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghd3JhcHBlcikge1xuICAgICAgICBsb2dnZXIoXCJubyB3cmFwcGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgICBsb2dnZXIobmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzRnVuY3Rpb24yKG5vZHVsZVtuYW1lXSkgfHwgIWlzRnVuY3Rpb24yKHdyYXBwZXIpKSB7XG4gICAgICAgIGxvZ2dlcihcIm9yaWdpbmFsIG9iamVjdCBhbmQgd3JhcHBlciBtdXN0IGJlIGZ1bmN0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9yaWdpbmFsID0gbm9kdWxlW25hbWVdO1xuICAgICAgdmFyIHdyYXBwZWQgPSB3cmFwcGVyKG9yaWdpbmFsLCBuYW1lKTtcbiAgICAgIGRlZmluZVByb3BlcnR5KHdyYXBwZWQsIFwiX19vcmlnaW5hbFwiLCBvcmlnaW5hbCk7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh3cmFwcGVkLCBcIl9fdW53cmFwXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobm9kdWxlW25hbWVdID09PSB3cmFwcGVkKVxuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG5vZHVsZSwgbmFtZSwgb3JpZ2luYWwpO1xuICAgICAgfSk7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh3cmFwcGVkLCBcIl9fd3JhcHBlZFwiLCB0cnVlKTtcbiAgICAgIGRlZmluZVByb3BlcnR5KG5vZHVsZSwgbmFtZSwgd3JhcHBlZCk7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFzc1dyYXAyKG5vZHVsZXMsIG5hbWVzLCB3cmFwcGVyKSB7XG4gICAgICBpZiAoIW5vZHVsZXMpIHtcbiAgICAgICAgbG9nZ2VyKFwibXVzdCBwcm92aWRlIG9uZSBvciBtb3JlIG1vZHVsZXMgdG8gcGF0Y2hcIik7XG4gICAgICAgIGxvZ2dlcihuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobm9kdWxlcykpIHtcbiAgICAgICAgbm9kdWxlcyA9IFtub2R1bGVzXTtcbiAgICAgIH1cbiAgICAgIGlmICghKG5hbWVzICYmIEFycmF5LmlzQXJyYXkobmFtZXMpKSkge1xuICAgICAgICBsb2dnZXIoXCJtdXN0IHByb3ZpZGUgb25lIG9yIG1vcmUgZnVuY3Rpb25zIHRvIHdyYXAgb24gbW9kdWxlc1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZHVsZSkge1xuICAgICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICB3cmFwMyhub2R1bGUsIG5hbWUsIHdyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndyYXAzKG5vZHVsZSwgbmFtZSkge1xuICAgICAgaWYgKCFub2R1bGUgfHwgIW5vZHVsZVtuYW1lXSkge1xuICAgICAgICBsb2dnZXIoXCJubyBmdW5jdGlvbiB0byB1bndyYXAuXCIpO1xuICAgICAgICBsb2dnZXIobmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIW5vZHVsZVtuYW1lXS5fX3Vud3JhcCkge1xuICAgICAgICBsb2dnZXIoXCJubyBvcmlnaW5hbCB0byB1bndyYXAgdG8gLS0gaGFzIFwiICsgbmFtZSArIFwiIGFscmVhZHkgYmVlbiB1bndyYXBwZWQ/XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZHVsZVtuYW1lXS5fX3Vud3JhcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXNzVW53cmFwMihub2R1bGVzLCBuYW1lcykge1xuICAgICAgaWYgKCFub2R1bGVzKSB7XG4gICAgICAgIGxvZ2dlcihcIm11c3QgcHJvdmlkZSBvbmUgb3IgbW9yZSBtb2R1bGVzIHRvIHBhdGNoXCIpO1xuICAgICAgICBsb2dnZXIobmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG5vZHVsZXMpKSB7XG4gICAgICAgIG5vZHVsZXMgPSBbbm9kdWxlc107XG4gICAgICB9XG4gICAgICBpZiAoIShuYW1lcyAmJiBBcnJheS5pc0FycmF5KG5hbWVzKSkpIHtcbiAgICAgICAgbG9nZ2VyKFwibXVzdCBwcm92aWRlIG9uZSBvciBtb3JlIGZ1bmN0aW9ucyB0byB1bndyYXAgb24gbW9kdWxlc1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZHVsZSkge1xuICAgICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICB1bndyYXAzKG5vZHVsZSwgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNoaW1tZXIyLndyYXAgPSB3cmFwMztcbiAgICBzaGltbWVyMi5tYXNzV3JhcCA9IG1hc3NXcmFwMjtcbiAgICBzaGltbWVyMi51bndyYXAgPSB1bndyYXAzO1xuICAgIHNoaW1tZXIyLm1hc3NVbndyYXAgPSBtYXNzVW53cmFwMjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBzaGltbWVyMjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9ob21lZGlyLmpzXG52YXIgcmVxdWlyZV9ob21lZGlyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL2hvbWVkaXIuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG9zMiA9IHJlcXVpcmUoXCJvc1wiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBvczIuaG9tZWRpciB8fCBmdW5jdGlvbiBob21lZGlyKCkge1xuICAgICAgdmFyIGhvbWUgPSBwcm9jZXNzLmVudi5IT01FO1xuICAgICAgdmFyIHVzZXIgPSBwcm9jZXNzLmVudi5MT0dOQU1FIHx8IHByb2Nlc3MuZW52LlVTRVIgfHwgcHJvY2Vzcy5lbnYuTE5BTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUk5BTUU7XG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5VU0VSUFJPRklMRSB8fCBwcm9jZXNzLmVudi5IT01FRFJJVkUgKyBwcm9jZXNzLmVudi5IT01FUEFUSCB8fCBob21lIHx8IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIikge1xuICAgICAgICByZXR1cm4gaG9tZSB8fCAodXNlciA/IFwiL1VzZXJzL1wiICsgdXNlciA6IG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwibGludXhcIikge1xuICAgICAgICByZXR1cm4gaG9tZSB8fCAocHJvY2Vzcy5nZXR1aWQoKSA9PT0gMCA/IFwiL3Jvb3RcIiA6IHVzZXIgPyBcIi9ob21lL1wiICsgdXNlciA6IG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvbWUgfHwgbnVsbDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL2NhbGxlci5qc1xudmFyIHJlcXVpcmVfY2FsbGVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL2NhbGxlci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcmlnUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24oXywgc3RhY2syKSB7XG4gICAgICAgIHJldHVybiBzdGFjazI7XG4gICAgICB9O1xuICAgICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG9yaWdQcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIHJldHVybiBzdGFja1syXS5nZXRGaWxlTmFtZSgpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcGF0aC1wYXJzZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfcGF0aF9wYXJzZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wYXRoLXBhcnNlL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCI7XG4gICAgdmFyIHNwbGl0V2luZG93c1JlID0gL14oKCg/OlthLXpBLVpdOnxbXFxcXFxcL117Mn1bXlxcXFxcXC9dK1tcXFxcXFwvXStbXlxcXFxcXC9dKyk/W1xcXFxcXC9dPykoPzpbXlxcXFxcXC9dKltcXFxcXFwvXSkqKSgoXFwuezEsMn18W15cXFxcXFwvXSs/fCkoXFwuW14uXFwvXFxcXF0qfCkpW1xcXFxcXC9dKiQvO1xuICAgIHZhciB3aW4zMiA9IHt9O1xuICAgIGZ1bmN0aW9uIHdpbjMyU3BsaXRQYXRoKGZpbGVuYW1lKSB7XG4gICAgICByZXR1cm4gc3BsaXRXaW5kb3dzUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIHdpbjMyLnBhcnNlID0gZnVuY3Rpb24ocGF0aFN0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJQYXJhbWV0ZXIgJ3BhdGhTdHJpbmcnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiBwYXRoU3RyaW5nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgYWxsUGFydHMgPSB3aW4zMlNwbGl0UGF0aChwYXRoU3RyaW5nKTtcbiAgICAgIGlmICghYWxsUGFydHMgfHwgYWxsUGFydHMubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHBhdGggJ1wiICsgcGF0aFN0cmluZyArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IGFsbFBhcnRzWzFdLFxuICAgICAgICBkaXI6IGFsbFBhcnRzWzBdID09PSBhbGxQYXJ0c1sxXSA/IGFsbFBhcnRzWzBdIDogYWxsUGFydHNbMF0uc2xpY2UoMCwgLTEpLFxuICAgICAgICBiYXNlOiBhbGxQYXJ0c1syXSxcbiAgICAgICAgZXh0OiBhbGxQYXJ0c1s0XSxcbiAgICAgICAgbmFtZTogYWxsUGFydHNbM11cbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3BsaXRQYXRoUmUgPSAvXigoXFwvPykoPzpbXlxcL10qXFwvKSopKChcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpW1xcL10qJC87XG4gICAgdmFyIHBvc2l4ID0ge307XG4gICAgZnVuY3Rpb24gcG9zaXhTcGxpdFBhdGgoZmlsZW5hbWUpIHtcbiAgICAgIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbiAgICB9XG4gICAgcG9zaXgucGFyc2UgPSBmdW5jdGlvbihwYXRoU3RyaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGhTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlBhcmFtZXRlciAncGF0aFN0cmluZycgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHBhdGhTdHJpbmdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBhbGxQYXJ0cyA9IHBvc2l4U3BsaXRQYXRoKHBhdGhTdHJpbmcpO1xuICAgICAgaWYgKCFhbGxQYXJ0cyB8fCBhbGxQYXJ0cy5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcGF0aCAnXCIgKyBwYXRoU3RyaW5nICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdDogYWxsUGFydHNbMV0sXG4gICAgICAgIGRpcjogYWxsUGFydHNbMF0uc2xpY2UoMCwgLTEpLFxuICAgICAgICBiYXNlOiBhbGxQYXJ0c1syXSxcbiAgICAgICAgZXh0OiBhbGxQYXJ0c1s0XSxcbiAgICAgICAgbmFtZTogYWxsUGFydHNbM11cbiAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoaXNXaW5kb3dzKVxuICAgICAgbW9kdWxlMi5leHBvcnRzID0gd2luMzIucGFyc2U7XG4gICAgZWxzZVxuICAgICAgbW9kdWxlMi5leHBvcnRzID0gcG9zaXgucGFyc2U7XG4gICAgbW9kdWxlMi5leHBvcnRzLnBvc2l4ID0gcG9zaXgucGFyc2U7XG4gICAgbW9kdWxlMi5leHBvcnRzLndpbjMyID0gd2luMzIucGFyc2U7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvbm9kZS1tb2R1bGVzLXBhdGhzLmpzXG52YXIgcmVxdWlyZV9ub2RlX21vZHVsZXNfcGF0aHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvbm9kZS1tb2R1bGVzLXBhdGhzLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBwYXRoMyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHZhciBwYXJzZTQgPSBwYXRoMy5wYXJzZSB8fCByZXF1aXJlX3BhdGhfcGFyc2UoKTtcbiAgICB2YXIgZ2V0Tm9kZU1vZHVsZXNEaXJzID0gZnVuY3Rpb24gZ2V0Tm9kZU1vZHVsZXNEaXJzMihhYnNvbHV0ZVN0YXJ0LCBtb2R1bGVzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gXCIvXCI7XG4gICAgICBpZiAoL14oW0EtWmEtel06KS8udGVzdChhYnNvbHV0ZVN0YXJ0KSkge1xuICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmICgvXlxcXFxcXFxcLy50ZXN0KGFic29sdXRlU3RhcnQpKSB7XG4gICAgICAgIHByZWZpeCA9IFwiXFxcXFxcXFxcIjtcbiAgICAgIH1cbiAgICAgIHZhciBwYXRocyA9IFthYnNvbHV0ZVN0YXJ0XTtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZTQoYWJzb2x1dGVTdGFydCk7XG4gICAgICB3aGlsZSAocGFyc2VkLmRpciAhPT0gcGF0aHNbcGF0aHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgcGF0aHMucHVzaChwYXJzZWQuZGlyKTtcbiAgICAgICAgcGFyc2VkID0gcGFyc2U0KHBhcnNlZC5kaXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhzLnJlZHVjZShmdW5jdGlvbihkaXJzLCBhUGF0aCkge1xuICAgICAgICByZXR1cm4gZGlycy5jb25jYXQobW9kdWxlcy5tYXAoZnVuY3Rpb24obW9kdWxlRGlyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGgzLnJlc29sdmUocHJlZml4LCBhUGF0aCwgbW9kdWxlRGlyKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gbm9kZU1vZHVsZXNQYXRocyhzdGFydCwgb3B0cywgcmVxdWVzdDMpIHtcbiAgICAgIHZhciBtb2R1bGVzID0gb3B0cyAmJiBvcHRzLm1vZHVsZURpcmVjdG9yeSA/IFtdLmNvbmNhdChvcHRzLm1vZHVsZURpcmVjdG9yeSkgOiBbXCJub2RlX21vZHVsZXNcIl07XG4gICAgICBpZiAob3B0cyAmJiB0eXBlb2Ygb3B0cy5wYXRocyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBvcHRzLnBhdGhzKFxuICAgICAgICAgIHJlcXVlc3QzLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5vZGVNb2R1bGVzRGlycyhzdGFydCwgbW9kdWxlcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgZGlycyA9IGdldE5vZGVNb2R1bGVzRGlycyhzdGFydCwgbW9kdWxlcyk7XG4gICAgICByZXR1cm4gb3B0cyAmJiBvcHRzLnBhdGhzID8gZGlycy5jb25jYXQob3B0cy5wYXRocykgOiBkaXJzO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvbm9ybWFsaXplLW9wdGlvbnMuanNcbnZhciByZXF1aXJlX25vcm1hbGl6ZV9vcHRpb25zID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL25vcm1hbGl6ZS1vcHRpb25zLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZ1bmN0aW9uKHgsIG9wdHMpIHtcbiAgICAgIHJldHVybiBvcHRzIHx8IHt9O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3JjNCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eTIgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNhbGwuYmluZCA/IGNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eTIpIDogZnVuY3Rpb24oTywgUCkge1xuICAgICAgcmV0dXJuIGNhbGwuY2FsbChoYXNPd25Qcm9wZXJ0eTIsIE8sIFApO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvaXMtY29yZS1tb2R1bGUvY29yZS5qc29uXG52YXIgcmVxdWlyZV9jb3JlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2lzLWNvcmUtbW9kdWxlL2NvcmUuanNvblwiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7XG4gICAgICBhc3NlcnQ6IHRydWUsXG4gICAgICBcIm5vZGU6YXNzZXJ0XCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwiYXNzZXJ0L3N0cmljdFwiOiBcIj49IDE1XCIsXG4gICAgICBcIm5vZGU6YXNzZXJ0L3N0cmljdFwiOiBcIj49IDE2XCIsXG4gICAgICBhc3luY19ob29rczogXCI+PSA4XCIsXG4gICAgICBcIm5vZGU6YXN5bmNfaG9va3NcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgYnVmZmVyX2llZWU3NTQ6IFwiPj0gMC41ICYmIDwgMC45LjdcIixcbiAgICAgIGJ1ZmZlcjogdHJ1ZSxcbiAgICAgIFwibm9kZTpidWZmZXJcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgY2hpbGRfcHJvY2VzczogdHJ1ZSxcbiAgICAgIFwibm9kZTpjaGlsZF9wcm9jZXNzXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGNsdXN0ZXI6IFwiPj0gMC41XCIsXG4gICAgICBcIm5vZGU6Y2x1c3RlclwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBjb25zb2xlOiB0cnVlLFxuICAgICAgXCJub2RlOmNvbnNvbGVcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgY29uc3RhbnRzOiB0cnVlLFxuICAgICAgXCJub2RlOmNvbnN0YW50c1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBjcnlwdG86IHRydWUsXG4gICAgICBcIm5vZGU6Y3J5cHRvXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIF9kZWJ1Z19hZ2VudDogXCI+PSAxICYmIDwgOFwiLFxuICAgICAgX2RlYnVnZ2VyOiBcIjwgOFwiLFxuICAgICAgZGdyYW06IHRydWUsXG4gICAgICBcIm5vZGU6ZGdyYW1cIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgZGlhZ25vc3RpY3NfY2hhbm5lbDogW1wiPj0gMTQuMTcgJiYgPCAxNVwiLCBcIj49IDE1LjFcIl0sXG4gICAgICBcIm5vZGU6ZGlhZ25vc3RpY3NfY2hhbm5lbFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBkbnM6IHRydWUsXG4gICAgICBcIm5vZGU6ZG5zXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwiZG5zL3Byb21pc2VzXCI6IFwiPj0gMTVcIixcbiAgICAgIFwibm9kZTpkbnMvcHJvbWlzZXNcIjogXCI+PSAxNlwiLFxuICAgICAgZG9tYWluOiBcIj49IDAuNy4xMlwiLFxuICAgICAgXCJub2RlOmRvbWFpblwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBldmVudHM6IHRydWUsXG4gICAgICBcIm5vZGU6ZXZlbnRzXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGZyZWVsaXN0OiBcIjwgNlwiLFxuICAgICAgZnM6IHRydWUsXG4gICAgICBcIm5vZGU6ZnNcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgXCJmcy9wcm9taXNlc1wiOiBbXCI+PSAxMCAmJiA8IDEwLjFcIiwgXCI+PSAxNFwiXSxcbiAgICAgIFwibm9kZTpmcy9wcm9taXNlc1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfaHR0cF9hZ2VudDogXCI+PSAwLjExLjFcIixcbiAgICAgIFwibm9kZTpfaHR0cF9hZ2VudFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfaHR0cF9jbGllbnQ6IFwiPj0gMC4xMS4xXCIsXG4gICAgICBcIm5vZGU6X2h0dHBfY2xpZW50XCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIF9odHRwX2NvbW1vbjogXCI+PSAwLjExLjFcIixcbiAgICAgIFwibm9kZTpfaHR0cF9jb21tb25cIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX2h0dHBfaW5jb21pbmc6IFwiPj0gMC4xMS4xXCIsXG4gICAgICBcIm5vZGU6X2h0dHBfaW5jb21pbmdcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX2h0dHBfb3V0Z29pbmc6IFwiPj0gMC4xMS4xXCIsXG4gICAgICBcIm5vZGU6X2h0dHBfb3V0Z29pbmdcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX2h0dHBfc2VydmVyOiBcIj49IDAuMTEuMVwiLFxuICAgICAgXCJub2RlOl9odHRwX3NlcnZlclwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBodHRwOiB0cnVlLFxuICAgICAgXCJub2RlOmh0dHBcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgaHR0cDI6IFwiPj0gOC44XCIsXG4gICAgICBcIm5vZGU6aHR0cDJcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgaHR0cHM6IHRydWUsXG4gICAgICBcIm5vZGU6aHR0cHNcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgaW5zcGVjdG9yOiBcIj49IDhcIixcbiAgICAgIFwibm9kZTppbnNwZWN0b3JcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgXCJpbnNwZWN0b3IvcHJvbWlzZXNcIjogW1wiPj0gMTlcIl0sXG4gICAgICBcIm5vZGU6aW5zcGVjdG9yL3Byb21pc2VzXCI6IFtcIj49IDE5XCJdLFxuICAgICAgX2xpbmtsaXN0OiBcIjwgOFwiLFxuICAgICAgbW9kdWxlOiB0cnVlLFxuICAgICAgXCJub2RlOm1vZHVsZVwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBuZXQ6IHRydWUsXG4gICAgICBcIm5vZGU6bmV0XCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwibm9kZS1pbnNwZWN0L2xpYi9faW5zcGVjdFwiOiBcIj49IDcuNiAmJiA8IDEyXCIsXG4gICAgICBcIm5vZGUtaW5zcGVjdC9saWIvaW50ZXJuYWwvaW5zcGVjdF9jbGllbnRcIjogXCI+PSA3LjYgJiYgPCAxMlwiLFxuICAgICAgXCJub2RlLWluc3BlY3QvbGliL2ludGVybmFsL2luc3BlY3RfcmVwbFwiOiBcIj49IDcuNiAmJiA8IDEyXCIsXG4gICAgICBvczogdHJ1ZSxcbiAgICAgIFwibm9kZTpvc1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBwYXRoOiB0cnVlLFxuICAgICAgXCJub2RlOnBhdGhcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgXCJwYXRoL3Bvc2l4XCI6IFwiPj0gMTUuM1wiLFxuICAgICAgXCJub2RlOnBhdGgvcG9zaXhcIjogXCI+PSAxNlwiLFxuICAgICAgXCJwYXRoL3dpbjMyXCI6IFwiPj0gMTUuM1wiLFxuICAgICAgXCJub2RlOnBhdGgvd2luMzJcIjogXCI+PSAxNlwiLFxuICAgICAgcGVyZl9ob29rczogXCI+PSA4LjVcIixcbiAgICAgIFwibm9kZTpwZXJmX2hvb2tzXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHByb2Nlc3M6IFwiPj0gMVwiLFxuICAgICAgXCJub2RlOnByb2Nlc3NcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgcHVueWNvZGU6IFwiPj0gMC41XCIsXG4gICAgICBcIm5vZGU6cHVueWNvZGVcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgcXVlcnlzdHJpbmc6IHRydWUsXG4gICAgICBcIm5vZGU6cXVlcnlzdHJpbmdcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgcmVhZGxpbmU6IHRydWUsXG4gICAgICBcIm5vZGU6cmVhZGxpbmVcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgXCJyZWFkbGluZS9wcm9taXNlc1wiOiBcIj49IDE3XCIsXG4gICAgICBcIm5vZGU6cmVhZGxpbmUvcHJvbWlzZXNcIjogXCI+PSAxN1wiLFxuICAgICAgcmVwbDogdHJ1ZSxcbiAgICAgIFwibm9kZTpyZXBsXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHNtYWxsb2M6IFwiPj0gMC4xMS41ICYmIDwgM1wiLFxuICAgICAgX3N0cmVhbV9kdXBsZXg6IFwiPj0gMC45LjRcIixcbiAgICAgIFwibm9kZTpfc3RyZWFtX2R1cGxleFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfc3RyZWFtX3RyYW5zZm9ybTogXCI+PSAwLjkuNFwiLFxuICAgICAgXCJub2RlOl9zdHJlYW1fdHJhbnNmb3JtXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIF9zdHJlYW1fd3JhcDogXCI+PSAxLjQuMVwiLFxuICAgICAgXCJub2RlOl9zdHJlYW1fd3JhcFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfc3RyZWFtX3Bhc3N0aHJvdWdoOiBcIj49IDAuOS40XCIsXG4gICAgICBcIm5vZGU6X3N0cmVhbV9wYXNzdGhyb3VnaFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfc3RyZWFtX3JlYWRhYmxlOiBcIj49IDAuOS40XCIsXG4gICAgICBcIm5vZGU6X3N0cmVhbV9yZWFkYWJsZVwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfc3RyZWFtX3dyaXRhYmxlOiBcIj49IDAuOS40XCIsXG4gICAgICBcIm5vZGU6X3N0cmVhbV93cml0YWJsZVwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBzdHJlYW06IHRydWUsXG4gICAgICBcIm5vZGU6c3RyZWFtXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwic3RyZWFtL2NvbnN1bWVyc1wiOiBcIj49IDE2LjdcIixcbiAgICAgIFwibm9kZTpzdHJlYW0vY29uc3VtZXJzXCI6IFwiPj0gMTYuN1wiLFxuICAgICAgXCJzdHJlYW0vcHJvbWlzZXNcIjogXCI+PSAxNVwiLFxuICAgICAgXCJub2RlOnN0cmVhbS9wcm9taXNlc1wiOiBcIj49IDE2XCIsXG4gICAgICBcInN0cmVhbS93ZWJcIjogXCI+PSAxNi41XCIsXG4gICAgICBcIm5vZGU6c3RyZWFtL3dlYlwiOiBcIj49IDE2LjVcIixcbiAgICAgIHN0cmluZ19kZWNvZGVyOiB0cnVlLFxuICAgICAgXCJub2RlOnN0cmluZ19kZWNvZGVyXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHN5czogW1wiPj0gMC40ICYmIDwgMC43XCIsIFwiPj0gMC44XCJdLFxuICAgICAgXCJub2RlOnN5c1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBcInRlc3QvcmVwb3J0ZXJzXCI6IFwiPj0gMTkuOSAmJiA8IDIwLjJcIixcbiAgICAgIFwibm9kZTp0ZXN0L3JlcG9ydGVyc1wiOiBbXCI+PSAxOC4xNyAmJiA8IDE5XCIsIFwiPj0gMTkuOVwiLCBcIj49IDIwXCJdLFxuICAgICAgXCJub2RlOnRlc3RcIjogW1wiPj0gMTYuMTcgJiYgPCAxN1wiLCBcIj49IDE4XCJdLFxuICAgICAgdGltZXJzOiB0cnVlLFxuICAgICAgXCJub2RlOnRpbWVyc1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBcInRpbWVycy9wcm9taXNlc1wiOiBcIj49IDE1XCIsXG4gICAgICBcIm5vZGU6dGltZXJzL3Byb21pc2VzXCI6IFwiPj0gMTZcIixcbiAgICAgIF90bHNfY29tbW9uOiBcIj49IDAuMTEuMTNcIixcbiAgICAgIFwibm9kZTpfdGxzX2NvbW1vblwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfdGxzX2xlZ2FjeTogXCI+PSAwLjExLjMgJiYgPCAxMFwiLFxuICAgICAgX3Rsc193cmFwOiBcIj49IDAuMTEuM1wiLFxuICAgICAgXCJub2RlOl90bHNfd3JhcFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICB0bHM6IHRydWUsXG4gICAgICBcIm5vZGU6dGxzXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHRyYWNlX2V2ZW50czogXCI+PSAxMFwiLFxuICAgICAgXCJub2RlOnRyYWNlX2V2ZW50c1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICB0dHk6IHRydWUsXG4gICAgICBcIm5vZGU6dHR5XCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHVybDogdHJ1ZSxcbiAgICAgIFwibm9kZTp1cmxcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgdXRpbDogdHJ1ZSxcbiAgICAgIFwibm9kZTp1dGlsXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwidXRpbC90eXBlc1wiOiBcIj49IDE1LjNcIixcbiAgICAgIFwibm9kZTp1dGlsL3R5cGVzXCI6IFwiPj0gMTZcIixcbiAgICAgIFwidjgvdG9vbHMvYXJndW1lbnRzXCI6IFwiPj0gMTAgJiYgPCAxMlwiLFxuICAgICAgXCJ2OC90b29scy9jb2RlbWFwXCI6IFtcIj49IDQuNCAmJiA8IDVcIiwgXCI+PSA1LjIgJiYgPCAxMlwiXSxcbiAgICAgIFwidjgvdG9vbHMvY29uc2FycmF5XCI6IFtcIj49IDQuNCAmJiA8IDVcIiwgXCI+PSA1LjIgJiYgPCAxMlwiXSxcbiAgICAgIFwidjgvdG9vbHMvY3N2cGFyc2VyXCI6IFtcIj49IDQuNCAmJiA8IDVcIiwgXCI+PSA1LjIgJiYgPCAxMlwiXSxcbiAgICAgIFwidjgvdG9vbHMvbG9ncmVhZGVyXCI6IFtcIj49IDQuNCAmJiA8IDVcIiwgXCI+PSA1LjIgJiYgPCAxMlwiXSxcbiAgICAgIFwidjgvdG9vbHMvcHJvZmlsZV92aWV3XCI6IFtcIj49IDQuNCAmJiA8IDVcIiwgXCI+PSA1LjIgJiYgPCAxMlwiXSxcbiAgICAgIFwidjgvdG9vbHMvc3BsYXl0cmVlXCI6IFtcIj49IDQuNCAmJiA8IDVcIiwgXCI+PSA1LjIgJiYgPCAxMlwiXSxcbiAgICAgIHY4OiBcIj49IDFcIixcbiAgICAgIFwibm9kZTp2OFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICB2bTogdHJ1ZSxcbiAgICAgIFwibm9kZTp2bVwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICB3YXNpOiBbXCI+PSAxMy40ICYmIDwgMTMuNVwiLCBcIj49IDE4LjE3ICYmIDwgMTlcIiwgXCI+PSAyMFwiXSxcbiAgICAgIFwibm9kZTp3YXNpXCI6IFtcIj49IDE4LjE3ICYmIDwgMTlcIiwgXCI+PSAyMFwiXSxcbiAgICAgIHdvcmtlcl90aHJlYWRzOiBcIj49IDExLjdcIixcbiAgICAgIFwibm9kZTp3b3JrZXJfdGhyZWFkc1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICB6bGliOiBcIj49IDAuNVwiLFxuICAgICAgXCJub2RlOnpsaWJcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9pcy1jb3JlLW1vZHVsZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNfY29yZV9tb2R1bGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvaXMtY29yZS1tb2R1bGUvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGhhcyA9IHJlcXVpcmVfc3JjNCgpO1xuICAgIGZ1bmN0aW9uIHNwZWNpZmllckluY2x1ZGVkKGN1cnJlbnQsIHNwZWNpZmllcikge1xuICAgICAgdmFyIG5vZGVQYXJ0cyA9IGN1cnJlbnQuc3BsaXQoXCIuXCIpO1xuICAgICAgdmFyIHBhcnRzID0gc3BlY2lmaWVyLnNwbGl0KFwiIFwiKTtcbiAgICAgIHZhciBvcCA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1swXSA6IFwiPVwiO1xuICAgICAgdmFyIHZlcnNpb25QYXJ0cyA9IChwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0gOiBwYXJ0c1swXSkuc3BsaXQoXCIuXCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgdmFyIGN1ciA9IHBhcnNlSW50KG5vZGVQYXJ0c1tpXSB8fCAwLCAxMCk7XG4gICAgICAgIHZhciB2ZXIgPSBwYXJzZUludCh2ZXJzaW9uUGFydHNbaV0gfHwgMCwgMTApO1xuICAgICAgICBpZiAoY3VyID09PSB2ZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AgPT09IFwiPFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGN1ciA8IHZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AgPT09IFwiPj1cIikge1xuICAgICAgICAgIHJldHVybiBjdXIgPj0gdmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcCA9PT0gXCI+PVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXRjaGVzUmFuZ2UoY3VycmVudCwgcmFuZ2UpIHtcbiAgICAgIHZhciBzcGVjaWZpZXJzID0gcmFuZ2Uuc3BsaXQoLyA/JiYgPy8pO1xuICAgICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIXNwZWNpZmllckluY2x1ZGVkKGN1cnJlbnQsIHNwZWNpZmllcnNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmVyc2lvbkluY2x1ZGVkKG5vZGVWZXJzaW9uLCBzcGVjaWZpZXJWYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpZXJWYWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllclZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnQgPSB0eXBlb2Ygbm9kZVZlcnNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSA6IG5vZGVWZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IodHlwZW9mIG5vZGVWZXJzaW9uID09PSBcInVuZGVmaW5lZFwiID8gXCJVbmFibGUgdG8gZGV0ZXJtaW5lIGN1cnJlbnQgbm9kZSB2ZXJzaW9uXCIgOiBcIklmIHByb3ZpZGVkLCBhIHZhbGlkIG5vZGUgdmVyc2lvbiBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGVjaWZpZXJWYWx1ZSAmJiB0eXBlb2Ygc3BlY2lmaWVyVmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpZXJWYWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmIChtYXRjaGVzUmFuZ2UoY3VycmVudCwgc3BlY2lmaWVyVmFsdWVbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZXNSYW5nZShjdXJyZW50LCBzcGVjaWZpZXJWYWx1ZSk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gcmVxdWlyZV9jb3JlKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaXNDb3JlKHgsIG5vZGVWZXJzaW9uKSB7XG4gICAgICByZXR1cm4gaGFzKGRhdGEsIHgpICYmIHZlcnNpb25JbmNsdWRlZChub2RlVmVyc2lvbiwgZGF0YVt4XSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9hc3luYy5qc1xudmFyIHJlcXVpcmVfYXN5bmMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvYXN5bmMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGZzMyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICB2YXIgZ2V0SG9tZWRpciA9IHJlcXVpcmVfaG9tZWRpcigpO1xuICAgIHZhciBwYXRoMyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHZhciBjYWxsZXIgPSByZXF1aXJlX2NhbGxlcigpO1xuICAgIHZhciBub2RlTW9kdWxlc1BhdGhzID0gcmVxdWlyZV9ub2RlX21vZHVsZXNfcGF0aHMoKTtcbiAgICB2YXIgbm9ybWFsaXplT3B0aW9ucyA9IHJlcXVpcmVfbm9ybWFsaXplX29wdGlvbnMoKTtcbiAgICB2YXIgaXNDb3JlID0gcmVxdWlyZV9pc19jb3JlX21vZHVsZSgpO1xuICAgIHZhciByZWFscGF0aEZTID0gcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJ3aW4zMlwiICYmIGZzMy5yZWFscGF0aCAmJiB0eXBlb2YgZnMzLnJlYWxwYXRoLm5hdGl2ZSA9PT0gXCJmdW5jdGlvblwiID8gZnMzLnJlYWxwYXRoLm5hdGl2ZSA6IGZzMy5yZWFscGF0aDtcbiAgICB2YXIgaG9tZWRpciA9IGdldEhvbWVkaXIoKTtcbiAgICB2YXIgZGVmYXVsdFBhdGhzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXRoMy5qb2luKGhvbWVkaXIsIFwiLm5vZGVfbW9kdWxlc1wiKSxcbiAgICAgICAgcGF0aDMuam9pbihob21lZGlyLCBcIi5ub2RlX2xpYnJhcmllc1wiKVxuICAgICAgXTtcbiAgICB9O1xuICAgIHZhciBkZWZhdWx0SXNGaWxlID0gZnVuY3Rpb24gaXNGaWxlKGZpbGUsIGNiKSB7XG4gICAgICBmczMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgc3RhdC5pc0ZpbGUoKSB8fCBzdGF0LmlzRklGTygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiRU5PRU5UXCIgfHwgZXJyLmNvZGUgPT09IFwiRU5PVERJUlwiKVxuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdElzRGlyID0gZnVuY3Rpb24gaXNEaXJlY3RvcnkoZGlyLCBjYikge1xuICAgICAgZnMzLnN0YXQoZGlyLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgc3RhdC5pc0RpcmVjdG9yeSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiRU5PRU5UXCIgfHwgZXJyLmNvZGUgPT09IFwiRU5PVERJUlwiKVxuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdFJlYWxwYXRoID0gZnVuY3Rpb24gcmVhbHBhdGgoeCwgY2IpIHtcbiAgICAgIHJlYWxwYXRoRlMoeCwgZnVuY3Rpb24ocmVhbHBhdGhFcnIsIHJlYWxQYXRoKSB7XG4gICAgICAgIGlmIChyZWFscGF0aEVyciAmJiByZWFscGF0aEVyci5jb2RlICE9PSBcIkVOT0VOVFwiKVxuICAgICAgICAgIGNiKHJlYWxwYXRoRXJyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNiKG51bGwsIHJlYWxwYXRoRXJyID8geCA6IHJlYWxQYXRoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIG1heWJlUmVhbHBhdGggPSBmdW5jdGlvbiBtYXliZVJlYWxwYXRoMihyZWFscGF0aCwgeCwgb3B0cywgY2IpIHtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMucHJlc2VydmVTeW1saW5rcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVhbHBhdGgoeCwgY2IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgeCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdFJlYWRQYWNrYWdlID0gZnVuY3Rpb24gZGVmYXVsdFJlYWRQYWNrYWdlMihyZWFkRmlsZSwgcGtnZmlsZSwgY2IpIHtcbiAgICAgIHJlYWRGaWxlKHBrZ2ZpbGUsIGZ1bmN0aW9uKHJlYWRGaWxlRXJyLCBib2R5KSB7XG4gICAgICAgIGlmIChyZWFkRmlsZUVycilcbiAgICAgICAgICBjYihyZWFkRmlsZUVycik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcGtnID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgIGNiKG51bGwsIHBrZyk7XG4gICAgICAgICAgfSBjYXRjaCAoanNvbkVycikge1xuICAgICAgICAgICAgY2IobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBnZXRQYWNrYWdlQ2FuZGlkYXRlcyA9IGZ1bmN0aW9uIGdldFBhY2thZ2VDYW5kaWRhdGVzMih4LCBzdGFydCwgb3B0cykge1xuICAgICAgdmFyIGRpcnMgPSBub2RlTW9kdWxlc1BhdGhzKHN0YXJ0LCBvcHRzLCB4KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkaXJzW2ldID0gcGF0aDMuam9pbihkaXJzW2ldLCB4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXJzO1xuICAgIH07XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gcmVzb2x2ZSh4LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGNiID0gY2FsbGJhY2s7XG4gICAgICB2YXIgb3B0cyA9IG9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYiA9IG9wdHM7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgeCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy5cIik7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNiKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb3B0cyA9IG5vcm1hbGl6ZU9wdGlvbnMoeCwgb3B0cyk7XG4gICAgICB2YXIgaXNGaWxlID0gb3B0cy5pc0ZpbGUgfHwgZGVmYXVsdElzRmlsZTtcbiAgICAgIHZhciBpc0RpcmVjdG9yeSA9IG9wdHMuaXNEaXJlY3RvcnkgfHwgZGVmYXVsdElzRGlyO1xuICAgICAgdmFyIHJlYWRGaWxlID0gb3B0cy5yZWFkRmlsZSB8fCBmczMucmVhZEZpbGU7XG4gICAgICB2YXIgcmVhbHBhdGggPSBvcHRzLnJlYWxwYXRoIHx8IGRlZmF1bHRSZWFscGF0aDtcbiAgICAgIHZhciByZWFkUGFja2FnZSA9IG9wdHMucmVhZFBhY2thZ2UgfHwgZGVmYXVsdFJlYWRQYWNrYWdlO1xuICAgICAgaWYgKG9wdHMucmVhZEZpbGUgJiYgb3B0cy5yZWFkUGFja2FnZSkge1xuICAgICAgICB2YXIgY29uZmxpY3RFcnIgPSBuZXcgVHlwZUVycm9yKFwiYHJlYWRGaWxlYCBhbmQgYHJlYWRQYWNrYWdlYCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlwiKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2IoY29uZmxpY3RFcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBwYWNrYWdlSXRlcmF0b3IgPSBvcHRzLnBhY2thZ2VJdGVyYXRvcjtcbiAgICAgIHZhciBleHRlbnNpb25zID0gb3B0cy5leHRlbnNpb25zIHx8IFtcIi5qc1wiXTtcbiAgICAgIHZhciBpbmNsdWRlQ29yZU1vZHVsZXMgPSBvcHRzLmluY2x1ZGVDb3JlTW9kdWxlcyAhPT0gZmFsc2U7XG4gICAgICB2YXIgYmFzZWRpciA9IG9wdHMuYmFzZWRpciB8fCBwYXRoMy5kaXJuYW1lKGNhbGxlcigpKTtcbiAgICAgIHZhciBwYXJlbnQgPSBvcHRzLmZpbGVuYW1lIHx8IGJhc2VkaXI7XG4gICAgICBvcHRzLnBhdGhzID0gb3B0cy5wYXRocyB8fCBkZWZhdWx0UGF0aHMoKTtcbiAgICAgIHZhciBhYnNvbHV0ZVN0YXJ0ID0gcGF0aDMucmVzb2x2ZShiYXNlZGlyKTtcbiAgICAgIG1heWJlUmVhbHBhdGgoXG4gICAgICAgIHJlYWxwYXRoLFxuICAgICAgICBhYnNvbHV0ZVN0YXJ0LFxuICAgICAgICBvcHRzLFxuICAgICAgICBmdW5jdGlvbihlcnIyLCByZWFsU3RhcnQpIHtcbiAgICAgICAgICBpZiAoZXJyMilcbiAgICAgICAgICAgIGNiKGVycjIpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGluaXQocmVhbFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHZhciByZXM7XG4gICAgICBmdW5jdGlvbiBpbml0KGJhc2VkaXIyKSB7XG4gICAgICAgIGlmICgvXig/OlxcLlxcLj8oPzpcXC98JCl8XFwvfChbQS1aYS16XTopP1svXFxcXF0pLy50ZXN0KHgpKSB7XG4gICAgICAgICAgcmVzID0gcGF0aDMucmVzb2x2ZShiYXNlZGlyMiwgeCk7XG4gICAgICAgICAgaWYgKHggPT09IFwiLlwiIHx8IHggPT09IFwiLi5cIiB8fCB4LnNsaWNlKC0xKSA9PT0gXCIvXCIpXG4gICAgICAgICAgICByZXMgKz0gXCIvXCI7XG4gICAgICAgICAgaWYgKC9cXC8kLy50ZXN0KHgpICYmIHJlcyA9PT0gYmFzZWRpcjIpIHtcbiAgICAgICAgICAgIGxvYWRBc0RpcmVjdG9yeShyZXMsIG9wdHMucGFja2FnZSwgb25maWxlKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGxvYWRBc0ZpbGUocmVzLCBvcHRzLnBhY2thZ2UsIG9uZmlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZUNvcmVNb2R1bGVzICYmIGlzQ29yZSh4KSkge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCB4KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbG9hZE5vZGVNb2R1bGVzKHgsIGJhc2VkaXIyLCBmdW5jdGlvbihlcnIyLCBuLCBwa2cpIHtcbiAgICAgICAgICAgIGlmIChlcnIyKVxuICAgICAgICAgICAgICBjYihlcnIyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUmVhbHBhdGgocmVhbHBhdGgsIG4sIG9wdHMsIGZ1bmN0aW9uKGVycjMsIHJlYWxOKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycjMpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGVycjMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjYihudWxsLCByZWFsTiwgcGtnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG1vZHVsZUVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHggKyBcIicgZnJvbSAnXCIgKyBwYXJlbnQgKyBcIidcIik7XG4gICAgICAgICAgICAgIG1vZHVsZUVycm9yLmNvZGUgPSBcIk1PRFVMRV9OT1RfRk9VTkRcIjtcbiAgICAgICAgICAgICAgY2IobW9kdWxlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25maWxlKGVycjIsIG0sIHBrZykge1xuICAgICAgICBpZiAoZXJyMilcbiAgICAgICAgICBjYihlcnIyKTtcbiAgICAgICAgZWxzZSBpZiAobSlcbiAgICAgICAgICBjYihudWxsLCBtLCBwa2cpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9hZEFzRGlyZWN0b3J5KHJlcywgZnVuY3Rpb24oZXJyMywgZCwgcGtnMikge1xuICAgICAgICAgICAgaWYgKGVycjMpXG4gICAgICAgICAgICAgIGNiKGVycjMpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZCkge1xuICAgICAgICAgICAgICBtYXliZVJlYWxwYXRoKHJlYWxwYXRoLCBkLCBvcHRzLCBmdW5jdGlvbihlcnI0LCByZWFsRCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnI0KSB7XG4gICAgICAgICAgICAgICAgICBjYihlcnI0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY2IobnVsbCwgcmVhbEQsIHBrZzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbW9kdWxlRXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgeCArIFwiJyBmcm9tICdcIiArIHBhcmVudCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgbW9kdWxlRXJyb3IuY29kZSA9IFwiTU9EVUxFX05PVF9GT1VORFwiO1xuICAgICAgICAgICAgICBjYihtb2R1bGVFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsb2FkQXNGaWxlKHgyLCB0aGVQYWNrYWdlLCBjYWxsYmFjazIpIHtcbiAgICAgICAgdmFyIGxvYWRBc0ZpbGVQYWNrYWdlID0gdGhlUGFja2FnZTtcbiAgICAgICAgdmFyIGNiMiA9IGNhbGxiYWNrMjtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2FkQXNGaWxlUGFja2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY2IyID0gbG9hZEFzRmlsZVBhY2thZ2U7XG4gICAgICAgICAgbG9hZEFzRmlsZVBhY2thZ2UgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dHMgPSBbXCJcIl0uY29uY2F0KGV4dGVuc2lvbnMpO1xuICAgICAgICBsb2FkKGV4dHMsIHgyLCBsb2FkQXNGaWxlUGFja2FnZSk7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWQoZXh0czIsIHgzLCBsb2FkUGFja2FnZSkge1xuICAgICAgICAgIGlmIChleHRzMi5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gY2IyKG51bGwsIHZvaWQgMCwgbG9hZFBhY2thZ2UpO1xuICAgICAgICAgIHZhciBmaWxlID0geDMgKyBleHRzMlswXTtcbiAgICAgICAgICB2YXIgcGtnID0gbG9hZFBhY2thZ2U7XG4gICAgICAgICAgaWYgKHBrZylcbiAgICAgICAgICAgIG9ucGtnKG51bGwsIHBrZyk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbG9hZHBrZyhwYXRoMy5kaXJuYW1lKGZpbGUpLCBvbnBrZyk7XG4gICAgICAgICAgZnVuY3Rpb24gb25wa2coZXJyMiwgcGtnXywgZGlyKSB7XG4gICAgICAgICAgICBwa2cgPSBwa2dfO1xuICAgICAgICAgICAgaWYgKGVycjIpXG4gICAgICAgICAgICAgIHJldHVybiBjYjIoZXJyMik7XG4gICAgICAgICAgICBpZiAoZGlyICYmIHBrZyAmJiBvcHRzLnBhdGhGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHJmaWxlID0gcGF0aDMucmVsYXRpdmUoZGlyLCBmaWxlKTtcbiAgICAgICAgICAgICAgdmFyIHJlbCA9IHJmaWxlLnNsaWNlKDAsIHJmaWxlLmxlbmd0aCAtIGV4dHMyWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgIHZhciByID0gb3B0cy5wYXRoRmlsdGVyKHBrZywgeDMsIHJlbCk7XG4gICAgICAgICAgICAgIGlmIChyKVxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKFxuICAgICAgICAgICAgICAgICAgW1wiXCJdLmNvbmNhdChleHRlbnNpb25zLnNsaWNlKCkpLFxuICAgICAgICAgICAgICAgICAgcGF0aDMucmVzb2x2ZShkaXIsIHIpLFxuICAgICAgICAgICAgICAgICAgcGtnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRmlsZShmaWxlLCBvbmV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gb25leChlcnIyLCBleCkge1xuICAgICAgICAgICAgaWYgKGVycjIpXG4gICAgICAgICAgICAgIHJldHVybiBjYjIoZXJyMik7XG4gICAgICAgICAgICBpZiAoZXgpXG4gICAgICAgICAgICAgIHJldHVybiBjYjIobnVsbCwgZmlsZSwgcGtnKTtcbiAgICAgICAgICAgIGxvYWQoZXh0czIuc2xpY2UoMSksIHgzLCBwa2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbG9hZHBrZyhkaXIsIGNiMikge1xuICAgICAgICBpZiAoZGlyID09PSBcIlwiIHx8IGRpciA9PT0gXCIvXCIpXG4gICAgICAgICAgcmV0dXJuIGNiMihudWxsKTtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIiAmJiAvXlxcdzpbL1xcXFxdKiQvLnRlc3QoZGlyKSkge1xuICAgICAgICAgIHJldHVybiBjYjIobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9bL1xcXFxdbm9kZV9tb2R1bGVzWy9cXFxcXSokLy50ZXN0KGRpcikpXG4gICAgICAgICAgcmV0dXJuIGNiMihudWxsKTtcbiAgICAgICAgbWF5YmVSZWFscGF0aChyZWFscGF0aCwgZGlyLCBvcHRzLCBmdW5jdGlvbih1bndyYXBFcnIsIHBrZ2Rpcikge1xuICAgICAgICAgIGlmICh1bndyYXBFcnIpXG4gICAgICAgICAgICByZXR1cm4gbG9hZHBrZyhwYXRoMy5kaXJuYW1lKGRpciksIGNiMik7XG4gICAgICAgICAgdmFyIHBrZ2ZpbGUgPSBwYXRoMy5qb2luKHBrZ2RpciwgXCJwYWNrYWdlLmpzb25cIik7XG4gICAgICAgICAgaXNGaWxlKHBrZ2ZpbGUsIGZ1bmN0aW9uKGVycjIsIGV4KSB7XG4gICAgICAgICAgICBpZiAoIWV4KVxuICAgICAgICAgICAgICByZXR1cm4gbG9hZHBrZyhwYXRoMy5kaXJuYW1lKGRpciksIGNiMik7XG4gICAgICAgICAgICByZWFkUGFja2FnZShyZWFkRmlsZSwgcGtnZmlsZSwgZnVuY3Rpb24oZXJyMywgcGtnUGFyYW0pIHtcbiAgICAgICAgICAgICAgaWYgKGVycjMpXG4gICAgICAgICAgICAgICAgY2IyKGVycjMpO1xuICAgICAgICAgICAgICB2YXIgcGtnID0gcGtnUGFyYW07XG4gICAgICAgICAgICAgIGlmIChwa2cgJiYgb3B0cy5wYWNrYWdlRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcGtnID0gb3B0cy5wYWNrYWdlRmlsdGVyKHBrZywgcGtnZmlsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2IyKG51bGwsIHBrZywgZGlyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxvYWRBc0RpcmVjdG9yeSh4MiwgbG9hZEFzRGlyZWN0b3J5UGFja2FnZSwgY2FsbGJhY2syKSB7XG4gICAgICAgIHZhciBjYjIgPSBjYWxsYmFjazI7XG4gICAgICAgIHZhciBmcGtnID0gbG9hZEFzRGlyZWN0b3J5UGFja2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBmcGtnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjYjIgPSBmcGtnO1xuICAgICAgICAgIGZwa2cgPSBvcHRzLnBhY2thZ2U7XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVSZWFscGF0aChyZWFscGF0aCwgeDIsIG9wdHMsIGZ1bmN0aW9uKHVud3JhcEVyciwgcGtnZGlyKSB7XG4gICAgICAgICAgaWYgKHVud3JhcEVycilcbiAgICAgICAgICAgIHJldHVybiBjYjIodW53cmFwRXJyKTtcbiAgICAgICAgICB2YXIgcGtnZmlsZSA9IHBhdGgzLmpvaW4ocGtnZGlyLCBcInBhY2thZ2UuanNvblwiKTtcbiAgICAgICAgICBpc0ZpbGUocGtnZmlsZSwgZnVuY3Rpb24oZXJyMiwgZXgpIHtcbiAgICAgICAgICAgIGlmIChlcnIyKVxuICAgICAgICAgICAgICByZXR1cm4gY2IyKGVycjIpO1xuICAgICAgICAgICAgaWYgKCFleClcbiAgICAgICAgICAgICAgcmV0dXJuIGxvYWRBc0ZpbGUocGF0aDMuam9pbih4MiwgXCJpbmRleFwiKSwgZnBrZywgY2IyKTtcbiAgICAgICAgICAgIHJlYWRQYWNrYWdlKHJlYWRGaWxlLCBwa2dmaWxlLCBmdW5jdGlvbihlcnIzLCBwa2dQYXJhbSkge1xuICAgICAgICAgICAgICBpZiAoZXJyMylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IyKGVycjMpO1xuICAgICAgICAgICAgICB2YXIgcGtnID0gcGtnUGFyYW07XG4gICAgICAgICAgICAgIGlmIChwa2cgJiYgb3B0cy5wYWNrYWdlRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcGtnID0gb3B0cy5wYWNrYWdlRmlsdGVyKHBrZywgcGtnZmlsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBrZyAmJiBwa2cubWFpbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGtnLm1haW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtYWluRXJyb3IgPSBuZXcgVHlwZUVycm9yKFwicGFja2FnZSBcXHUyMDFDXCIgKyBwa2cubmFtZSArIFwiXFx1MjAxRCBgbWFpbmAgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgIG1haW5FcnJvci5jb2RlID0gXCJJTlZBTElEX1BBQ0tBR0VfTUFJTlwiO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiMihtYWluRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGtnLm1haW4gPT09IFwiLlwiIHx8IHBrZy5tYWluID09PSBcIi4vXCIpIHtcbiAgICAgICAgICAgICAgICAgIHBrZy5tYWluID0gXCJpbmRleFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkQXNGaWxlKHBhdGgzLnJlc29sdmUoeDIsIHBrZy5tYWluKSwgcGtnLCBmdW5jdGlvbihlcnI0LCBtLCBwa2cyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXJyNClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiMihlcnI0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IyKG51bGwsIG0sIHBrZzIpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFwa2cyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9hZEFzRmlsZShwYXRoMy5qb2luKHgyLCBcImluZGV4XCIpLCBwa2cyLCBjYjIpO1xuICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IHBhdGgzLnJlc29sdmUoeDIsIHBrZzIubWFpbik7XG4gICAgICAgICAgICAgICAgICBsb2FkQXNEaXJlY3RvcnkoZGlyLCBwa2cyLCBmdW5jdGlvbihlcnI1LCBuLCBwa2czKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnI1KVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYjIoZXJyNSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYjIobnVsbCwgbiwgcGtnMyk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRBc0ZpbGUocGF0aDMuam9pbih4MiwgXCJpbmRleFwiKSwgcGtnMywgY2IyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsb2FkQXNGaWxlKHBhdGgzLmpvaW4oeDIsIFwiL2luZGV4XCIpLCBwa2csIGNiMik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwcm9jZXNzRGlycyhjYjIsIGRpcnMpIHtcbiAgICAgICAgaWYgKGRpcnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHJldHVybiBjYjIobnVsbCwgdm9pZCAwKTtcbiAgICAgICAgdmFyIGRpciA9IGRpcnNbMF07XG4gICAgICAgIGlzRGlyZWN0b3J5KHBhdGgzLmRpcm5hbWUoZGlyKSwgaXNkaXIpO1xuICAgICAgICBmdW5jdGlvbiBpc2RpcihlcnIyLCBpc2RpcjIpIHtcbiAgICAgICAgICBpZiAoZXJyMilcbiAgICAgICAgICAgIHJldHVybiBjYjIoZXJyMik7XG4gICAgICAgICAgaWYgKCFpc2RpcjIpXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0RpcnMoY2IyLCBkaXJzLnNsaWNlKDEpKTtcbiAgICAgICAgICBsb2FkQXNGaWxlKGRpciwgb3B0cy5wYWNrYWdlLCBvbmZpbGUyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmZpbGUyKGVycjIsIG0sIHBrZykge1xuICAgICAgICAgIGlmIChlcnIyKVxuICAgICAgICAgICAgcmV0dXJuIGNiMihlcnIyKTtcbiAgICAgICAgICBpZiAobSlcbiAgICAgICAgICAgIHJldHVybiBjYjIobnVsbCwgbSwgcGtnKTtcbiAgICAgICAgICBsb2FkQXNEaXJlY3RvcnkoZGlyLCBvcHRzLnBhY2thZ2UsIG9uZGlyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmRpcihlcnIyLCBuLCBwa2cpIHtcbiAgICAgICAgICBpZiAoZXJyMilcbiAgICAgICAgICAgIHJldHVybiBjYjIoZXJyMik7XG4gICAgICAgICAgaWYgKG4pXG4gICAgICAgICAgICByZXR1cm4gY2IyKG51bGwsIG4sIHBrZyk7XG4gICAgICAgICAgcHJvY2Vzc0RpcnMoY2IyLCBkaXJzLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbG9hZE5vZGVNb2R1bGVzKHgyLCBzdGFydCwgY2IyKSB7XG4gICAgICAgIHZhciB0aHVuayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBnZXRQYWNrYWdlQ2FuZGlkYXRlcyh4Miwgc3RhcnQsIG9wdHMpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRGlycyhcbiAgICAgICAgICBjYjIsXG4gICAgICAgICAgcGFja2FnZUl0ZXJhdG9yID8gcGFja2FnZUl0ZXJhdG9yKHgyLCBzdGFydCwgdGh1bmssIG9wdHMpIDogdGh1bmsoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvY29yZS5qc29uXG52YXIgcmVxdWlyZV9jb3JlMiA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9jb3JlLmpzb25cIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgYXNzZXJ0OiB0cnVlLFxuICAgICAgXCJub2RlOmFzc2VydFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBcImFzc2VydC9zdHJpY3RcIjogXCI+PSAxNVwiLFxuICAgICAgXCJub2RlOmFzc2VydC9zdHJpY3RcIjogXCI+PSAxNlwiLFxuICAgICAgYXN5bmNfaG9va3M6IFwiPj0gOFwiLFxuICAgICAgXCJub2RlOmFzeW5jX2hvb2tzXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGJ1ZmZlcl9pZWVlNzU0OiBcIj49IDAuNSAmJiA8IDAuOS43XCIsXG4gICAgICBidWZmZXI6IHRydWUsXG4gICAgICBcIm5vZGU6YnVmZmVyXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGNoaWxkX3Byb2Nlc3M6IHRydWUsXG4gICAgICBcIm5vZGU6Y2hpbGRfcHJvY2Vzc1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBjbHVzdGVyOiBcIj49IDAuNVwiLFxuICAgICAgXCJub2RlOmNsdXN0ZXJcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgY29uc29sZTogdHJ1ZSxcbiAgICAgIFwibm9kZTpjb25zb2xlXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGNvbnN0YW50czogdHJ1ZSxcbiAgICAgIFwibm9kZTpjb25zdGFudHNcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgY3J5cHRvOiB0cnVlLFxuICAgICAgXCJub2RlOmNyeXB0b1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfZGVidWdfYWdlbnQ6IFwiPj0gMSAmJiA8IDhcIixcbiAgICAgIF9kZWJ1Z2dlcjogXCI8IDhcIixcbiAgICAgIGRncmFtOiB0cnVlLFxuICAgICAgXCJub2RlOmRncmFtXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGRpYWdub3N0aWNzX2NoYW5uZWw6IFtcIj49IDE0LjE3ICYmIDwgMTVcIiwgXCI+PSAxNS4xXCJdLFxuICAgICAgXCJub2RlOmRpYWdub3N0aWNzX2NoYW5uZWxcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgZG5zOiB0cnVlLFxuICAgICAgXCJub2RlOmRuc1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBcImRucy9wcm9taXNlc1wiOiBcIj49IDE1XCIsXG4gICAgICBcIm5vZGU6ZG5zL3Byb21pc2VzXCI6IFwiPj0gMTZcIixcbiAgICAgIGRvbWFpbjogXCI+PSAwLjcuMTJcIixcbiAgICAgIFwibm9kZTpkb21haW5cIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgZXZlbnRzOiB0cnVlLFxuICAgICAgXCJub2RlOmV2ZW50c1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBmcmVlbGlzdDogXCI8IDZcIixcbiAgICAgIGZzOiB0cnVlLFxuICAgICAgXCJub2RlOmZzXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwiZnMvcHJvbWlzZXNcIjogW1wiPj0gMTAgJiYgPCAxMC4xXCIsIFwiPj0gMTRcIl0sXG4gICAgICBcIm5vZGU6ZnMvcHJvbWlzZXNcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX2h0dHBfYWdlbnQ6IFwiPj0gMC4xMS4xXCIsXG4gICAgICBcIm5vZGU6X2h0dHBfYWdlbnRcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX2h0dHBfY2xpZW50OiBcIj49IDAuMTEuMVwiLFxuICAgICAgXCJub2RlOl9odHRwX2NsaWVudFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfaHR0cF9jb21tb246IFwiPj0gMC4xMS4xXCIsXG4gICAgICBcIm5vZGU6X2h0dHBfY29tbW9uXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIF9odHRwX2luY29taW5nOiBcIj49IDAuMTEuMVwiLFxuICAgICAgXCJub2RlOl9odHRwX2luY29taW5nXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIF9odHRwX291dGdvaW5nOiBcIj49IDAuMTEuMVwiLFxuICAgICAgXCJub2RlOl9odHRwX291dGdvaW5nXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIF9odHRwX3NlcnZlcjogXCI+PSAwLjExLjFcIixcbiAgICAgIFwibm9kZTpfaHR0cF9zZXJ2ZXJcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgaHR0cDogdHJ1ZSxcbiAgICAgIFwibm9kZTpodHRwXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGh0dHAyOiBcIj49IDguOFwiLFxuICAgICAgXCJub2RlOmh0dHAyXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGh0dHBzOiB0cnVlLFxuICAgICAgXCJub2RlOmh0dHBzXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIGluc3BlY3RvcjogXCI+PSA4XCIsXG4gICAgICBcIm5vZGU6aW5zcGVjdG9yXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwiaW5zcGVjdG9yL3Byb21pc2VzXCI6IFtcIj49IDE5XCJdLFxuICAgICAgXCJub2RlOmluc3BlY3Rvci9wcm9taXNlc1wiOiBbXCI+PSAxOVwiXSxcbiAgICAgIF9saW5rbGlzdDogXCI8IDhcIixcbiAgICAgIG1vZHVsZTogdHJ1ZSxcbiAgICAgIFwibm9kZTptb2R1bGVcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgbmV0OiB0cnVlLFxuICAgICAgXCJub2RlOm5ldFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBcIm5vZGUtaW5zcGVjdC9saWIvX2luc3BlY3RcIjogXCI+PSA3LjYgJiYgPCAxMlwiLFxuICAgICAgXCJub2RlLWluc3BlY3QvbGliL2ludGVybmFsL2luc3BlY3RfY2xpZW50XCI6IFwiPj0gNy42ICYmIDwgMTJcIixcbiAgICAgIFwibm9kZS1pbnNwZWN0L2xpYi9pbnRlcm5hbC9pbnNwZWN0X3JlcGxcIjogXCI+PSA3LjYgJiYgPCAxMlwiLFxuICAgICAgb3M6IHRydWUsXG4gICAgICBcIm5vZGU6b3NcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgcGF0aDogdHJ1ZSxcbiAgICAgIFwibm9kZTpwYXRoXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwicGF0aC9wb3NpeFwiOiBcIj49IDE1LjNcIixcbiAgICAgIFwibm9kZTpwYXRoL3Bvc2l4XCI6IFwiPj0gMTZcIixcbiAgICAgIFwicGF0aC93aW4zMlwiOiBcIj49IDE1LjNcIixcbiAgICAgIFwibm9kZTpwYXRoL3dpbjMyXCI6IFwiPj0gMTZcIixcbiAgICAgIHBlcmZfaG9va3M6IFwiPj0gOC41XCIsXG4gICAgICBcIm5vZGU6cGVyZl9ob29rc1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBwcm9jZXNzOiBcIj49IDFcIixcbiAgICAgIFwibm9kZTpwcm9jZXNzXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHB1bnljb2RlOiBcIj49IDAuNVwiLFxuICAgICAgXCJub2RlOnB1bnljb2RlXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHF1ZXJ5c3RyaW5nOiB0cnVlLFxuICAgICAgXCJub2RlOnF1ZXJ5c3RyaW5nXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHJlYWRsaW5lOiB0cnVlLFxuICAgICAgXCJub2RlOnJlYWRsaW5lXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIFwicmVhZGxpbmUvcHJvbWlzZXNcIjogXCI+PSAxN1wiLFxuICAgICAgXCJub2RlOnJlYWRsaW5lL3Byb21pc2VzXCI6IFwiPj0gMTdcIixcbiAgICAgIHJlcGw6IHRydWUsXG4gICAgICBcIm5vZGU6cmVwbFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBzbWFsbG9jOiBcIj49IDAuMTEuNSAmJiA8IDNcIixcbiAgICAgIF9zdHJlYW1fZHVwbGV4OiBcIj49IDAuOS40XCIsXG4gICAgICBcIm5vZGU6X3N0cmVhbV9kdXBsZXhcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX3N0cmVhbV90cmFuc2Zvcm06IFwiPj0gMC45LjRcIixcbiAgICAgIFwibm9kZTpfc3RyZWFtX3RyYW5zZm9ybVwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBfc3RyZWFtX3dyYXA6IFwiPj0gMS40LjFcIixcbiAgICAgIFwibm9kZTpfc3RyZWFtX3dyYXBcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX3N0cmVhbV9wYXNzdGhyb3VnaDogXCI+PSAwLjkuNFwiLFxuICAgICAgXCJub2RlOl9zdHJlYW1fcGFzc3Rocm91Z2hcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX3N0cmVhbV9yZWFkYWJsZTogXCI+PSAwLjkuNFwiLFxuICAgICAgXCJub2RlOl9zdHJlYW1fcmVhZGFibGVcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX3N0cmVhbV93cml0YWJsZTogXCI+PSAwLjkuNFwiLFxuICAgICAgXCJub2RlOl9zdHJlYW1fd3JpdGFibGVcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgXCJub2RlOnN0cmVhbVwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBcInN0cmVhbS9jb25zdW1lcnNcIjogXCI+PSAxNi43XCIsXG4gICAgICBcIm5vZGU6c3RyZWFtL2NvbnN1bWVyc1wiOiBcIj49IDE2LjdcIixcbiAgICAgIFwic3RyZWFtL3Byb21pc2VzXCI6IFwiPj0gMTVcIixcbiAgICAgIFwibm9kZTpzdHJlYW0vcHJvbWlzZXNcIjogXCI+PSAxNlwiLFxuICAgICAgXCJzdHJlYW0vd2ViXCI6IFwiPj0gMTYuNVwiLFxuICAgICAgXCJub2RlOnN0cmVhbS93ZWJcIjogXCI+PSAxNi41XCIsXG4gICAgICBzdHJpbmdfZGVjb2RlcjogdHJ1ZSxcbiAgICAgIFwibm9kZTpzdHJpbmdfZGVjb2RlclwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBzeXM6IFtcIj49IDAuNCAmJiA8IDAuN1wiLCBcIj49IDAuOFwiXSxcbiAgICAgIFwibm9kZTpzeXNcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgXCJ0ZXN0L3JlcG9ydGVyc1wiOiBcIj49IDE5LjkgJiYgPCAyMC4yXCIsXG4gICAgICBcIm5vZGU6dGVzdC9yZXBvcnRlcnNcIjogW1wiPj0gMTguMTcgJiYgPCAxOVwiLCBcIj49IDE5LjlcIiwgXCI+PSAyMFwiXSxcbiAgICAgIFwibm9kZTp0ZXN0XCI6IFtcIj49IDE2LjE3ICYmIDwgMTdcIiwgXCI+PSAxOFwiXSxcbiAgICAgIHRpbWVyczogdHJ1ZSxcbiAgICAgIFwibm9kZTp0aW1lcnNcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgXCJ0aW1lcnMvcHJvbWlzZXNcIjogXCI+PSAxNVwiLFxuICAgICAgXCJub2RlOnRpbWVycy9wcm9taXNlc1wiOiBcIj49IDE2XCIsXG4gICAgICBfdGxzX2NvbW1vbjogXCI+PSAwLjExLjEzXCIsXG4gICAgICBcIm5vZGU6X3Rsc19jb21tb25cIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgX3Rsc19sZWdhY3k6IFwiPj0gMC4xMS4zICYmIDwgMTBcIixcbiAgICAgIF90bHNfd3JhcDogXCI+PSAwLjExLjNcIixcbiAgICAgIFwibm9kZTpfdGxzX3dyYXBcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgdGxzOiB0cnVlLFxuICAgICAgXCJub2RlOnRsc1wiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICB0cmFjZV9ldmVudHM6IFwiPj0gMTBcIixcbiAgICAgIFwibm9kZTp0cmFjZV9ldmVudHNcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgdHR5OiB0cnVlLFxuICAgICAgXCJub2RlOnR0eVwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICB1cmw6IHRydWUsXG4gICAgICBcIm5vZGU6dXJsXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXSxcbiAgICAgIHV0aWw6IHRydWUsXG4gICAgICBcIm5vZGU6dXRpbFwiOiBbXCI+PSAxNC4xOCAmJiA8IDE1XCIsIFwiPj0gMTZcIl0sXG4gICAgICBcInV0aWwvdHlwZXNcIjogXCI+PSAxNS4zXCIsXG4gICAgICBcIm5vZGU6dXRpbC90eXBlc1wiOiBcIj49IDE2XCIsXG4gICAgICBcInY4L3Rvb2xzL2FyZ3VtZW50c1wiOiBcIj49IDEwICYmIDwgMTJcIixcbiAgICAgIFwidjgvdG9vbHMvY29kZW1hcFwiOiBbXCI+PSA0LjQgJiYgPCA1XCIsIFwiPj0gNS4yICYmIDwgMTJcIl0sXG4gICAgICBcInY4L3Rvb2xzL2NvbnNhcnJheVwiOiBbXCI+PSA0LjQgJiYgPCA1XCIsIFwiPj0gNS4yICYmIDwgMTJcIl0sXG4gICAgICBcInY4L3Rvb2xzL2NzdnBhcnNlclwiOiBbXCI+PSA0LjQgJiYgPCA1XCIsIFwiPj0gNS4yICYmIDwgMTJcIl0sXG4gICAgICBcInY4L3Rvb2xzL2xvZ3JlYWRlclwiOiBbXCI+PSA0LjQgJiYgPCA1XCIsIFwiPj0gNS4yICYmIDwgMTJcIl0sXG4gICAgICBcInY4L3Rvb2xzL3Byb2ZpbGVfdmlld1wiOiBbXCI+PSA0LjQgJiYgPCA1XCIsIFwiPj0gNS4yICYmIDwgMTJcIl0sXG4gICAgICBcInY4L3Rvb2xzL3NwbGF5dHJlZVwiOiBbXCI+PSA0LjQgJiYgPCA1XCIsIFwiPj0gNS4yICYmIDwgMTJcIl0sXG4gICAgICB2ODogXCI+PSAxXCIsXG4gICAgICBcIm5vZGU6djhcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgdm06IHRydWUsXG4gICAgICBcIm5vZGU6dm1cIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgd2FzaTogW1wiPj0gMTMuNCAmJiA8IDEzLjVcIiwgXCI+PSAxOC4xNyAmJiA8IDE5XCIsIFwiPj0gMjBcIl0sXG4gICAgICBcIm5vZGU6d2FzaVwiOiBbXCI+PSAxOC4xNyAmJiA8IDE5XCIsIFwiPj0gMjBcIl0sXG4gICAgICB3b3JrZXJfdGhyZWFkczogXCI+PSAxMS43XCIsXG4gICAgICBcIm5vZGU6d29ya2VyX3RocmVhZHNcIjogW1wiPj0gMTQuMTggJiYgPCAxNVwiLCBcIj49IDE2XCJdLFxuICAgICAgemxpYjogXCI+PSAwLjVcIixcbiAgICAgIFwibm9kZTp6bGliXCI6IFtcIj49IDE0LjE4ICYmIDwgMTVcIiwgXCI+PSAxNlwiXVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvY29yZS5qc1xudmFyIHJlcXVpcmVfY29yZTMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvY29yZS5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNDb3JlTW9kdWxlID0gcmVxdWlyZV9pc19jb3JlX21vZHVsZSgpO1xuICAgIHZhciBkYXRhID0gcmVxdWlyZV9jb3JlMigpO1xuICAgIHZhciBjb3JlID0ge307XG4gICAgZm9yIChtb2QgaW4gZGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBtb2QpKSB7XG4gICAgICAgIGNvcmVbbW9kXSA9IGlzQ29yZU1vZHVsZShtb2QpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbW9kO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGNvcmU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvaXMtY29yZS5qc1xudmFyIHJlcXVpcmVfaXNfY29yZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9pcy1jb3JlLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBpc0NvcmVNb2R1bGUgPSByZXF1aXJlX2lzX2NvcmVfbW9kdWxlKCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24gaXNDb3JlKHgpIHtcbiAgICAgIHJldHVybiBpc0NvcmVNb2R1bGUoeCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9zeW5jLmpzXG52YXIgcmVxdWlyZV9zeW5jID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL3N5bmMuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIGlzQ29yZSA9IHJlcXVpcmVfaXNfY29yZV9tb2R1bGUoKTtcbiAgICB2YXIgZnMzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIHZhciBwYXRoMyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHZhciBnZXRIb21lZGlyID0gcmVxdWlyZV9ob21lZGlyKCk7XG4gICAgdmFyIGNhbGxlciA9IHJlcXVpcmVfY2FsbGVyKCk7XG4gICAgdmFyIG5vZGVNb2R1bGVzUGF0aHMgPSByZXF1aXJlX25vZGVfbW9kdWxlc19wYXRocygpO1xuICAgIHZhciBub3JtYWxpemVPcHRpb25zID0gcmVxdWlyZV9ub3JtYWxpemVfb3B0aW9ucygpO1xuICAgIHZhciByZWFscGF0aEZTID0gcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJ3aW4zMlwiICYmIGZzMy5yZWFscGF0aFN5bmMgJiYgdHlwZW9mIGZzMy5yZWFscGF0aFN5bmMubmF0aXZlID09PSBcImZ1bmN0aW9uXCIgPyBmczMucmVhbHBhdGhTeW5jLm5hdGl2ZSA6IGZzMy5yZWFscGF0aFN5bmM7XG4gICAgdmFyIGhvbWVkaXIgPSBnZXRIb21lZGlyKCk7XG4gICAgdmFyIGRlZmF1bHRQYXRocyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcGF0aDMuam9pbihob21lZGlyLCBcIi5ub2RlX21vZHVsZXNcIiksXG4gICAgICAgIHBhdGgzLmpvaW4oaG9tZWRpciwgXCIubm9kZV9saWJyYXJpZXNcIilcbiAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdElzRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZShmaWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RhdCA9IGZzMy5zdGF0U3luYyhmaWxlLCB7IHRocm93SWZOb0VudHJ5OiBmYWxzZSB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgJiYgKGUuY29kZSA9PT0gXCJFTk9FTlRcIiB8fCBlLmNvZGUgPT09IFwiRU5PVERJUlwiKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFzdGF0ICYmIChzdGF0LmlzRmlsZSgpIHx8IHN0YXQuaXNGSUZPKCkpO1xuICAgIH07XG4gICAgdmFyIGRlZmF1bHRJc0RpciA9IGZ1bmN0aW9uIGlzRGlyZWN0b3J5KGRpcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0YXQgPSBmczMuc3RhdFN5bmMoZGlyLCB7IHRocm93SWZOb0VudHJ5OiBmYWxzZSB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgJiYgKGUuY29kZSA9PT0gXCJFTk9FTlRcIiB8fCBlLmNvZGUgPT09IFwiRU5PVERJUlwiKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFzdGF0ICYmIHN0YXQuaXNEaXJlY3RvcnkoKTtcbiAgICB9O1xuICAgIHZhciBkZWZhdWx0UmVhbHBhdGhTeW5jID0gZnVuY3Rpb24gcmVhbHBhdGhTeW5jKHgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZWFscGF0aEZTKHgpO1xuICAgICAgfSBjYXRjaCAocmVhbHBhdGhFcnIpIHtcbiAgICAgICAgaWYgKHJlYWxwYXRoRXJyLmNvZGUgIT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICB0aHJvdyByZWFscGF0aEVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICB2YXIgbWF5YmVSZWFscGF0aFN5bmMgPSBmdW5jdGlvbiBtYXliZVJlYWxwYXRoU3luYzIocmVhbHBhdGhTeW5jLCB4LCBvcHRzKSB7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnByZXNlcnZlU3ltbGlua3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByZWFscGF0aFN5bmMoeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIHZhciBkZWZhdWx0UmVhZFBhY2thZ2VTeW5jID0gZnVuY3Rpb24gZGVmYXVsdFJlYWRQYWNrYWdlU3luYzIocmVhZEZpbGVTeW5jLCBwa2dmaWxlKSB7XG4gICAgICB2YXIgYm9keSA9IHJlYWRGaWxlU3luYyhwa2dmaWxlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBwa2cgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICByZXR1cm4gcGtnO1xuICAgICAgfSBjYXRjaCAoanNvbkVycikge1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGdldFBhY2thZ2VDYW5kaWRhdGVzID0gZnVuY3Rpb24gZ2V0UGFja2FnZUNhbmRpZGF0ZXMyKHgsIHN0YXJ0LCBvcHRzKSB7XG4gICAgICB2YXIgZGlycyA9IG5vZGVNb2R1bGVzUGF0aHMoc3RhcnQsIG9wdHMsIHgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpcnNbaV0gPSBwYXRoMy5qb2luKGRpcnNbaV0sIHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpcnM7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbiByZXNvbHZlU3luYyh4LCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIHggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy5cIik7XG4gICAgICB9XG4gICAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZU9wdGlvbnMoeCwgb3B0aW9ucyk7XG4gICAgICB2YXIgaXNGaWxlID0gb3B0cy5pc0ZpbGUgfHwgZGVmYXVsdElzRmlsZTtcbiAgICAgIHZhciByZWFkRmlsZVN5bmMgPSBvcHRzLnJlYWRGaWxlU3luYyB8fCBmczMucmVhZEZpbGVTeW5jO1xuICAgICAgdmFyIGlzRGlyZWN0b3J5ID0gb3B0cy5pc0RpcmVjdG9yeSB8fCBkZWZhdWx0SXNEaXI7XG4gICAgICB2YXIgcmVhbHBhdGhTeW5jID0gb3B0cy5yZWFscGF0aFN5bmMgfHwgZGVmYXVsdFJlYWxwYXRoU3luYztcbiAgICAgIHZhciByZWFkUGFja2FnZVN5bmMgPSBvcHRzLnJlYWRQYWNrYWdlU3luYyB8fCBkZWZhdWx0UmVhZFBhY2thZ2VTeW5jO1xuICAgICAgaWYgKG9wdHMucmVhZEZpbGVTeW5jICYmIG9wdHMucmVhZFBhY2thZ2VTeW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJgcmVhZEZpbGVTeW5jYCBhbmQgYHJlYWRQYWNrYWdlU3luY2AgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cIik7XG4gICAgICB9XG4gICAgICB2YXIgcGFja2FnZUl0ZXJhdG9yID0gb3B0cy5wYWNrYWdlSXRlcmF0b3I7XG4gICAgICB2YXIgZXh0ZW5zaW9ucyA9IG9wdHMuZXh0ZW5zaW9ucyB8fCBbXCIuanNcIl07XG4gICAgICB2YXIgaW5jbHVkZUNvcmVNb2R1bGVzID0gb3B0cy5pbmNsdWRlQ29yZU1vZHVsZXMgIT09IGZhbHNlO1xuICAgICAgdmFyIGJhc2VkaXIgPSBvcHRzLmJhc2VkaXIgfHwgcGF0aDMuZGlybmFtZShjYWxsZXIoKSk7XG4gICAgICB2YXIgcGFyZW50ID0gb3B0cy5maWxlbmFtZSB8fCBiYXNlZGlyO1xuICAgICAgb3B0cy5wYXRocyA9IG9wdHMucGF0aHMgfHwgZGVmYXVsdFBhdGhzKCk7XG4gICAgICB2YXIgYWJzb2x1dGVTdGFydCA9IG1heWJlUmVhbHBhdGhTeW5jKHJlYWxwYXRoU3luYywgcGF0aDMucmVzb2x2ZShiYXNlZGlyKSwgb3B0cyk7XG4gICAgICBpZiAoL14oPzpcXC5cXC4/KD86XFwvfCQpfFxcL3woW0EtWmEtel06KT9bL1xcXFxdKS8udGVzdCh4KSkge1xuICAgICAgICB2YXIgcmVzID0gcGF0aDMucmVzb2x2ZShhYnNvbHV0ZVN0YXJ0LCB4KTtcbiAgICAgICAgaWYgKHggPT09IFwiLlwiIHx8IHggPT09IFwiLi5cIiB8fCB4LnNsaWNlKC0xKSA9PT0gXCIvXCIpXG4gICAgICAgICAgcmVzICs9IFwiL1wiO1xuICAgICAgICB2YXIgbSA9IGxvYWRBc0ZpbGVTeW5jKHJlcykgfHwgbG9hZEFzRGlyZWN0b3J5U3luYyhyZXMpO1xuICAgICAgICBpZiAobSlcbiAgICAgICAgICByZXR1cm4gbWF5YmVSZWFscGF0aFN5bmMocmVhbHBhdGhTeW5jLCBtLCBvcHRzKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZUNvcmVNb2R1bGVzICYmIGlzQ29yZSh4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuID0gbG9hZE5vZGVNb2R1bGVzU3luYyh4LCBhYnNvbHV0ZVN0YXJ0KTtcbiAgICAgICAgaWYgKG4pXG4gICAgICAgICAgcmV0dXJuIG1heWJlUmVhbHBhdGhTeW5jKHJlYWxwYXRoU3luYywgbiwgb3B0cyk7XG4gICAgICB9XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHggKyBcIicgZnJvbSAnXCIgKyBwYXJlbnQgKyBcIidcIik7XG4gICAgICBlcnIuY29kZSA9IFwiTU9EVUxFX05PVF9GT1VORFwiO1xuICAgICAgdGhyb3cgZXJyO1xuICAgICAgZnVuY3Rpb24gbG9hZEFzRmlsZVN5bmMoeDIpIHtcbiAgICAgICAgdmFyIHBrZyA9IGxvYWRwa2cocGF0aDMuZGlybmFtZSh4MikpO1xuICAgICAgICBpZiAocGtnICYmIHBrZy5kaXIgJiYgcGtnLnBrZyAmJiBvcHRzLnBhdGhGaWx0ZXIpIHtcbiAgICAgICAgICB2YXIgcmZpbGUgPSBwYXRoMy5yZWxhdGl2ZShwa2cuZGlyLCB4Mik7XG4gICAgICAgICAgdmFyIHIgPSBvcHRzLnBhdGhGaWx0ZXIocGtnLnBrZywgeDIsIHJmaWxlKTtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgeDIgPSBwYXRoMy5yZXNvbHZlKHBrZy5kaXIsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGaWxlKHgyKSkge1xuICAgICAgICAgIHJldHVybiB4MjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZmlsZSA9IHgyICsgZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICBpZiAoaXNGaWxlKGZpbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxvYWRwa2coZGlyKSB7XG4gICAgICAgIGlmIChkaXIgPT09IFwiXCIgfHwgZGlyID09PSBcIi9cIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIgJiYgL15cXHc6Wy9cXFxcXSokLy50ZXN0KGRpcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9bL1xcXFxdbm9kZV9tb2R1bGVzWy9cXFxcXSokLy50ZXN0KGRpcikpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcGtnZmlsZSA9IHBhdGgzLmpvaW4obWF5YmVSZWFscGF0aFN5bmMocmVhbHBhdGhTeW5jLCBkaXIsIG9wdHMpLCBcInBhY2thZ2UuanNvblwiKTtcbiAgICAgICAgaWYgKCFpc0ZpbGUocGtnZmlsZSkpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZHBrZyhwYXRoMy5kaXJuYW1lKGRpcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwa2cgPSByZWFkUGFja2FnZVN5bmMocmVhZEZpbGVTeW5jLCBwa2dmaWxlKTtcbiAgICAgICAgaWYgKHBrZyAmJiBvcHRzLnBhY2thZ2VGaWx0ZXIpIHtcbiAgICAgICAgICBwa2cgPSBvcHRzLnBhY2thZ2VGaWx0ZXIoXG4gICAgICAgICAgICBwa2csXG4gICAgICAgICAgICAvKnBrZ2ZpbGUsKi9cbiAgICAgICAgICAgIGRpclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcGtnLCBkaXIgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxvYWRBc0RpcmVjdG9yeVN5bmMoeDIpIHtcbiAgICAgICAgdmFyIHBrZ2ZpbGUgPSBwYXRoMy5qb2luKG1heWJlUmVhbHBhdGhTeW5jKHJlYWxwYXRoU3luYywgeDIsIG9wdHMpLCBcIi9wYWNrYWdlLmpzb25cIik7XG4gICAgICAgIGlmIChpc0ZpbGUocGtnZmlsZSkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHBrZyA9IHJlYWRQYWNrYWdlU3luYyhyZWFkRmlsZVN5bmMsIHBrZ2ZpbGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBrZyAmJiBvcHRzLnBhY2thZ2VGaWx0ZXIpIHtcbiAgICAgICAgICAgIHBrZyA9IG9wdHMucGFja2FnZUZpbHRlcihcbiAgICAgICAgICAgICAgcGtnLFxuICAgICAgICAgICAgICAvKnBrZ2ZpbGUsKi9cbiAgICAgICAgICAgICAgeDJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwa2cgJiYgcGtnLm1haW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGtnLm1haW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdmFyIG1haW5FcnJvciA9IG5ldyBUeXBlRXJyb3IoXCJwYWNrYWdlIFxcdTIwMUNcIiArIHBrZy5uYW1lICsgXCJcXHUyMDFEIGBtYWluYCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICBtYWluRXJyb3IuY29kZSA9IFwiSU5WQUxJRF9QQUNLQUdFX01BSU5cIjtcbiAgICAgICAgICAgICAgdGhyb3cgbWFpbkVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBrZy5tYWluID09PSBcIi5cIiB8fCBwa2cubWFpbiA9PT0gXCIuL1wiKSB7XG4gICAgICAgICAgICAgIHBrZy5tYWluID0gXCJpbmRleFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIG0yID0gbG9hZEFzRmlsZVN5bmMocGF0aDMucmVzb2x2ZSh4MiwgcGtnLm1haW4pKTtcbiAgICAgICAgICAgICAgaWYgKG0yKVxuICAgICAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgICAgICAgdmFyIG4yID0gbG9hZEFzRGlyZWN0b3J5U3luYyhwYXRoMy5yZXNvbHZlKHgyLCBwa2cubWFpbikpO1xuICAgICAgICAgICAgICBpZiAobjIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG4yO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9hZEFzRmlsZVN5bmMocGF0aDMuam9pbih4MiwgXCIvaW5kZXhcIikpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbG9hZE5vZGVNb2R1bGVzU3luYyh4Miwgc3RhcnQpIHtcbiAgICAgICAgdmFyIHRodW5rID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFBhY2thZ2VDYW5kaWRhdGVzKHgyLCBzdGFydCwgb3B0cyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkaXJzID0gcGFja2FnZUl0ZXJhdG9yID8gcGFja2FnZUl0ZXJhdG9yKHgyLCBzdGFydCwgdGh1bmssIG9wdHMpIDogdGh1bmsoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRpciA9IGRpcnNbaV07XG4gICAgICAgICAgaWYgKGlzRGlyZWN0b3J5KHBhdGgzLmRpcm5hbWUoZGlyKSkpIHtcbiAgICAgICAgICAgIHZhciBtMiA9IGxvYWRBc0ZpbGVTeW5jKGRpcik7XG4gICAgICAgICAgICBpZiAobTIpXG4gICAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgICAgIHZhciBuMiA9IGxvYWRBc0RpcmVjdG9yeVN5bmMoZGlyKTtcbiAgICAgICAgICAgIGlmIChuMilcbiAgICAgICAgICAgICAgcmV0dXJuIG4yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcmVzb2x2ZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfcmVzb2x2ZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9yZXNvbHZlL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBhc3luYyA9IHJlcXVpcmVfYXN5bmMoKTtcbiAgICBhc3luYy5jb3JlID0gcmVxdWlyZV9jb3JlMygpO1xuICAgIGFzeW5jLmlzQ29yZSA9IHJlcXVpcmVfaXNfY29yZSgpO1xuICAgIGFzeW5jLnN5bmMgPSByZXF1aXJlX3N5bmMoKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBhc3luYztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tcy9pbmRleC5qc1xudmFyIHJlcXVpcmVfbXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbXMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIHMgPSAxZTM7XG4gICAgdmFyIG0gPSBzICogNjA7XG4gICAgdmFyIGggPSBtICogNjA7XG4gICAgdmFyIGQgPSBoICogMjQ7XG4gICAgdmFyIHcgPSBkICogNztcbiAgICB2YXIgeSA9IGQgKiAzNjUuMjU7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZTQodmFsKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICAgICApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcGFyc2U0KHN0cikge1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgICAgIHN0clxuICAgICAgKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8IFwibXNcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwieWVhcnNcIjpcbiAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgY2FzZSBcInlyc1wiOlxuICAgICAgICBjYXNlIFwieXJcIjpcbiAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICByZXR1cm4gbiAqIHk7XG4gICAgICAgIGNhc2UgXCJ3ZWVrc1wiOlxuICAgICAgICBjYXNlIFwid2Vla1wiOlxuICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgIHJldHVybiBuICogdztcbiAgICAgICAgY2FzZSBcImRheXNcIjpcbiAgICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIHJldHVybiBuICogZDtcbiAgICAgICAgY2FzZSBcImhvdXJzXCI6XG4gICAgICAgIGNhc2UgXCJob3VyXCI6XG4gICAgICAgIGNhc2UgXCJocnNcIjpcbiAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIG4gKiBoO1xuICAgICAgICBjYXNlIFwibWludXRlc1wiOlxuICAgICAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICAgIGNhc2UgXCJtaW5zXCI6XG4gICAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICByZXR1cm4gbiAqIG07XG4gICAgICAgIGNhc2UgXCJzZWNvbmRzXCI6XG4gICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgICAgY2FzZSBcInNlY3NcIjpcbiAgICAgICAgY2FzZSBcInNlY1wiOlxuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgIHJldHVybiBuICogcztcbiAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcbiAgICAgICAgY2FzZSBcIm1zZWNzXCI6XG4gICAgICAgIGNhc2UgXCJtc2VjXCI6XG4gICAgICAgIGNhc2UgXCJtc1wiOlxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gICAgICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gICAgICBpZiAobXNBYnMgPj0gZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgXCJkXCI7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gaCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgXCJoXCI7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgXCJtXCI7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgXCJzXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXMgKyBcIm1zXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgICAgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgICAgIGlmIChtc0FicyA+PSBkKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCBcImRheVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtc0FicyA+PSBoKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCBcImhvdXJcIik7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgXCJtaW51dGVcIik7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgXCJzZWNvbmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXMgKyBcIiBtc1wiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gICAgICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArIFwiIFwiICsgbmFtZSArIChpc1BsdXJhbCA/IFwic1wiIDogXCJcIik7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanNcbnZhciByZXF1aXJlX2NvbW1vbiA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIGZ1bmN0aW9uIHNldHVwKGVudjMpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gICAgICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gICAgICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gICAgICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlX21zKCk7XG4gICAgICBjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgIE9iamVjdC5rZXlzKGVudjMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52M1trZXldO1xuICAgICAgfSk7XG4gICAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIGhhc2ggfD0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gICAgICB9XG4gICAgICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAgICAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgICAgIGxldCBwcmV2VGltZTtcbiAgICAgICAgbGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcbiAgICAgICAgbGV0IG5hbWVzcGFjZXNDYWNoZTtcbiAgICAgICAgbGV0IGVuYWJsZWRDYWNoZTtcbiAgICAgICAgZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuICAgICAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzZWxmMiA9IGRlYnVnO1xuICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpO1xuICAgICAgICAgIGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgICAgICBzZWxmMi5kaWZmID0gbXM7XG4gICAgICAgICAgc2VsZjIucHJldiA9IHByZXZUaW1lO1xuICAgICAgICAgIHNlbGYyLmN1cnIgPSBjdXJyO1xuICAgICAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KFwiJU9cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPT09IFwiJSVcIikge1xuICAgICAgICAgICAgICByZXR1cm4gXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmMiwgdmFsKTtcbiAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmMiwgYXJncyk7XG4gICAgICAgICAgY29uc3QgbG9nRm4gPSBzZWxmMi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYyLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgICAgICBkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gICAgICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcbiAgICAgICAgZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuICAgICAgICAgICAgICBuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuICAgICAgICAgICAgICBlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5hYmxlZENhY2hlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiAodikgPT4ge1xuICAgICAgICAgICAgZW5hYmxlT3ZlcnJpZGUgPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgICAgIGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwiOlwiIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gICAgICAgIG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuICAgICAgICByZXR1cm4gbmV3RGVidWc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSBcInN0cmluZ1wiID8gbmFtZXNwYWNlcyA6IFwiXCIpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgXCIuKj9cIik7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgXCIkXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKFwiXlwiICsgbmFtZXNwYWNlcyArIFwiJFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICBjb25zdCBuYW1lc3BhY2VzID0gW1xuICAgICAgICAgIC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG4gICAgICAgICAgLi4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAoKG5hbWVzcGFjZSkgPT4gXCItXCIgKyBuYW1lc3BhY2UpXG4gICAgICAgIF0uam9pbihcIixcIik7XG4gICAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZShcIlwiKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZXM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGxlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG4gICAgICAgIHJldHVybiByZWdleHAudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMikucmVwbGFjZSgvXFwuXFwqXFw/JC8sIFwiKlwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKTtcbiAgICAgIH1cbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZURlYnVnO1xuICAgIH1cbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBzZXR1cDtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qc1xudmFyIHJlcXVpcmVfYnJvd3NlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG4gICAgZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbiAgICBleHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbiAgICBleHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuICAgICAgbGV0IHdhcm5lZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkluc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC5cIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBleHBvcnRzLmNvbG9ycyA9IFtcbiAgICAgIFwiIzAwMDBDQ1wiLFxuICAgICAgXCIjMDAwMEZGXCIsXG4gICAgICBcIiMwMDMzQ0NcIixcbiAgICAgIFwiIzAwMzNGRlwiLFxuICAgICAgXCIjMDA2NkNDXCIsXG4gICAgICBcIiMwMDY2RkZcIixcbiAgICAgIFwiIzAwOTlDQ1wiLFxuICAgICAgXCIjMDA5OUZGXCIsXG4gICAgICBcIiMwMENDMDBcIixcbiAgICAgIFwiIzAwQ0MzM1wiLFxuICAgICAgXCIjMDBDQzY2XCIsXG4gICAgICBcIiMwMENDOTlcIixcbiAgICAgIFwiIzAwQ0NDQ1wiLFxuICAgICAgXCIjMDBDQ0ZGXCIsXG4gICAgICBcIiMzMzAwQ0NcIixcbiAgICAgIFwiIzMzMDBGRlwiLFxuICAgICAgXCIjMzMzM0NDXCIsXG4gICAgICBcIiMzMzMzRkZcIixcbiAgICAgIFwiIzMzNjZDQ1wiLFxuICAgICAgXCIjMzM2NkZGXCIsXG4gICAgICBcIiMzMzk5Q0NcIixcbiAgICAgIFwiIzMzOTlGRlwiLFxuICAgICAgXCIjMzNDQzAwXCIsXG4gICAgICBcIiMzM0NDMzNcIixcbiAgICAgIFwiIzMzQ0M2NlwiLFxuICAgICAgXCIjMzNDQzk5XCIsXG4gICAgICBcIiMzM0NDQ0NcIixcbiAgICAgIFwiIzMzQ0NGRlwiLFxuICAgICAgXCIjNjYwMENDXCIsXG4gICAgICBcIiM2NjAwRkZcIixcbiAgICAgIFwiIzY2MzNDQ1wiLFxuICAgICAgXCIjNjYzM0ZGXCIsXG4gICAgICBcIiM2NkNDMDBcIixcbiAgICAgIFwiIzY2Q0MzM1wiLFxuICAgICAgXCIjOTkwMENDXCIsXG4gICAgICBcIiM5OTAwRkZcIixcbiAgICAgIFwiIzk5MzNDQ1wiLFxuICAgICAgXCIjOTkzM0ZGXCIsXG4gICAgICBcIiM5OUNDMDBcIixcbiAgICAgIFwiIzk5Q0MzM1wiLFxuICAgICAgXCIjQ0MwMDAwXCIsXG4gICAgICBcIiNDQzAwMzNcIixcbiAgICAgIFwiI0NDMDA2NlwiLFxuICAgICAgXCIjQ0MwMDk5XCIsXG4gICAgICBcIiNDQzAwQ0NcIixcbiAgICAgIFwiI0NDMDBGRlwiLFxuICAgICAgXCIjQ0MzMzAwXCIsXG4gICAgICBcIiNDQzMzMzNcIixcbiAgICAgIFwiI0NDMzM2NlwiLFxuICAgICAgXCIjQ0MzMzk5XCIsXG4gICAgICBcIiNDQzMzQ0NcIixcbiAgICAgIFwiI0NDMzNGRlwiLFxuICAgICAgXCIjQ0M2NjAwXCIsXG4gICAgICBcIiNDQzY2MzNcIixcbiAgICAgIFwiI0NDOTkwMFwiLFxuICAgICAgXCIjQ0M5OTMzXCIsXG4gICAgICBcIiNDQ0NDMDBcIixcbiAgICAgIFwiI0NDQ0MzM1wiLFxuICAgICAgXCIjRkYwMDAwXCIsXG4gICAgICBcIiNGRjAwMzNcIixcbiAgICAgIFwiI0ZGMDA2NlwiLFxuICAgICAgXCIjRkYwMDk5XCIsXG4gICAgICBcIiNGRjAwQ0NcIixcbiAgICAgIFwiI0ZGMDBGRlwiLFxuICAgICAgXCIjRkYzMzAwXCIsXG4gICAgICBcIiNGRjMzMzNcIixcbiAgICAgIFwiI0ZGMzM2NlwiLFxuICAgICAgXCIjRkYzMzk5XCIsXG4gICAgICBcIiNGRjMzQ0NcIixcbiAgICAgIFwiI0ZGMzNGRlwiLFxuICAgICAgXCIjRkY2NjAwXCIsXG4gICAgICBcIiNGRjY2MzNcIixcbiAgICAgIFwiI0ZGOTkwMFwiLFxuICAgICAgXCIjRkY5OTMzXCIsXG4gICAgICBcIiNGRkNDMDBcIixcbiAgICAgIFwiI0ZGQ0MzM1wiXG4gICAgXTtcbiAgICBmdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gXCJyZW5kZXJlclwiIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gICAgICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gXCIlY1wiIDogXCJcIikgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/IFwiICVjXCIgOiBcIiBcIikgKyBhcmdzWzBdICsgKHRoaXMudXNlQ29sb3JzID8gXCIlYyBcIiA6IFwiIFwiKSArIFwiK1wiICsgbW9kdWxlMi5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG4gICAgICBpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGMgPSBcImNvbG9yOiBcIiArIHRoaXMuY29sb3I7XG4gICAgICBhcmdzLnNwbGljZSgxLCAwLCBjLCBcImNvbG9yOiBpbmhlcml0XCIpO1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIGxldCBsYXN0QyA9IDA7XG4gICAgICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgKG1hdGNoKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gXCIlJVwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gXCIlY1wiKSB7XG4gICAgICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gICAgfVxuICAgIGV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbShcImRlYnVnXCIsIG5hbWVzcGFjZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVidWdcIik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICBsZXQgcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbShcImRlYnVnXCIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcImVudlwiIGluIHByb2Nlc3MpIHtcbiAgICAgICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2NvbW1vbigpKGV4cG9ydHMpO1xuICAgIHZhciB7IGZvcm1hdHRlcnMgfSA9IG1vZHVsZTIuZXhwb3J0cztcbiAgICBmb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gXCJbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogXCIgKyBlcnJvci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanNcbnZhciByZXF1aXJlX2hhc19mbGFnID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IChmbGFnLCBhcmd2KSA9PiB7XG4gICAgICBhcmd2ID0gYXJndiB8fCBwcm9jZXNzLmFyZ3Y7XG4gICAgICBjb25zdCBwcmVmaXggPSBmbGFnLnN0YXJ0c1dpdGgoXCItXCIpID8gXCJcIiA6IGZsYWcubGVuZ3RoID09PSAxID8gXCItXCIgOiBcIi0tXCI7XG4gICAgICBjb25zdCBwb3MgPSBhcmd2LmluZGV4T2YocHJlZml4ICsgZmxhZyk7XG4gICAgICBjb25zdCB0ZXJtaW5hdG9yUG9zID0gYXJndi5pbmRleE9mKFwiLS1cIik7XG4gICAgICByZXR1cm4gcG9zICE9PSAtMSAmJiAodGVybWluYXRvclBvcyA9PT0gLTEgPyB0cnVlIDogcG9zIDwgdGVybWluYXRvclBvcyk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qc1xudmFyIHJlcXVpcmVfc3VwcG9ydHNfY29sb3IgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG9zMiA9IHJlcXVpcmUoXCJvc1wiKTtcbiAgICB2YXIgaGFzRmxhZyA9IHJlcXVpcmVfaGFzX2ZsYWcoKTtcbiAgICB2YXIgZW52MyA9IHByb2Nlc3MuZW52O1xuICAgIHZhciBmb3JjZUNvbG9yO1xuICAgIGlmIChoYXNGbGFnKFwibm8tY29sb3JcIikgfHwgaGFzRmxhZyhcIm5vLWNvbG9yc1wiKSB8fCBoYXNGbGFnKFwiY29sb3I9ZmFsc2VcIikpIHtcbiAgICAgIGZvcmNlQ29sb3IgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGhhc0ZsYWcoXCJjb2xvclwiKSB8fCBoYXNGbGFnKFwiY29sb3JzXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj10cnVlXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj1hbHdheXNcIikpIHtcbiAgICAgIGZvcmNlQ29sb3IgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoXCJGT1JDRV9DT0xPUlwiIGluIGVudjMpIHtcbiAgICAgIGZvcmNlQ29sb3IgPSBlbnYzLkZPUkNFX0NPTE9SLmxlbmd0aCA9PT0gMCB8fCBwYXJzZUludChlbnYzLkZPUkNFX0NPTE9SLCAxMCkgIT09IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZUxldmVsKGxldmVsKSB7XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIGhhc0Jhc2ljOiB0cnVlLFxuICAgICAgICBoYXMyNTY6IGxldmVsID49IDIsXG4gICAgICAgIGhhczE2bTogbGV2ZWwgPj0gM1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VwcG9ydHNDb2xvcihzdHJlYW0pIHtcbiAgICAgIGlmIChmb3JjZUNvbG9yID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNGbGFnKFwiY29sb3I9MTZtXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj1mdWxsXCIpIHx8IGhhc0ZsYWcoXCJjb2xvcj10cnVlY29sb3JcIikpIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgICB9XG4gICAgICBpZiAoaGFzRmxhZyhcImNvbG9yPTI1NlwiKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0gJiYgIXN0cmVhbS5pc1RUWSAmJiBmb3JjZUNvbG9yICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgY29uc3QgbWluID0gZm9yY2VDb2xvciA/IDEgOiAwO1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICBjb25zdCBvc1JlbGVhc2UgPSBvczIucmVsZWFzZSgpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKE51bWJlcihwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoXCIuXCIpWzBdKSA+PSA4ICYmIE51bWJlcihvc1JlbGVhc2VbMF0pID49IDEwICYmIE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2KSB7XG4gICAgICAgICAgcmV0dXJuIE51bWJlcihvc1JlbGVhc2VbMl0pID49IDE0OTMxID8gMyA6IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAoXCJDSVwiIGluIGVudjMpIHtcbiAgICAgICAgaWYgKFtcIlRSQVZJU1wiLCBcIkNJUkNMRUNJXCIsIFwiQVBQVkVZT1JcIiwgXCJHSVRMQUJfQ0lcIl0uc29tZSgoc2lnbikgPT4gc2lnbiBpbiBlbnYzKSB8fCBlbnYzLkNJX05BTUUgPT09IFwiY29kZXNoaXBcIikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgICB9XG4gICAgICBpZiAoXCJURUFNQ0lUWV9WRVJTSU9OXCIgaW4gZW52Mykge1xuICAgICAgICByZXR1cm4gL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoZW52My5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGVudjMuQ09MT1JURVJNID09PSBcInRydWVjb2xvclwiKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgICAgfVxuICAgICAgaWYgKFwiVEVSTV9QUk9HUkFNXCIgaW4gZW52Mykge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoKGVudjMuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgXCJcIikuc3BsaXQoXCIuXCIpWzBdLCAxMCk7XG4gICAgICAgIHN3aXRjaCAoZW52My5URVJNX1BST0dSQU0pIHtcbiAgICAgICAgICBjYXNlIFwiaVRlcm0uYXBwXCI6XG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSAzID8gMyA6IDI7XG4gICAgICAgICAgY2FzZSBcIkFwcGxlX1Rlcm1pbmFsXCI6XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKC8tMjU2KGNvbG9yKT8kL2kudGVzdChlbnYzLlRFUk0pKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfVxuICAgICAgaWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYzLlRFUk0pKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKFwiQ09MT1JURVJNXCIgaW4gZW52Mykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChlbnYzLlRFUk0gPT09IFwiZHVtYlwiKSB7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0TGV2ZWwoc3RyZWFtKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHN1cHBvcnRzQ29sb3Ioc3RyZWFtKTtcbiAgICAgIHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG4gICAgfVxuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHtcbiAgICAgIHN1cHBvcnRzQ29sb3I6IGdldFN1cHBvcnRMZXZlbCxcbiAgICAgIHN0ZG91dDogZ2V0U3VwcG9ydExldmVsKHByb2Nlc3Muc3Rkb3V0KSxcbiAgICAgIHN0ZGVycjogZ2V0U3VwcG9ydExldmVsKHByb2Nlc3Muc3RkZXJyKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanNcbnZhciByZXF1aXJlX25vZGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanNcIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoXCJ0dHlcIik7XG4gICAgdmFyIHV0aWwyID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgZXhwb3J0cy5pbml0ID0gaW5pdDtcbiAgICBleHBvcnRzLmxvZyA9IGxvZztcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG4gICAgZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbiAgICBleHBvcnRzLmRlc3Ryb3kgPSB1dGlsMi5kZXByZWNhdGUoXG4gICAgICAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgXCJJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuXCJcbiAgICApO1xuICAgIGV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZV9zdXBwb3J0c19jb2xvcigpO1xuICAgICAgaWYgKHN1cHBvcnRzQ29sb3IgJiYgKHN1cHBvcnRzQ29sb3Iuc3RkZXJyIHx8IHN1cHBvcnRzQ29sb3IpLmxldmVsID49IDIpIHtcbiAgICAgICAgZXhwb3J0cy5jb2xvcnMgPSBbXG4gICAgICAgICAgMjAsXG4gICAgICAgICAgMjEsXG4gICAgICAgICAgMjYsXG4gICAgICAgICAgMjcsXG4gICAgICAgICAgMzIsXG4gICAgICAgICAgMzMsXG4gICAgICAgICAgMzgsXG4gICAgICAgICAgMzksXG4gICAgICAgICAgNDAsXG4gICAgICAgICAgNDEsXG4gICAgICAgICAgNDIsXG4gICAgICAgICAgNDMsXG4gICAgICAgICAgNDQsXG4gICAgICAgICAgNDUsXG4gICAgICAgICAgNTYsXG4gICAgICAgICAgNTcsXG4gICAgICAgICAgNjIsXG4gICAgICAgICAgNjMsXG4gICAgICAgICAgNjgsXG4gICAgICAgICAgNjksXG4gICAgICAgICAgNzQsXG4gICAgICAgICAgNzUsXG4gICAgICAgICAgNzYsXG4gICAgICAgICAgNzcsXG4gICAgICAgICAgNzgsXG4gICAgICAgICAgNzksXG4gICAgICAgICAgODAsXG4gICAgICAgICAgODEsXG4gICAgICAgICAgOTIsXG4gICAgICAgICAgOTMsXG4gICAgICAgICAgOTgsXG4gICAgICAgICAgOTksXG4gICAgICAgICAgMTEyLFxuICAgICAgICAgIDExMyxcbiAgICAgICAgICAxMjgsXG4gICAgICAgICAgMTI5LFxuICAgICAgICAgIDEzNCxcbiAgICAgICAgICAxMzUsXG4gICAgICAgICAgMTQ4LFxuICAgICAgICAgIDE0OSxcbiAgICAgICAgICAxNjAsXG4gICAgICAgICAgMTYxLFxuICAgICAgICAgIDE2MixcbiAgICAgICAgICAxNjMsXG4gICAgICAgICAgMTY0LFxuICAgICAgICAgIDE2NSxcbiAgICAgICAgICAxNjYsXG4gICAgICAgICAgMTY3LFxuICAgICAgICAgIDE2OCxcbiAgICAgICAgICAxNjksXG4gICAgICAgICAgMTcwLFxuICAgICAgICAgIDE3MSxcbiAgICAgICAgICAxNzIsXG4gICAgICAgICAgMTczLFxuICAgICAgICAgIDE3OCxcbiAgICAgICAgICAxNzksXG4gICAgICAgICAgMTg0LFxuICAgICAgICAgIDE4NSxcbiAgICAgICAgICAxOTYsXG4gICAgICAgICAgMTk3LFxuICAgICAgICAgIDE5OCxcbiAgICAgICAgICAxOTksXG4gICAgICAgICAgMjAwLFxuICAgICAgICAgIDIwMSxcbiAgICAgICAgICAyMDIsXG4gICAgICAgICAgMjAzLFxuICAgICAgICAgIDIwNCxcbiAgICAgICAgICAyMDUsXG4gICAgICAgICAgMjA2LFxuICAgICAgICAgIDIwNyxcbiAgICAgICAgICAyMDgsXG4gICAgICAgICAgMjA5LFxuICAgICAgICAgIDIxNCxcbiAgICAgICAgICAyMTUsXG4gICAgICAgICAgMjIwLFxuICAgICAgICAgIDIyMVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICAgIGV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgIHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbiAgICB9KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICBjb25zdCBwcm9wID0ga2V5LnN1YnN0cmluZyg2KS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18oW2Etel0pL2csIChfLCBrKSA9PiB7XG4gICAgICAgIHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICAgIGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuICAgICAgaWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuICAgICAgICB2YWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuICAgICAgICB2YWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsID09PSBcIm51bGxcIikge1xuICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICB9XG4gICAgICBvYmpbcHJvcF0gPSB2YWw7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBmdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gICAgICByZXR1cm4gXCJjb2xvcnNcIiBpbiBleHBvcnRzLmluc3BlY3RPcHRzID8gQm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOiB0dHkuaXNhdHR5KHByb2Nlc3Muc3RkZXJyLmZkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gICAgICBjb25zdCB7IG5hbWVzcGFjZTogbmFtZSwgdXNlQ29sb3JzOiB1c2VDb2xvcnMyIH0gPSB0aGlzO1xuICAgICAgaWYgKHVzZUNvbG9yczIpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuY29sb3I7XG4gICAgICAgIGNvbnN0IGNvbG9yQ29kZSA9IFwiXFx4MUJbM1wiICsgKGMgPCA4ID8gYyA6IFwiODs1O1wiICsgYyk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGAgICR7Y29sb3JDb2RlfTsxbSR7bmFtZX0gXFx4MUJbMG1gO1xuICAgICAgICBhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdChcIlxcblwiKS5qb2luKFwiXFxuXCIgKyBwcmVmaXgpO1xuICAgICAgICBhcmdzLnB1c2goY29sb3JDb2RlICsgXCJtK1wiICsgbW9kdWxlMi5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyBcIlxceDFCWzBtXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyBcIiBcIiArIGFyZ3NbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICBpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnRvSVNPU3RyaW5nKCkgKyBcIiBcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsMi5mb3JtYXQoLi4uYXJncykgKyBcIlxcblwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gICAgICBpZiAobmFtZXNwYWNlcykge1xuICAgICAgICBwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXQoZGVidWcpIHtcbiAgICAgIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2NvbW1vbigpKGV4cG9ydHMpO1xuICAgIHZhciB7IGZvcm1hdHRlcnMgfSA9IG1vZHVsZTIuZXhwb3J0cztcbiAgICBmb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICAgICAgcmV0dXJuIHV0aWwyLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cykuc3BsaXQoXCJcXG5cIikubWFwKChzdHIpID0+IHN0ci50cmltKCkpLmpvaW4oXCIgXCIpO1xuICAgIH07XG4gICAgZm9ybWF0dGVycy5PID0gZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgICAgIHJldHVybiB1dGlsMi5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zcmM1ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG4gICAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2Jyb3dzZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9ub2RlKCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21vZHVsZS1kZXRhaWxzLWZyb20tcGF0aC9pbmRleC5qc1xudmFyIHJlcXVpcmVfbW9kdWxlX2RldGFpbHNfZnJvbV9wYXRoID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21vZHVsZS1kZXRhaWxzLWZyb20tcGF0aC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcGF0aDMgPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBmaWxlLnNwbGl0KHBhdGgzLnNlcCk7XG4gICAgICB2YXIgaW5kZXggPSBzZWdtZW50cy5sYXN0SW5kZXhPZihcIm5vZGVfbW9kdWxlc1wiKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghc2VnbWVudHNbaW5kZXggKyAxXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIHNjb3BlZCA9IHNlZ21lbnRzW2luZGV4ICsgMV1bMF0gPT09IFwiQFwiO1xuICAgICAgdmFyIG5hbWUgPSBzY29wZWQgPyBzZWdtZW50c1tpbmRleCArIDFdICsgXCIvXCIgKyBzZWdtZW50c1tpbmRleCArIDJdIDogc2VnbWVudHNbaW5kZXggKyAxXTtcbiAgICAgIHZhciBvZmZzZXQgPSBzY29wZWQgPyAzIDogMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGJhc2VkaXI6IHNlZ21lbnRzLnNsaWNlKDAsIGluZGV4ICsgb2Zmc2V0KS5qb2luKHBhdGgzLnNlcCksXG4gICAgICAgIHBhdGg6IHNlZ21lbnRzLnNsaWNlKGluZGV4ICsgb2Zmc2V0KS5qb2luKHBhdGgzLnNlcClcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9yZXF1aXJlLWluLXRoZS1taWRkbGUvcGFja2FnZS5qc29uXG52YXIgcmVxdWlyZV9wYWNrYWdlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3JlcXVpcmUtaW4tdGhlLW1pZGRsZS9wYWNrYWdlLmpzb25cIihleHBvcnRzLCBtb2R1bGUyKSB7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge1xuICAgICAgbmFtZTogXCJyZXF1aXJlLWluLXRoZS1taWRkbGVcIixcbiAgICAgIHZlcnNpb246IFwiNy4yLjBcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk1vZHVsZSB0byBob29rIGludG8gdGhlIE5vZGUuanMgcmVxdWlyZSBmdW5jdGlvblwiLFxuICAgICAgbWFpbjogXCJpbmRleC5qc1wiLFxuICAgICAgdHlwZXM6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICAgICAgZGVwZW5kZW5jaWVzOiB7XG4gICAgICAgIGRlYnVnOiBcIl40LjEuMVwiLFxuICAgICAgICBcIm1vZHVsZS1kZXRhaWxzLWZyb20tcGF0aFwiOiBcIl4xLjAuM1wiLFxuICAgICAgICByZXNvbHZlOiBcIl4xLjIyLjFcIlxuICAgICAgfSxcbiAgICAgIGRldkRlcGVuZGVuY2llczoge1xuICAgICAgICBcIkBiYWJlbC9jb3JlXCI6IFwiXjcuOS4wXCIsXG4gICAgICAgIFwiQGJhYmVsL3ByZXNldC1lbnZcIjogXCJeNy45LjVcIixcbiAgICAgICAgXCJAYmFiZWwvcHJlc2V0LXR5cGVzY3JpcHRcIjogXCJeNy45LjBcIixcbiAgICAgICAgXCJAYmFiZWwvcmVnaXN0ZXJcIjogXCJeNy45LjBcIixcbiAgICAgICAgXCJpcHAtcHJpbnRlclwiOiBcIl4xLjAuMFwiLFxuICAgICAgICBwYXR0ZXJuczogXCJeMS4wLjNcIixcbiAgICAgICAgcm91bmRyb3VuZDogXCJeMC4yLjBcIixcbiAgICAgICAgc2VtdmVyOiBcIl42LjMuMFwiLFxuICAgICAgICBzdGFuZGFyZDogXCJeMTQuMy4xXCIsXG4gICAgICAgIHRhcGU6IFwiXjQuMTEuMFwiXG4gICAgICB9LFxuICAgICAgc2NyaXB0czoge1xuICAgICAgICB0ZXN0OiBcIm5wbSBydW4gdGVzdDpsaW50ICYmIG5wbSBydW4gdGVzdDp0YXBlICYmIG5wbSBydW4gdGVzdDpiYWJlbFwiLFxuICAgICAgICBcInRlc3Q6bGludFwiOiBcInN0YW5kYXJkXCIsXG4gICAgICAgIFwidGVzdDp0YXBlXCI6IFwidGFwZSB0ZXN0LyouanNcIixcbiAgICAgICAgXCJ0ZXN0OmJhYmVsXCI6IFwibm9kZSB0ZXN0L2JhYmVsL2JhYmVsLXJlZ2lzdGVyLmpzXCJcbiAgICAgIH0sXG4gICAgICByZXBvc2l0b3J5OiB7XG4gICAgICAgIHR5cGU6IFwiZ2l0XCIsXG4gICAgICAgIHVybDogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2VsYXN0aWMvcmVxdWlyZS1pbi10aGUtbWlkZGxlLmdpdFwiXG4gICAgICB9LFxuICAgICAga2V5d29yZHM6IFtcbiAgICAgICAgXCJyZXF1aXJlXCIsXG4gICAgICAgIFwiaG9va1wiLFxuICAgICAgICBcInNoaW1cIixcbiAgICAgICAgXCJzaGltbWVyXCIsXG4gICAgICAgIFwic2hpbW1pbmdcIixcbiAgICAgICAgXCJwYXRjaFwiLFxuICAgICAgICBcIm1vbmtleVwiLFxuICAgICAgICBcIm1vbmtleXBhdGNoXCIsXG4gICAgICAgIFwibW9kdWxlXCIsXG4gICAgICAgIFwibG9hZFwiXG4gICAgICBdLFxuICAgICAgZmlsZXM6IFtcbiAgICAgICAgXCJ0eXBlc1wiXG4gICAgICBdLFxuICAgICAgYXV0aG9yOiBcIlRob21hcyBXYXRzb24gU3RlZW4gPHdAdHNvbi5kaz4gKGh0dHBzOi8vdHdpdHRlci5jb20vd2E3c29uKVwiLFxuICAgICAgbGljZW5zZTogXCJNSVRcIixcbiAgICAgIGJ1Z3M6IHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lbGFzdGljL3JlcXVpcmUtaW4tdGhlLW1pZGRsZS9pc3N1ZXNcIlxuICAgICAgfSxcbiAgICAgIGhvbWVwYWdlOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9lbGFzdGljL3JlcXVpcmUtaW4tdGhlLW1pZGRsZSNyZWFkbWVcIixcbiAgICAgIGVuZ2luZXM6IHtcbiAgICAgICAgbm9kZTogXCI+PTguNi4wXCJcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3JlcXVpcmUtaW4tdGhlLW1pZGRsZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfcmVxdWlyZV9pbl90aGVfbWlkZGxlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3JlcXVpcmUtaW4tdGhlLW1pZGRsZS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcGF0aDMgPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICB2YXIgTW9kdWxlID0gcmVxdWlyZShcIm1vZHVsZVwiKTtcbiAgICB2YXIgcmVzb2x2ZSA9IHJlcXVpcmVfcmVzb2x2ZSgpO1xuICAgIHZhciBkZWJ1ZyA9IHJlcXVpcmVfc3JjNSgpKFwicmVxdWlyZS1pbi10aGUtbWlkZGxlXCIpO1xuICAgIHZhciBtb2R1bGVEZXRhaWxzRnJvbVBhdGggPSByZXF1aXJlX21vZHVsZV9kZXRhaWxzX2Zyb21fcGF0aCgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IEhvb2szO1xuICAgIG1vZHVsZTIuZXhwb3J0cy5Ib29rID0gSG9vazM7XG4gICAgdmFyIGlzQ29yZTtcbiAgICBpZiAoTW9kdWxlLmlzQnVpbHRpbikge1xuICAgICAgaXNDb3JlID0gTW9kdWxlLmlzQnVpbHRpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ham9yMiwgbWlub3JdID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICAgIGlmIChtYWpvcjIgPT09IDggJiYgbWlub3IgPCA4KSB7XG4gICAgICAgIGlzQ29yZSA9IChtb2R1bGVOYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKG1vZHVsZU5hbWUgPT09IFwiaHR0cDJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhIXJlc29sdmUuY29yZVttb2R1bGVOYW1lXTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQ29yZSA9IChtb2R1bGVOYW1lKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICEhcmVzb2x2ZS5jb3JlW21vZHVsZU5hbWVdO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplMyA9IC8oWy9cXFxcXWluZGV4KT8oXFwuanMpPyQvO1xuICAgIHZhciBFeHBvcnRzQ2FjaGUgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2tSaXRtRXhwb3J0cyA9IFN5bWJvbChcIlJpdG1FeHBvcnRzXCIpO1xuICAgICAgfVxuICAgICAgaGFzKGZpbGVuYW1lLCBpc0J1aWx0aW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsQ2FjaGUuaGFzKGZpbGVuYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0J1aWx0aW4pIHtcbiAgICAgICAgICBjb25zdCBtb2QgPSByZXF1aXJlLmNhY2hlW2ZpbGVuYW1lXTtcbiAgICAgICAgICByZXR1cm4gISEobW9kICYmIHRoaXMuX2tSaXRtRXhwb3J0cyBpbiBtb2QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0KGZpbGVuYW1lLCBpc0J1aWx0aW4pIHtcbiAgICAgICAgY29uc3QgY2FjaGVkRXhwb3J0cyA9IHRoaXMuX2xvY2FsQ2FjaGUuZ2V0KGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGNhY2hlZEV4cG9ydHMgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBjYWNoZWRFeHBvcnRzO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0J1aWx0aW4pIHtcbiAgICAgICAgICBjb25zdCBtb2QgPSByZXF1aXJlLmNhY2hlW2ZpbGVuYW1lXTtcbiAgICAgICAgICByZXR1cm4gbW9kICYmIG1vZFt0aGlzLl9rUml0bUV4cG9ydHNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXQoZmlsZW5hbWUsIGV4cG9ydHMyLCBpc0J1aWx0aW4pIHtcbiAgICAgICAgaWYgKGlzQnVpbHRpbikge1xuICAgICAgICAgIHRoaXMuX2xvY2FsQ2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzMik7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUgaW4gcmVxdWlyZS5jYWNoZSkge1xuICAgICAgICAgIHJlcXVpcmUuY2FjaGVbZmlsZW5hbWVdW3RoaXMuX2tSaXRtRXhwb3J0c10gPSBleHBvcnRzMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1Zygnbm9uLWNvcmUgbW9kdWxlIGlzIHVuZXhwZWN0ZWRseSBub3QgaW4gcmVxdWlyZS5jYWNoZTogXCIlc1wiJywgZmlsZW5hbWUpO1xuICAgICAgICAgIHRoaXMuX2xvY2FsQ2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIEhvb2szKG1vZHVsZXMsIG9wdGlvbnMsIG9ucmVxdWlyZSkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBIb29rMyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBuZXcgSG9vazMobW9kdWxlcywgb3B0aW9ucywgb25yZXF1aXJlKTtcbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9ucmVxdWlyZSA9IG1vZHVsZXM7XG4gICAgICAgIG1vZHVsZXMgPSBudWxsO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvbnJlcXVpcmUgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgTW9kdWxlLl9yZXNvbHZlRmlsZW5hbWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IEV4cGVjdGVkIE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lIHRvIGJlIGEgZnVuY3Rpb24gKHdhczogJXMpIC0gYWJvcnRpbmchXCIsIHR5cGVvZiBNb2R1bGUuX3Jlc29sdmVGaWxlbmFtZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IgYXMgYW4gaXNzdWUgcmVsYXRlZCB0byBOb2RlLmpzICVzIGF0ICVzXCIsIHByb2Nlc3MudmVyc2lvbiwgcmVxdWlyZV9wYWNrYWdlKCkuYnVncy51cmwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZSA9IG5ldyBFeHBvcnRzQ2FjaGUoKTtcbiAgICAgIHRoaXMuX3VuaG9va2VkID0gZmFsc2U7XG4gICAgICB0aGlzLl9vcmlnUmVxdWlyZSA9IE1vZHVsZS5wcm90b3R5cGUucmVxdWlyZTtcbiAgICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICAgIGNvbnN0IHBhdGNoaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IGludGVybmFscyA9IG9wdGlvbnMgPyBvcHRpb25zLmludGVybmFscyA9PT0gdHJ1ZSA6IGZhbHNlO1xuICAgICAgY29uc3QgaGFzV2hpdGVsaXN0ID0gQXJyYXkuaXNBcnJheShtb2R1bGVzKTtcbiAgICAgIGRlYnVnKFwicmVnaXN0ZXJpbmcgcmVxdWlyZSBob29rXCIpO1xuICAgICAgdGhpcy5fcmVxdWlyZSA9IE1vZHVsZS5wcm90b3R5cGUucmVxdWlyZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChzZWxmMi5fdW5ob29rZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBkZWJ1ZyhcImlnbm9yaW5nIHJlcXVpcmUgY2FsbCAtIG1vZHVsZSBpcyBzb2Z0LXVuaG9va2VkXCIpO1xuICAgICAgICAgIHJldHVybiBzZWxmMi5fb3JpZ1JlcXVpcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3JlID0gaXNDb3JlKGlkKTtcbiAgICAgICAgbGV0IGZpbGVuYW1lO1xuICAgICAgICBpZiAoY29yZSkge1xuICAgICAgICAgIGZpbGVuYW1lID0gaWQ7XG4gICAgICAgICAgaWYgKGlkLnN0YXJ0c1dpdGgoXCJub2RlOlwiKSkge1xuICAgICAgICAgICAgY29uc3QgaWRXaXRob3V0UHJlZml4ID0gaWQuc2xpY2UoNSk7XG4gICAgICAgICAgICBpZiAoaXNDb3JlKGlkV2l0aG91dFByZWZpeCkpIHtcbiAgICAgICAgICAgICAgZmlsZW5hbWUgPSBpZFdpdGhvdXRQcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IE1vZHVsZS5fcmVzb2x2ZUZpbGVuYW1lKGlkLCB0aGlzKTtcbiAgICAgICAgICB9IGNhdGNoIChyZXNvbHZlRXJyKSB7XG4gICAgICAgICAgICBkZWJ1ZygnTW9kdWxlLl9yZXNvbHZlRmlsZW5hbWUoXCIlc1wiKSB0aHJldyAlaiwgY2FsbGluZyBvcmlnaW5hbCBNb2R1bGUucmVxdWlyZScsIGlkLCByZXNvbHZlRXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYyLl9vcmlnUmVxdWlyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kdWxlTmFtZSwgYmFzZWRpcjtcbiAgICAgICAgZGVidWcoXCJwcm9jZXNzaW5nICVzIG1vZHVsZSByZXF1aXJlKCclcycpOiAlc1wiLCBjb3JlID09PSB0cnVlID8gXCJjb3JlXCIgOiBcIm5vbi1jb3JlXCIsIGlkLCBmaWxlbmFtZSk7XG4gICAgICAgIGlmIChzZWxmMi5fY2FjaGUuaGFzKGZpbGVuYW1lLCBjb3JlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRlYnVnKFwicmV0dXJuaW5nIGFscmVhZHkgcGF0Y2hlZCBjYWNoZWQgbW9kdWxlOiAlc1wiLCBmaWxlbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIHNlbGYyLl9jYWNoZS5nZXQoZmlsZW5hbWUsIGNvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUGF0Y2hpbmcgPSBwYXRjaGluZy5oYXMoZmlsZW5hbWUpO1xuICAgICAgICBpZiAoaXNQYXRjaGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBwYXRjaGluZy5hZGQoZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9ydHMyID0gc2VsZjIuX29yaWdSZXF1aXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc1BhdGNoaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgZGVidWcoXCJtb2R1bGUgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgcGF0Y2hlZCBhbHJlYWR5IC0gaWdub3Jpbmc6ICVzXCIsIGZpbGVuYW1lKTtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0czI7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2hpbmcuZGVsZXRlKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGNvcmUgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoaGFzV2hpdGVsaXN0ID09PSB0cnVlICYmIG1vZHVsZXMuaW5jbHVkZXMoZmlsZW5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVidWcoXCJpZ25vcmluZyBjb3JlIG1vZHVsZSBub3Qgb24gd2hpdGVsaXN0OiAlc1wiLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0czI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZHVsZU5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNXaGl0ZWxpc3QgPT09IHRydWUgJiYgbW9kdWxlcy5pbmNsdWRlcyhmaWxlbmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRQYXRoID0gcGF0aDMucGFyc2UoZmlsZW5hbWUpO1xuICAgICAgICAgIG1vZHVsZU5hbWUgPSBwYXJzZWRQYXRoLm5hbWU7XG4gICAgICAgICAgYmFzZWRpciA9IHBhcnNlZFBhdGguZGlyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0YXQgPSBtb2R1bGVEZXRhaWxzRnJvbVBhdGgoZmlsZW5hbWUpO1xuICAgICAgICAgIGlmIChzdGF0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY291bGQgbm90IHBhcnNlIGZpbGVuYW1lOiAlc1wiLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0czI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZHVsZU5hbWUgPSBzdGF0Lm5hbWU7XG4gICAgICAgICAgYmFzZWRpciA9IHN0YXQuYmFzZWRpcjtcbiAgICAgICAgICBjb25zdCBmdWxsTW9kdWxlTmFtZSA9IHJlc29sdmVNb2R1bGVOYW1lKHN0YXQpO1xuICAgICAgICAgIGRlYnVnKFwicmVzb2x2ZWQgZmlsZW5hbWUgdG8gbW9kdWxlOiAlcyAoaWQ6ICVzLCByZXNvbHZlZDogJXMsIGJhc2VkaXI6ICVzKVwiLCBtb2R1bGVOYW1lLCBpZCwgZnVsbE1vZHVsZU5hbWUsIGJhc2VkaXIpO1xuICAgICAgICAgIGlmIChoYXNXaGl0ZWxpc3QgPT09IHRydWUgJiYgbW9kdWxlcy5pbmNsdWRlcyhtb2R1bGVOYW1lKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGVzLmluY2x1ZGVzKGZ1bGxNb2R1bGVOYW1lKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgIHJldHVybiBleHBvcnRzMjtcbiAgICAgICAgICAgIG1vZHVsZU5hbWUgPSBmdWxsTW9kdWxlTmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlcyA9IHJlc29sdmUuc3luYyhtb2R1bGVOYW1lLCB7IGJhc2VkaXIgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGRlYnVnKFwiY291bGQgbm90IHJlc29sdmUgbW9kdWxlOiAlc1wiLCBtb2R1bGVOYW1lKTtcbiAgICAgICAgICAgICAgc2VsZjIuX2NhY2hlLnNldChmaWxlbmFtZSwgZXhwb3J0czIsIGNvcmUpO1xuICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0czI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzICE9PSBmaWxlbmFtZSkge1xuICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZSA9IG1vZHVsZU5hbWUgKyBwYXRoMy5zZXAgKyBwYXRoMy5yZWxhdGl2ZShiYXNlZGlyLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJwcmVwYXJpbmcgdG8gcHJvY2VzcyByZXF1aXJlIG9mIGludGVybmFsIGZpbGU6ICVzXCIsIG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiaWdub3JpbmcgcmVxdWlyZSBvZiBub24tbWFpbiBtb2R1bGUgZmlsZTogJXNcIiwgcmVzKTtcbiAgICAgICAgICAgICAgICBzZWxmMi5fY2FjaGUuc2V0KGZpbGVuYW1lLCBleHBvcnRzMiwgY29yZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYyLl9jYWNoZS5zZXQoZmlsZW5hbWUsIGV4cG9ydHMyLCBjb3JlKTtcbiAgICAgICAgZGVidWcoXCJjYWxsaW5nIHJlcXVpcmUgaG9vazogJXNcIiwgbW9kdWxlTmFtZSk7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRFeHBvcnRzID0gb25yZXF1aXJlKGV4cG9ydHMyLCBtb2R1bGVOYW1lLCBiYXNlZGlyKTtcbiAgICAgICAgc2VsZjIuX2NhY2hlLnNldChmaWxlbmFtZSwgcGF0Y2hlZEV4cG9ydHMsIGNvcmUpO1xuICAgICAgICBkZWJ1ZyhcInJldHVybmluZyBtb2R1bGU6ICVzXCIsIG1vZHVsZU5hbWUpO1xuICAgICAgICByZXR1cm4gcGF0Y2hlZEV4cG9ydHM7XG4gICAgICB9O1xuICAgIH1cbiAgICBIb29rMy5wcm90b3R5cGUudW5ob29rID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl91bmhvb2tlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5fcmVxdWlyZSA9PT0gTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlKSB7XG4gICAgICAgIE1vZHVsZS5wcm90b3R5cGUucmVxdWlyZSA9IHRoaXMuX29yaWdSZXF1aXJlO1xuICAgICAgICBkZWJ1ZyhcInVuaG9vayBzdWNjZXNzZnVsXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoXCJ1bmhvb2sgdW5zdWNjZXNzZnVsXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZU5hbWUoc3RhdCkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBwYXRoMy5zZXAgIT09IFwiL1wiID8gc3RhdC5wYXRoLnNwbGl0KHBhdGgzLnNlcCkuam9pbihcIi9cIikgOiBzdGF0LnBhdGg7XG4gICAgICByZXR1cm4gcGF0aDMucG9zaXguam9pbihzdGF0Lm5hbWUsIG5vcm1hbGl6ZWRQYXRoKS5yZXBsYWNlKG5vcm1hbGl6ZTMsIFwiXCIpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9pbXBvcnQtaW4tdGhlLW1pZGRsZS9saWIvcmVnaXN0ZXIuanNcbnZhciByZXF1aXJlX3JlZ2lzdGVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2ltcG9ydC1pbi10aGUtbWlkZGxlL2xpYi9yZWdpc3Rlci5qc1wiKGV4cG9ydHMpIHtcbiAgICB2YXIgaW1wb3J0SG9va3MgPSBbXTtcbiAgICB2YXIgc2V0dGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBzcGVjaWZpZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB2YXIgdG9Ib29rID0gW107XG4gICAgdmFyIHByb3h5SGFuZGxlciA9IHtcbiAgICAgIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzZXR0ZXJzLmdldCh0YXJnZXQpW25hbWVdKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmICghKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdldHRlcnMvc2V0dGVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgZXhwb3J0cyBwcm9wZXJ0eSBkZXNjcmlwdG9ycy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRlcnMuZ2V0KHRhcmdldClbcHJvcGVydHldKGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXIobmFtZSwgbmFtZXNwYWNlLCBzZXQsIHNwZWNpZmllcikge1xuICAgICAgc3BlY2lmaWVycy5zZXQobmFtZSwgc3BlY2lmaWVyKTtcbiAgICAgIHNldHRlcnMuc2V0KG5hbWVzcGFjZSwgc2V0KTtcbiAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KG5hbWVzcGFjZSwgcHJveHlIYW5kbGVyKTtcbiAgICAgIGltcG9ydEhvb2tzLmZvckVhY2goKGhvb2spID0+IGhvb2sobmFtZSwgcHJveHkpKTtcbiAgICAgIHRvSG9vay5wdXNoKFtuYW1lLCBwcm94eV0pO1xuICAgIH1cbiAgICBleHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG4gICAgZXhwb3J0cy5pbXBvcnRIb29rcyA9IGltcG9ydEhvb2tzO1xuICAgIGV4cG9ydHMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XG4gICAgZXhwb3J0cy50b0hvb2sgPSB0b0hvb2s7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvaW1wb3J0LWluLXRoZS1taWRkbGUvaW5kZXguanNcbnZhciByZXF1aXJlX2ltcG9ydF9pbl90aGVfbWlkZGxlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2ltcG9ydC1pbi10aGUtbWlkZGxlL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlMikge1xuICAgIHZhciBwYXRoMyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHZhciBwYXJzZTQgPSByZXF1aXJlX21vZHVsZV9kZXRhaWxzX2Zyb21fcGF0aCgpO1xuICAgIHZhciB7IGZpbGVVUkxUb1BhdGggfSA9IHJlcXVpcmUoXCJ1cmxcIik7XG4gICAgdmFyIHtcbiAgICAgIGltcG9ydEhvb2tzLFxuICAgICAgc3BlY2lmaWVycyxcbiAgICAgIHRvSG9va1xuICAgIH0gPSByZXF1aXJlX3JlZ2lzdGVyKCk7XG4gICAgZnVuY3Rpb24gYWRkSG9vayhob29rKSB7XG4gICAgICBpbXBvcnRIb29rcy5wdXNoKGhvb2spO1xuICAgICAgdG9Ib29rLmZvckVhY2goKFtuYW1lLCBuYW1lc3BhY2VdKSA9PiBob29rKG5hbWUsIG5hbWVzcGFjZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVIb29rKGhvb2spIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaW1wb3J0SG9va3MuaW5kZXhPZihob29rKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGltcG9ydEhvb2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxIb29rRm4oaG9va0ZuLCBuYW1lc3BhY2UsIG5hbWUsIGJhc2VEaXIpIHtcbiAgICAgIGNvbnN0IG5ld0RlZmF1bHQgPSBob29rRm4obmFtZXNwYWNlLCBuYW1lLCBiYXNlRGlyKTtcbiAgICAgIGlmIChuZXdEZWZhdWx0ICYmIG5ld0RlZmF1bHQgIT09IG5hbWVzcGFjZSkge1xuICAgICAgICBuYW1lc3BhY2UuZGVmYXVsdCA9IG5ld0RlZmF1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEhvb2szKG1vZHVsZXMsIG9wdGlvbnMsIGhvb2tGbikge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBIb29rMyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBuZXcgSG9vazMobW9kdWxlcywgb3B0aW9ucywgaG9va0ZuKTtcbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGhvb2tGbiA9IG1vZHVsZXM7XG4gICAgICAgIG1vZHVsZXMgPSBudWxsO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBob29rRm4gPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGludGVybmFscyA9IG9wdGlvbnMgPyBvcHRpb25zLmludGVybmFscyA9PT0gdHJ1ZSA6IGZhbHNlO1xuICAgICAgdGhpcy5faWl0bUhvb2sgPSAobmFtZSwgbmFtZXNwYWNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gbmFtZTtcbiAgICAgICAgY29uc3QgaXNCdWlsdGluID0gbmFtZS5zdGFydHNXaXRoKFwibm9kZTpcIik7XG4gICAgICAgIGxldCBiYXNlRGlyO1xuICAgICAgICBpZiAoaXNCdWlsdGluKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXm5vZGU6LywgXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBmaWxlVVJMVG9QYXRoKG5hbWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZXRhaWxzID0gcGFyc2U0KG5hbWUpO1xuICAgICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICBuYW1lID0gZGV0YWlscy5uYW1lO1xuICAgICAgICAgICAgYmFzZURpciA9IGRldGFpbHMuYmFzZWRpcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZHVsZXMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZU5hbWUgb2YgbW9kdWxlcykge1xuICAgICAgICAgICAgaWYgKG1vZHVsZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKGJhc2VEaXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzKSB7XG4gICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSArIHBhdGgzLnNlcCArIHBhdGgzLnJlbGF0aXZlKGJhc2VEaXIsIGZpbGVVUkxUb1BhdGgoZmlsZW5hbWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlRGlyLmVuZHNXaXRoKHNwZWNpZmllcnMuZ2V0KGZpbGVuYW1lKSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYWxsSG9va0ZuKGhvb2tGbiwgbmFtZXNwYWNlLCBuYW1lLCBiYXNlRGlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2tGbihob29rRm4sIG5hbWVzcGFjZSwgbmFtZSwgYmFzZURpcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhZGRIb29rKHRoaXMuX2lpdG1Ib29rKTtcbiAgICB9XG4gICAgSG9vazMucHJvdG90eXBlLnVuaG9vayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVtb3ZlSG9vayh0aGlzLl9paXRtSG9vayk7XG4gICAgfTtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBIb29rMztcbiAgICBtb2R1bGUyLmV4cG9ydHMuYWRkSG9vayA9IGFkZEhvb2s7XG4gICAgbW9kdWxlMi5leHBvcnRzLnJlbW92ZUhvb2sgPSByZW1vdmVIb29rO1xuICB9XG59KTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIEJhc2VsaW1lU0RLOiAoKSA9PiBCYXNlbGltZVNESyxcbiAgQmV0dGVySHR0cEluc3RydW1lbnRhdGlvbjogKCkgPT4gQmV0dGVySHR0cEluc3RydW1lbnRhdGlvbixcbiAgSHR0cFBsdWdpbjogKCkgPT4gSHR0cFBsdWdpbixcbiAgU3RyaXBlUGx1Z2luOiAoKSA9PiBTdHJpcGVQbHVnaW4sXG4gIFZlcmNlbFBsdWdpbjogKCkgPT4gVmVyY2VsUGx1Z2luXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL2Jhc2VsaW1lLnRzXG52YXIgaW1wb3J0X3Nka190cmFjZV9ub2RlID0gX190b0VTTShyZXF1aXJlX3NyYzIoKSwgMSk7XG5pbml0X2VzbSgpO1xuaW5pdF9lc201KCk7XG52YXIgaW1wb3J0X3Jlc291cmNlX2RldGVjdG9yX2F3cyA9IF9fdG9FU00ocmVxdWlyZV9zcmMzKCksIDEpO1xuXG4vLyBzcmMvcmVzb3VyY2VzL3ZlcmNlbC50c1xuaW5pdF9lc201KCk7XG5pbml0X2VzbTIoKTtcbnZhciBWZXJjZWxEZXRlY3RvciA9IGNsYXNzIHtcbiAgZGV0ZWN0KF9jb25maWcpIHtcbiAgICBpZiAoIXByb2Nlc3MuZW52LlZFUkNFTCkge1xuICAgICAgcmV0dXJuIFJlc291cmNlLmVtcHR5KCk7XG4gICAgfVxuICAgIGNvbnN0IGRlcGxveW1lbnRVcmwgPSBTdHJpbmcocHJvY2Vzcy5lbnYuVkVSQ0VMX1VSTCk7XG4gICAgaWYgKCFkZXBsb3ltZW50VXJsKSB7XG4gICAgICByZXR1cm4gUmVzb3VyY2UuZW1wdHkoKTtcbiAgICB9XG4gICAgY29uc3QgZ2l0QnJhbmNoVXJsID0gU3RyaW5nKHByb2Nlc3MuZW52LlZFUkNFTF9CUkFOQ0hfVVJMKTtcbiAgICBsZXQgc2VydmljZU5hbWU7XG4gICAgbGV0IHNlcnZpY2VOYW1lc3BhY2U7XG4gICAgaWYgKGdpdEJyYW5jaFVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VydmljZU5hbWUgPSBnaXRCcmFuY2hVcmwuc3BsaXQoXCItZ2l0LVwiKVswXTtcbiAgICAgICAgc2VydmljZU5hbWVzcGFjZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgW1NFTVJFU0FUVFJTX0NMT1VEX1BST1ZJREVSXTogU3RyaW5nKFxuICAgICAgICBcIlZlcmNlbFwiXG4gICAgICApLFxuICAgICAgW1NFTVJFU0FUVFJTX0NMT1VEX1BMQVRGT1JNXTogU3RyaW5nKFxuICAgICAgICBcIlZlcmNlbCBGdW5jdGlvbnNcIlxuICAgICAgKSxcbiAgICAgIFtTRU1SRVNBVFRSU19DTE9VRF9SRUdJT05dOiBTdHJpbmcocHJvY2Vzcy5lbnYuVkVSQ0VMX1JFR0lPTiksXG4gICAgICBcInZlcmNlbC5lbnZpcm9ubWVudFwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuVkVSQ0VMX0VOViksXG4gICAgICBcInZlcmNlbC51cmxcIjogU3RyaW5nKHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpLFxuICAgICAgXCJ2ZXJjZWwudXJsLmJyYW5jaFwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuVkVSQ0VMX0JSQU5DSF9VUkwpLFxuICAgICAgXCJ2ZXJjZWwuZ2l0LnByb3ZpZGVyXCI6IFN0cmluZyhwcm9jZXNzLmVudi5WRVJDRUxfR0lUX1BST1ZJREVSKSxcbiAgICAgIFwidmVyY2VsLmdpdC5yZXBvXCI6IFN0cmluZyhwcm9jZXNzLmVudi5WRVJDRUxfR0lUX1JFUE9fU0xVRyksXG4gICAgICBcInZlcmNlbC5naXQuY29tbWl0XCI6IFN0cmluZyhwcm9jZXNzLmVudi5WRVJDRUxfR0lUX0NPTU1JVF9TSEEpLFxuICAgICAgXCJ2ZXJjZWwuZ2l0Lm1lc3NhZ2VcIjogU3RyaW5nKHByb2Nlc3MuZW52LlZFUkNFTF9HSVRfQ09NTUlUX01FU1NBR0UpLFxuICAgICAgXCJ2ZXJjZWwuZ2l0LmF1dGhvclwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuVkVSQ0VMX0dJVF9DT01NSVRfQVVUSE9SX05BTUUpLFxuICAgICAgXCJzZXJ2aWNlLm5hbWVcIjogc2VydmljZU5hbWUsXG4gICAgICBcInNlcnZpY2UubmFtZXNwYWNlXCI6IHNlcnZpY2VOYW1lc3BhY2VcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUmVzb3VyY2UoYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9leHBvcnRlci10cmFjZS1vdGxwLWh0dHAvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvT1RMUFRyYWNlRXhwb3J0ZXIuanNcbmluaXRfZXNtMygpO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvb3RscC1leHBvcnRlci1iYXNlL2J1aWxkL2VzbS9PVExQRXhwb3J0ZXJCYXNlLmpzXG5pbml0X2VzbSgpO1xuaW5pdF9lc20zKCk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9vdGxwLWV4cG9ydGVyLWJhc2UvYnVpbGQvZXNtL3V0aWwuanNcbmluaXRfZXNtKCk7XG5pbml0X2VzbTMoKTtcbnZhciBfX3JlYWQxNiA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pXG4gICAgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlID0geyBlcnJvciB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpXG4gICAgICAgIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpXG4gICAgICAgIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn07XG52YXIgREVGQVVMVF9UUkFDRV9USU1FT1VUID0gMWU0O1xudmFyIERFRkFVTFRfRVhQT1JUX01BWF9BVFRFTVBUUyA9IDU7XG52YXIgREVGQVVMVF9FWFBPUlRfSU5JVElBTF9CQUNLT0ZGID0gMWUzO1xudmFyIERFRkFVTFRfRVhQT1JUX01BWF9CQUNLT0ZGID0gNWUzO1xudmFyIERFRkFVTFRfRVhQT1JUX0JBQ0tPRkZfTVVMVElQTElFUiA9IDEuNTtcbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhwYXJ0aWFsSGVhZGVycykge1xuICBpZiAocGFydGlhbEhlYWRlcnMgPT09IHZvaWQgMCkge1xuICAgIHBhcnRpYWxIZWFkZXJzID0ge307XG4gIH1cbiAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgT2JqZWN0LmVudHJpZXMocGFydGlhbEhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24oX2EyKSB7XG4gICAgdmFyIF9iID0gX19yZWFkMTYoX2EyLCAyKSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaGVhZGVyc1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlhZzIud2FybignSGVhZGVyIFwiJyArIGtleSArICdcIiBoYXMgaW52YWxpZCB2YWx1ZSAoJyArIHZhbHVlICsgXCIpIGFuZCB3aWxsIGJlIGlnbm9yZWRcIik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBhcHBlbmRSZXNvdXJjZVBhdGhUb1VybCh1cmw0LCBwYXRoMykge1xuICBpZiAoIXVybDQuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgdXJsNCA9IHVybDQgKyBcIi9cIjtcbiAgfVxuICByZXR1cm4gdXJsNCArIHBhdGgzO1xufVxuZnVuY3Rpb24gYXBwZW5kUm9vdFBhdGhUb1VybElmTmVlZGVkKHVybDQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmw0KTtcbiAgICBpZiAocGFyc2VkVXJsLnBhdGhuYW1lID09PSBcIlwiKSB7XG4gICAgICBwYXJzZWRVcmwucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBcIi9cIjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFVybC50b1N0cmluZygpO1xuICB9IGNhdGNoIChfYTIpIHtcbiAgICBkaWFnMi53YXJuKFwiQ291bGQgbm90IHBhcnNlIGV4cG9ydCBVUkw6ICdcIiArIHVybDQgKyBcIidcIik7XG4gICAgcmV0dXJuIHVybDQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZUV4cG9ydGVyVGltZW91dCh0aW1lb3V0TWlsbGlzKSB7XG4gIGlmICh0eXBlb2YgdGltZW91dE1pbGxpcyA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICh0aW1lb3V0TWlsbGlzIDw9IDApIHtcbiAgICAgIHJldHVybiBpbnZhbGlkVGltZW91dCh0aW1lb3V0TWlsbGlzLCBERUZBVUxUX1RSQUNFX1RJTUVPVVQpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZW91dE1pbGxpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0RXhwb3J0ZXJUaW1lb3V0RnJvbUVudigpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRFeHBvcnRlclRpbWVvdXRGcm9tRW52KCkge1xuICB2YXIgX2EyO1xuICB2YXIgZGVmaW5lZFRpbWVvdXQgPSBOdW1iZXIoKF9hMiA9IGdldEVudigpLk9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfVElNRU9VVCkgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiBnZXRFbnYoKS5PVEVMX0VYUE9SVEVSX09UTFBfVElNRU9VVCk7XG4gIGlmIChkZWZpbmVkVGltZW91dCA8PSAwKSB7XG4gICAgcmV0dXJuIGludmFsaWRUaW1lb3V0KGRlZmluZWRUaW1lb3V0LCBERUZBVUxUX1RSQUNFX1RJTUVPVVQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZpbmVkVGltZW91dDtcbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZFRpbWVvdXQodGltZW91dCwgZGVmYXVsdFRpbWVvdXQpIHtcbiAgZGlhZzIud2FybihcIlRpbWVvdXQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiLCB0aW1lb3V0KTtcbiAgcmV0dXJuIGRlZmF1bHRUaW1lb3V0O1xufVxuZnVuY3Rpb24gaXNFeHBvcnRSZXRyeWFibGUoc3RhdHVzQ29kZSkge1xuICB2YXIgcmV0cnlDb2RlcyA9IFs0MjksIDUwMiwgNTAzLCA1MDRdO1xuICByZXR1cm4gcmV0cnlDb2Rlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmV0cnlBZnRlclRvTWlsbHMocmV0cnlBZnRlcikge1xuICBpZiAocmV0cnlBZnRlciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBzZWNvbmRzID0gTnVtYmVyLnBhcnNlSW50KHJldHJ5QWZ0ZXIsIDEwKTtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIoc2Vjb25kcykpIHtcbiAgICByZXR1cm4gc2Vjb25kcyA+IDAgPyBzZWNvbmRzICogMWUzIDogLTE7XG4gIH1cbiAgdmFyIGRlbGF5ID0gbmV3IERhdGUocmV0cnlBZnRlcikuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKTtcbiAgaWYgKGRlbGF5ID49IDApIHtcbiAgICByZXR1cm4gZGVsYXk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9vdGxwLWV4cG9ydGVyLWJhc2UvYnVpbGQvZXNtL09UTFBFeHBvcnRlckJhc2UuanNcbnZhciBPVExQRXhwb3J0ZXJCYXNlID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE9UTFBFeHBvcnRlckJhc2UyKGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VuZGluZ1Byb21pc2VzID0gW107XG4gICAgICB0aGlzLnVybCA9IHRoaXMuZ2V0RGVmYXVsdFVybChjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcuaG9zdG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9IGNvbmZpZy5ob3N0bmFtZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2h1dGRvd24gPSB0aGlzLnNodXRkb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9zaHV0ZG93bk9uY2UgPSBuZXcgQmluZE9uY2VGdXR1cmUodGhpcy5fc2h1dGRvd24sIHRoaXMpO1xuICAgICAgdGhpcy5fY29uY3VycmVuY3lMaW1pdCA9IHR5cGVvZiBjb25maWcuY29uY3VycmVuY3lMaW1pdCA9PT0gXCJudW1iZXJcIiA/IGNvbmZpZy5jb25jdXJyZW5jeUxpbWl0IDogMzA7XG4gICAgICB0aGlzLnRpbWVvdXRNaWxsaXMgPSBjb25maWd1cmVFeHBvcnRlclRpbWVvdXQoY29uZmlnLnRpbWVvdXRNaWxsaXMpO1xuICAgICAgdGhpcy5vbkluaXQoY29uZmlnKTtcbiAgICB9XG4gICAgT1RMUEV4cG9ydGVyQmFzZTIucHJvdG90eXBlLmV4cG9ydCA9IGZ1bmN0aW9uKGl0ZW1zLCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuX3NodXRkb3duT25jZS5pc0NhbGxlZCkge1xuICAgICAgICByZXN1bHRDYWxsYmFjayh7XG4gICAgICAgICAgY29kZTogRXhwb3J0UmVzdWx0Q29kZS5GQUlMRUQsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIkV4cG9ydGVyIGhhcyBiZWVuIHNodXRkb3duXCIpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2VuZGluZ1Byb21pc2VzLmxlbmd0aCA+PSB0aGlzLl9jb25jdXJyZW5jeUxpbWl0KSB7XG4gICAgICAgIHJlc3VsdENhbGxiYWNrKHtcbiAgICAgICAgICBjb2RlOiBFeHBvcnRSZXN1bHRDb2RlLkZBSUxFRCxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiQ29uY3VycmVudCBleHBvcnQgbGltaXQgcmVhY2hlZFwiKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZXhwb3J0KGl0ZW1zKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHRDYWxsYmFjayh7IGNvZGU6IEV4cG9ydFJlc3VsdENvZGUuU1VDQ0VTUyB9KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIHJlc3VsdENhbGxiYWNrKHsgY29kZTogRXhwb3J0UmVzdWx0Q29kZS5GQUlMRUQsIGVycm9yIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBPVExQRXhwb3J0ZXJCYXNlMi5wcm90b3R5cGUuX2V4cG9ydCA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRpYWcyLmRlYnVnKFwiaXRlbXMgdG8gYmUgc2VudFwiLCBpdGVtcyk7XG4gICAgICAgICAgX3RoaXMuc2VuZChpdGVtcywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBPVExQRXhwb3J0ZXJCYXNlMi5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaHV0ZG93bk9uY2UuY2FsbCgpO1xuICAgIH07XG4gICAgT1RMUEV4cG9ydGVyQmFzZTIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLl9zZW5kaW5nUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIE9UTFBFeHBvcnRlckJhc2UyLnByb3RvdHlwZS5fc2h1dGRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgIGRpYWcyLmRlYnVnKFwic2h1dGRvd24gc3RhcnRlZFwiKTtcbiAgICAgIHRoaXMub25TaHV0ZG93bigpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9yY2VGbHVzaCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE9UTFBFeHBvcnRlckJhc2UyO1xuICB9KClcbik7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9vdGxwLWV4cG9ydGVyLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvdXRpbC5qc1xudmFyIHVybCA9IF9fdG9FU00ocmVxdWlyZShcInVybFwiKSk7XG52YXIgaHR0cCA9IF9fdG9FU00ocmVxdWlyZShcImh0dHBcIikpO1xudmFyIGh0dHBzID0gX190b0VTTShyZXF1aXJlKFwiaHR0cHNcIikpO1xudmFyIHpsaWIgPSBfX3RvRVNNKHJlcXVpcmUoXCJ6bGliXCIpKTtcbnZhciBpbXBvcnRfc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmluaXRfZXNtKCk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9vdGxwLWV4cG9ydGVyLWJhc2UvYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvdHlwZXMuanNcbnZhciBDb21wcmVzc2lvbkFsZ29yaXRobTtcbihmdW5jdGlvbihDb21wcmVzc2lvbkFsZ29yaXRobTIpIHtcbiAgQ29tcHJlc3Npb25BbGdvcml0aG0yW1wiTk9ORVwiXSA9IFwibm9uZVwiO1xuICBDb21wcmVzc2lvbkFsZ29yaXRobTJbXCJHWklQXCJdID0gXCJnemlwXCI7XG59KShDb21wcmVzc2lvbkFsZ29yaXRobSB8fCAoQ29tcHJlc3Npb25BbGdvcml0aG0gPSB7fSkpO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvb3RscC1leHBvcnRlci1iYXNlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL3V0aWwuanNcbmluaXRfZXNtMygpO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvb3RscC1leHBvcnRlci1iYXNlL2J1aWxkL2VzbS90eXBlcy5qc1xudmFyIF9fZXh0ZW5kczQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgZDIuX19wcm90b19fID0gYjI7XG4gICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYjIpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHApKVxuICAgICAgICAgIGQyW3BdID0gYjJbcF07XG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xufSgpO1xudmFyIE9UTFBFeHBvcnRlckVycm9yID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kczQoT1RMUEV4cG9ydGVyRXJyb3IyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9UTFBFeHBvcnRlckVycm9yMihtZXNzYWdlLCBjb2RlLCBkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgX3RoaXMubmFtZSA9IFwiT1RMUEV4cG9ydGVyRXJyb3JcIjtcbiAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBPVExQRXhwb3J0ZXJFcnJvcjI7XG4gIH0oRXJyb3IpXG4pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvb3RscC1leHBvcnRlci1iYXNlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL3V0aWwuanNcbnZhciBfX2Fzc2lnbjMgPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24zID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIHNlbmRXaXRoSHR0cChjb2xsZWN0b3IsIGRhdGEsIGNvbnRlbnRUeXBlLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgdmFyIGV4cG9ydGVyVGltZW91dCA9IGNvbGxlY3Rvci50aW1lb3V0TWlsbGlzO1xuICB2YXIgcGFyc2VkVXJsID0gbmV3IHVybC5VUkwoY29sbGVjdG9yLnVybCk7XG4gIHZhciBub2RlVmVyc2lvbiA9IE51bWJlcihwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoXCIuXCIpWzBdKTtcbiAgdmFyIHJldHJ5VGltZXI7XG4gIHZhciByZXE7XG4gIHZhciByZXFJc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2YXIgZXhwb3J0ZXJUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZXIpO1xuICAgIHJlcUlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpZiAocmVxLmRlc3Ryb3llZCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBPVExQRXhwb3J0ZXJFcnJvcihcIlJlcXVlc3QgVGltZW91dFwiKTtcbiAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZVZlcnNpb24gPj0gMTQgPyByZXEuZGVzdHJveSgpIDogcmVxLmFib3J0KCk7XG4gICAgfVxuICB9LCBleHBvcnRlclRpbWVvdXQpO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBob3N0bmFtZTogcGFyc2VkVXJsLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHBhcnNlZFVybC5wb3J0LFxuICAgIHBhdGg6IHBhcnNlZFVybC5wYXRobmFtZSxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IF9fYXNzaWduMyh7IFwiQ29udGVudC1UeXBlXCI6IGNvbnRlbnRUeXBlIH0sIGNvbGxlY3Rvci5oZWFkZXJzKSxcbiAgICBhZ2VudDogY29sbGVjdG9yLmFnZW50XG4gIH07XG4gIHZhciByZXF1ZXN0MyA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiID8gaHR0cC5yZXF1ZXN0IDogaHR0cHMucmVxdWVzdDtcbiAgdmFyIHNlbmRXaXRoUmV0cnkgPSBmdW5jdGlvbihyZXRyaWVzLCBtaW5EZWxheSkge1xuICAgIGlmIChyZXRyaWVzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHJpZXMgPSBERUZBVUxUX0VYUE9SVF9NQVhfQVRURU1QVFM7XG4gICAgfVxuICAgIGlmIChtaW5EZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW5EZWxheSA9IERFRkFVTFRfRVhQT1JUX0lOSVRJQUxfQkFDS09GRjtcbiAgICB9XG4gICAgcmVxID0gcmVxdWVzdDMob3B0aW9ucywgZnVuY3Rpb24ocmVzKSB7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gXCJcIjtcbiAgICAgIHJlcy5vbihcImRhdGFcIiwgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0YSArPSBjaHVuaztcbiAgICAgIH0pO1xuICAgICAgcmVzLm9uKFwiYWJvcnRlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcUlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBPVExQRXhwb3J0ZXJFcnJvcihcIlJlcXVlc3QgVGltZW91dFwiKTtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVxSXNEZXN0cm95ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlICYmIHJlcy5zdGF0dXNDb2RlIDwgMjk5KSB7XG4gICAgICAgICAgICBkaWFnMi5kZWJ1ZyhcInN0YXR1c0NvZGU6IFwiICsgcmVzLnN0YXR1c0NvZGUsIHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICBvblN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChleHBvcnRlclRpbWVyKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXRyeVRpbWVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5zdGF0dXNDb2RlICYmIGlzRXhwb3J0UmV0cnlhYmxlKHJlcy5zdGF0dXNDb2RlKSAmJiByZXRyaWVzID4gMCkge1xuICAgICAgICAgICAgdmFyIHJldHJ5VGltZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIG1pbkRlbGF5ID0gREVGQVVMVF9FWFBPUlRfQkFDS09GRl9NVUxUSVBMSUVSICogbWluRGVsYXk7XG4gICAgICAgICAgICBpZiAocmVzLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXSkge1xuICAgICAgICAgICAgICByZXRyeVRpbWUgPSBwYXJzZVJldHJ5QWZ0ZXJUb01pbGxzKHJlcy5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0cnlUaW1lID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKERFRkFVTFRfRVhQT1JUX01BWF9CQUNLT0ZGIC0gbWluRGVsYXkpICsgbWluRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0cnlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbmRXaXRoUmV0cnkocmV0cmllcyAtIDEsIG1pbkRlbGF5KTtcbiAgICAgICAgICAgIH0sIHJldHJ5VGltZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBPVExQRXhwb3J0ZXJFcnJvcihyZXMuc3RhdHVzTWVzc2FnZSwgcmVzLnN0YXR1c0NvZGUsIHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChleHBvcnRlclRpbWVyKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXRyeVRpbWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJlcS5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBpZiAocmVxSXNEZXN0cm95ZWQpIHtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBPVExQRXhwb3J0ZXJFcnJvcihcIlJlcXVlc3QgVGltZW91dFwiLCBlcnJvci5jb2RlKTtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoZXhwb3J0ZXJUaW1lcik7XG4gICAgICBjbGVhclRpbWVvdXQocmV0cnlUaW1lcik7XG4gICAgfSk7XG4gICAgcmVxLm9uKFwiYWJvcnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmVxSXNEZXN0cm95ZWQpIHtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBPVExQRXhwb3J0ZXJFcnJvcihcIlJlcXVlc3QgVGltZW91dFwiKTtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KGV4cG9ydGVyVGltZXIpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJldHJ5VGltZXIpO1xuICAgIH0pO1xuICAgIHN3aXRjaCAoY29sbGVjdG9yLmNvbXByZXNzaW9uKSB7XG4gICAgICBjYXNlIENvbXByZXNzaW9uQWxnb3JpdGhtLkdaSVA6IHtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIiwgXCJnemlwXCIpO1xuICAgICAgICB2YXIgZGF0YVN0cmVhbSA9IHJlYWRhYmxlRnJvbUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgZGF0YVN0cmVhbS5vbihcImVycm9yXCIsIG9uRXJyb3IpLnBpcGUoemxpYi5jcmVhdGVHemlwKCkpLm9uKFwiZXJyb3JcIiwgb25FcnJvcikucGlwZShyZXEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlcS5lbmQoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbiAgc2VuZFdpdGhSZXRyeSgpO1xufVxuZnVuY3Rpb24gcmVhZGFibGVGcm9tQnVmZmVyKGJ1ZmYpIHtcbiAgdmFyIHJlYWRhYmxlID0gbmV3IGltcG9ydF9zdHJlYW0uUmVhZGFibGUoKTtcbiAgcmVhZGFibGUucHVzaChidWZmKTtcbiAgcmVhZGFibGUucHVzaChudWxsKTtcbiAgcmV0dXJuIHJlYWRhYmxlO1xufVxuZnVuY3Rpb24gY3JlYXRlSHR0cEFnZW50KGNvbmZpZykge1xuICBpZiAoY29uZmlnLmh0dHBBZ2VudE9wdGlvbnMgJiYgY29uZmlnLmtlZXBBbGl2ZSA9PT0gZmFsc2UpIHtcbiAgICBkaWFnMi53YXJuKFwiaHR0cEFnZW50T3B0aW9ucyBpcyB1c2VkIG9ubHkgd2hlbiBrZWVwQWxpdmUgaXMgdHJ1ZVwiKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChjb25maWcua2VlcEFsaXZlID09PSBmYWxzZSB8fCAhY29uZmlnLnVybClcbiAgICByZXR1cm4gdm9pZCAwO1xuICB0cnkge1xuICAgIHZhciBwYXJzZWRVcmwgPSBuZXcgdXJsLlVSTChjb25maWcudXJsKTtcbiAgICB2YXIgQWdlbnQzID0gcGFyc2VkVXJsLnByb3RvY29sID09PSBcImh0dHA6XCIgPyBodHRwLkFnZW50IDogaHR0cHMuQWdlbnQ7XG4gICAgcmV0dXJuIG5ldyBBZ2VudDMoX19hc3NpZ24zKHsga2VlcEFsaXZlOiB0cnVlIH0sIGNvbmZpZy5odHRwQWdlbnRPcHRpb25zKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRpYWcyLmVycm9yKFwiY29sbGVjdG9yIGV4cG9ydGVyIGZhaWxlZCB0byBjcmVhdGUgaHR0cCBhZ2VudC4gZXJyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBjb25maWd1cmVDb21wcmVzc2lvbihjb21wcmVzc2lvbikge1xuICBpZiAoY29tcHJlc3Npb24pIHtcbiAgICByZXR1cm4gY29tcHJlc3Npb247XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlZmluZWRDb21wcmVzc2lvbiA9IGdldEVudigpLk9URUxfRVhQT1JURVJfT1RMUF9UUkFDRVNfQ09NUFJFU1NJT04gfHwgZ2V0RW52KCkuT1RFTF9FWFBPUlRFUl9PVExQX0NPTVBSRVNTSU9OO1xuICAgIHJldHVybiBkZWZpbmVkQ29tcHJlc3Npb24gPT09IENvbXByZXNzaW9uQWxnb3JpdGhtLkdaSVAgPyBDb21wcmVzc2lvbkFsZ29yaXRobS5HWklQIDogQ29tcHJlc3Npb25BbGdvcml0aG0uTk9ORTtcbiAgfVxufVxuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvb3RscC1leHBvcnRlci1iYXNlL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL09UTFBFeHBvcnRlck5vZGVCYXNlLmpzXG5pbml0X2VzbSgpO1xuaW5pdF9lc20zKCk7XG52YXIgX19leHRlbmRzNSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZDIsIGIyKSB7XG4gICAgICBkMi5fX3Byb3RvX18gPSBiMjtcbiAgICB9IHx8IGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiMilcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiMiwgcCkpXG4gICAgICAgICAgZDJbcF0gPSBiMltwXTtcbiAgICB9O1xuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oZCwgYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgIH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KCk7XG52YXIgT1RMUEV4cG9ydGVyTm9kZUJhc2UgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzNShPVExQRXhwb3J0ZXJOb2RlQmFzZTIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT1RMUEV4cG9ydGVyTm9kZUJhc2UyKGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuREVGQVVMVF9IRUFERVJTID0ge307XG4gICAgICBpZiAoY29uZmlnLm1ldGFkYXRhKSB7XG4gICAgICAgIGRpYWcyLndhcm4oXCJNZXRhZGF0YSBjYW5ub3QgYmUgc2V0IHdoZW4gdXNpbmcgaHR0cFwiKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKF90aGlzLkRFRkFVTFRfSEVBREVSUywgcGFyc2VIZWFkZXJzKGNvbmZpZy5oZWFkZXJzKSwgdXRpbHNfZXhwb3J0cy5wYXJzZUtleVBhaXJzSW50b1JlY29yZChnZXRFbnYoKS5PVEVMX0VYUE9SVEVSX09UTFBfSEVBREVSUykpO1xuICAgICAgX3RoaXMuYWdlbnQgPSBjcmVhdGVIdHRwQWdlbnQoY29uZmlnKTtcbiAgICAgIF90aGlzLmNvbXByZXNzaW9uID0gY29uZmlndXJlQ29tcHJlc3Npb24oY29uZmlnLmNvbXByZXNzaW9uKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT1RMUEV4cG9ydGVyTm9kZUJhc2UyLnByb3RvdHlwZS5vbkluaXQgPSBmdW5jdGlvbihfY29uZmlnKSB7XG4gICAgfTtcbiAgICBPVExQRXhwb3J0ZXJOb2RlQmFzZTIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihvYmplY3RzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5fc2h1dGRvd25PbmNlLmlzQ2FsbGVkKSB7XG4gICAgICAgIGRpYWcyLmRlYnVnKFwiU2h1dGRvd24gYWxyZWFkeSBzdGFydGVkLiBDYW5ub3Qgc2VuZCBvYmplY3RzXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2VydmljZVJlcXVlc3QgPSB0aGlzLmNvbnZlcnQob2JqZWN0cyk7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZW5kV2l0aEh0dHAoX3RoaXMsIEpTT04uc3RyaW5naWZ5KHNlcnZpY2VSZXF1ZXN0KSwgXCJhcHBsaWNhdGlvbi9qc29uXCIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgICB0aGlzLl9zZW5kaW5nUHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgIHZhciBwb3BQcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9zZW5kaW5nUHJvbWlzZXMuaW5kZXhPZihwcm9taXNlKTtcbiAgICAgICAgX3RoaXMuX3NlbmRpbmdQcm9taXNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfTtcbiAgICAgIHByb21pc2UudGhlbihwb3BQcm9taXNlLCBwb3BQcm9taXNlKTtcbiAgICB9O1xuICAgIE9UTFBFeHBvcnRlck5vZGVCYXNlMi5wcm90b3R5cGUub25TaHV0ZG93biA9IGZ1bmN0aW9uKCkge1xuICAgIH07XG4gICAgcmV0dXJuIE9UTFBFeHBvcnRlck5vZGVCYXNlMjtcbiAgfShPVExQRXhwb3J0ZXJCYXNlKVxuKTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L290bHAtdHJhbnNmb3JtZXIvYnVpbGQvZXNtL2NvbW1vbi9pbmRleC5qc1xuaW5pdF9lc20zKCk7XG5mdW5jdGlvbiBoclRpbWVUb05hbm9zKGhyVGltZTIpIHtcbiAgdmFyIE5BTk9TRUNPTkRTID0gQmlnSW50KDFlOSk7XG4gIHJldHVybiBCaWdJbnQoaHJUaW1lMlswXSkgKiBOQU5PU0VDT05EUyArIEJpZ0ludChoclRpbWUyWzFdKTtcbn1cbmZ1bmN0aW9uIHRvTG9uZ0JpdHModmFsdWUpIHtcbiAgdmFyIGxvdyA9IE51bWJlcihCaWdJbnQuYXNVaW50TigzMiwgdmFsdWUpKTtcbiAgdmFyIGhpZ2ggPSBOdW1iZXIoQmlnSW50LmFzVWludE4oMzIsIHZhbHVlID4+IEJpZ0ludCgzMikpKTtcbiAgcmV0dXJuIHsgbG93LCBoaWdoIH07XG59XG5mdW5jdGlvbiBlbmNvZGVBc0xvbmdCaXRzKGhyVGltZTIpIHtcbiAgdmFyIG5hbm9zID0gaHJUaW1lVG9OYW5vcyhoclRpbWUyKTtcbiAgcmV0dXJuIHRvTG9uZ0JpdHMobmFub3MpO1xufVxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcoaHJUaW1lMikge1xuICB2YXIgbmFub3MgPSBoclRpbWVUb05hbm9zKGhyVGltZTIpO1xuICByZXR1cm4gbmFub3MudG9TdHJpbmcoKTtcbn1cbnZhciBlbmNvZGVUaW1lc3RhbXAgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiID8gZW5jb2RlQXNTdHJpbmcgOiBoclRpbWVUb05hbm9zZWNvbmRzO1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gb3B0aW9uYWxIZXhUb0JpbmFyeShzdHIpIHtcbiAgaWYgKHN0ciA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBoZXhUb0JpbmFyeShzdHIpO1xufVxudmFyIERFRkFVTFRfRU5DT0RFUiA9IHtcbiAgZW5jb2RlSHJUaW1lOiBlbmNvZGVBc0xvbmdCaXRzLFxuICBlbmNvZGVTcGFuQ29udGV4dDogaGV4VG9CaW5hcnksXG4gIGVuY29kZU9wdGlvbmFsU3BhbkNvbnRleHQ6IG9wdGlvbmFsSGV4VG9CaW5hcnlcbn07XG5mdW5jdGlvbiBnZXRPdGxwRW5jb2RlcihvcHRpb25zKSB7XG4gIHZhciBfYTIsIF9iO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfRU5DT0RFUjtcbiAgfVxuICB2YXIgdXNlTG9uZ0JpdHMgPSAoX2EyID0gb3B0aW9ucy51c2VMb25nQml0cykgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiB0cnVlO1xuICB2YXIgdXNlSGV4ID0gKF9iID0gb3B0aW9ucy51c2VIZXgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGVuY29kZUhyVGltZTogdXNlTG9uZ0JpdHMgPyBlbmNvZGVBc0xvbmdCaXRzIDogZW5jb2RlVGltZXN0YW1wLFxuICAgIGVuY29kZVNwYW5Db250ZXh0OiB1c2VIZXggPyBpZGVudGl0eSA6IGhleFRvQmluYXJ5LFxuICAgIGVuY29kZU9wdGlvbmFsU3BhbkNvbnRleHQ6IHVzZUhleCA/IGlkZW50aXR5IDogb3B0aW9uYWxIZXhUb0JpbmFyeVxuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvb3RscC10cmFuc2Zvcm1lci9idWlsZC9lc20vY29tbW9uL2ludGVybmFsLmpzXG52YXIgX19yZWFkMTcgPSBmdW5jdGlvbihvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKVxuICAgIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZSA9IHsgZXJyb3IgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKVxuICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59O1xuZnVuY3Rpb24gdG9BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdG9LZXlWYWx1ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdG9LZXlWYWx1ZShrZXksIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlOiB0b0FueVZhbHVlKHZhbHVlKVxuICB9O1xufVxuZnVuY3Rpb24gdG9BbnlWYWx1ZSh2YWx1ZSkge1xuICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHQgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6IHZhbHVlIH07XG4gIGlmICh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSlcbiAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiB2YWx1ZSB9O1xuICAgIHJldHVybiB7IGludFZhbHVlOiB2YWx1ZSB9O1xuICB9XG4gIGlmICh0ID09PSBcImJvb2xlYW5cIilcbiAgICByZXR1cm4geyBib29sVmFsdWU6IHZhbHVlIH07XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgcmV0dXJuIHsgYnl0ZXNWYWx1ZTogdmFsdWUgfTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzOiB2YWx1ZS5tYXAodG9BbnlWYWx1ZSkgfSB9O1xuICBpZiAodCA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPSBudWxsKVxuICAgIHJldHVybiB7XG4gICAgICBrdmxpc3RWYWx1ZToge1xuICAgICAgICB2YWx1ZXM6IE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoZnVuY3Rpb24oX2EyKSB7XG4gICAgICAgICAgdmFyIF9iID0gX19yZWFkMTcoX2EyLCAyKSwgayA9IF9iWzBdLCB2ID0gX2JbMV07XG4gICAgICAgICAgcmV0dXJuIHRvS2V5VmFsdWUoaywgdik7XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgcmV0dXJuIHt9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvb3RscC10cmFuc2Zvcm1lci9idWlsZC9lc20vdHJhY2UvaW50ZXJuYWwuanNcbmZ1bmN0aW9uIHNka1NwYW5Ub090bHBTcGFuKHNwYW4sIGVuY29kZXIpIHtcbiAgdmFyIF9hMjtcbiAgdmFyIGN0eCA9IHNwYW4uc3BhbkNvbnRleHQoKTtcbiAgdmFyIHN0YXR1cyA9IHNwYW4uc3RhdHVzO1xuICByZXR1cm4ge1xuICAgIHRyYWNlSWQ6IGVuY29kZXIuZW5jb2RlU3BhbkNvbnRleHQoY3R4LnRyYWNlSWQpLFxuICAgIHNwYW5JZDogZW5jb2Rlci5lbmNvZGVTcGFuQ29udGV4dChjdHguc3BhbklkKSxcbiAgICBwYXJlbnRTcGFuSWQ6IGVuY29kZXIuZW5jb2RlT3B0aW9uYWxTcGFuQ29udGV4dChzcGFuLnBhcmVudFNwYW5JZCksXG4gICAgdHJhY2VTdGF0ZTogKF9hMiA9IGN0eC50cmFjZVN0YXRlKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5zZXJpYWxpemUoKSxcbiAgICBuYW1lOiBzcGFuLm5hbWUsXG4gICAgLy8gU3BhbiBraW5kIGlzIG9mZnNldCBieSAxIGJlY2F1c2UgdGhlIEFQSSBkb2VzIG5vdCBkZWZpbmUgYSB2YWx1ZSBmb3IgdW5zZXRcbiAgICBraW5kOiBzcGFuLmtpbmQgPT0gbnVsbCA/IDAgOiBzcGFuLmtpbmQgKyAxLFxuICAgIHN0YXJ0VGltZVVuaXhOYW5vOiBlbmNvZGVyLmVuY29kZUhyVGltZShzcGFuLnN0YXJ0VGltZSksXG4gICAgZW5kVGltZVVuaXhOYW5vOiBlbmNvZGVyLmVuY29kZUhyVGltZShzcGFuLmVuZFRpbWUpLFxuICAgIGF0dHJpYnV0ZXM6IHRvQXR0cmlidXRlcyhzcGFuLmF0dHJpYnV0ZXMpLFxuICAgIGRyb3BwZWRBdHRyaWJ1dGVzQ291bnQ6IHNwYW4uZHJvcHBlZEF0dHJpYnV0ZXNDb3VudCxcbiAgICBldmVudHM6IHNwYW4uZXZlbnRzLm1hcChmdW5jdGlvbihldmVudCkge1xuICAgICAgcmV0dXJuIHRvT3RscFNwYW5FdmVudChldmVudCwgZW5jb2Rlcik7XG4gICAgfSksXG4gICAgZHJvcHBlZEV2ZW50c0NvdW50OiBzcGFuLmRyb3BwZWRFdmVudHNDb3VudCxcbiAgICBzdGF0dXM6IHtcbiAgICAgIC8vIEFQSSBhbmQgcHJvdG8gZW51bXMgc2hhcmUgdGhlIHNhbWUgdmFsdWVzXG4gICAgICBjb2RlOiBzdGF0dXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHN0YXR1cy5tZXNzYWdlXG4gICAgfSxcbiAgICBsaW5rczogc3Bhbi5saW5rcy5tYXAoZnVuY3Rpb24obGluaykge1xuICAgICAgcmV0dXJuIHRvT3RscExpbmsobGluaywgZW5jb2Rlcik7XG4gICAgfSksXG4gICAgZHJvcHBlZExpbmtzQ291bnQ6IHNwYW4uZHJvcHBlZExpbmtzQ291bnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvT3RscExpbmsobGluaywgZW5jb2Rlcikge1xuICB2YXIgX2EyO1xuICByZXR1cm4ge1xuICAgIGF0dHJpYnV0ZXM6IGxpbmsuYXR0cmlidXRlcyA/IHRvQXR0cmlidXRlcyhsaW5rLmF0dHJpYnV0ZXMpIDogW10sXG4gICAgc3BhbklkOiBlbmNvZGVyLmVuY29kZVNwYW5Db250ZXh0KGxpbmsuY29udGV4dC5zcGFuSWQpLFxuICAgIHRyYWNlSWQ6IGVuY29kZXIuZW5jb2RlU3BhbkNvbnRleHQobGluay5jb250ZXh0LnRyYWNlSWQpLFxuICAgIHRyYWNlU3RhdGU6IChfYTIgPSBsaW5rLmNvbnRleHQudHJhY2VTdGF0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuc2VyaWFsaXplKCksXG4gICAgZHJvcHBlZEF0dHJpYnV0ZXNDb3VudDogbGluay5kcm9wcGVkQXR0cmlidXRlc0NvdW50IHx8IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvT3RscFNwYW5FdmVudCh0aW1lZEV2ZW50LCBlbmNvZGVyKSB7XG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlczogdGltZWRFdmVudC5hdHRyaWJ1dGVzID8gdG9BdHRyaWJ1dGVzKHRpbWVkRXZlbnQuYXR0cmlidXRlcykgOiBbXSxcbiAgICBuYW1lOiB0aW1lZEV2ZW50Lm5hbWUsXG4gICAgdGltZVVuaXhOYW5vOiBlbmNvZGVyLmVuY29kZUhyVGltZSh0aW1lZEV2ZW50LnRpbWUpLFxuICAgIGRyb3BwZWRBdHRyaWJ1dGVzQ291bnQ6IHRpbWVkRXZlbnQuZHJvcHBlZEF0dHJpYnV0ZXNDb3VudCB8fCAwXG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9vdGxwLXRyYW5zZm9ybWVyL2J1aWxkL2VzbS90cmFjZS9pbmRleC5qc1xudmFyIF9fdmFsdWVzMTEgPSBmdW5jdGlvbihvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKVxuICAgIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpXG4gICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICAgIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkMTggPSBmdW5jdGlvbihvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKVxuICAgIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSlcbiAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZSA9IHsgZXJyb3IgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKVxuICAgICAgICB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59O1xuZnVuY3Rpb24gY3JlYXRlRXhwb3J0VHJhY2VTZXJ2aWNlUmVxdWVzdChzcGFucywgb3B0aW9ucykge1xuICB2YXIgZW5jb2RlciA9IGdldE90bHBFbmNvZGVyKG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHJlc291cmNlU3BhbnM6IHNwYW5SZWNvcmRzVG9SZXNvdXJjZVNwYW5zKHNwYW5zLCBlbmNvZGVyKVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzb3VyY2VNYXAocmVhZGFibGVTcGFucykge1xuICB2YXIgZV8xLCBfYTI7XG4gIHZhciByZXNvdXJjZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgcmVhZGFibGVTcGFuc18xID0gX192YWx1ZXMxMShyZWFkYWJsZVNwYW5zKSwgcmVhZGFibGVTcGFuc18xXzEgPSByZWFkYWJsZVNwYW5zXzEubmV4dCgpOyAhcmVhZGFibGVTcGFuc18xXzEuZG9uZTsgcmVhZGFibGVTcGFuc18xXzEgPSByZWFkYWJsZVNwYW5zXzEubmV4dCgpKSB7XG4gICAgICB2YXIgcmVjb3JkID0gcmVhZGFibGVTcGFuc18xXzEudmFsdWU7XG4gICAgICB2YXIgaWxtTWFwID0gcmVzb3VyY2VNYXAuZ2V0KHJlY29yZC5yZXNvdXJjZSk7XG4gICAgICBpZiAoIWlsbU1hcCkge1xuICAgICAgICBpbG1NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICByZXNvdXJjZU1hcC5zZXQocmVjb3JkLnJlc291cmNlLCBpbG1NYXApO1xuICAgICAgfVxuICAgICAgdmFyIGluc3RydW1lbnRhdGlvbkxpYnJhcnlLZXkgPSByZWNvcmQuaW5zdHJ1bWVudGF0aW9uTGlicmFyeS5uYW1lICsgXCJAXCIgKyAocmVjb3JkLmluc3RydW1lbnRhdGlvbkxpYnJhcnkudmVyc2lvbiB8fCBcIlwiKSArIFwiOlwiICsgKHJlY29yZC5pbnN0cnVtZW50YXRpb25MaWJyYXJ5LnNjaGVtYVVybCB8fCBcIlwiKTtcbiAgICAgIHZhciByZWNvcmRzID0gaWxtTWFwLmdldChpbnN0cnVtZW50YXRpb25MaWJyYXJ5S2V5KTtcbiAgICAgIGlmICghcmVjb3Jkcykge1xuICAgICAgICByZWNvcmRzID0gW107XG4gICAgICAgIGlsbU1hcC5zZXQoaW5zdHJ1bWVudGF0aW9uTGlicmFyeUtleSwgcmVjb3Jkcyk7XG4gICAgICB9XG4gICAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHJlYWRhYmxlU3BhbnNfMV8xICYmICFyZWFkYWJsZVNwYW5zXzFfMS5kb25lICYmIChfYTIgPSByZWFkYWJsZVNwYW5zXzEucmV0dXJuKSlcbiAgICAgICAgX2EyLmNhbGwocmVhZGFibGVTcGFuc18xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSlcbiAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb3VyY2VNYXA7XG59XG5mdW5jdGlvbiBzcGFuUmVjb3Jkc1RvUmVzb3VyY2VTcGFucyhyZWFkYWJsZVNwYW5zLCBlbmNvZGVyKSB7XG4gIHZhciByZXNvdXJjZU1hcCA9IGNyZWF0ZVJlc291cmNlTWFwKHJlYWRhYmxlU3BhbnMpO1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBlbnRyeUl0ZXJhdG9yID0gcmVzb3VyY2VNYXAuZW50cmllcygpO1xuICB2YXIgZW50cnkgPSBlbnRyeUl0ZXJhdG9yLm5leHQoKTtcbiAgd2hpbGUgKCFlbnRyeS5kb25lKSB7XG4gICAgdmFyIF9hMiA9IF9fcmVhZDE4KGVudHJ5LnZhbHVlLCAyKSwgcmVzb3VyY2UgPSBfYTJbMF0sIGlsbU1hcCA9IF9hMlsxXTtcbiAgICB2YXIgc2NvcGVSZXNvdXJjZVNwYW5zID0gW107XG4gICAgdmFyIGlsbUl0ZXJhdG9yID0gaWxtTWFwLnZhbHVlcygpO1xuICAgIHZhciBpbG1FbnRyeSA9IGlsbUl0ZXJhdG9yLm5leHQoKTtcbiAgICB3aGlsZSAoIWlsbUVudHJ5LmRvbmUpIHtcbiAgICAgIHZhciBzY29wZVNwYW5zID0gaWxtRW50cnkudmFsdWU7XG4gICAgICBpZiAoc2NvcGVTcGFucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfYiA9IHNjb3BlU3BhbnNbMF0uaW5zdHJ1bWVudGF0aW9uTGlicmFyeSwgbmFtZV8xID0gX2IubmFtZSwgdmVyc2lvbiA9IF9iLnZlcnNpb24sIHNjaGVtYVVybCA9IF9iLnNjaGVtYVVybDtcbiAgICAgICAgdmFyIHNwYW5zID0gc2NvcGVTcGFucy5tYXAoZnVuY3Rpb24ocmVhZGFibGVTcGFuKSB7XG4gICAgICAgICAgcmV0dXJuIHNka1NwYW5Ub090bHBTcGFuKHJlYWRhYmxlU3BhbiwgZW5jb2Rlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBzY29wZVJlc291cmNlU3BhbnMucHVzaCh7XG4gICAgICAgICAgc2NvcGU6IHsgbmFtZTogbmFtZV8xLCB2ZXJzaW9uIH0sXG4gICAgICAgICAgc3BhbnMsXG4gICAgICAgICAgc2NoZW1hVXJsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWxtRW50cnkgPSBpbG1JdGVyYXRvci5uZXh0KCk7XG4gICAgfVxuICAgIHZhciB0cmFuc2Zvcm1lZFNwYW5zID0ge1xuICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgYXR0cmlidXRlczogdG9BdHRyaWJ1dGVzKHJlc291cmNlLmF0dHJpYnV0ZXMpLFxuICAgICAgICBkcm9wcGVkQXR0cmlidXRlc0NvdW50OiAwXG4gICAgICB9LFxuICAgICAgc2NvcGVTcGFuczogc2NvcGVSZXNvdXJjZVNwYW5zLFxuICAgICAgc2NoZW1hVXJsOiB2b2lkIDBcbiAgICB9O1xuICAgIG91dC5wdXNoKHRyYW5zZm9ybWVkU3BhbnMpO1xuICAgIGVudHJ5ID0gZW50cnlJdGVyYXRvci5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2V4cG9ydGVyLXRyYWNlLW90bHAtaHR0cC9idWlsZC9lc20vdmVyc2lvbi5qc1xudmFyIFZFUlNJT040ID0gXCIwLjUwLjBcIjtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2V4cG9ydGVyLXRyYWNlLW90bHAtaHR0cC9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9PVExQVHJhY2VFeHBvcnRlci5qc1xudmFyIF9fZXh0ZW5kczYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgZDIuX19wcm90b19fID0gYjI7XG4gICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYjIpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHApKVxuICAgICAgICAgIGQyW3BdID0gYjJbcF07XG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xufSgpO1xudmFyIF9fYXNzaWduNCA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbjQgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ240LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIERFRkFVTFRfQ09MTEVDVE9SX1JFU09VUkNFX1BBVEggPSBcInYxL3RyYWNlc1wiO1xudmFyIERFRkFVTFRfQ09MTEVDVE9SX1VSTCA9IFwiaHR0cDovL2xvY2FsaG9zdDo0MzE4L1wiICsgREVGQVVMVF9DT0xMRUNUT1JfUkVTT1VSQ0VfUEFUSDtcbnZhciBVU0VSX0FHRU5UID0ge1xuICBcIlVzZXItQWdlbnRcIjogXCJPVGVsLU9UTFAtRXhwb3J0ZXItSmF2YVNjcmlwdC9cIiArIFZFUlNJT040XG59O1xudmFyIE9UTFBUcmFjZUV4cG9ydGVyID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kczYoT1RMUFRyYWNlRXhwb3J0ZXIyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9UTFBUcmFjZUV4cG9ydGVyMihjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcbiAgICAgIF90aGlzLmhlYWRlcnMgPSBfX2Fzc2lnbjQoX19hc3NpZ240KF9fYXNzaWduNChfX2Fzc2lnbjQoe30sIF90aGlzLmhlYWRlcnMpLCBVU0VSX0FHRU5UKSwgdXRpbHNfZXhwb3J0cy5wYXJzZUtleVBhaXJzSW50b1JlY29yZChnZXRFbnYoKS5PVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0hFQURFUlMpKSwgcGFyc2VIZWFkZXJzKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5oZWFkZXJzKSk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9UTFBUcmFjZUV4cG9ydGVyMi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uKHNwYW5zKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXhwb3J0VHJhY2VTZXJ2aWNlUmVxdWVzdChzcGFucywge1xuICAgICAgICB1c2VIZXg6IHRydWUsXG4gICAgICAgIHVzZUxvbmdCaXRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBPVExQVHJhY2VFeHBvcnRlcjIucHJvdG90eXBlLmdldERlZmF1bHRVcmwgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY29uZmlnLnVybCA9PT0gXCJzdHJpbmdcIiA/IGNvbmZpZy51cmwgOiBnZXRFbnYoKS5PVEVMX0VYUE9SVEVSX09UTFBfVFJBQ0VTX0VORFBPSU5ULmxlbmd0aCA+IDAgPyBhcHBlbmRSb290UGF0aFRvVXJsSWZOZWVkZWQoZ2V0RW52KCkuT1RFTF9FWFBPUlRFUl9PVExQX1RSQUNFU19FTkRQT0lOVCkgOiBnZXRFbnYoKS5PVEVMX0VYUE9SVEVSX09UTFBfRU5EUE9JTlQubGVuZ3RoID4gMCA/IGFwcGVuZFJlc291cmNlUGF0aFRvVXJsKGdldEVudigpLk9URUxfRVhQT1JURVJfT1RMUF9FTkRQT0lOVCwgREVGQVVMVF9DT0xMRUNUT1JfUkVTT1VSQ0VfUEFUSCkgOiBERUZBVUxUX0NPTExFQ1RPUl9VUkw7XG4gICAgfTtcbiAgICByZXR1cm4gT1RMUFRyYWNlRXhwb3J0ZXIyO1xuICB9KE9UTFBFeHBvcnRlck5vZGVCYXNlKVxuKTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi9idWlsZC9lc20vYXV0b0xvYWRlci5qc1xuaW5pdF9lc20oKTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS1sb2dzL2J1aWxkL2VzbS9Ob29wTG9nZ2VyLmpzXG52YXIgTm9vcExvZ2dlciA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBOb29wTG9nZ2VyMigpIHtcbiAgICB9XG4gICAgTm9vcExvZ2dlcjIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihfbG9nUmVjb3JkKSB7XG4gICAgfTtcbiAgICByZXR1cm4gTm9vcExvZ2dlcjI7XG4gIH0oKVxuKTtcbnZhciBOT09QX0xPR0dFUiA9IG5ldyBOb29wTG9nZ2VyKCk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGktbG9ncy9idWlsZC9lc20vTm9vcExvZ2dlclByb3ZpZGVyLmpzXG52YXIgTm9vcExvZ2dlclByb3ZpZGVyID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vb3BMb2dnZXJQcm92aWRlcjIoKSB7XG4gICAgfVxuICAgIE5vb3BMb2dnZXJQcm92aWRlcjIucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uKF9uYW1lLCBfdmVyc2lvbiwgX29wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgTm9vcExvZ2dlcigpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vb3BMb2dnZXJQcm92aWRlcjI7XG4gIH0oKVxuKTtcbnZhciBOT09QX0xPR0dFUl9QUk9WSURFUiA9IG5ldyBOb29wTG9nZ2VyUHJvdmlkZXIoKTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS1sb2dzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2dsb2JhbFRoaXMuanNcbnZhciBfZ2xvYmFsVGhpczQgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbFRoaXMgOiBnbG9iYWw7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9hcGktbG9ncy9idWlsZC9lc20vaW50ZXJuYWwvZ2xvYmFsLXV0aWxzLmpzXG52YXIgR0xPQkFMX0xPR1NfQVBJX0tFWSA9IFN5bWJvbC5mb3IoXCJpby5vcGVudGVsZW1ldHJ5LmpzLmFwaS5sb2dzXCIpO1xudmFyIF9nbG9iYWwyID0gX2dsb2JhbFRoaXM0O1xuZnVuY3Rpb24gbWFrZUdldHRlcihyZXF1aXJlZFZlcnNpb24sIGluc3RhbmNlLCBmYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24odmVyc2lvbikge1xuICAgIHJldHVybiB2ZXJzaW9uID09PSByZXF1aXJlZFZlcnNpb24gPyBpbnN0YW5jZSA6IGZhbGxiYWNrO1xuICB9O1xufVxudmFyIEFQSV9CQUNLV0FSRFNfQ09NUEFUSUJJTElUWV9WRVJTSU9OID0gMTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS1sb2dzL2J1aWxkL2VzbS9hcGkvbG9ncy5qc1xudmFyIExvZ3NBUEkgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTG9nc0FQSTIoKSB7XG4gICAgfVxuICAgIExvZ3NBUEkyLmdldEluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IExvZ3NBUEkyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gICAgfTtcbiAgICBMb2dzQVBJMi5wcm90b3R5cGUuc2V0R2xvYmFsTG9nZ2VyUHJvdmlkZXIgPSBmdW5jdGlvbihwcm92aWRlcikge1xuICAgICAgaWYgKF9nbG9iYWwyW0dMT0JBTF9MT0dTX0FQSV9LRVldKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExvZ2dlclByb3ZpZGVyKCk7XG4gICAgICB9XG4gICAgICBfZ2xvYmFsMltHTE9CQUxfTE9HU19BUElfS0VZXSA9IG1ha2VHZXR0ZXIoQVBJX0JBQ0tXQVJEU19DT01QQVRJQklMSVRZX1ZFUlNJT04sIHByb3ZpZGVyLCBOT09QX0xPR0dFUl9QUk9WSURFUik7XG4gICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfTtcbiAgICBMb2dzQVBJMi5wcm90b3R5cGUuZ2V0TG9nZ2VyUHJvdmlkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYTIgPSBfZ2xvYmFsMltHTE9CQUxfTE9HU19BUElfS0VZXSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuY2FsbChfZ2xvYmFsMiwgQVBJX0JBQ0tXQVJEU19DT01QQVRJQklMSVRZX1ZFUlNJT04pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBOT09QX0xPR0dFUl9QUk9WSURFUjtcbiAgICB9O1xuICAgIExvZ3NBUEkyLnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMb2dnZXJQcm92aWRlcigpLmdldExvZ2dlcihuYW1lLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIExvZ3NBUEkyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgX2dsb2JhbDJbR0xPQkFMX0xPR1NfQVBJX0tFWV07XG4gICAgfTtcbiAgICByZXR1cm4gTG9nc0FQSTI7XG4gIH0oKVxuKTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2FwaS1sb2dzL2J1aWxkL2VzbS9pbmRleC5qc1xudmFyIGxvZ3MgPSBMb2dzQVBJLmdldEluc3RhbmNlKCk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24vYnVpbGQvZXNtL2F1dG9Mb2FkZXJVdGlscy5qc1xuZnVuY3Rpb24gcGFyc2VJbnN0cnVtZW50YXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSBbXTtcbiAgfVxuICB2YXIgaW5zdHJ1bWVudGF0aW9ucyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbaV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uKSkge1xuICAgICAgdmFyIHJlc3VsdHMgPSBwYXJzZUluc3RydW1lbnRhdGlvbk9wdGlvbnMob3B0aW9uKTtcbiAgICAgIGluc3RydW1lbnRhdGlvbnMgPSBpbnN0cnVtZW50YXRpb25zLmNvbmNhdChyZXN1bHRzLmluc3RydW1lbnRhdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpbnN0cnVtZW50YXRpb25zLnB1c2gobmV3IG9wdGlvbigpKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbi5pbnN0cnVtZW50YXRpb25OYW1lKSB7XG4gICAgICBpbnN0cnVtZW50YXRpb25zLnB1c2gob3B0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaW5zdHJ1bWVudGF0aW9ucyB9O1xufVxuZnVuY3Rpb24gZW5hYmxlSW5zdHJ1bWVudGF0aW9ucyhpbnN0cnVtZW50YXRpb25zLCB0cmFjZXJQcm92aWRlciwgbWV0ZXJQcm92aWRlciwgbG9nZ2VyUHJvdmlkZXIpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBpbnN0cnVtZW50YXRpb25zLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIHZhciBpbnN0cnVtZW50YXRpb24gPSBpbnN0cnVtZW50YXRpb25zW2ldO1xuICAgIGlmICh0cmFjZXJQcm92aWRlcikge1xuICAgICAgaW5zdHJ1bWVudGF0aW9uLnNldFRyYWNlclByb3ZpZGVyKHRyYWNlclByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKG1ldGVyUHJvdmlkZXIpIHtcbiAgICAgIGluc3RydW1lbnRhdGlvbi5zZXRNZXRlclByb3ZpZGVyKG1ldGVyUHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAobG9nZ2VyUHJvdmlkZXIgJiYgaW5zdHJ1bWVudGF0aW9uLnNldExvZ2dlclByb3ZpZGVyKSB7XG4gICAgICBpbnN0cnVtZW50YXRpb24uc2V0TG9nZ2VyUHJvdmlkZXIobG9nZ2VyUHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoIWluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5lbmFibGVkKSB7XG4gICAgICBpbnN0cnVtZW50YXRpb24uZW5hYmxlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaXNhYmxlSW5zdHJ1bWVudGF0aW9ucyhpbnN0cnVtZW50YXRpb25zKSB7XG4gIGluc3RydW1lbnRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpbnN0cnVtZW50YXRpb24pIHtcbiAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLmRpc2FibGUoKTtcbiAgfSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24vYnVpbGQvZXNtL2F1dG9Mb2FkZXIuanNcbmZ1bmN0aW9uIHJlZ2lzdGVySW5zdHJ1bWVudGF0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBpbnN0cnVtZW50YXRpb25zID0gcGFyc2VJbnN0cnVtZW50YXRpb25PcHRpb25zKG9wdGlvbnMuaW5zdHJ1bWVudGF0aW9ucykuaW5zdHJ1bWVudGF0aW9ucztcbiAgdmFyIHRyYWNlclByb3ZpZGVyID0gb3B0aW9ucy50cmFjZXJQcm92aWRlciB8fCB0cmFjZS5nZXRUcmFjZXJQcm92aWRlcigpO1xuICB2YXIgbWV0ZXJQcm92aWRlciA9IG9wdGlvbnMubWV0ZXJQcm92aWRlciB8fCBtZXRyaWNzLmdldE1ldGVyUHJvdmlkZXIoKTtcbiAgdmFyIGxvZ2dlclByb3ZpZGVyID0gb3B0aW9ucy5sb2dnZXJQcm92aWRlciB8fCBsb2dzLmdldExvZ2dlclByb3ZpZGVyKCk7XG4gIGVuYWJsZUluc3RydW1lbnRhdGlvbnMoaW5zdHJ1bWVudGF0aW9ucywgdHJhY2VyUHJvdmlkZXIsIG1ldGVyUHJvdmlkZXIsIGxvZ2dlclByb3ZpZGVyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRpc2FibGVJbnN0cnVtZW50YXRpb25zKGluc3RydW1lbnRhdGlvbnMpO1xuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2luc3RydW1lbnRhdGlvbi5qc1xudmFyIHBhdGgyID0gX190b0VTTShyZXF1aXJlKFwicGF0aFwiKSk7XG52YXIgaW1wb3J0X3V0aWw2ID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgaW1wb3J0X3NlbXZlcjIgPSBfX3RvRVNNKHJlcXVpcmVfc2VtdmVyMigpKTtcbnZhciBpbXBvcnRfc2hpbW1lciA9IF9fdG9FU00ocmVxdWlyZV9zaGltbWVyKCkpO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uL2J1aWxkL2VzbS9pbnN0cnVtZW50YXRpb24uanNcbmluaXRfZXNtKCk7XG52YXIgc2hpbW1lciA9IF9fdG9FU00ocmVxdWlyZV9zaGltbWVyKCkpO1xudmFyIF9fYXNzaWduNSA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbjUgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ241LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIEluc3RydW1lbnRhdGlvbkFic3RyYWN0ID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEluc3RydW1lbnRhdGlvbkFic3RyYWN0MihpbnN0cnVtZW50YXRpb25OYW1lLCBpbnN0cnVtZW50YXRpb25WZXJzaW9uLCBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSA9IGluc3RydW1lbnRhdGlvbk5hbWU7XG4gICAgICB0aGlzLmluc3RydW1lbnRhdGlvblZlcnNpb24gPSBpbnN0cnVtZW50YXRpb25WZXJzaW9uO1xuICAgICAgdGhpcy5fd3JhcCA9IHNoaW1tZXIud3JhcDtcbiAgICAgIHRoaXMuX3Vud3JhcCA9IHNoaW1tZXIudW53cmFwO1xuICAgICAgdGhpcy5fbWFzc1dyYXAgPSBzaGltbWVyLm1hc3NXcmFwO1xuICAgICAgdGhpcy5fbWFzc1Vud3JhcCA9IHNoaW1tZXIubWFzc1Vud3JhcDtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IF9fYXNzaWduNSh7IGVuYWJsZWQ6IHRydWUgfSwgY29uZmlnKTtcbiAgICAgIHRoaXMuX2RpYWcgPSBkaWFnMi5jcmVhdGVDb21wb25lbnRMb2dnZXIoe1xuICAgICAgICBuYW1lc3BhY2U6IGluc3RydW1lbnRhdGlvbk5hbWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fdHJhY2VyID0gdHJhY2UuZ2V0VHJhY2VyKGluc3RydW1lbnRhdGlvbk5hbWUsIGluc3RydW1lbnRhdGlvblZlcnNpb24pO1xuICAgICAgdGhpcy5fbWV0ZXIgPSBtZXRyaWNzLmdldE1ldGVyKGluc3RydW1lbnRhdGlvbk5hbWUsIGluc3RydW1lbnRhdGlvblZlcnNpb24pO1xuICAgICAgdGhpcy5fbG9nZ2VyID0gbG9ncy5nZXRMb2dnZXIoaW5zdHJ1bWVudGF0aW9uTmFtZSwgaW5zdHJ1bWVudGF0aW9uVmVyc2lvbik7XG4gICAgICB0aGlzLl91cGRhdGVNZXRyaWNJbnN0cnVtZW50cygpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdHJ1bWVudGF0aW9uQWJzdHJhY3QyLnByb3RvdHlwZSwgXCJtZXRlclwiLCB7XG4gICAgICAvKiBSZXR1cm5zIG1ldGVyICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0ZXI7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBJbnN0cnVtZW50YXRpb25BYnN0cmFjdDIucHJvdG90eXBlLnNldE1ldGVyUHJvdmlkZXIgPSBmdW5jdGlvbihtZXRlclByb3ZpZGVyKSB7XG4gICAgICB0aGlzLl9tZXRlciA9IG1ldGVyUHJvdmlkZXIuZ2V0TWV0ZXIodGhpcy5pbnN0cnVtZW50YXRpb25OYW1lLCB0aGlzLmluc3RydW1lbnRhdGlvblZlcnNpb24pO1xuICAgICAgdGhpcy5fdXBkYXRlTWV0cmljSW5zdHJ1bWVudHMoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0cnVtZW50YXRpb25BYnN0cmFjdDIucHJvdG90eXBlLCBcImxvZ2dlclwiLCB7XG4gICAgICAvKiBSZXR1cm5zIGxvZ2dlciAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlcjtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEluc3RydW1lbnRhdGlvbkFic3RyYWN0Mi5wcm90b3R5cGUuc2V0TG9nZ2VyUHJvdmlkZXIgPSBmdW5jdGlvbihsb2dnZXJQcm92aWRlcikge1xuICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyUHJvdmlkZXIuZ2V0TG9nZ2VyKHRoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSwgdGhpcy5pbnN0cnVtZW50YXRpb25WZXJzaW9uKTtcbiAgICB9O1xuICAgIEluc3RydW1lbnRhdGlvbkFic3RyYWN0Mi5wcm90b3R5cGUuZ2V0TW9kdWxlRGVmaW5pdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICB2YXIgaW5pdFJlc3VsdCA9IChfYTIgPSB0aGlzLmluaXQoKSkgIT09IG51bGwgJiYgX2EyICE9PSB2b2lkIDAgPyBfYTIgOiBbXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbml0UmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gW2luaXRSZXN1bHRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluaXRSZXN1bHQ7XG4gICAgfTtcbiAgICBJbnN0cnVtZW50YXRpb25BYnN0cmFjdDIucHJvdG90eXBlLl91cGRhdGVNZXRyaWNJbnN0cnVtZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgSW5zdHJ1bWVudGF0aW9uQWJzdHJhY3QyLnByb3RvdHlwZS5nZXRDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfTtcbiAgICBJbnN0cnVtZW50YXRpb25BYnN0cmFjdDIucHJvdG90eXBlLnNldENvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcbiAgICB9O1xuICAgIEluc3RydW1lbnRhdGlvbkFic3RyYWN0Mi5wcm90b3R5cGUuc2V0VHJhY2VyUHJvdmlkZXIgPSBmdW5jdGlvbih0cmFjZXJQcm92aWRlcikge1xuICAgICAgdGhpcy5fdHJhY2VyID0gdHJhY2VyUHJvdmlkZXIuZ2V0VHJhY2VyKHRoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSwgdGhpcy5pbnN0cnVtZW50YXRpb25WZXJzaW9uKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0cnVtZW50YXRpb25BYnN0cmFjdDIucHJvdG90eXBlLCBcInRyYWNlclwiLCB7XG4gICAgICAvKiBSZXR1cm5zIHRyYWNlciAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNlcjtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBJbnN0cnVtZW50YXRpb25BYnN0cmFjdDI7XG4gIH0oKVxuKTtcblxuLy8gbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9SZXF1aXJlSW5UaGVNaWRkbGVTaW5nbGV0b24uanNcbnZhciBpbXBvcnRfcmVxdWlyZV9pbl90aGVfbWlkZGxlID0gX190b0VTTShyZXF1aXJlX3JlcXVpcmVfaW5fdGhlX21pZGRsZSgpKTtcbnZhciBwYXRoID0gX190b0VTTShyZXF1aXJlKFwicGF0aFwiKSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24vYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvTW9kdWxlTmFtZVRyaWUuanNcbnZhciBfX3ZhbHVlczEyID0gZnVuY3Rpb24obykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSlcbiAgICByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZDE5ID0gZnVuY3Rpb24obywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSlcbiAgICByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpXG4gICAgICBhci5wdXNoKHIudmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGUgPSB7IGVycm9yIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSlcbiAgICAgICAgbS5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZSlcbiAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5OCA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgaWYgKCFhcilcbiAgICAgICAgICBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgTW9kdWxlTmFtZVNlcGFyYXRvciA9IFwiL1wiO1xudmFyIE1vZHVsZU5hbWVUcmllTm9kZSA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNb2R1bGVOYW1lVHJpZU5vZGUyKCkge1xuICAgICAgdGhpcy5ob29rcyA9IFtdO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBNb2R1bGVOYW1lVHJpZU5vZGUyO1xuICB9KClcbik7XG52YXIgTW9kdWxlTmFtZVRyaWUgPSAoXG4gIC8qKiBAY2xhc3MgKi9cbiAgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTW9kdWxlTmFtZVRyaWUyKCkge1xuICAgICAgdGhpcy5fdHJpZSA9IG5ldyBNb2R1bGVOYW1lVHJpZU5vZGUoKTtcbiAgICAgIHRoaXMuX2NvdW50ZXIgPSAwO1xuICAgIH1cbiAgICBNb2R1bGVOYW1lVHJpZTIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGhvb2spIHtcbiAgICAgIHZhciBlXzEsIF9hMjtcbiAgICAgIHZhciB0cmllTm9kZSA9IHRoaXMuX3RyaWU7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzMTIoaG9vay5tb2R1bGVOYW1lLnNwbGl0KE1vZHVsZU5hbWVTZXBhcmF0b3IpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgIHZhciBtb2R1bGVOYW1lUGFydCA9IF9jLnZhbHVlO1xuICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IHRyaWVOb2RlLmNoaWxkcmVuLmdldChtb2R1bGVOYW1lUGFydCk7XG4gICAgICAgICAgaWYgKCFuZXh0Tm9kZSkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXcgTW9kdWxlTmFtZVRyaWVOb2RlKCk7XG4gICAgICAgICAgICB0cmllTm9kZS5jaGlsZHJlbi5zZXQobW9kdWxlTmFtZVBhcnQsIG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZU5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYTIgPSBfYi5yZXR1cm4pKVxuICAgICAgICAgICAgX2EyLmNhbGwoX2IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpXG4gICAgICAgICAgICB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyaWVOb2RlLmhvb2tzLnB1c2goeyBob29rLCBpbnNlcnRlZElkOiB0aGlzLl9jb3VudGVyKysgfSk7XG4gICAgfTtcbiAgICBNb2R1bGVOYW1lVHJpZTIucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKG1vZHVsZU5hbWUsIF9hMikge1xuICAgICAgdmFyIGVfMiwgX2I7XG4gICAgICB2YXIgX2MgPSBfYTIgPT09IHZvaWQgMCA/IHt9IDogX2EyLCBtYWludGFpbkluc2VydGlvbk9yZGVyID0gX2MubWFpbnRhaW5JbnNlcnRpb25PcmRlciwgZnVsbE9ubHkgPSBfYy5mdWxsT25seTtcbiAgICAgIHZhciB0cmllTm9kZSA9IHRoaXMuX3RyaWU7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgdmFyIGZvdW5kRnVsbCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZCA9IF9fdmFsdWVzMTIobW9kdWxlTmFtZS5zcGxpdChNb2R1bGVOYW1lU2VwYXJhdG9yKSksIF9lID0gX2QubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfZC5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlTmFtZVBhcnQgPSBfZS52YWx1ZTtcbiAgICAgICAgICB2YXIgbmV4dE5vZGUgPSB0cmllTm9kZS5jaGlsZHJlbi5nZXQobW9kdWxlTmFtZVBhcnQpO1xuICAgICAgICAgIGlmICghbmV4dE5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kRnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnVsbE9ubHkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBfX3NwcmVhZEFycmF5OChbXSwgX19yZWFkMTkobmV4dE5vZGUuaG9va3MpLCBmYWxzZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmllTm9kZSA9IG5leHROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoX2UgJiYgIV9lLmRvbmUgJiYgKF9iID0gX2QucmV0dXJuKSlcbiAgICAgICAgICAgIF9iLmNhbGwoX2QpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzIpXG4gICAgICAgICAgICB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmdWxsT25seSAmJiBmb3VuZEZ1bGwpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIF9fc3ByZWFkQXJyYXk4KFtdLCBfX3JlYWQxOSh0cmllTm9kZS5ob29rcyksIGZhbHNlKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbcmVzdWx0c1swXS5ob29rXTtcbiAgICAgIH1cbiAgICAgIGlmIChtYWludGFpbkluc2VydGlvbk9yZGVyKSB7XG4gICAgICAgIHJlc3VsdHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaW5zZXJ0ZWRJZCAtIGIuaW5zZXJ0ZWRJZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cy5tYXAoZnVuY3Rpb24oX2EzKSB7XG4gICAgICAgIHZhciBob29rID0gX2EzLmhvb2s7XG4gICAgICAgIHJldHVybiBob29rO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTW9kdWxlTmFtZVRyaWUyO1xuICB9KClcbik7XG5cbi8vIG5vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24vYnVpbGQvZXNtL3BsYXRmb3JtL25vZGUvUmVxdWlyZUluVGhlTWlkZGxlU2luZ2xldG9uLmpzXG52YXIgX192YWx1ZXMxMyA9IGZ1bmN0aW9uKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgaWYgKG0pXG4gICAgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aClcbiAgICAgICAgICBvID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gICAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBpc01vY2hhID0gW1xuICBcImFmdGVyRWFjaFwiLFxuICBcImFmdGVyXCIsXG4gIFwiYmVmb3JlRWFjaFwiLFxuICBcImJlZm9yZVwiLFxuICBcImRlc2NyaWJlXCIsXG4gIFwiaXRcIlxuXS5ldmVyeShmdW5jdGlvbihmbikge1xuICByZXR1cm4gdHlwZW9mIGdsb2JhbFtmbl0gPT09IFwiZnVuY3Rpb25cIjtcbn0pO1xudmFyIFJlcXVpcmVJblRoZU1pZGRsZVNpbmdsZXRvbiA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBSZXF1aXJlSW5UaGVNaWRkbGVTaW5nbGV0b24yKCkge1xuICAgICAgdGhpcy5fbW9kdWxlTmFtZVRyaWUgPSBuZXcgTW9kdWxlTmFtZVRyaWUoKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICB9XG4gICAgUmVxdWlyZUluVGhlTWlkZGxlU2luZ2xldG9uMi5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBuZXcgaW1wb3J0X3JlcXVpcmVfaW5fdGhlX21pZGRsZS5Ib29rKFxuICAgICAgICAvLyBJbnRlcmNlcHQgYWxsIGByZXF1aXJlYCBjYWxsczsgd2Ugd2lsbCBmaWx0ZXIgdGhlIG1hdGNoaW5nIG9uZXMgYmVsb3dcbiAgICAgICAgbnVsbCxcbiAgICAgICAgeyBpbnRlcm5hbHM6IHRydWUgfSxcbiAgICAgICAgZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgYmFzZWRpcikge1xuICAgICAgICAgIHZhciBlXzEsIF9hMjtcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZE1vZHVsZU5hbWUgPSBub3JtYWxpemVQYXRoU2VwYXJhdG9ycyhuYW1lKTtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IF90aGlzLl9tb2R1bGVOYW1lVHJpZS5zZWFyY2gobm9ybWFsaXplZE1vZHVsZU5hbWUsIHtcbiAgICAgICAgICAgIG1haW50YWluSW5zZXJ0aW9uT3JkZXI6IHRydWUsXG4gICAgICAgICAgICAvLyBGb3IgY29yZSBtb2R1bGVzIChlLmcuIGBmc2ApLCBkbyBub3QgbWF0Y2ggb24gc3ViLXBhdGhzIChlLmcuIGBmcy9wcm9taXNlcycpLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBiZWhhdmlvciBvZiBgcmVxdWlyZS1pbi10aGUtbWlkZGxlYC5cbiAgICAgICAgICAgIC8vIGBiYXNlZGlyYCBpcyBhbHdheXMgYHVuZGVmaW5lZGAgZm9yIGNvcmUgbW9kdWxlcy5cbiAgICAgICAgICAgIGZ1bGxPbmx5OiBiYXNlZGlyID09PSB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgbWF0Y2hlc18xID0gX192YWx1ZXMxMyhtYXRjaGVzKSwgbWF0Y2hlc18xXzEgPSBtYXRjaGVzXzEubmV4dCgpOyAhbWF0Y2hlc18xXzEuZG9uZTsgbWF0Y2hlc18xXzEgPSBtYXRjaGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgIHZhciBvblJlcXVpcmUgPSBtYXRjaGVzXzFfMS52YWx1ZS5vblJlcXVpcmU7XG4gICAgICAgICAgICAgIGV4cG9ydHMgPSBvblJlcXVpcmUoZXhwb3J0cywgbmFtZSwgYmFzZWRpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGVzXzFfMSAmJiAhbWF0Y2hlc18xXzEuZG9uZSAmJiAoX2EyID0gbWF0Y2hlc18xLnJldHVybikpXG4gICAgICAgICAgICAgICAgX2EyLmNhbGwobWF0Y2hlc18xKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChlXzEpXG4gICAgICAgICAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICAgIFJlcXVpcmVJblRoZU1pZGRsZVNpbmdsZXRvbjIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24obW9kdWxlTmFtZSwgb25SZXF1aXJlKSB7XG4gICAgICB2YXIgaG9va2VkID0geyBtb2R1bGVOYW1lLCBvblJlcXVpcmUgfTtcbiAgICAgIHRoaXMuX21vZHVsZU5hbWVUcmllLmluc2VydChob29rZWQpO1xuICAgICAgcmV0dXJuIGhvb2tlZDtcbiAgICB9O1xuICAgIFJlcXVpcmVJblRoZU1pZGRsZVNpbmdsZXRvbjIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoaXNNb2NoYSlcbiAgICAgICAgcmV0dXJuIG5ldyBSZXF1aXJlSW5UaGVNaWRkbGVTaW5nbGV0b24yKCk7XG4gICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgPSAoX2EyID0gdGhpcy5faW5zdGFuY2UpICE9PSBudWxsICYmIF9hMiAhPT0gdm9pZCAwID8gX2EyIDogbmV3IFJlcXVpcmVJblRoZU1pZGRsZVNpbmdsZXRvbjIoKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXF1aXJlSW5UaGVNaWRkbGVTaW5nbGV0b24yO1xuICB9KClcbik7XG5mdW5jdGlvbiBub3JtYWxpemVQYXRoU2VwYXJhdG9ycyhtb2R1bGVOYW1lT3JQYXRoKSB7XG4gIHJldHVybiBwYXRoLnNlcCAhPT0gTW9kdWxlTmFtZVNlcGFyYXRvciA/IG1vZHVsZU5hbWVPclBhdGguc3BsaXQocGF0aC5zZXApLmpvaW4oTW9kdWxlTmFtZVNlcGFyYXRvcikgOiBtb2R1bGVOYW1lT3JQYXRoO1xufVxuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2luc3RydW1lbnRhdGlvbi5qc1xudmFyIGltcG9ydF9pbXBvcnRfaW5fdGhlX21pZGRsZSA9IF9fdG9FU00ocmVxdWlyZV9pbXBvcnRfaW5fdGhlX21pZGRsZSgpKTtcbmluaXRfZXNtKCk7XG52YXIgaW1wb3J0X3JlcXVpcmVfaW5fdGhlX21pZGRsZTIgPSBfX3RvRVNNKHJlcXVpcmVfcmVxdWlyZV9pbl90aGVfbWlkZGxlKCkpO1xudmFyIF9fZXh0ZW5kczcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQyLCBiMikge1xuICAgICAgZDIuX19wcm90b19fID0gYjI7XG4gICAgfSB8fCBmdW5jdGlvbihkMiwgYjIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYjIpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYjIsIHApKVxuICAgICAgICAgIGQyW3BdID0gYjJbcF07XG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xufSgpO1xudmFyIF9fdmFsdWVzMTQgPSBmdW5jdGlvbihvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKVxuICAgIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpXG4gICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICAgIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgSW5zdHJ1bWVudGF0aW9uQmFzZSA9IChcbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHM3KEluc3RydW1lbnRhdGlvbkJhc2UyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluc3RydW1lbnRhdGlvbkJhc2UyKGluc3RydW1lbnRhdGlvbk5hbWUsIGluc3RydW1lbnRhdGlvblZlcnNpb24sIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5zdHJ1bWVudGF0aW9uTmFtZSwgaW5zdHJ1bWVudGF0aW9uVmVyc2lvbiwgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuX2hvb2tzID0gW107XG4gICAgICBfdGhpcy5fcmVxdWlyZUluVGhlTWlkZGxlU2luZ2xldG9uID0gUmVxdWlyZUluVGhlTWlkZGxlU2luZ2xldG9uLmdldEluc3RhbmNlKCk7XG4gICAgICBfdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMuX3dyYXAgPSBmdW5jdGlvbihtb2R1bGVFeHBvcnRzLCBuYW1lLCB3cmFwcGVyKSB7XG4gICAgICAgIGlmICghaW1wb3J0X3V0aWw2LnR5cGVzLmlzUHJveHkobW9kdWxlRXhwb3J0cykpIHtcbiAgICAgICAgICByZXR1cm4gKDAsIGltcG9ydF9zaGltbWVyLndyYXApKG1vZHVsZUV4cG9ydHMsIG5hbWUsIHdyYXBwZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB3cmFwcGVkID0gKDAsIGltcG9ydF9zaGltbWVyLndyYXApKE9iamVjdC5hc3NpZ24oe30sIG1vZHVsZUV4cG9ydHMpLCBuYW1lLCB3cmFwcGVyKTtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZUV4cG9ydHMsIG5hbWUsIHtcbiAgICAgICAgICAgIHZhbHVlOiB3cmFwcGVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy5fdW53cmFwID0gZnVuY3Rpb24obW9kdWxlRXhwb3J0cywgbmFtZSkge1xuICAgICAgICBpZiAoIWltcG9ydF91dGlsNi50eXBlcy5pc1Byb3h5KG1vZHVsZUV4cG9ydHMpKSB7XG4gICAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfc2hpbW1lci51bndyYXApKG1vZHVsZUV4cG9ydHMsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlRXhwb3J0cywgbmFtZSwge1xuICAgICAgICAgICAgdmFsdWU6IG1vZHVsZUV4cG9ydHNbbmFtZV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF90aGlzLl9tYXNzV3JhcCA9IGZ1bmN0aW9uKG1vZHVsZUV4cG9ydHNBcnJheSwgbmFtZXMsIHdyYXBwZXIpIHtcbiAgICAgICAgaWYgKCFtb2R1bGVFeHBvcnRzQXJyYXkpIHtcbiAgICAgICAgICBkaWFnMi5lcnJvcihcIm11c3QgcHJvdmlkZSBvbmUgb3IgbW9yZSBtb2R1bGVzIHRvIHBhdGNoXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVFeHBvcnRzQXJyYXkpKSB7XG4gICAgICAgICAgbW9kdWxlRXhwb3J0c0FycmF5ID0gW21vZHVsZUV4cG9ydHNBcnJheV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEobmFtZXMgJiYgQXJyYXkuaXNBcnJheShuYW1lcykpKSB7XG4gICAgICAgICAgZGlhZzIuZXJyb3IoXCJtdXN0IHByb3ZpZGUgb25lIG9yIG1vcmUgZnVuY3Rpb25zIHRvIHdyYXAgb24gbW9kdWxlc1wiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlRXhwb3J0c0FycmF5LmZvckVhY2goZnVuY3Rpb24obW9kdWxlRXhwb3J0cykge1xuICAgICAgICAgIG5hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgX3RoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgbmFtZSwgd3JhcHBlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIF90aGlzLl9tYXNzVW53cmFwID0gZnVuY3Rpb24obW9kdWxlRXhwb3J0c0FycmF5LCBuYW1lcykge1xuICAgICAgICBpZiAoIW1vZHVsZUV4cG9ydHNBcnJheSkge1xuICAgICAgICAgIGRpYWcyLmVycm9yKFwibXVzdCBwcm92aWRlIG9uZSBvciBtb3JlIG1vZHVsZXMgdG8gcGF0Y2hcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1vZHVsZUV4cG9ydHNBcnJheSkpIHtcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzQXJyYXkgPSBbbW9kdWxlRXhwb3J0c0FycmF5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShuYW1lcyAmJiBBcnJheS5pc0FycmF5KG5hbWVzKSkpIHtcbiAgICAgICAgICBkaWFnMi5lcnJvcihcIm11c3QgcHJvdmlkZSBvbmUgb3IgbW9yZSBmdW5jdGlvbnMgdG8gd3JhcCBvbiBtb2R1bGVzXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb2R1bGVFeHBvcnRzQXJyYXkuZm9yRWFjaChmdW5jdGlvbihtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgICAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsIG5hbWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB2YXIgbW9kdWxlcyA9IF90aGlzLmluaXQoKTtcbiAgICAgIGlmIChtb2R1bGVzICYmICFBcnJheS5pc0FycmF5KG1vZHVsZXMpKSB7XG4gICAgICAgIG1vZHVsZXMgPSBbbW9kdWxlc107XG4gICAgICB9XG4gICAgICBfdGhpcy5fbW9kdWxlcyA9IG1vZHVsZXMgfHwgW107XG4gICAgICBpZiAoX3RoaXMuX21vZHVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRpYWcyLmRlYnVnKFwiTm8gbW9kdWxlcyBpbnN0cnVtZW50YXRpb24gaGFzIGJlZW4gZGVmaW5lZCBmb3IgXCIgKyAoXCInXCIgKyBfdGhpcy5pbnN0cnVtZW50YXRpb25OYW1lICsgXCJAXCIgKyBfdGhpcy5pbnN0cnVtZW50YXRpb25WZXJzaW9uICsgXCInXCIpICsgXCIsIG5vdGhpbmcgd2lsbCBiZSBwYXRjaGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLl9jb25maWcuZW5hYmxlZCkge1xuICAgICAgICBfdGhpcy5lbmFibGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5zdHJ1bWVudGF0aW9uQmFzZTIucHJvdG90eXBlLl93YXJuT25QcmVsb2FkZWRNb2R1bGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5fbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZTIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBtb2R1bGUyLm5hbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJlc29sdmVkTW9kdWxlID0gcmVxdWlyZS5yZXNvbHZlKG5hbWUpO1xuICAgICAgICAgIGlmIChyZXF1aXJlLmNhY2hlW3Jlc29sdmVkTW9kdWxlXSkge1xuICAgICAgICAgICAgX3RoaXMuX2RpYWcud2FybihcIk1vZHVsZSBcIiArIG5hbWUgKyBcIiBoYXMgYmVlbiBsb2FkZWQgYmVmb3JlIFwiICsgX3RoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSArIFwiIHNvIGl0IG1pZ2h0IG5vdCB3b3JrLCBwbGVhc2UgaW5pdGlhbGl6ZSBpdCBiZWZvcmUgcmVxdWlyaW5nIFwiICsgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChfYTIpIHtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBJbnN0cnVtZW50YXRpb25CYXNlMi5wcm90b3R5cGUuX2V4dHJhY3RQYWNrYWdlVmVyc2lvbiA9IGZ1bmN0aW9uKGJhc2VEaXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcmVxdWlyZShwYXRoMi5qb2luKGJhc2VEaXIsIFwicGFja2FnZS5qc29uXCIpKS52ZXJzaW9uO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZlcnNpb24gPT09IFwic3RyaW5nXCIgPyB2ZXJzaW9uIDogdm9pZCAwO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGlhZzIud2FybihcIkZhaWxlZCBleHRyYWN0aW5nIHZlcnNpb25cIiwgYmFzZURpcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gICAgSW5zdHJ1bWVudGF0aW9uQmFzZTIucHJvdG90eXBlLl9vblJlcXVpcmUgPSBmdW5jdGlvbihtb2R1bGUyLCBleHBvcnRzLCBuYW1lLCBiYXNlRGlyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICghYmFzZURpcikge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZTIucGF0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIG1vZHVsZTIubW9kdWxlRXhwb3J0cyA9IGV4cG9ydHM7XG4gICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUyLnBhdGNoKGV4cG9ydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy5fZXh0cmFjdFBhY2thZ2VWZXJzaW9uKGJhc2VEaXIpO1xuICAgICAgbW9kdWxlMi5tb2R1bGVWZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgIGlmIChtb2R1bGUyLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgaWYgKGlzU3VwcG9ydGVkKG1vZHVsZTIuc3VwcG9ydGVkVmVyc2lvbnMsIHZlcnNpb24sIG1vZHVsZTIuaW5jbHVkZVByZXJlbGVhc2UpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUyLnBhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1vZHVsZTIubW9kdWxlRXhwb3J0cyA9IGV4cG9ydHM7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlMi5wYXRjaChleHBvcnRzLCBtb2R1bGUyLm1vZHVsZVZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHZhciBmaWxlcyA9IChfYTIgPSBtb2R1bGUyLmZpbGVzKSAhPT0gbnVsbCAmJiBfYTIgIT09IHZvaWQgMCA/IF9hMiA6IFtdO1xuICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gcGF0aDIubm9ybWFsaXplKG5hbWUpO1xuICAgICAgdmFyIHN1cHBvcnRlZEZpbGVJbnN0cnVtZW50YXRpb25zID0gZmlsZXMuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGYubmFtZSA9PT0gbm9ybWFsaXplZE5hbWU7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gaXNTdXBwb3J0ZWQoZi5zdXBwb3J0ZWRWZXJzaW9ucywgdmVyc2lvbiwgbW9kdWxlMi5pbmNsdWRlUHJlcmVsZWFzZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdXBwb3J0ZWRGaWxlSW5zdHJ1bWVudGF0aW9ucy5yZWR1Y2UoZnVuY3Rpb24ocGF0Y2hlZEV4cG9ydHMsIGZpbGUpIHtcbiAgICAgICAgZmlsZS5tb2R1bGVFeHBvcnRzID0gcGF0Y2hlZEV4cG9ydHM7XG4gICAgICAgIGlmIChfdGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybiBmaWxlLnBhdGNoKHBhdGNoZWRFeHBvcnRzLCBtb2R1bGUyLm1vZHVsZVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRjaGVkRXhwb3J0cztcbiAgICAgIH0sIGV4cG9ydHMpO1xuICAgIH07XG4gICAgSW5zdHJ1bWVudGF0aW9uQmFzZTIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVfMSwgX2EyLCBlXzIsIF9iLCBlXzMsIF9jO1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuX2hvb2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfZCA9IF9fdmFsdWVzMTQodGhpcy5fbW9kdWxlcyksIF9lID0gX2QubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfZC5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBtb2R1bGVfMSA9IF9lLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVfMS5wYXRjaCA9PT0gXCJmdW5jdGlvblwiICYmIG1vZHVsZV8xLm1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgbW9kdWxlXzEucGF0Y2gobW9kdWxlXzEubW9kdWxlRXhwb3J0cywgbW9kdWxlXzEubW9kdWxlVmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IChlXzIgPSB2b2lkIDAsIF9fdmFsdWVzMTQobW9kdWxlXzEuZmlsZXMpKSwgX2cgPSBfZi5uZXh0KCk7ICFfZy5kb25lOyBfZyA9IF9mLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gX2cudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUubW9kdWxlRXhwb3J0cykge1xuICAgICAgICAgICAgICAgICAgZmlsZS5wYXRjaChmaWxlLm1vZHVsZUV4cG9ydHMsIG1vZHVsZV8xLm1vZHVsZVZlcnNpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9nICYmICFfZy5kb25lICYmIChfYiA9IF9mLnJldHVybikpXG4gICAgICAgICAgICAgICAgICBfYi5jYWxsKF9mKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoZV8yKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfZSAmJiAhX2UuZG9uZSAmJiAoX2EyID0gX2QucmV0dXJuKSlcbiAgICAgICAgICAgICAgX2EyLmNhbGwoX2QpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8xKVxuICAgICAgICAgICAgICB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3dhcm5PblByZWxvYWRlZE1vZHVsZXMoKTtcbiAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24obW9kdWxlXzIyKSB7XG4gICAgICAgIHZhciBob29rRm4gPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBiYXNlRGlyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9vblJlcXVpcmUobW9kdWxlXzIyLCBleHBvcnRzLCBuYW1lLCBiYXNlRGlyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uUmVxdWlyZSA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGJhc2VEaXIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX29uUmVxdWlyZShtb2R1bGVfMjIsIGV4cG9ydHMsIG5hbWUsIGJhc2VEaXIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaG9vayA9IHBhdGgyLmlzQWJzb2x1dGUobW9kdWxlXzIyLm5hbWUpID8gbmV3IGltcG9ydF9yZXF1aXJlX2luX3RoZV9taWRkbGUyLkhvb2soW21vZHVsZV8yMi5uYW1lXSwgeyBpbnRlcm5hbHM6IHRydWUgfSwgb25SZXF1aXJlKSA6IHRoaXNfMS5fcmVxdWlyZUluVGhlTWlkZGxlU2luZ2xldG9uLnJlZ2lzdGVyKG1vZHVsZV8yMi5uYW1lLCBvblJlcXVpcmUpO1xuICAgICAgICB0aGlzXzEuX2hvb2tzLnB1c2goaG9vayk7XG4gICAgICAgIHZhciBlc21Ib29rID0gbmV3IGltcG9ydF9pbXBvcnRfaW5fdGhlX21pZGRsZS5kZWZhdWx0KFttb2R1bGVfMjIubmFtZV0sIHsgaW50ZXJuYWxzOiBmYWxzZSB9LCBob29rRm4pO1xuICAgICAgICB0aGlzXzEuX2hvb2tzLnB1c2goZXNtSG9vayk7XG4gICAgICB9O1xuICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaCA9IF9fdmFsdWVzMTQodGhpcy5fbW9kdWxlcyksIF9qID0gX2gubmV4dCgpOyAhX2ouZG9uZTsgX2ogPSBfaC5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgbW9kdWxlXzIgPSBfai52YWx1ZTtcbiAgICAgICAgICBfbG9vcF8xKG1vZHVsZV8yKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8zXzEpIHtcbiAgICAgICAgZV8zID0geyBlcnJvcjogZV8zXzEgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF9qICYmICFfai5kb25lICYmIChfYyA9IF9oLnJldHVybikpXG4gICAgICAgICAgICBfYy5jYWxsKF9oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8zKVxuICAgICAgICAgICAgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnN0cnVtZW50YXRpb25CYXNlMi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVfNCwgX2EyLCBlXzUsIF9iO1xuICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMxNCh0aGlzLl9tb2R1bGVzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgIHZhciBtb2R1bGVfMyA9IF9kLnZhbHVlO1xuICAgICAgICAgIGlmICh0eXBlb2YgbW9kdWxlXzMudW5wYXRjaCA9PT0gXCJmdW5jdGlvblwiICYmIG1vZHVsZV8zLm1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZV8zLnVucGF0Y2gobW9kdWxlXzMubW9kdWxlRXhwb3J0cywgbW9kdWxlXzMubW9kdWxlVmVyc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IChlXzUgPSB2b2lkIDAsIF9fdmFsdWVzMTQobW9kdWxlXzMuZmlsZXMpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgICB2YXIgZmlsZSA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZmlsZS5tb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgZmlsZS51bnBhdGNoKGZpbGUubW9kdWxlRXhwb3J0cywgbW9kdWxlXzMubW9kdWxlVmVyc2lvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlXzVfMSkge1xuICAgICAgICAgICAgZV81ID0geyBlcnJvcjogZV81XzEgfTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpXG4gICAgICAgICAgICAgICAgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoZV81KVxuICAgICAgICAgICAgICAgIHRocm93IGVfNS5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfNF8xKSB7XG4gICAgICAgIGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EyID0gX2MucmV0dXJuKSlcbiAgICAgICAgICAgIF9hMi5jYWxsKF9jKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV80KVxuICAgICAgICAgICAgdGhyb3cgZV80LmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnN0cnVtZW50YXRpb25CYXNlMi5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9O1xuICAgIHJldHVybiBJbnN0cnVtZW50YXRpb25CYXNlMjtcbiAgfShJbnN0cnVtZW50YXRpb25BYnN0cmFjdClcbik7XG5mdW5jdGlvbiBpc1N1cHBvcnRlZChzdXBwb3J0ZWRWZXJzaW9ucywgdmVyc2lvbiwgaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFZlcnNpb25zLmluY2x1ZGVzKFwiKlwiKTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkVmVyc2lvbnMuc29tZShmdW5jdGlvbihzdXBwb3J0ZWRWZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfc2VtdmVyMi5zYXRpc2ZpZXMpKHZlcnNpb24sIHN1cHBvcnRlZFZlcnNpb24sIHsgaW5jbHVkZVByZXJlbGVhc2UgfSk7XG4gIH0pO1xufVxuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uL2J1aWxkL2VzbS9pbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbi5qc1xudmFyIEluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uID0gKFxuICAvKiogQGNsYXNzICovXG4gIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uMihuYW1lLCBzdXBwb3J0ZWRWZXJzaW9ucywgcGF0Y2gsIHVucGF0Y2gsIGZpbGVzKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5zdXBwb3J0ZWRWZXJzaW9ucyA9IHN1cHBvcnRlZFZlcnNpb25zO1xuICAgICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xuICAgICAgdGhpcy51bnBhdGNoID0gdW5wYXRjaDtcbiAgICAgIHRoaXMuZmlsZXMgPSBmaWxlcyB8fCBbXTtcbiAgICB9XG4gICAgcmV0dXJuIEluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uMjtcbiAgfSgpXG4pO1xuXG4vLyBub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uL2J1aWxkL2VzbS91dGlscy5qc1xuZnVuY3Rpb24gc2FmZUV4ZWN1dGVJblRoZU1pZGRsZShleGVjdXRlLCBvbkZpbmlzaCwgcHJldmVudFRocm93aW5nRXJyb3IpIHtcbiAgdmFyIGVycm9yO1xuICB2YXIgcmVzdWx0O1xuICB0cnkge1xuICAgIHJlc3VsdCA9IGV4ZWN1dGUoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBvbkZpbmlzaChlcnJvciwgcmVzdWx0KTtcbiAgICBpZiAoZXJyb3IgJiYgIXByZXZlbnRUaHJvd2luZ0Vycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gaXNXcmFwcGVkMihmdW5jKSB7XG4gIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBmdW5jLl9fb3JpZ2luYWwgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZnVuYy5fX3Vud3JhcCA9PT0gXCJmdW5jdGlvblwiICYmIGZ1bmMuX193cmFwcGVkID09PSB0cnVlO1xufVxuXG4vLyBzcmMvYmFzZWxpbWUudHNcbnZhciBpbXBvcnRfZnMzID0gcmVxdWlyZShcImZzXCIpO1xuXG4vLyBzcmMvcmVzb3VyY2VzL3NlcnZpY2UudHNcbmluaXRfZXNtNSgpO1xudmFyIFNlcnZpY2VEZXRlY3RvciA9IGNsYXNzIHtcbiAgc2VydmljZU5hbWU7XG4gIGF0dHJpYnV0ZXM7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuc2VydmljZU5hbWUgPSBjb25maWc/LnNlcnZpY2VOYW1lIHx8IHByb2Nlc3MuZW52Lk9URUxfU0VSVklDRV9OQU1FO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGNvbmZpZz8uYXR0cmlidXRlcyBpbnN0YW5jZW9mIFJlc291cmNlID8gY29uZmlnLmF0dHJpYnV0ZXMuYXR0cmlidXRlcyA6IGNvbmZpZz8uYXR0cmlidXRlcyB8fCB7fTtcbiAgfVxuICBkZXRlY3QoX2NvbmZpZykge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlTmFtZSB8fCAhdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gUmVzb3VyY2UuZW1wdHkoKTtcbiAgICB9XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIFwic2VydmljZS5uYW1lXCI6IHRoaXMuc2VydmljZU5hbWUsXG4gICAgICBcInNlcnZpY2UubmFtZXNwYWNlXCI6IHRoaXMuc2VydmljZU5hbWUsXG4gICAgICAuLi50aGlzLmF0dHJpYnV0ZXNcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUmVzb3VyY2UoYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNvdXJjZXMva295ZWIudHNcbmluaXRfZXNtNSgpO1xuaW5pdF9lc20yKCk7XG52YXIgS295ZWJEZXRlY3RvciA9IGNsYXNzIHtcbiAgZGV0ZWN0KF9jb25maWcpIHtcbiAgICBpZiAoIXByb2Nlc3MuZW52LktPWUVCX0FQUF9OQU1FKSB7XG4gICAgICByZXR1cm4gUmVzb3VyY2UuZW1wdHkoKTtcbiAgICB9XG4gICAgY29uc3QgcG9ydFByb3RvY29scyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJLT1lFQl9QT1JUX1wiKSk7XG4gICAgY29uc3QgcHJvdG9jb2xzID0gcG9ydFByb3RvY29scy5yZWR1Y2UoKHN1bSwgZWwpID0+ICh7XG4gICAgICAuLi5zdW0sXG4gICAgICBbZWwucmVwbGFjZShcIl9cIiwgXCIuXCIpLnRvTG93ZXJDYXNlKCldOiBwcm9jZXNzLmVudltlbF1cbiAgICB9KSwge30pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuQ0xPVURfUFJPVklERVJdOiBTdHJpbmcoXG4gICAgICAgIFwiS295ZWJcIlxuICAgICAgKSxcbiAgICAgIFtTZW1hbnRpY1Jlc291cmNlQXR0cmlidXRlcy5DTE9VRF9QTEFURk9STV06IFN0cmluZyhcbiAgICAgICAgXCJLb3llYiBNaWNyb1ZNXCJcbiAgICAgICksXG4gICAgICBbU2VtYW50aWNSZXNvdXJjZUF0dHJpYnV0ZXMuQ0xPVURfUkVHSU9OXTogU3RyaW5nKHByb2Nlc3MuZW52LktPWUVCX0RDKSxcbiAgICAgIFwia295ZWIuYXBwLm5hbWVcIjogU3RyaW5nKHByb2Nlc3MuZW52LktPWUVCX0FQUF9OQU1FKSxcbiAgICAgIFwia295ZWIuYXBwLmlkXCI6IFN0cmluZyhwcm9jZXNzLmVudi5LT1lFQl9BUFBfSUQpLFxuICAgICAgXCJrb3llYi5vcmdhbml6YXRpb24ubmFtZVwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfT1JHQU5JWkFUSU9OX05BTUUpLFxuICAgICAgXCJrb3llYi5vcmdhbml6YXRpb24uaWRcIjogU3RyaW5nKHByb2Nlc3MuZW52LktPWUVCX09SR0FOSVpBVElPTl9JRCksXG4gICAgICBcImtveWViLnNlcnZpY2UubmFtZVwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfU0VSVklDRV9OQU1FKSxcbiAgICAgIFwia295ZWIuc2VydmljZS5pZFwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfU0VSVklDRV9JRCksXG4gICAgICBcImtveWViLnNlcnZpY2UucHJpdmF0ZURvbWFpblwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfU0VSVklDRV9QUklWQVRFX0RPTUFJTiksXG4gICAgICBcImtveWViLnB1YmxpY0RvbWFpblwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfUFVCTElDX0RPTUFJTiksXG4gICAgICBcImtveWViLnJlZ2lvblwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfUkVHSU9OKSxcbiAgICAgIFwia295ZWIucmVnaW9uYWxEZXBsb3ltZW50SWRcIjogU3RyaW5nKHByb2Nlc3MuZW52LktPWUVCX1JFR0lPTkFMX0RFUExPWU1FTlRfSUQpLFxuICAgICAgXCJrb3llYi5pbnN0YW5jZS5pZFwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfSU5TVEFOQ0VfSUQpLFxuICAgICAgXCJrb3llYi5pbnN0YW5jZS50eXBlXCI6IFN0cmluZyhwcm9jZXNzLmVudi5LT1lFQl9JTlNUQU5DRV9UWVBFKSxcbiAgICAgIFwia295ZWIuaW5zdGFuY2UubWVtb3J5XCI6IFN0cmluZyhwcm9jZXNzLmVudi5LT1lFQl9JTlNUQU5DRV9NRU1PUllfTUIpLFxuICAgICAgXCJrb3llYi5wcml2aWxlZ2VkXCI6IHByb2Nlc3MuZW52LktPWUVCX1BSSVZJTEVHRUQgPT09IFwidHJ1ZVwiLFxuICAgICAgXCJrb3llYi5oeXBlcnZpc29yLmlkXCI6IFN0cmluZyhwcm9jZXNzLmVudi5LT1lFQl9IWVBFUlZJU09SX0lEKSxcbiAgICAgIFwia295ZWIuZGNcIjogU3RyaW5nKHByb2Nlc3MuZW52LktPWUVCX0RDKSxcbiAgICAgIFwia295ZWIuZG9ja2VyLnJlZlwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfRE9DS0VSX1JFRiksXG4gICAgICBcImtveWViLmdpdC5zaGFcIjogU3RyaW5nKHByb2Nlc3MuZW52LktPWUVCX0dJVF9TSEEpLFxuICAgICAgXCJrb3llYi5naXQuYnJhbmNoXCI6IFN0cmluZyhwcm9jZXNzLmVudi5LT1lFQl9HSVRfQlJBTkNIKSxcbiAgICAgIFwia295ZWIuZ2l0LmNvbW1pdC5hdXRob3JcIjogU3RyaW5nKHByb2Nlc3MuZW52LktPWUVCX0dJVF9DT01NSVRfQVVUSE9SKSxcbiAgICAgIFwia295ZWIuZ2l0LmNvbW1pdC5tZXNzYWdlXCI6IFN0cmluZyhwcm9jZXNzLmVudi5LT1lFQl9HSVRfQ09NTUlUX01FU1NBR0UpLFxuICAgICAgXCJrb3llYi5naXQucmVwb3NpdG9yeVwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfR0lUX1JFUE9TSVRPUlkpLFxuICAgICAgLi4ucHJvdG9jb2xzLFxuICAgICAgLy8gU0VUIE9URUwgU1BFQ0lBTCBBVFRSSUJVVEVTXG4gICAgICBcInNlcnZpY2UubmFtZVwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfQVBQX05BTUUpLFxuICAgICAgXCJzZXJ2aWNlLm5hbWVzcGFjZVwiOiBTdHJpbmcocHJvY2Vzcy5lbnYuS09ZRUJfU0VSVklDRV9OQU1FKVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZShhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuLy8gc3JjL2Jhc2VsaW1lLnRzXG52YXIgQmFzZWxpbWVTREsgPSBjbGFzcyB7XG4gIG9wdGlvbnM7XG4gIGF0dHJpYnV0ZXM7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnNlcnZlcmxlc3MgPSBvcHRpb25zLnNlcnZlcmxlc3MgfHwgZmFsc2U7XG4gICAgb3B0aW9ucy5jb2xsZWN0b3JVcmwgPSBvcHRpb25zLmNvbGxlY3RvclVybCB8fCBwcm9jZXNzLmVudi5DT0xMRUNUT1JfVVJMIHx8IFwiaHR0cHM6Ly9vdGVsLmJhc2VsaW1lLmlvL3YxXCI7XG4gICAgb3B0aW9ucy5iYXNlbGltZUtleSA9IG9wdGlvbnMuYmFzZWxpbWVLZXkgfHwgcHJvY2Vzcy5lbnYuQkFTRUxJTUVfQVBJX0tFWSB8fCBwcm9jZXNzLmVudi5CQVNFTElNRV9LRVk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBzdGFydCgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuT1RFTF9MT0dfTEVWRUwgPT09IFwiZGVidWdcIikge1xuICAgICAgZXNtX2RlZmF1bHQuZGlhZy5zZXRMb2dnZXIobmV3IERpYWdDb25zb2xlTG9nZ2VyKCksIERpYWdMb2dMZXZlbC5BTEwpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBpbXBvcnRfc2RrX3RyYWNlX25vZGUuTm9kZVRyYWNlclByb3ZpZGVyKHtcbiAgICAgIHNhbXBsZXI6IHRoaXMub3B0aW9ucy5zYW1wbGVyLFxuICAgICAgcmVzb3VyY2U6IGRldGVjdFJlc291cmNlc1N5bmMoe1xuICAgICAgICBkZXRlY3RvcnM6IFtcbiAgICAgICAgICBpbXBvcnRfcmVzb3VyY2VfZGV0ZWN0b3JfYXdzLmF3c0xhbWJkYURldGVjdG9yLFxuICAgICAgICAgIG5ldyBWZXJjZWxEZXRlY3RvcigpLFxuICAgICAgICAgIG5ldyBLb3llYkRldGVjdG9yKCksXG4gICAgICAgICAgLi4udGhpcy5vcHRpb25zLnJlc291cmNlRGV0ZWN0b3JzIHx8IFtdLFxuICAgICAgICAgIG5ldyBTZXJ2aWNlRGV0ZWN0b3IoeyBzZXJ2aWNlTmFtZTogdGhpcy5vcHRpb25zLnNlcnZpY2UsIGF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5yZXNvdXJjZUF0dHJpYnV0ZXMgfSlcbiAgICAgICAgXVxuICAgICAgfSksXG4gICAgICBmb3JjZUZsdXNoVGltZW91dE1pbGxpczogNWUzXG4gICAgfSk7XG4gICAgbGV0IGV4cG9ydGVyID0gdm9pZCAwO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmJhc2VsaW1lS2V5KSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJObyBCYXNlbGltZSBBUEkga2V5IHByb3ZpZGVkLiBUcmFjZXMgd2lsbCBub3QgYmUgc2VudCB0byBCYXNlbGltZS5cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmFzZWxpbWVLZXkpIHtcbiAgICAgIGxldCBjb2xsZWN0b3JVcmwgPSB0aGlzLm9wdGlvbnMuY29sbGVjdG9yVXJsO1xuICAgICAgaWYgKCgwLCBpbXBvcnRfZnMzLmV4aXN0c1N5bmMpKFwiL29wdC9leHRlbnNpb25zL2Jhc2VsaW1lXCIpKSB7XG4gICAgICAgIGNvbGxlY3RvclVybCA9IFwiaHR0cDovL3NhbmRib3g6NDMyMy9vdGVsXCI7XG4gICAgICB9XG4gICAgICBleHBvcnRlciA9IG5ldyBPVExQVHJhY2VFeHBvcnRlcih7XG4gICAgICAgIHVybDogY29sbGVjdG9yVXJsLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJ4LWFwaS1rZXlcIjogdGhpcy5vcHRpb25zLmJhc2VsaW1lS2V5IHx8IHByb2Nlc3MuZW52LkJBU0VMSU1FX0tFWSB8fCBwcm9jZXNzLmVudi5CQVNFTElNRV9PVEVMX0tFWVxuICAgICAgICB9LFxuICAgICAgICB0aW1lb3V0TWlsbGlzOiAxZTNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxvZykge1xuICAgICAgZXhwb3J0ZXIgPSBuZXcgaW1wb3J0X3Nka190cmFjZV9ub2RlLkNvbnNvbGVTcGFuRXhwb3J0ZXIoKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydGVyKSB7XG4gICAgICBjb25zdCBzcGFuUHJvY2Vzc29yID0gdGhpcy5vcHRpb25zLnNlcnZlcmxlc3MgPyBuZXcgaW1wb3J0X3Nka190cmFjZV9ub2RlLlNpbXBsZVNwYW5Qcm9jZXNzb3IoZXhwb3J0ZXIpIDogbmV3IGltcG9ydF9zZGtfdHJhY2Vfbm9kZS5CYXRjaFNwYW5Qcm9jZXNzb3IoZXhwb3J0ZXIsIHtcbiAgICAgICAgbWF4UXVldWVTaXplOiAxMDAsXG4gICAgICAgIG1heEV4cG9ydEJhdGNoU2l6ZTogNVxuICAgICAgfSk7XG4gICAgICBwcm92aWRlci5hZGRTcGFuUHJvY2Vzc29yKHNwYW5Qcm9jZXNzb3IpO1xuICAgIH1cbiAgICBwcm92aWRlci5yZWdpc3RlcigpO1xuICAgIHJlZ2lzdGVySW5zdHJ1bWVudGF0aW9ucyh7XG4gICAgICBpbnN0cnVtZW50YXRpb25zOiBbXG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnN0cnVtZW50YXRpb25zIHx8IFtdXG4gICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xuICB9XG59O1xuXG4vLyBzcmMvaHR0cC50c1xudmFyIGltcG9ydF9odHRwID0gcmVxdWlyZShcImh0dHBcIik7XG5cbi8vIG5vZGVfbW9kdWxlcy9mbGF0L2luZGV4LmpzXG5mdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopO1xufVxuZnVuY3Rpb24ga2V5SWRlbnRpdHkoa2V5KSB7XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBmbGF0dGVuKHRhcmdldCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgY29uc3QgZGVsaW1pdGVyID0gb3B0cy5kZWxpbWl0ZXIgfHwgXCIuXCI7XG4gIGNvbnN0IG1heERlcHRoID0gb3B0cy5tYXhEZXB0aDtcbiAgY29uc3QgdHJhbnNmb3JtS2V5ID0gb3B0cy50cmFuc2Zvcm1LZXkgfHwga2V5SWRlbnRpdHk7XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBmdW5jdGlvbiBzdGVwKG9iamVjdCwgcHJldiwgY3VycmVudERlcHRoKSB7XG4gICAgY3VycmVudERlcHRoID0gY3VycmVudERlcHRoIHx8IDE7XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIGNvbnN0IGlzYXJyYXkgPSBvcHRzLnNhZmUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGNvbnN0IGlzYnVmZmVyID0gaXNCdWZmZXIodmFsdWUpO1xuICAgICAgY29uc3QgaXNvYmplY3QgPSB0eXBlID09PSBcIltvYmplY3QgT2JqZWN0XVwiIHx8IHR5cGUgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgIGNvbnN0IG5ld0tleSA9IHByZXYgPyBwcmV2ICsgZGVsaW1pdGVyICsgdHJhbnNmb3JtS2V5KGtleSkgOiB0cmFuc2Zvcm1LZXkoa2V5KTtcbiAgICAgIGlmICghaXNhcnJheSAmJiAhaXNidWZmZXIgJiYgaXNvYmplY3QgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCAmJiAoIW9wdHMubWF4RGVwdGggfHwgY3VycmVudERlcHRoIDwgbWF4RGVwdGgpKSB7XG4gICAgICAgIHJldHVybiBzdGVwKHZhbHVlLCBuZXdLZXksIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgfVxuICAgICAgb3V0cHV0W25ld0tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuICBzdGVwKHRhcmdldCk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIHNyYy9odHRwL2luZGV4LnRzXG5pbml0X2VzbSgpO1xuaW5pdF9lc20zKCk7XG52YXIgdXJsMyA9IF9fdG9FU00ocmVxdWlyZShcInVybFwiKSwgMSk7XG5cbi8vIHNyYy9odHRwL3V0aWxzLnRzXG5pbml0X2VzbSgpO1xuaW5pdF9lc20yKCk7XG5pbml0X2VzbTMoKTtcbnZhciB1cmwyID0gX190b0VTTShyZXF1aXJlKFwidXJsXCIpLCAxKTtcbnZhciBnZXRBYnNvbHV0ZVVybCA9IChyZXF1ZXN0VXJsLCBoZWFkZXJzLCBmYWxsYmFja1Byb3RvY29sID0gXCJodHRwOlwiKSA9PiB7XG4gIGNvbnN0IHJlcVVybE9iamVjdCA9IHJlcXVlc3RVcmwgfHwge307XG4gIGNvbnN0IHByb3RvY29sID0gcmVxVXJsT2JqZWN0LnByb3RvY29sIHx8IGZhbGxiYWNrUHJvdG9jb2w7XG4gIGNvbnN0IHBvcnQgPSAocmVxVXJsT2JqZWN0LnBvcnQgfHwgXCJcIikudG9TdHJpbmcoKTtcbiAgY29uc3QgcGF0aDMgPSByZXFVcmxPYmplY3QucGF0aCB8fCBcIi9cIjtcbiAgbGV0IGhvc3QgPSByZXFVcmxPYmplY3QuaG9zdCB8fCByZXFVcmxPYmplY3QuaG9zdG5hbWUgfHwgaGVhZGVycy5ob3N0IHx8IFwibG9jYWxob3N0XCI7XG4gIGlmIChob3N0LmluZGV4T2YoXCI6XCIpID09PSAtMSAmJiBwb3J0ICYmIHBvcnQgIT09IFwiODBcIiAmJiBwb3J0ICE9PSBcIjQ0M1wiKSB7XG4gICAgaG9zdCArPSBgOiR7cG9ydH1gO1xuICB9XG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdH0ke3BhdGgzfWA7XG59O1xudmFyIHBhcnNlUmVzcG9uc2VTdGF0dXMgPSAoa2luZCwgc3RhdHVzQ29kZSkgPT4ge1xuICBjb25zdCB1cHBlckJvdW5kID0ga2luZCA9PT0gU3BhbktpbmQuQ0xJRU5UID8gNDAwIDogNTAwO1xuICBpZiAoc3RhdHVzQ29kZSAmJiBzdGF0dXNDb2RlID49IDEwMCAmJiBzdGF0dXNDb2RlIDwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBTcGFuU3RhdHVzQ29kZS5VTlNFVDtcbiAgfVxuICByZXR1cm4gU3BhblN0YXR1c0NvZGUuRVJST1I7XG59O1xudmFyIHNhdGlzZmllc1BhdHRlcm4gPSAoY29uc3RhbnQsIHBhdHRlcm4pID0+IHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4gPT09IGNvbnN0YW50O1xuICB9IGVsc2UgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KGNvbnN0YW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4oY29uc3RhbnQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXR0ZXJuIGlzIGluIHVuc3VwcG9ydGVkIGRhdGF0eXBlXCIpO1xuICB9XG59O1xudmFyIGlzSWdub3JlZCA9IChjb25zdGFudCwgbGlzdCwgb25FeGNlcHRpb24pID0+IHtcbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGxpc3QpIHtcbiAgICAgIGlmIChzYXRpc2ZpZXNQYXR0ZXJuKGNvbnN0YW50LCBwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAob25FeGNlcHRpb24pIHtcbiAgICAgIG9uRXhjZXB0aW9uKGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIHNldFNwYW5XaXRoRXJyb3IgPSAoc3BhbiwgZXJyb3IpID0+IHtcbiAgY29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgW1wiaHR0cC5lcnJvcl9uYW1lXCIgLyogSFRUUF9FUlJPUl9OQU1FICovXTogZXJyb3IubmFtZSxcbiAgICBbXCJodHRwLmVycm9yX21lc3NhZ2VcIiAvKiBIVFRQX0VSUk9SX01FU1NBR0UgKi9dOiBtZXNzYWdlXG4gIH0pO1xuICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLCBtZXNzYWdlIH0pO1xuICBzcGFuLnJlY29yZEV4Y2VwdGlvbihlcnJvcik7XG59O1xudmFyIHNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlID0gKHJlcXVlc3QzLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGxlbmd0aCA9IGdldENvbnRlbnRMZW5ndGgocmVxdWVzdDMuaGVhZGVycyk7XG4gIGlmIChsZW5ndGggPT09IG51bGwpXG4gICAgcmV0dXJuO1xuICBpZiAoaXNDb21wcmVzc2VkKHJlcXVlc3QzLmhlYWRlcnMpKSB7XG4gICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIXSA9IGxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VEXSA9IGxlbmd0aDtcbiAgfVxufTtcbnZhciBzZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSAocmVzcG9uc2UsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0Q29udGVudExlbmd0aChyZXNwb25zZS5oZWFkZXJzKTtcbiAgaWYgKGxlbmd0aCA9PT0gbnVsbClcbiAgICByZXR1cm47XG4gIGlmIChpc0NvbXByZXNzZWQocmVzcG9uc2UuaGVhZGVycykpIHtcbiAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIXSA9IGxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRF0gPSBsZW5ndGg7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRDb250ZW50TGVuZ3RoKGhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudExlbmd0aEhlYWRlciA9IGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXTtcbiAgaWYgKGNvbnRlbnRMZW5ndGhIZWFkZXIgPT09IHZvaWQgMClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgY29udGVudExlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZWFkZXIsIDEwKTtcbiAgaWYgKGlzTmFOKGNvbnRlbnRMZW5ndGgpKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gY29udGVudExlbmd0aDtcbn1cbnZhciBpc0NvbXByZXNzZWQgPSAoaGVhZGVycykgPT4ge1xuICBjb25zdCBlbmNvZGluZyA9IGhlYWRlcnNbXCJjb250ZW50LWVuY29kaW5nXCJdO1xuICByZXR1cm4gISFlbmNvZGluZyAmJiBlbmNvZGluZyAhPT0gXCJpZGVudGl0eVwiO1xufTtcbnZhciBnZXRSZXF1ZXN0SW5mbyA9IChvcHRpb25zLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgbGV0IHBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBvcmlnaW4gPSBcIlwiO1xuICBsZXQgb3B0aW9uc1BhcnNlZDtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgb3B0aW9uc1BhcnNlZCA9IHVybDIucGFyc2Uob3B0aW9ucyk7XG4gICAgcGF0aG5hbWUgPSBvcHRpb25zUGFyc2VkLnBhdGhuYW1lIHx8IFwiL1wiO1xuICAgIG9yaWdpbiA9IGAke29wdGlvbnNQYXJzZWQucHJvdG9jb2wgfHwgXCJodHRwOlwifS8vJHtvcHRpb25zUGFyc2VkLmhvc3R9YDtcbiAgICBpZiAoZXh0cmFPcHRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc1BhcnNlZCwgZXh0cmFPcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIHVybDIuVVJMKSB7XG4gICAgb3B0aW9uc1BhcnNlZCA9IHtcbiAgICAgIHByb3RvY29sOiBvcHRpb25zLnByb3RvY29sLFxuICAgICAgaG9zdG5hbWU6IHR5cGVvZiBvcHRpb25zLmhvc3RuYW1lID09PSBcInN0cmluZ1wiICYmIG9wdGlvbnMuaG9zdG5hbWUuc3RhcnRzV2l0aChcIltcIikgPyBvcHRpb25zLmhvc3RuYW1lLnNsaWNlKDEsIC0xKSA6IG9wdGlvbnMuaG9zdG5hbWUsXG4gICAgICBwYXRoOiBgJHtvcHRpb25zLnBhdGhuYW1lIHx8IFwiXCJ9JHtvcHRpb25zLnNlYXJjaCB8fCBcIlwifWBcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLnBvcnQgIT09IFwiXCIpIHtcbiAgICAgIG9wdGlvbnNQYXJzZWQucG9ydCA9IE51bWJlcihvcHRpb25zLnBvcnQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51c2VybmFtZSB8fCBvcHRpb25zLnBhc3N3b3JkKSB7XG4gICAgICBvcHRpb25zUGFyc2VkLmF1dGggPSBgJHtvcHRpb25zLnVzZXJuYW1lfToke29wdGlvbnMucGFzc3dvcmR9YDtcbiAgICB9XG4gICAgcGF0aG5hbWUgPSBvcHRpb25zLnBhdGhuYW1lO1xuICAgIG9yaWdpbiA9IG9wdGlvbnMub3JpZ2luO1xuICAgIGlmIChleHRyYU9wdGlvbnMgIT09IHZvaWQgMCkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zUGFyc2VkLCBleHRyYU9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zUGFyc2VkID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHsgcHJvdG9jb2w6IG9wdGlvbnMuaG9zdCA/IFwiaHR0cDpcIiA6IHZvaWQgMCB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcGF0aG5hbWUgPSBvcHRpb25zLnBhdGhuYW1lO1xuICAgIGlmICghcGF0aG5hbWUgJiYgb3B0aW9uc1BhcnNlZC5wYXRoKSB7XG4gICAgICBwYXRobmFtZSA9IHVybDIucGFyc2Uob3B0aW9uc1BhcnNlZC5wYXRoKS5wYXRobmFtZSB8fCBcIi9cIjtcbiAgICB9XG4gICAgY29uc3QgaG9zdG5hbWUyID0gb3B0aW9uc1BhcnNlZC5ob3N0IHx8IChvcHRpb25zUGFyc2VkLnBvcnQgIT0gbnVsbCA/IGAke29wdGlvbnNQYXJzZWQuaG9zdG5hbWV9JHtvcHRpb25zUGFyc2VkLnBvcnR9YCA6IG9wdGlvbnNQYXJzZWQuaG9zdG5hbWUpO1xuICAgIG9yaWdpbiA9IGAke29wdGlvbnNQYXJzZWQucHJvdG9jb2wgfHwgXCJodHRwOlwifS8vJHtob3N0bmFtZTJ9YDtcbiAgfVxuICBjb25zdCBtZXRob2QgPSBvcHRpb25zUGFyc2VkLm1ldGhvZCA/IG9wdGlvbnNQYXJzZWQubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiO1xuICByZXR1cm4geyBvcmlnaW4sIHBhdGhuYW1lLCBtZXRob2QsIG9wdGlvbnNQYXJzZWQgfTtcbn07XG52YXIgaXNWYWxpZE9wdGlvbnNUeXBlID0gKG9wdGlvbnMpID0+IHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2Ygb3B0aW9ucztcbiAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKTtcbn07XG52YXIgZXh0cmFjdEhvc3RuYW1lQW5kUG9ydCA9IChyZXF1ZXN0T3B0aW9ucykgPT4ge1xuICBpZiAocmVxdWVzdE9wdGlvbnMuaG9zdG5hbWUgJiYgcmVxdWVzdE9wdGlvbnMucG9ydCkge1xuICAgIHJldHVybiB7IGhvc3RuYW1lOiByZXF1ZXN0T3B0aW9ucy5ob3N0bmFtZSwgcG9ydDogcmVxdWVzdE9wdGlvbnMucG9ydCB9O1xuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSByZXF1ZXN0T3B0aW9ucy5ob3N0Py5tYXRjaCgvXihbXjovIF0rKSg6XFxkezEsNX0pPy8pIHx8IG51bGw7XG4gIGNvbnN0IGhvc3RuYW1lMiA9IHJlcXVlc3RPcHRpb25zLmhvc3RuYW1lIHx8IChtYXRjaGVzID09PSBudWxsID8gXCJsb2NhbGhvc3RcIiA6IG1hdGNoZXNbMV0pO1xuICBsZXQgcG9ydCA9IHJlcXVlc3RPcHRpb25zLnBvcnQ7XG4gIGlmICghcG9ydCkge1xuICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXNbMl0pIHtcbiAgICAgIHBvcnQgPSBtYXRjaGVzWzJdLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9ydCA9IHJlcXVlc3RPcHRpb25zLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaG9zdG5hbWU6IGhvc3RuYW1lMiwgcG9ydCB9O1xufTtcbnZhciBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzID0gKHJlcXVlc3RPcHRpb25zLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGhvc3RuYW1lMiA9IG9wdGlvbnMuaG9zdG5hbWU7XG4gIGNvbnN0IHBvcnQgPSBvcHRpb25zLnBvcnQ7XG4gIGNvbnN0IHJlcXVlc3RNZXRob2QgPSByZXF1ZXN0T3B0aW9ucy5tZXRob2Q7XG4gIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3RNZXRob2QgPyByZXF1ZXN0TWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiO1xuICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdE9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgY29uc3QgdXNlckFnZW50ID0gaGVhZGVyc1tcInVzZXItYWdlbnRcIl07XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1VSTF06IGdldEFic29sdXRlVXJsKFxuICAgICAgcmVxdWVzdE9wdGlvbnMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYCR7b3B0aW9ucy5jb21wb25lbnR9OmBcbiAgICApLFxuICAgIFtTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9NRVRIT0RdOiBtZXRob2QsXG4gICAgW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1RBUkdFVF06IHJlcXVlc3RPcHRpb25zLnBhdGggfHwgXCIvXCIsXG4gICAgW1NlbWFudGljQXR0cmlidXRlcy5ORVRfUEVFUl9OQU1FXTogaG9zdG5hbWUyLFxuICAgIFtTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9IT1NUXTogcmVxdWVzdE9wdGlvbnMuaGVhZGVycz8uaG9zdCA/PyBgJHtob3N0bmFtZTJ9OiR7cG9ydH1gXG4gIH07XG4gIGlmICh1c2VyQWdlbnQgIT09IHZvaWQgMCkge1xuICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfVVNFUl9BR0VOVF0gPSB1c2VyQWdlbnQ7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgb3B0aW9ucy5ob29rQXR0cmlidXRlcyk7XG59O1xudmFyIGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICBtZXRyaWNBdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX01FVEhPRF0gPSBzcGFuQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9NRVRIT0RdO1xuICBtZXRyaWNBdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5ORVRfUEVFUl9OQU1FXSA9IHNwYW5BdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5ORVRfUEVFUl9OQU1FXTtcbiAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xudmFyIGdldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQgPSAoa2luZCkgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGlmIChraW5kKSB7XG4gICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9GTEFWT1JdID0ga2luZDtcbiAgICBpZiAoa2luZC50b1VwcGVyQ2FzZSgpICE9PSBcIlFVSUNcIikge1xuICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuTkVUX1RSQU5TUE9SVF0gPSBOZXRUcmFuc3BvcnRWYWx1ZXMuSVBfVENQO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5ORVRfVFJBTlNQT1JUXSA9IE5ldFRyYW5zcG9ydFZhbHVlcy5JUF9VRFA7XG4gICAgfVxuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcbnZhciBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICBjb25zdCB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGh0dHBWZXJzaW9uLCBzb2NrZXQgfSA9IHJlc3BvbnNlO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGlmIChzb2NrZXQpIHtcbiAgICBjb25zdCB7IHJlbW90ZUFkZHJlc3MsIHJlbW90ZVBvcnQgfSA9IHNvY2tldDtcbiAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5ORVRfUEVFUl9JUF0gPSByZW1vdGVBZGRyZXNzO1xuICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLk5FVF9QRUVSX1BPUlRdID0gcmVtb3RlUG9ydDtcbiAgfVxuICBzZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGUocmVzcG9uc2UsIGF0dHJpYnV0ZXMpO1xuICBpZiAoc3RhdHVzQ29kZSkge1xuICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfU1RBVFVTX0NPREVdID0gc3RhdHVzQ29kZTtcbiAgICBhdHRyaWJ1dGVzW1wiaHR0cC5zdGF0dXNfdGV4dFwiIC8qIEhUVFBfU1RBVFVTX1RFWFQgKi9dID0gKHN0YXR1c01lc3NhZ2UgfHwgXCJcIikudG9VcHBlckNhc2UoKTtcbiAgfVxuICBjb25zdCBodHRwS2luZEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kKGh0dHBWZXJzaW9uKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgaHR0cEtpbmRBdHRyaWJ1dGVzKTtcbn07XG52YXIgZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICBtZXRyaWNBdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5ORVRfUEVFUl9QT1JUXSA9IHNwYW5BdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5ORVRfUEVFUl9QT1JUXTtcbiAgbWV0cmljQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9TVEFUVVNfQ09ERV0gPSBzcGFuQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9TVEFUVVNfQ09ERV07XG4gIG1ldHJpY0F0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfRkxBVk9SXSA9IHNwYW5BdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX0ZMQVZPUl07XG4gIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbnZhciBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzID0gKHJlcXVlc3QzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0My5oZWFkZXJzO1xuICBjb25zdCB1c2VyQWdlbnQgPSBoZWFkZXJzW1widXNlci1hZ2VudFwiXTtcbiAgY29uc3QgaXBzID0gaGVhZGVyc1tcIngtZm9yd2FyZGVkLWZvclwiXTtcbiAgY29uc3QgbWV0aG9kID0gcmVxdWVzdDMubWV0aG9kIHx8IFwiR0VUXCI7XG4gIGNvbnN0IGh0dHBWZXJzaW9uID0gcmVxdWVzdDMuaHR0cFZlcnNpb247XG4gIGNvbnN0IHJlcXVlc3RVcmwgPSByZXF1ZXN0My51cmwgPyB1cmwyLnBhcnNlKHJlcXVlc3QzLnVybCkgOiBudWxsO1xuICBjb25zdCBob3N0ID0gcmVxdWVzdFVybD8uaG9zdCB8fCBoZWFkZXJzLmhvc3Q7XG4gIGNvbnN0IGhvc3RuYW1lMiA9IHJlcXVlc3RVcmw/Lmhvc3RuYW1lIHx8IGhvc3Q/LnJlcGxhY2UoL14oLiopKDpbMC05XXsxLDV9KS8sIFwiJDFcIikgfHwgXCJsb2NhbGhvc3RcIjtcbiAgY29uc3Qgc2VydmVyTmFtZSA9IG9wdGlvbnMuc2VydmVyTmFtZTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICBbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfVVJMXTogZ2V0QWJzb2x1dGVVcmwoXG4gICAgICByZXF1ZXN0VXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGAke29wdGlvbnMuY29tcG9uZW50fTpgXG4gICAgKSxcbiAgICBbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfSE9TVF06IGhvc3QsXG4gICAgW1NlbWFudGljQXR0cmlidXRlcy5ORVRfSE9TVF9OQU1FXTogaG9zdG5hbWUyLFxuICAgIFtTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9NRVRIT0RdOiBtZXRob2QsXG4gICAgW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1NDSEVNRV06IG9wdGlvbnMuY29tcG9uZW50XG4gIH07XG4gIGlmICh0eXBlb2YgaXBzID09PSBcInN0cmluZ1wiKSB7XG4gICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9DTElFTlRfSVBdID0gaXBzLnNwbGl0KFwiLFwiKVswXTtcbiAgfVxuICBpZiAodHlwZW9mIHNlcnZlck5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1NFUlZFUl9OQU1FXSA9IHNlcnZlck5hbWU7XG4gIH1cbiAgaWYgKHJlcXVlc3RVcmwpIHtcbiAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1RBUkdFVF0gPSByZXF1ZXN0VXJsLnBhdGggfHwgXCIvXCI7XG4gIH1cbiAgaWYgKHVzZXJBZ2VudCAhPT0gdm9pZCAwKSB7XG4gICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9VU0VSX0FHRU5UXSA9IHVzZXJBZ2VudDtcbiAgfVxuICBzZXRSZXF1ZXN0Q29udGVudExlbmd0aEF0dHJpYnV0ZShyZXF1ZXN0MywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IGh0dHBLaW5kQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQoaHR0cFZlcnNpb24pO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBodHRwS2luZEF0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xufTtcbnZhciBnZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzID0gKHNwYW5BdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IG1ldHJpY0F0dHJpYnV0ZXMgPSB7fTtcbiAgbWV0cmljQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9TQ0hFTUVdID0gc3BhbkF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfU0NIRU1FXTtcbiAgbWV0cmljQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9NRVRIT0RdID0gc3BhbkF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfTUVUSE9EXTtcbiAgbWV0cmljQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuTkVUX0hPU1RfTkFNRV0gPSBzcGFuQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuTkVUX0hPU1RfTkFNRV07XG4gIG1ldHJpY0F0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfRkxBVk9SXSA9IHNwYW5BdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX0ZMQVZPUl07XG4gIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbnZhciBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChyZXF1ZXN0MywgcmVzcG9uc2UpID0+IHtcbiAgY29uc3QgeyBzb2NrZXQgfSA9IHJlcXVlc3QzO1xuICBjb25zdCB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UgfSA9IHJlc3BvbnNlO1xuICBjb25zdCBycGNNZXRhZGF0YSA9IGdldFJQQ01ldGFkYXRhKGNvbnRleHQuYWN0aXZlKCkpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gIGlmIChzb2NrZXQpIHtcbiAgICBjb25zdCB7IGxvY2FsQWRkcmVzcywgbG9jYWxQb3J0LCByZW1vdGVBZGRyZXNzLCByZW1vdGVQb3J0IH0gPSBzb2NrZXQ7XG4gICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuTkVUX0hPU1RfSVBdID0gbG9jYWxBZGRyZXNzO1xuICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLk5FVF9IT1NUX1BPUlRdID0gbG9jYWxQb3J0O1xuICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLk5FVF9QRUVSX0lQXSA9IHJlbW90ZUFkZHJlc3M7XG4gICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuTkVUX1BFRVJfUE9SVF0gPSByZW1vdGVQb3J0O1xuICB9XG4gIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfU1RBVFVTX0NPREVdID0gc3RhdHVzQ29kZTtcbiAgYXR0cmlidXRlc1tcImh0dHAuc3RhdHVzX3RleHRcIiAvKiBIVFRQX1NUQVRVU19URVhUICovXSA9IChzdGF0dXNNZXNzYWdlIHx8IFwiXCIpLnRvVXBwZXJDYXNlKCk7XG4gIGlmIChycGNNZXRhZGF0YT8udHlwZSA9PT0gUlBDVHlwZS5IVFRQICYmIHJwY01ldGFkYXRhLnJvdXRlICE9PSB2b2lkIDApIHtcbiAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1JPVVRFXSA9IHJwY01ldGFkYXRhLnJvdXRlO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcbnZhciBnZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChzcGFuQXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0ge307XG4gIG1ldHJpY0F0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfU1RBVFVTX0NPREVdID0gc3BhbkF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfU1RBVFVTX0NPREVdO1xuICBtZXRyaWNBdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5ORVRfSE9TVF9QT1JUXSA9IHNwYW5BdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5ORVRfSE9TVF9QT1JUXTtcbiAgaWYgKHNwYW5BdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1JPVVRFXSAhPT0gdm9pZCAwKSB7XG4gICAgbWV0cmljQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9ST1VURV0gPSBzcGFuQXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9ST1VURV07XG4gIH1cbiAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZnVuY3Rpb24gaGVhZGVyQ2FwdHVyZSh0eXBlLCBoZWFkZXJzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRIZWFkZXJzID0gbmV3IE1hcChcbiAgICBoZWFkZXJzLm1hcCgoaGVhZGVyKSA9PiBbXG4gICAgICBoZWFkZXIudG9Mb3dlckNhc2UoKSxcbiAgICAgIGhlYWRlci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgXCJfXCIpXG4gICAgXSlcbiAgKTtcbiAgcmV0dXJuIChzcGFuLCBnZXRIZWFkZXIpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtjYXB0dXJlZEhlYWRlciwgbm9ybWFsaXplZEhlYWRlcl0gb2Ygbm9ybWFsaXplZEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0SGVhZGVyKGNhcHR1cmVkSGVhZGVyKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gYGh0dHAuJHt0eXBlfS5oZWFkZXIuJHtub3JtYWxpemVkSGVhZGVyfWA7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGtleSwgW3ZhbHVlXSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoa2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9odHRwL2luZGV4LnRzXG5pbml0X2VzbTMoKTtcbnZhciBpbXBvcnRfZXZlbnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmluaXRfZXNtMigpO1xudmFyIEh0dHBJbnN0cnVtZW50YXRpb24gPSBjbGFzcyBleHRlbmRzIEluc3RydW1lbnRhdGlvbkJhc2Uge1xuICAvKioga2VlcCB0cmFjayBvbiBzcGFucyBub3QgZW5kZWQgKi9cbiAgX3NwYW5Ob3RFbmRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICBfaGVhZGVyQ2FwdHVyZTtcbiAgX2h0dHBTZXJ2ZXJEdXJhdGlvbkhpc3RvZ3JhbTtcbiAgX2h0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbTtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cFwiLCBcIjEuMFwiLCBjb25maWcpO1xuICAgIHRoaXMuX2hlYWRlckNhcHR1cmUgPSB0aGlzLl9jcmVhdGVIZWFkZXJDYXB0dXJlKCk7XG4gIH1cbiAgX3VwZGF0ZU1ldHJpY0luc3RydW1lbnRzKCkge1xuICAgIHRoaXMuX2h0dHBTZXJ2ZXJEdXJhdGlvbkhpc3RvZ3JhbSA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKFxuICAgICAgXCJodHRwLnNlcnZlci5kdXJhdGlvblwiLFxuICAgICAge1xuICAgICAgICBkZXNjcmlwdGlvbjogXCJNZWFzdXJlcyB0aGUgZHVyYXRpb24gb2YgaW5ib3VuZCBIVFRQIHJlcXVlc3RzLlwiLFxuICAgICAgICB1bml0OiBcIm1zXCIsXG4gICAgICAgIHZhbHVlVHlwZTogVmFsdWVUeXBlLkRPVUJMRVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5faHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oXG4gICAgICBcImh0dHAuY2xpZW50LmR1cmF0aW9uXCIsXG4gICAgICB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk1lYXN1cmVzIHRoZSBkdXJhdGlvbiBvZiBvdXRib3VuZCBIVFRQIHJlcXVlc3RzLlwiLFxuICAgICAgICB1bml0OiBcIm1zXCIsXG4gICAgICAgIHZhbHVlVHlwZTogVmFsdWVUeXBlLkRPVUJMRVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2dldENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICB9XG4gIHNldENvbmZpZyhjb25maWcpIHtcbiAgICBzdXBlci5zZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9oZWFkZXJDYXB0dXJlID0gdGhpcy5fY3JlYXRlSGVhZGVyQ2FwdHVyZSgpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgcmV0dXJuIFt0aGlzLl9nZXRIdHRwc0luc3RydW1lbnRhdGlvbigpLCB0aGlzLl9nZXRIdHRwSW5zdHJ1bWVudGF0aW9uKCldO1xuICB9XG4gIF9nZXRIdHRwSW5zdHJ1bWVudGF0aW9uKCkge1xuICAgIGNvbnN0IHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gICAgcmV0dXJuIG5ldyBJbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbihcbiAgICAgIFwiaHR0cFwiLFxuICAgICAgW1wiKlwiXSxcbiAgICAgIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgIHRoaXMuX2RpYWcuZGVidWcoYEFwcGx5aW5nIHBhdGNoIGZvciBodHRwQCR7dmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKGlzV3JhcHBlZDIobW9kdWxlRXhwb3J0cy5yZXF1ZXN0KSkge1xuICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCBcInJlcXVlc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcChcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzLFxuICAgICAgICAgIFwicmVxdWVzdFwiLFxuICAgICAgICAgIHRoaXMuX2dldFBhdGNoT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oXCJodHRwXCIpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpc1dyYXBwZWQyKG1vZHVsZUV4cG9ydHMuZ2V0KSkge1xuICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCBcImdldFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cmFwKFxuICAgICAgICAgIG1vZHVsZUV4cG9ydHMsXG4gICAgICAgICAgXCJnZXRcIixcbiAgICAgICAgICB0aGlzLl9nZXRQYXRjaE91dGdvaW5nR2V0RnVuY3Rpb24obW9kdWxlRXhwb3J0cy5yZXF1ZXN0KVxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNXcmFwcGVkMihtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUuZW1pdCkpIHtcbiAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5TZXJ2ZXIucHJvdG90eXBlLCBcImVtaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcChcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsXG4gICAgICAgICAgXCJlbWl0XCIsXG4gICAgICAgICAgdGhpcy5fZ2V0UGF0Y2hJbmNvbWluZ1JlcXVlc3RGdW5jdGlvbihcImh0dHBcIilcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgICB9LFxuICAgICAgKG1vZHVsZUV4cG9ydHMpID0+IHtcbiAgICAgICAgaWYgKG1vZHVsZUV4cG9ydHMgPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2RpYWcuZGVidWcoYFJlbW92aW5nIHBhdGNoIGZvciBodHRwQCR7dmVyc2lvbn1gKTtcbiAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsIFwicmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsIFwiZ2V0XCIpO1xuICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5TZXJ2ZXIucHJvdG90eXBlLCBcImVtaXRcIik7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfZ2V0SHR0cHNJbnN0cnVtZW50YXRpb24oKSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgICByZXR1cm4gbmV3IEluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKFxuICAgICAgXCJodHRwc1wiLFxuICAgICAgW1wiKlwiXSxcbiAgICAgIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgIHRoaXMuX2RpYWcuZGVidWcoYEFwcGx5aW5nIHBhdGNoIGZvciBodHRwc0Ake3ZlcnNpb259YCk7XG4gICAgICAgIGlmIChpc1dyYXBwZWQyKG1vZHVsZUV4cG9ydHMucmVxdWVzdCkpIHtcbiAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgXCJyZXF1ZXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dyYXAoXG4gICAgICAgICAgbW9kdWxlRXhwb3J0cyxcbiAgICAgICAgICBcInJlcXVlc3RcIixcbiAgICAgICAgICB0aGlzLl9nZXRQYXRjaEh0dHBzT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oXCJodHRwc1wiKVxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNXcmFwcGVkMihtb2R1bGVFeHBvcnRzLmdldCkpIHtcbiAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgXCJnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcChcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzLFxuICAgICAgICAgIFwiZ2V0XCIsXG4gICAgICAgICAgdGhpcy5fZ2V0UGF0Y2hIdHRwc091dGdvaW5nR2V0RnVuY3Rpb24obW9kdWxlRXhwb3J0cy5yZXF1ZXN0KVxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNXcmFwcGVkMihtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUuZW1pdCkpIHtcbiAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5TZXJ2ZXIucHJvdG90eXBlLCBcImVtaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcChcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsXG4gICAgICAgICAgXCJlbWl0XCIsXG4gICAgICAgICAgdGhpcy5fZ2V0UGF0Y2hJbmNvbWluZ1JlcXVlc3RGdW5jdGlvbihcImh0dHBzXCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgICAgfSxcbiAgICAgIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgIGlmIChtb2R1bGVFeHBvcnRzID09PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9kaWFnLmRlYnVnKGBSZW1vdmluZyBwYXRjaCBmb3IgaHR0cHNAJHt2ZXJzaW9ufWApO1xuICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgXCJyZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgXCJnZXRcIik7XG4gICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsIFwiZW1pdFwiKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHNwYW5zIGZvciBpbmNvbWluZyByZXF1ZXN0cywgcmVzdG9yaW5nIHNwYW5zJyBjb250ZXh0IGlmIGFwcGxpZWQuXG4gICAqL1xuICBfZ2V0UGF0Y2hJbmNvbWluZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5faW5jb21pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50LCBvcmlnaW5hbCk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBzcGFucyBmb3Igb3V0Z29pbmcgcmVxdWVzdHMsIHNlbmRpbmcgc3BhbnMnIGNvbnRleHQgZm9yIGRpc3RyaWJ1dGVkXG4gICAqIHRyYWNpbmcuXG4gICAqL1xuICBfZ2V0UGF0Y2hPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fb3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50LCBvcmlnaW5hbCk7XG4gICAgfTtcbiAgfVxuICBfZ2V0UGF0Y2hPdXRnb2luZ0dldEZ1bmN0aW9uKGNsaWVudFJlcXVlc3QpIHtcbiAgICByZXR1cm4gKF9vcmlnaW5hbCkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG91dGdvaW5nR2V0UmVxdWVzdChvcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IGNsaWVudFJlcXVlc3Qob3B0aW9ucywgLi4uYXJncyk7XG4gICAgICAgIHJlcS5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICAvKiogUGF0Y2hlcyBIVFRQUyBvdXRnb2luZyByZXF1ZXN0cyAqL1xuICBfZ2V0UGF0Y2hIdHRwc091dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaHR0cHNPdXRnb2luZ1JlcXVlc3Qob3B0aW9ucywgLi4uYXJncykge1xuICAgICAgICBpZiAoY29tcG9uZW50ID09PSBcImh0dHBzXCIgJiYgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucz8uY29uc3RydWN0b3I/Lm5hbWUgIT09IFwiVVJMXCIpIHtcbiAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9zZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9nZXRQYXRjaE91dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCkoXG4gICAgICAgICAgb3JpZ2luYWxcbiAgICAgICAgKShvcHRpb25zLCAuLi5hcmdzKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfc2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIG9wdGlvbnMucHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sIHx8IFwiaHR0cHM6XCI7XG4gICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IDQ0MztcbiAgfVxuICAvKiogUGF0Y2hlcyBIVFRQUyBvdXRnb2luZyBnZXQgcmVxdWVzdHMgKi9cbiAgX2dldFBhdGNoSHR0cHNPdXRnb2luZ0dldEZ1bmN0aW9uKGNsaWVudFJlcXVlc3QpIHtcbiAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBzT3V0Z29pbmdSZXF1ZXN0KG9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZ2V0UGF0Y2hPdXRnb2luZ0dldEZ1bmN0aW9uKGNsaWVudFJlcXVlc3QpKFxuICAgICAgICAgIG9yaWdpbmFsXG4gICAgICAgICkob3B0aW9ucywgLi4uYXJncyk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gYSBjbGllbnQgcmVxdWVzdCB0byBlbmQgc3BhbiBhbmQgYWRkIHNwYW4gYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcGFyYW0gc3BhbiByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgcmVwcmVzZW50aW5nIHRoZSBzdGFydCB0aW1lIG9mIHRoZSByZXF1ZXN0IHRvIGNhbGN1bGF0ZSBkdXJhdGlvbiBpbiBNZXRyaWNcbiAgICogQHBhcmFtIG1ldHJpY0F0dHJpYnV0ZXMgbWV0cmljIGF0dHJpYnV0ZXNcbiAgICovXG4gIF90cmFjZUNsaWVudFJlcXVlc3QocmVxdWVzdDMsIHNwYW4sIHN0YXJ0VGltZSwgbWV0cmljQXR0cmlidXRlcykge1xuICAgIGlmICh0aGlzLl9nZXRDb25maWcoKS5yZXF1ZXN0SG9vaykge1xuICAgICAgdGhpcy5fY2FsbFJlcXVlc3RIb29rKHNwYW4sIHJlcXVlc3QzKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlRmluaXNoZWQgPSBmYWxzZTtcbiAgICByZXF1ZXN0My5wcmVwZW5kTGlzdGVuZXIoXG4gICAgICBcInJlc3BvbnNlXCIsXG4gICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGhpcy5fZGlhZy5kZWJ1ZyhcIm91dGdvaW5nUmVxdWVzdCBvbiByZXNwb25zZSgpXCIpO1xuICAgICAgICBpZiAocmVxdWVzdDMubGlzdGVuZXJDb3VudChcInJlc3BvbnNlXCIpIDw9IDEpIHtcbiAgICAgICAgICByZXNwb25zZS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUF0dHJpYnV0ZXMgPSBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhyZXNwb25zZUF0dHJpYnV0ZXMpO1xuICAgICAgICBtZXRyaWNBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBtZXRyaWNBdHRyaWJ1dGVzLFxuICAgICAgICAgIGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlKHJlc3BvbnNlQXR0cmlidXRlcylcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXMuX2dldENvbmZpZygpLnJlc3BvbnNlSG9vaykge1xuICAgICAgICAgIHRoaXMuX2NhbGxSZXNwb25zZUhvb2soc3BhbiwgcmVzcG9uc2UsIHRoaXMsIHN0YXJ0VGltZSwgbWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZS5jbGllbnQuY2FwdHVyZVJlcXVlc3RIZWFkZXJzKFxuICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgKGhlYWRlcikgPT4gcmVxdWVzdDMuZ2V0SGVhZGVyKGhlYWRlcilcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZS5jbGllbnQuY2FwdHVyZVJlc3BvbnNlSGVhZGVycyhcbiAgICAgICAgICBzcGFuLFxuICAgICAgICAgIChoZWFkZXIpID0+IHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyXVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmJpbmQoY29udGV4dC5hY3RpdmUoKSwgcmVzcG9uc2UpO1xuICAgICAgICBjb25zdCBlbmRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2RpYWcuZGVidWcoXCJvdXRnb2luZ1JlcXVlc3Qgb24gZW5kKClcIik7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2VGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgbGV0IHN0YXR1cztcbiAgICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCAmJiAhcmVzcG9uc2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IHsgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0ge1xuICAgICAgICAgICAgICBjb2RlOiBwYXJzZVJlc3BvbnNlU3RhdHVzKFxuICAgICAgICAgICAgICAgIFNwYW5LaW5kLkNMSUVOVCxcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgaWYgKHRoaXMuX2dldENvbmZpZygpLmFwcGx5Q3VzdG9tQXR0cmlidXRlc09uU3Bhbikge1xuICAgICAgICAgICAgc2FmZUV4ZWN1dGVJblRoZU1pZGRsZShcbiAgICAgICAgICAgICAgKCkgPT4gdGhpcy5fZ2V0Q29uZmlnKCkuYXBwbHlDdXN0b21BdHRyaWJ1dGVzT25TcGFuKFxuICAgICAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICAgICAgcmVxdWVzdDMsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuX2dldENvbmZpZygpLnJlc3BvbnNlSG9vaykge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VIdHRwU3BhbihcbiAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgICAgU3BhbktpbmQuQ0xJRU5ULFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIG1ldHJpY0F0dHJpYnV0ZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgcmVzcG9uc2Uub24oaW1wb3J0X2V2ZW50cy5lcnJvck1vbml0b3IsIChlcnJvcikgPT4ge1xuICAgICAgICAgIHRoaXMuX2RpYWcuZGVidWcoXCJvdXRnb2luZ1JlcXVlc3Qgb24gZXJyb3IoKVwiLCBlcnJvcik7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2VGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgc2V0U3BhbldpdGhFcnJvcihzcGFuLCBlcnJvcik7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fY2xvc2VIdHRwU3BhbihcbiAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICBTcGFuS2luZC5DTElFTlQsXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICBtZXRyaWNBdHRyaWJ1dGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXF1ZXN0My5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2RpYWcuZGVidWcoXCJvdXRnb2luZ1JlcXVlc3Qgb24gcmVxdWVzdCBjbG9zZSgpXCIpO1xuICAgICAgaWYgKHJlcXVlc3QzLmFib3J0ZWQgfHwgcmVzcG9uc2VGaW5pc2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNwb25zZUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgIH0pO1xuICAgIHJlcXVlc3QzLm9uKGltcG9ydF9ldmVudHMuZXJyb3JNb25pdG9yLCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuX2RpYWcuZGVidWcoXCJvdXRnb2luZ1JlcXVlc3Qgb24gcmVxdWVzdCBlcnJvcigpXCIsIGVycm9yKTtcbiAgICAgIGlmIChyZXNwb25zZUZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlRmluaXNoZWQgPSB0cnVlO1xuICAgICAgc2V0U3BhbldpdGhFcnJvcihzcGFuLCBlcnJvcik7XG4gICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIFNwYW5LaW5kLkNMSUVOVCwgc3RhcnRUaW1lLCBtZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICB9KTtcbiAgICB0aGlzLl9kaWFnLmRlYnVnKFwiaHR0cC5DbGllbnRSZXF1ZXN0IHJldHVybiByZXF1ZXN0XCIpO1xuICAgIHJldHVybiByZXF1ZXN0MztcbiAgfVxuICBfaW5jb21pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50LCBvcmlnaW5hbCkge1xuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGluY29taW5nUmVxdWVzdChldmVudCwgLi4uYXJncykge1xuICAgICAgaWYgKGV2ZW50ICE9PSBcInJlcXVlc3RcIikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2V2ZW50LCAuLi5hcmdzXSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXF1ZXN0MyA9IGFyZ3NbMF07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGFyZ3NbMV07XG4gICAgICBjb25zdCBwYXRobmFtZSA9IHJlcXVlc3QzLnVybCA/IHVybDMucGFyc2UocmVxdWVzdDMudXJsKS5wYXRobmFtZSB8fCBcIi9cIiA6IFwiL1wiO1xuICAgICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdDMubWV0aG9kIHx8IFwiR0VUXCI7XG4gICAgICBpbnN0cnVtZW50YXRpb24uX2RpYWcuZGVidWcoXG4gICAgICAgIGAke2NvbXBvbmVudH0gaW5zdHJ1bWVudGF0aW9uIGluY29taW5nUmVxdWVzdGBcbiAgICAgICk7XG4gICAgICBpZiAoaXNJZ25vcmVkKFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9nZXRDb25maWcoKS5pZ25vcmVJbmNvbWluZ1BhdGhzLFxuICAgICAgICAoZSkgPT4gaW5zdHJ1bWVudGF0aW9uLl9kaWFnLmVycm9yKFwiY2F1Z2h0IGlnbm9yZUluY29taW5nUGF0aHMgZXJyb3I6IFwiLCBlKVxuICAgICAgKSB8fCBzYWZlRXhlY3V0ZUluVGhlTWlkZGxlKFxuICAgICAgICAoKSA9PiBpbnN0cnVtZW50YXRpb24uX2dldENvbmZpZygpLmlnbm9yZUluY29taW5nUmVxdWVzdEhvb2s/LihyZXF1ZXN0MyksXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9kaWFnLmVycm9yKFxuICAgICAgICAgICAgICBcImNhdWdodCBpZ25vcmVJbmNvbWluZ1JlcXVlc3RIb29rIGVycm9yOiBcIixcbiAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRydWVcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQud2l0aChzdXBwcmVzc1RyYWNpbmcoY29udGV4dC5hY3RpdmUoKSksICgpID0+IHtcbiAgICAgICAgICBjb250ZXh0LmJpbmQoY29udGV4dC5hY3RpdmUoKSwgcmVxdWVzdDMpO1xuICAgICAgICAgIGNvbnRleHQuYmluZChjb250ZXh0LmFjdGl2ZSgpLCByZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtldmVudCwgLi4uYXJnc10pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0My5oZWFkZXJzO1xuICAgICAgY29uc3Qgc3BhbkF0dHJpYnV0ZXMgPSBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzKHJlcXVlc3QzLCB7XG4gICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgc2VydmVyTmFtZTogaW5zdHJ1bWVudGF0aW9uLl9nZXRDb25maWcoKS5zZXJ2ZXJOYW1lLFxuICAgICAgICBob29rQXR0cmlidXRlczogaW5zdHJ1bWVudGF0aW9uLl9jYWxsU3RhcnRTcGFuSG9vayhcbiAgICAgICAgICByZXF1ZXN0MyxcbiAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2dldENvbmZpZygpLnN0YXJ0SW5jb21pbmdTcGFuSG9va1xuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgICAgICBraW5kOiBTcGFuS2luZC5TRVJWRVIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHNwYW5BdHRyaWJ1dGVzXG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gaHJUaW1lKCk7XG4gICAgICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0gZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyhzcGFuQXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBjdHggPSBwcm9wYWdhdGlvbi5leHRyYWN0KFJPT1RfQ09OVEVYVCwgaGVhZGVycyk7XG4gICAgICBjb25zdCBzcGFuID0gaW5zdHJ1bWVudGF0aW9uLl9zdGFydEh0dHBTcGFuKG1ldGhvZCwgc3Bhbk9wdGlvbnMsIGN0eCk7XG4gICAgICBjb25zdCBycGNNZXRhZGF0YSA9IHtcbiAgICAgICAgdHlwZTogUlBDVHlwZS5IVFRQLFxuICAgICAgICBzcGFuXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNvbnRleHQud2l0aChcbiAgICAgICAgc2V0UlBDTWV0YWRhdGEodHJhY2Uuc2V0U3BhbihjdHgsIHNwYW4pLCBycGNNZXRhZGF0YSksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjb250ZXh0LmJpbmQoY29udGV4dC5hY3RpdmUoKSwgcmVxdWVzdDMpO1xuICAgICAgICAgIGNvbnRleHQuYmluZChjb250ZXh0LmFjdGl2ZSgpLCByZXNwb25zZSk7XG4gICAgICAgICAgaWYgKGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uZmlnKCkucmVxdWVzdEhvb2spIHtcbiAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fY2FsbFJlcXVlc3RIb29rKHNwYW4sIHJlcXVlc3QzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uZmlnKCkucmVzcG9uc2VIb29rKSB7XG4gICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2NhbGxSZXNwb25zZUhvb2soc3BhbiwgcmVzcG9uc2UsIGluc3RydW1lbnRhdGlvbiwgc3RhcnRUaW1lLCBtZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9oZWFkZXJDYXB0dXJlLnNlcnZlci5jYXB0dXJlUmVxdWVzdEhlYWRlcnMoXG4gICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgKGhlYWRlcikgPT4gcmVxdWVzdDMuaGVhZGVyc1toZWFkZXJdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICByZXNwb25zZS5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX29uU2VydmVyUmVzcG9uc2VGaW5pc2goXG4gICAgICAgICAgICAgIHJlcXVlc3QzLFxuICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgICAgbWV0cmljQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgc3RhcnRUaW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc3BvbnNlLm9uKGltcG9ydF9ldmVudHMuZXJyb3JNb25pdG9yLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX29uU2VydmVyUmVzcG9uc2VFcnJvcihcbiAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgICAgbWV0cmljQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHNhZmVFeGVjdXRlSW5UaGVNaWRkbGUoXG4gICAgICAgICAgICAoKSA9PiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbZXZlbnQsIC4uLmFyZ3NdKSxcbiAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZXRTcGFuV2l0aEVycm9yKHNwYW4sIGVycm9yKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2Nsb3NlSHR0cFNwYW4oXG4gICAgICAgICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgICAgICAgU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgbWV0cmljQXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgX291dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCwgb3JpZ2luYWwpIHtcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiBvdXRnb2luZ1JlcXVlc3Qob3B0aW9ucywgLi4uYXJncykge1xuICAgICAgaWYgKCFpc1ZhbGlkT3B0aW9uc1R5cGUob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zLCAuLi5hcmdzXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBleHRyYU9wdGlvbnMgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJvYmplY3RcIiAmJiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIHVybDMuVVJMKSA/IGFyZ3Muc2hpZnQoKSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgbWV0aG9kLCBvcHRpb25zUGFyc2VkIH0gPSBnZXRSZXF1ZXN0SW5mbyhcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZXh0cmFPcHRpb25zXG4gICAgICApO1xuICAgICAgaWYgKGlzSWdub3JlZChcbiAgICAgICAgb3JpZ2luICsgcGF0aG5hbWUsXG4gICAgICAgIGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uZmlnKCkuaWdub3JlT3V0Z29pbmdVcmxzLFxuICAgICAgICAoZSkgPT4gaW5zdHJ1bWVudGF0aW9uLl9kaWFnLmVycm9yKFwiY2F1Z2h0IGlnbm9yZU91dGdvaW5nVXJscyBlcnJvcjogXCIsIGUpXG4gICAgICApIHx8IHNhZmVFeGVjdXRlSW5UaGVNaWRkbGUoXG4gICAgICAgICgpID0+IGluc3RydW1lbnRhdGlvbi5fZ2V0Q29uZmlnKCkuaWdub3JlT3V0Z29pbmdSZXF1ZXN0SG9vaz8uKG9wdGlvbnNQYXJzZWQpLFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fZGlhZy5lcnJvcihcbiAgICAgICAgICAgICAgXCJjYXVnaHQgaWdub3JlT3V0Z29pbmdSZXF1ZXN0SG9vayBlcnJvcjogXCIsXG4gICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cnVlXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbb3B0aW9uc1BhcnNlZCwgLi4uYXJnc10pO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBob3N0bmFtZTogaG9zdG5hbWUyLCBwb3J0IH0gPSBleHRyYWN0SG9zdG5hbWVBbmRQb3J0KG9wdGlvbnNQYXJzZWQpO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXMob3B0aW9uc1BhcnNlZCwge1xuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIGhvc3RuYW1lOiBob3N0bmFtZTIsXG4gICAgICAgIGhvb2tBdHRyaWJ1dGVzOiBpbnN0cnVtZW50YXRpb24uX2NhbGxTdGFydFNwYW5Ib29rKFxuICAgICAgICAgIG9wdGlvbnNQYXJzZWQsXG4gICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9nZXRDb25maWcoKS5zdGFydE91dGdvaW5nU3Bhbkhvb2tcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBoclRpbWUoKTtcbiAgICAgIGNvbnN0IG1ldHJpY0F0dHJpYnV0ZXMgPSBnZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAgICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgICAgIGtpbmQ6IFNwYW5LaW5kLkNMSUVOVCxcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0SHR0cFNwYW4obWV0aG9kLCBzcGFuT3B0aW9ucyk7XG4gICAgICBjb25zdCBwYXJlbnRDb250ZXh0ID0gY29udGV4dC5hY3RpdmUoKTtcbiAgICAgIGNvbnN0IHJlcXVlc3RDb250ZXh0ID0gdHJhY2Uuc2V0U3BhbihwYXJlbnRDb250ZXh0LCBzcGFuKTtcbiAgICAgIGlmICghb3B0aW9uc1BhcnNlZC5oZWFkZXJzKSB7XG4gICAgICAgIG9wdGlvbnNQYXJzZWQuaGVhZGVycyA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uc1BhcnNlZC5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uc1BhcnNlZC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHByb3BhZ2F0aW9uLmluamVjdChyZXF1ZXN0Q29udGV4dCwgb3B0aW9uc1BhcnNlZC5oZWFkZXJzKTtcbiAgICAgIHJldHVybiBjb250ZXh0LndpdGgocmVxdWVzdENvbnRleHQsICgpID0+IHtcbiAgICAgICAgY29uc3QgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGNvbnRleHQuYmluZChwYXJlbnRDb250ZXh0LCBjYik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdDMgPSBzYWZlRXhlY3V0ZUluVGhlTWlkZGxlKFxuICAgICAgICAgICgpID0+IG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zUGFyc2VkLCAuLi5hcmdzXSksXG4gICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgc2V0U3BhbldpdGhFcnJvcihzcGFuLCBlcnJvcik7XG4gICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fY2xvc2VIdHRwU3BhbihcbiAgICAgICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgICAgIFNwYW5LaW5kLkNMSUVOVCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgbWV0cmljQXR0cmlidXRlc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGluc3RydW1lbnRhdGlvbi5fZGlhZy5kZWJ1ZyhcbiAgICAgICAgICBgJHtjb21wb25lbnR9IGluc3RydW1lbnRhdGlvbiBvdXRnb2luZ1JlcXVlc3RgXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRleHQuYmluZChwYXJlbnRDb250ZXh0LCByZXF1ZXN0Myk7XG4gICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX3RyYWNlQ2xpZW50UmVxdWVzdChcbiAgICAgICAgICByZXF1ZXN0MyxcbiAgICAgICAgICBzcGFuLFxuICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICBtZXRyaWNBdHRyaWJ1dGVzXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIF9vblNlcnZlclJlc3BvbnNlRmluaXNoKHJlcXVlc3QzLCByZXNwb25zZSwgc3BhbiwgbWV0cmljQXR0cmlidXRlcywgc3RhcnRUaW1lKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlKFxuICAgICAgcmVxdWVzdDMsXG4gICAgICByZXNwb25zZVxuICAgICk7XG4gICAgbWV0cmljQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICBtZXRyaWNBdHRyaWJ1dGVzLFxuICAgICAgZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UoYXR0cmlidXRlcylcbiAgICApO1xuICAgIHRoaXMuX2hlYWRlckNhcHR1cmUuc2VydmVyLmNhcHR1cmVSZXNwb25zZUhlYWRlcnMoXG4gICAgICBzcGFuLFxuICAgICAgKGhlYWRlcikgPT4gcmVzcG9uc2UuZ2V0SGVhZGVyKGhlYWRlcilcbiAgICApO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKS5zZXRTdGF0dXMoe1xuICAgICAgY29kZTogcGFyc2VSZXNwb25zZVN0YXR1cyhTcGFuS2luZC5TRVJWRVIsIHJlc3BvbnNlLnN0YXR1c0NvZGUpXG4gICAgfSk7XG4gICAgY29uc3Qgcm91dGUgPSBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlcy5IVFRQX1JPVVRFXTtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIHNwYW4udXBkYXRlTmFtZShgJHtyZXF1ZXN0My5tZXRob2QgfHwgXCJHRVRcIn0gJHtyb3V0ZX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2dldENvbmZpZygpLmFwcGx5Q3VzdG9tQXR0cmlidXRlc09uU3Bhbikge1xuICAgICAgc2FmZUV4ZWN1dGVJblRoZU1pZGRsZShcbiAgICAgICAgKCkgPT4gdGhpcy5fZ2V0Q29uZmlnKCkuYXBwbHlDdXN0b21BdHRyaWJ1dGVzT25TcGFuKFxuICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgcmVxdWVzdDMsXG4gICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIFNwYW5LaW5kLlNFUlZFUiwgc3RhcnRUaW1lLCBtZXRyaWNBdHRyaWJ1dGVzKTtcbiAgfVxuICBfb25TZXJ2ZXJSZXNwb25zZUVycm9yKHNwYW4sIG1ldHJpY0F0dHJpYnV0ZXMsIHN0YXJ0VGltZSwgZXJyb3IpIHtcbiAgICBzZXRTcGFuV2l0aEVycm9yKHNwYW4sIGVycm9yKTtcbiAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIFNwYW5LaW5kLlNFUlZFUiwgc3RhcnRUaW1lLCBtZXRyaWNBdHRyaWJ1dGVzKTtcbiAgfVxuICBfc3RhcnRIdHRwU3BhbihuYW1lLCBvcHRpb25zLCBjdHggPSBjb250ZXh0LmFjdGl2ZSgpKSB7XG4gICAgY29uc3QgcmVxdWlyZVBhcmVudCA9IG9wdGlvbnMua2luZCA9PT0gU3BhbktpbmQuQ0xJRU5UID8gdGhpcy5fZ2V0Q29uZmlnKCkucmVxdWlyZVBhcmVudGZvck91dGdvaW5nU3BhbnMgOiB0aGlzLl9nZXRDb25maWcoKS5yZXF1aXJlUGFyZW50Zm9ySW5jb21pbmdTcGFucztcbiAgICBsZXQgc3BhbjtcbiAgICBjb25zdCBjdXJyZW50U3BhbiA9IHRyYWNlLmdldFNwYW4oY3R4KTtcbiAgICBpZiAocmVxdWlyZVBhcmVudCA9PT0gdHJ1ZSAmJiBjdXJyZW50U3BhbiA9PT0gdm9pZCAwKSB7XG4gICAgICBzcGFuID0gdHJhY2Uud3JhcFNwYW5Db250ZXh0KElOVkFMSURfU1BBTl9DT05URVhUKTtcbiAgICB9IGVsc2UgaWYgKHJlcXVpcmVQYXJlbnQgPT09IHRydWUgJiYgY3VycmVudFNwYW4/LnNwYW5Db250ZXh0KCkuaXNSZW1vdGUpIHtcbiAgICAgIHNwYW4gPSBjdXJyZW50U3BhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihuYW1lLCBvcHRpb25zLCBjdHgpO1xuICAgIH1cbiAgICB0aGlzLl9zcGFuTm90RW5kZWQuYWRkKHNwYW4pO1xuICAgIHJldHVybiBzcGFuO1xuICB9XG4gIF9jbG9zZUh0dHBTcGFuKHNwYW4sIHNwYW5LaW5kLCBzdGFydFRpbWUsIG1ldHJpY0F0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIXRoaXMuX3NwYW5Ob3RFbmRlZC5oYXMoc3BhbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3Bhbi5lbmQoKTtcbiAgICB0aGlzLl9zcGFuTm90RW5kZWQuZGVsZXRlKHNwYW4pO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gaHJUaW1lVG9NaWxsaXNlY29uZHMoaHJUaW1lRHVyYXRpb24oc3RhcnRUaW1lLCBoclRpbWUoKSkpO1xuICAgIGlmIChzcGFuS2luZCA9PT0gU3BhbktpbmQuU0VSVkVSKSB7XG4gICAgICB0aGlzLl9odHRwU2VydmVyRHVyYXRpb25IaXN0b2dyYW0ucmVjb3JkKGR1cmF0aW9uLCBtZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2UgaWYgKHNwYW5LaW5kID09PSBTcGFuS2luZC5DTElFTlQpIHtcbiAgICAgIHRoaXMuX2h0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbS5yZWNvcmQoZHVyYXRpb24sIG1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuICBfY2FsbFJlc3BvbnNlSG9vayhzcGFuLCByZXNwb25zZSwgaW5zdHJ1bWVudGF0aW9uLCBzdGFydFRpbWUsIG1ldHJpY0F0dHJpYnV0ZXMpIHtcbiAgICBzYWZlRXhlY3V0ZUluVGhlTWlkZGxlKFxuICAgICAgKCkgPT4gdGhpcy5fZ2V0Q29uZmlnKCkucmVzcG9uc2VIb29rKHNwYW4sIHJlc3BvbnNlLCAoKSA9PiB7XG4gICAgICAgIGluc3RydW1lbnRhdGlvbi5fY2xvc2VIdHRwU3BhbihcbiAgICAgICAgICBzcGFuLFxuICAgICAgICAgIFNwYW5LaW5kLlNFUlZFUixcbiAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgbWV0cmljQXR0cmlidXRlc1xuICAgICAgICApO1xuICAgICAgfSksXG4gICAgICAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbiAgX2NhbGxSZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0Mykge1xuICAgIHNhZmVFeGVjdXRlSW5UaGVNaWRkbGUoXG4gICAgICAoKSA9PiB0aGlzLl9nZXRDb25maWcoKS5yZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0MyksXG4gICAgICAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH1cbiAgX2NhbGxTdGFydFNwYW5Ib29rKHJlcXVlc3QzLCBob29rRnVuYykge1xuICAgIGlmICh0eXBlb2YgaG9va0Z1bmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHNhZmVFeGVjdXRlSW5UaGVNaWRkbGUoXG4gICAgICAgICgpID0+IGhvb2tGdW5jKHJlcXVlc3QzKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlSGVhZGVyQ2FwdHVyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9nZXRDb25maWcoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50OiB7XG4gICAgICAgIGNhcHR1cmVSZXF1ZXN0SGVhZGVyczogaGVhZGVyQ2FwdHVyZShcbiAgICAgICAgICBcInJlcXVlc3RcIixcbiAgICAgICAgICBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXM/LmNsaWVudD8ucmVxdWVzdEhlYWRlcnMgPz8gW11cbiAgICAgICAgKSxcbiAgICAgICAgY2FwdHVyZVJlc3BvbnNlSGVhZGVyczogaGVhZGVyQ2FwdHVyZShcbiAgICAgICAgICBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzPy5jbGllbnQ/LnJlc3BvbnNlSGVhZGVycyA/PyBbXVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgc2VydmVyOiB7XG4gICAgICAgIGNhcHR1cmVSZXF1ZXN0SGVhZGVyczogaGVhZGVyQ2FwdHVyZShcbiAgICAgICAgICBcInJlcXVlc3RcIixcbiAgICAgICAgICBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXM/LnNlcnZlcj8ucmVxdWVzdEhlYWRlcnMgPz8gW11cbiAgICAgICAgKSxcbiAgICAgICAgY2FwdHVyZVJlc3BvbnNlSGVhZGVyczogaGVhZGVyQ2FwdHVyZShcbiAgICAgICAgICBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzPy5zZXJ2ZXI/LnJlc3BvbnNlSGVhZGVycyA/PyBbXVxuICAgICAgICApXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2h0dHAudHNcbnZhciBpbXBvcnRfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG52YXIgaW1wb3J0X3N0cmVhbTIgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuZnVuY3Rpb24gX2JldHRlckh0dHBJbnN0cnVtZW50YXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMucGx1Z2lucyA9IG9wdGlvbnMucGx1Z2lucyB8fCBbXTtcbiAgcmV0dXJuIHtcbiAgICByZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0Mykge1xuICAgICAgaWYgKHJlcXVlc3QzIGluc3RhbmNlb2YgaW1wb3J0X2h0dHAuQ2xpZW50UmVxdWVzdCkge1xuICAgICAgICBjb25zdCBwbHVnaW4yID0gb3B0aW9ucy5wbHVnaW5zLmZpbmQoKHBsdWdpbjMpID0+IHBsdWdpbjM/LnNob3VsZFBhcnNlUmVxdWVzdChyZXF1ZXN0MykpO1xuICAgICAgICBpZiAocGx1Z2luMikge1xuICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiaHR0cC5wbHVnaW4ubmFtZVwiLCBwbHVnaW4yLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0My5nZXRIZWFkZXJzKCk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2FwdHVyZUhlYWRlcnMpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhmbGF0dGVuKHsgcmVxdWVzdDogeyBoZWFkZXJzIH0gfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGx1Z2luMi5jYXB0dXJlQm9keSkge1xuICAgICAgICAgICAgZ2V0Q2xpZW50UmVxdWVzdEJvZHkocmVxdWVzdDMsIChib2R5KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3REYXRhID0gX3BhcnNlQm9keVNhZmUoYm9keSwgaGVhZGVycyk7XG4gICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhmbGF0dGVuKHsgcmVxdWVzdDogeyBib2R5OiByZXF1ZXN0RGF0YSB9IH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdDMuZ2V0SGVhZGVycygpO1xuICAgICAgICAgIGlmIChvcHRpb25zLmNhcHR1cmVIZWFkZXJzKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoZmxhdHRlbih7IHJlcXVlc3Q6IHsgaGVhZGVycyB9IH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2FwdHVyZUJvZHkgJiYgc2hvdWxkQ2FwdHVyZUJvZHkocmVxdWVzdDMuaG9zdCkpIHtcbiAgICAgICAgICAgIGdldENsaWVudFJlcXVlc3RCb2R5KHJlcXVlc3QzLCAoYm9keSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IF9wYXJzZUJvZHlTYWZlKGJvZHksIGhlYWRlcnMpO1xuICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoZmxhdHRlbih7IHJlcXVlc3Q6IHsgYm9keTogcmVxdWVzdERhdGEgfSB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0MyBpbnN0YW5jZW9mIGltcG9ydF9odHRwLkluY29taW5nTWVzc2FnZSkge1xuICAgICAgICBjb25zdCBwbHVnaW4yID0gb3B0aW9ucy5wbHVnaW5zLmZpbmQoKHBsdWdpbjMpID0+IHBsdWdpbjMuc2hvdWxkUGFyc2VSZXF1ZXN0ICYmIHBsdWdpbjMuc2hvdWxkUGFyc2VSZXF1ZXN0KHJlcXVlc3QzKSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiaHR0cC5wbHVnaW4ubmFtZVwiLCBwbHVnaW4yLm5hbWUpO1xuICAgICAgICBpZiAocGx1Z2luMi5wYXJzZUluY29tbWluZ01lc3NhZ2UpIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcGx1Z2luMi5wYXJzZUluY29tbWluZ01lc3NhZ2UocmVxdWVzdDMpO1xuICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhmbGF0dGVuKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdEhvb2spIHtcbiAgICAgICAgb3B0aW9ucy5yZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0Myk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNwb25zZUhvb2soc3BhbiwgcmVzcG9uc2UsIGNiKSB7XG4gICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBpbXBvcnRfaHR0cC5JbmNvbWluZ01lc3NhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgICBpZiAob3B0aW9ucy5jYXB0dXJlSGVhZGVycykge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKGZsYXR0ZW4oeyByZXNwb25zZTogeyBoZWFkZXJzIH0gfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5jYXB0dXJlQm9keSAmJiBzaG91bGRDYXB0dXJlQm9keShyZXNwb25zZS51cmwgfHwgXCJcIikpIHtcbiAgICAgICAgICAgIGdldENsaWVudFJlc3BvbnNlQm9keShyZXNwb25zZSwgKGJvZHkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gX3BhcnNlQm9keVNhZmUoYm9keSwgaGVhZGVycyk7XG4gICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhmbGF0dGVuKHsgcmVzcG9uc2U6IHsgYm9keTogcmVzcG9uc2VEYXRhIH0gfSkpO1xuICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2VIb29rKSB7XG4gICAgICAgIG9wdGlvbnMucmVzcG9uc2VIb29rKHNwYW4sIHJlc3BvbnNlLCBjYik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIGlnbm9yZWRIb3N0cyA9IFtcbiAgXCJsb2NhbGhvc3RcIixcbiAgXCJvdGVsLmJhc2VsaW1lXCJcbl07XG5mdW5jdGlvbiBnZXRDbGllbnRSZXF1ZXN0Qm9keShyLCBjYikge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgY29uc3Qgb2xkV3JpdGUgPSByLndyaXRlLmJpbmQocik7XG4gIHIud3JpdGUgPSAoZGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2h1bmtzLnB1c2goQnVmZmVyLmZyb20oZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSBcIn1cIikge1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSBCdWZmZXIuY29uY2F0KGNodW5rcykudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgIGNiKGJvZHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVua3MucHVzaChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gMTI1KSB7XG4gICAgICAgICAgY29uc3QgYm9keSA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgICAgY2IoYm9keSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiBvbGRXcml0ZShkYXRhKTtcbiAgfTtcbiAgY29uc3Qgb2xkRW5kID0gci5lbmQuYmluZChyKTtcbiAgci5lbmQgPSAoZGF0YSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjaHVua3MucHVzaChCdWZmZXIuZnJvbShkYXRhKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBib2R5ID0gQnVmZmVyLmNvbmNhdChjaHVua3MpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgICAgY2IoYm9keSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gb2xkRW5kKGRhdGEpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVzcG9uc2VCb2R5KHIsIGNiKSB7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBjb25zdCBwdCA9IG5ldyBpbXBvcnRfc3RyZWFtMi5QYXNzVGhyb3VnaCgpO1xuICBwdC5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2h1bmtzLnB1c2goQnVmZmVyLmZyb20oY2h1bmspKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9KS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChjaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBib2R5ID0gQnVmZmVyLmNvbmNhdChjaHVua3MpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgICAgY2IoYm9keSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG9yaWdpbmFsU3RhdGUgPSByLnJlYWRhYmxlRmxvd2luZztcbiAgci5waXBlKHB0KTtcbiAgci5yZWFkYWJsZUZsb3dpbmcgPSBvcmlnaW5hbFN0YXRlO1xufVxuZnVuY3Rpb24gc2hvdWxkQ2FwdHVyZUJvZHkoaG9zdCkge1xuICByZXR1cm4gIWlnbm9yZWRIb3N0cy5maW5kKChpZ25vcmVkSG9zdCkgPT4gaG9zdC5pbmNsdWRlcyhpZ25vcmVkSG9zdCkpO1xufVxuZnVuY3Rpb24gX3BhcnNlQm9keVNhZmUoYm9keSwgaGVhZGVycykge1xuICBsZXQgcmVxdWVzdERhdGEgPSBib2R5O1xuICB0cnkge1xuICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdICYmIHR5cGVvZiBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikgfHwgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3gtYW16LWpzb25cIikpIHtcbiAgICAgICAgcmVxdWVzdERhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdLmluY2x1ZGVzKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpKSB7XG4gICAgICAgIHJlcXVlc3REYXRhID0gKDAsIGltcG9ydF9xdWVyeXN0cmluZy5wYXJzZSkoYm9keSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3REYXRhO1xufVxudmFyIEJldHRlckh0dHBJbnN0cnVtZW50YXRpb24gPSBjbGFzcyBleHRlbmRzIEh0dHBJbnN0cnVtZW50YXRpb24ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5fYmV0dGVySHR0cEluc3RydW1lbnRhdGlvbihvcHRpb25zKSxcbiAgICAgIGlnbm9yZUluY29taW5nUmVxdWVzdEhvb2s6IG9wdGlvbnMuaWdub3JlSW5jb21pbmdSZXF1ZXN0SG9vayxcbiAgICAgIGlnbm9yZU91dGdvaW5nUmVxdWVzdEhvb2s6IG9wdGlvbnMuaWdub3JlT3V0Z29pbmdSZXF1ZXN0SG9vayxcbiAgICAgIHN0YXJ0SW5jb21pbmdTcGFuSG9vazogb3B0aW9ucy5zdGFydEluY29taW5nU3Bhbkhvb2ssXG4gICAgICBzdGFydE91dGdvaW5nU3Bhbkhvb2s6IG9wdGlvbnMuc3RhcnRPdXRnb2luZ1NwYW5Ib29rXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9odHRwLXBsdWdpbnMvc3RyaXBlLnRzXG52YXIgaW1wb3J0X2h0dHAzID0gcmVxdWlyZShcImh0dHBcIik7XG5cbi8vIHNyYy9odHRwLXBsdWdpbnMvcGx1Z2luLnRzXG52YXIgSHR0cFBsdWdpbiA9IGNsYXNzIHtcbiAgY2FwdHVyZUJvZHkgPSBmYWxzZTtcbiAgbmFtZSA9IFwiYmFzZS1wbHVnaW4tc2hvdWxkLWV4dGVuZFwiO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuICBzaG91bGRQYXJzZVJlcXVlc3QocmVxdWVzdDMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2hvdWxkUGFyc2VSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gc3JjL2h0dHAtcGx1Z2lucy9zdHJpcGUudHNcbnZhciBTdHJpcGVQbHVnaW4gPSBjbGFzcyBleHRlbmRzIEh0dHBQbHVnaW4ge1xuICBjYXB0dXJlQm9keSA9IHRydWU7XG4gIG5hbWUgPSBcInN0cmlwZVwiO1xuICBzaG91bGRQYXJzZVJlcXVlc3QocmVxdWVzdDMpIHtcbiAgICBpZiAocmVxdWVzdDMgaW5zdGFuY2VvZiBpbXBvcnRfaHR0cDMuQ2xpZW50UmVxdWVzdCAmJiByZXF1ZXN0My5ob3N0Py5pbmNsdWRlcyhcImFwaS5zdHJpcGUuY29tXCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlQ2xpZW50UmVxdWVzdChyZXF1ZXN0Mykge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QzLm1ldGhvZDtcbiAgICBjb25zdCBbdmVyc2lvbiwgZW50aXR5LCBlbnRpdHlJZE9yT3BlcmF0aW9uLCBvcGVyYXRpb25dID0gcmVxdWVzdDMucGF0aC5zcGxpdChcIi9cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmlwZToge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGVudGl0eSxcbiAgICAgICAgZW50aXR5SWRPck9wZXJhdGlvbixcbiAgICAgICAgb3BlcmF0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBwbHVnaW4gPSBuZXcgU3RyaXBlUGx1Z2luKCk7XG5cbi8vIHNyYy9odHRwLXBsdWdpbnMvdmVyY2VsLnRzXG52YXIgaW1wb3J0X2h0dHA0ID0gcmVxdWlyZShcImh0dHBcIik7XG52YXIgVmVyY2VsUGx1Z2luID0gY2xhc3MgZXh0ZW5kcyBIdHRwUGx1Z2luIHtcbiAgbmFtZSA9IFwidmVyY2VsXCI7XG4gIHNob3VsZFBhcnNlUmVxdWVzdChyZXF1ZXN0Mykge1xuICAgIGlmIChyZXF1ZXN0MyBpbnN0YW5jZW9mIGltcG9ydF9odHRwNC5JbmNvbWluZ01lc3NhZ2UgJiYgcmVxdWVzdDMuaGVhZGVyc1tcIngtdmVyY2VsLWlkXCJdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlSW5jb21taW5nTWVzc2FnZShyZXF1ZXN0Mykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0My5oZWFkZXJzO1xuICAgIGNvbnN0IHZlcmNlbFJlcXVlc3RJZCA9IGhlYWRlcnNbXCJ4LXZlcmNlbC1pZFwiXTtcbiAgICBpZiAodHlwZW9mIHZlcmNlbFJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcmVxdWVzdElkUGFydHMgPSB2ZXJjZWxSZXF1ZXN0SWQuc3BsaXQoXCI6OlwiKTtcbiAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlcXVlc3RJZFBhcnRzW3JlcXVlc3RJZFBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgdXNlciA9IHtcbiAgICAgICAgaXA6IGhlYWRlcnNbXCJ4LWZvcndhcmRlZC1mb3JcIl0sXG4gICAgICAgIGNvdW50cnk6IGhlYWRlcnNbXCJ4LXZlcmNlbC1pcC1jb3VudHJ5XCJdLFxuICAgICAgICByZWdpb246IGhlYWRlcnNbXCJ4LXZlcmNlbC1pcC1yZWdpb25cIl0sXG4gICAgICAgIGNpdHk6IGhlYWRlcnNbXCJ4LXZlcmNlbC1pcC1jaXR5XCJdLFxuICAgICAgICBsYXRpdHVkZTogaGVhZGVyc1tcIngtdmVyY2VsLWlwLWxhdGl0dWRlXCJdLFxuICAgICAgICBsb25naXR1ZGU6IGhlYWRlcnNbXCJ4LXZlcmNlbC1pcC1sb25naXR1ZGVcIl0sXG4gICAgICAgIHRpbWV6b25lOiBoZWFkZXJzW1wieC12ZXJjZWwtaXAtdGltZXpvbmVcIl1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGZhYXM6IHsgZXhlY3V0aW9uOiByZXF1ZXN0SWQgfSxcbiAgICAgICAgdXNlclxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQmFzZWxpbWVTREssXG4gIEJldHRlckh0dHBJbnN0cnVtZW50YXRpb24sXG4gIEh0dHBQbHVnaW4sXG4gIFN0cmlwZVBsdWdpbixcbiAgVmVyY2VsUGx1Z2luXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@baselime+node-opentelemetry@0.5.8_@trpc+server@10.45.2/node_modules/@baselime/node-opentelemetry/dist/index.cjs\n");

/***/ })

};
;